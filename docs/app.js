/*! For license information please see app.js.LICENSE.txt */
!(function () {
  try {
    const e = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {}
    const t = (new Error()).stack
    t && (e._sentryDebugIds = e._sentryDebugIds || {},
    e._sentryDebugIds[t] = 'ec57bc80-3feb-4902-9aa8-5229057ae14b',
    e._sentryDebugIdIdentifier = 'sentry-dbid-ec57bc80-3feb-4902-9aa8-5229057ae14b')
  } catch (e) {}
}()),
(() => {
  const e = {
    3527: e => {
      'use strict'
      e.exports = function (e) {
        const t = []
        return t.toString = function () {
          return this.map(function (t) {
            let n = ''
            const r = void 0 !== t[5]
            return t[4] && (n += '@supports ('.concat(t[4], ') {')),
            t[2] && (n += '@media '.concat(t[2], ' {')),
            r && (n += '@layer'.concat(t[5].length > 0 ? ' '.concat(t[5]) : '', ' {')),
            n += e(t),
            r && (n += '}'),
            t[2] && (n += '}'),
            t[4] && (n += '}'),
            n
          }
          ).join('')
        }
        ,
        t.i = function (e, n, r, o, i) {
          typeof e === 'string' && (e = [[null, e, void 0]])
          const a = {}
          if (r) {
            for (let s = 0; s < this.length; s++) {
              const c = this[s][0]
              c != null && (a[c] = !0)
            }
          }
          for (let l = 0; l < e.length; l++) {
            const p = [].concat(e[l])
            r && a[p[0]] || (void 0 !== i && (void 0 === p[5] || (p[1] = '@layer'.concat(p[5].length > 0 ? ' '.concat(p[5]) : '', ' {').concat(p[1], '}')),
            p[5] = i),
            n && (p[2]
              ? (p[1] = '@media '.concat(p[2], ' {').concat(p[1], '}'),
                p[2] = n)
              : p[2] = n),
            o && (p[4]
              ? (p[1] = '@supports ('.concat(p[4], ') {').concat(p[1], '}'),
                p[4] = o)
              : p[4] = ''.concat(o)),
            t.push(p))
          }
        }
        ,
        t
      }
    },
    9038: e => {
      'use strict'
      e.exports = function (e, t) {
        return t || (t = {}),
        e
          ? (e = String(e.__esModule ? e.default : e),
            /^['"].*['"]$/.test(e) && (e = e.slice(1, -1)),
            t.hash && (e += t.hash),
            /["'() \t\n]|(%20)/.test(e) || t.needQuotes ? '"'.concat(e.replace(/"/g, '\\"').replace(/\n/g, '\\n'), '"') : e)
          : e
      }
    },
    2017: e => {
      'use strict'
      e.exports = function (e) {
        const t = e[1]
        const n = e[3]
        if (!n) { return t }
        if (typeof btoa === 'function') {
          const r = btoa(unescape(encodeURIComponent(JSON.stringify(n))))
          const o = 'sourceMappingURL=data:application/json;charset=utf-8;base64,'.concat(r)
          const i = '/*# '.concat(o, ' */')
          return [t].concat([i]).join('\n')
        }
        return [t].join('\n')
      }
    },
    7913: function (e, t) {
      let n, r
      void 0 === (r = typeof (n = function () {
        return function e (t, n, r) {
          let o; let i; const a = window; const s = 'application/octet-stream'; let c = r || s; let l = t; const p = !n && !r && l; const u = document.createElement('a'); const d = function (e) {
            return String(e)
          }; let f = a.Blob || a.MozBlob || a.WebKitBlob || d; let h = n || 'download'
          if (f = f.call ? f.bind(a) : Blob,
          String(this) === 'true' && (c = (l = [l, c])[0],
          l = l[1]),
          p && p.length < 2048 && (h = p.split('/').pop().split('?')[0],
          u.href = p,
          u.href.indexOf(p) !== -1)) {
            const m = new XMLHttpRequest()
            return m.open('GET', p, !0),
            m.responseType = 'blob',
            m.onload = function (t) {
              e(t.target.response, h, s)
            }
            ,
            setTimeout(function () {
              m.send()
            }
            , 0),
            m
          }
          if (/^data:([\w+-]+\/[\w+.-]+)?[,;]/.test(l)) {
            if (!(l.length > 2096103.424 && f !== d)) { return navigator.msSaveBlob ? navigator.msSaveBlob(b(l), h) : A(l) }
            c = (l = b(l)).type || s
          } else if (/([\x80-\xff])/.test(l)) {
            for (var v = 0, g = new Uint8Array(l.length), y = g.length; v < y; ++v) { g[v] = l.charCodeAt(v) }
            l = new f([g], {
              type: c
            })
          }
          function b (e) {
            for (var t = e.split(/[:;,]/), n = t[1], r = (t[2] == 'base64' ? atob : decodeURIComponent)(t.pop()), o = r.length, i = 0, a = new Uint8Array(o); i < o; ++i) { a[i] = r.charCodeAt(i) }
            return new f([a], {
              type: n
            })
          }
          function A (e, t) {
            if ('download' in u) {
              return u.href = e,
              u.setAttribute('download', h),
              u.className = 'download-js-link',
              u.innerHTML = 'downloading...',
              u.style.display = 'none',
              document.body.appendChild(u),
              setTimeout(function () {
                u.click(),
                document.body.removeChild(u),
                !0 === t && setTimeout(function () {
                  a.URL.revokeObjectURL(u.href)
                }
                , 250)
              }
              , 66),
              !0
            }
            if (/(Version)\/(\d+)\.(\d+)(?:\.(\d+))?.*Safari\//.test(navigator.userAgent)) {
              return /^data:/.test(e) && (e = 'data:' + e.replace(/^data:([\w\/\-\+]+)/, s)),
              window.open(e) || confirm('Displaying New Document\n\nUse Save As... to download, then click back to return to this page.') && (location.href = e),
              !0
            }
            const n = document.createElement('iframe')
            document.body.appendChild(n),
            !t && /^data:/.test(e) && (e = 'data:' + e.replace(/^data:([\w\/\-\+]+)/, s)),
            n.src = e,
            setTimeout(function () {
              document.body.removeChild(n)
            }
            , 333)
          }
          if (o = l instanceof f
            ? l
            : new f([l], {
              type: c
            }),
          navigator.msSaveBlob) { return navigator.msSaveBlob(o, h) }
          if (a.URL) { A(a.URL.createObjectURL(o), !0) } else {
            if (typeof o === 'string' || o.constructor === d) {
              try {
                return A('data:' + c + ';base64,' + a.btoa(o))
              } catch (e) {
                return A('data:' + c + ',' + encodeURIComponent(o))
              }
            }
            (i = new FileReader()).onload = function (e) {
              A(this.result)
            }
            ,
            i.readAsDataURL(o)
          }
          return !0
        }
      }
      ) === 'function'
        ? n.apply(t, [])
        : n) || (e.exports = r)
    },
    9371: function (e, t, n) {
      let r
      function o (e) {
        return o = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
          ? function (e) {
            return typeof e
          }
          : function (e) {
            return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
          }
        ,
        o(e)
      }
      e = n.nmd(e),
      (function (t, n) {
        'use strict'
        o(e) === 'object' && o(e.exports) === 'object'
          ? e.exports = t.document
            ? n(t, !0)
            : function (e) {
              if (!e.document) { throw new Error('jQuery requires a window with a document') }
              return n(e)
            }
          : n(t)
      }(typeof window !== 'undefined' ? window : this, function (n, i) {
        'use strict'
        const a = []
        const s = Object.getPrototypeOf
        const c = a.slice
        const l = a.flat
          ? function (e) {
            return a.flat.call(e)
          }
          : function (e) {
            return a.concat.apply([], e)
          }
        const p = a.push
        const u = a.indexOf
        const d = {}
        const f = d.toString
        const h = d.hasOwnProperty
        const m = h.toString
        const v = m.call(Object)
        const g = {}
        const y = function (e) {
          return typeof e === 'function' && typeof e.nodeType !== 'number' && typeof e.item !== 'function'
        }
        const b = function (e) {
          return e != null && e === e.window
        }
        const A = n.document
        const E = {
          type: !0,
          src: !0,
          nonce: !0,
          noModule: !0
        }
        function x (e, t, n) {
          let r; let o; const i = (n = n || A).createElement('script')
          if (i.text = e,
          t) {
            for (r in E) { (o = t[r] || t.getAttribute && t.getAttribute(r)) && i.setAttribute(r, o) }
          }
          n.head.appendChild(i).parentNode.removeChild(i)
        }
        function w (e) {
          return e == null ? e + '' : o(e) === 'object' || typeof e === 'function' ? d[f.call(e)] || 'object' : o(e)
        }
        const _ = '3.6.1'
        const C = function e (t, n) {
          return new e.fn.init(t, n)
        }
        function S (e) {
          const t = !!e && 'length' in e && e.length
          const n = w(e)
          return !y(e) && !b(e) && (n === 'array' || t === 0 || typeof t === 'number' && t > 0 && t - 1 in e)
        }
        C.fn = C.prototype = {
          jquery: _,
          constructor: C,
          length: 0,
          toArray: function () {
            return c.call(this)
          },
          get: function (e) {
            return e == null ? c.call(this) : e < 0 ? this[e + this.length] : this[e]
          },
          pushStack: function (e) {
            const t = C.merge(this.constructor(), e)
            return t.prevObject = this,
            t
          },
          each: function (e) {
            return C.each(this, e)
          },
          map: function (e) {
            return this.pushStack(C.map(this, function (t, n) {
              return e.call(t, n, t)
            }
            ))
          },
          slice: function () {
            return this.pushStack(c.apply(this, arguments))
          },
          first: function () {
            return this.eq(0)
          },
          last: function () {
            return this.eq(-1)
          },
          even: function () {
            return this.pushStack(C.grep(this, function (e, t) {
              return (t + 1) % 2
            }
            ))
          },
          odd: function () {
            return this.pushStack(C.grep(this, function (e, t) {
              return t % 2
            }
            ))
          },
          eq: function (e) {
            const t = this.length
            const n = +e + (e < 0 ? t : 0)
            return this.pushStack(n >= 0 && n < t ? [this[n]] : [])
          },
          end: function () {
            return this.prevObject || this.constructor()
          },
          push: p,
          sort: a.sort,
          splice: a.splice
        },
        C.extend = C.fn.extend = function () {
          let e; let t; let n; let r; let i; let a; let s = arguments[0] || {}; let c = 1; const l = arguments.length; let p = !1
          for (typeof s === 'boolean' && (p = s,
          s = arguments[c] || {},
          c++),
          o(s) === 'object' || y(s) || (s = {}),
          c === l && (s = this,
          c--); c < l; c++) {
            if ((e = arguments[c]) != null) {
              for (t in e) {
                r = e[t],
                t !== '__proto__' && s !== r && (p && r && (C.isPlainObject(r) || (i = Array.isArray(r)))
                  ? (n = s[t],
                    a = i && !Array.isArray(n) ? [] : i || C.isPlainObject(n) ? n : {},
                    i = !1,
                    s[t] = C.extend(p, a, r))
                  : void 0 !== r && (s[t] = r))
              }
            }
          }
          return s
        }
        ,
        C.extend({
          expando: 'jQuery' + (_ + Math.random()).replace(/\D/g, ''),
          isReady: !0,
          error: function (e) {
            throw new Error(e)
          },
          noop: function () {},
          isPlainObject: function (e) {
            let t, n
            return !(!e || f.call(e) !== '[object Object]' || (t = s(e)) && (typeof (n = h.call(t, 'constructor') && t.constructor) !== 'function' || m.call(n) !== v))
          },
          isEmptyObject: function (e) {
            let t
            for (t in e) { return !1 }
            return !0
          },
          globalEval: function (e, t, n) {
            x(e, {
              nonce: t && t.nonce
            }, n)
          },
          each: function (e, t) {
            let n; let r = 0
            if (S(e)) {
              for (n = e.length; r < n && !1 !== t.call(e[r], r, e[r]); r++)
                ;
            } else {
              for (r in e) {
                if (!1 === t.call(e[r], r, e[r])) { break }
              }
            }
            return e
          },
          makeArray: function (e, t) {
            const n = t || []
            return e != null && (S(Object(e)) ? C.merge(n, typeof e === 'string' ? [e] : e) : p.call(n, e)),
            n
          },
          inArray: function (e, t, n) {
            return t == null ? -1 : u.call(t, e, n)
          },
          merge: function (e, t) {
            for (var n = +t.length, r = 0, o = e.length; r < n; r++) { e[o++] = t[r] }
            return e.length = o,
            e
          },
          grep: function (e, t, n) {
            for (var r = [], o = 0, i = e.length, a = !n; o < i; o++) { !t(e[o], o) !== a && r.push(e[o]) }
            return r
          },
          map: function (e, t, n) {
            let r; let o; let i = 0; const a = []
            if (S(e)) {
              for (r = e.length; i < r; i++) { (o = t(e[i], i, n)) != null && a.push(o) }
            } else {
              for (i in e) { (o = t(e[i], i, n)) != null && a.push(o) }
            }
            return l(a)
          },
          guid: 1,
          support: g
        }),
        typeof Symbol === 'function' && (C.fn[Symbol.iterator] = a[Symbol.iterator]),
        C.each('Boolean Number String Function Array Date RegExp Object Error Symbol'.split(' '), function (e, t) {
          d['[object ' + t + ']'] = t.toLowerCase()
        }
        )
        const k = (function (e) {
          let t; let n; let r; let o; let i; let a; let s; let c; let l; let p; let u; let d; let f; let h; let m; let v; let g; let y; let b; const A = 'sizzle' + 1 * new Date(); const E = e.document; let x = 0; let w = 0; const _ = ce(); const C = ce(); const S = ce(); const k = ce(); let j = function (e, t) {
            return e === t && (u = !0),
            0
          }; const B = {}.hasOwnProperty; let D = []; const P = D.pop; const O = D.push; let T = D.push; const R = D.slice; const N = function (e, t) {
            for (let n = 0, r = e.length; n < r; n++) {
              if (e[n] === t) { return n }
            }
            return -1
          }; const M = 'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped'; const I = '[\\x20\\t\\r\\n\\f]'; const L = '(?:\\\\[\\da-fA-F]{1,6}' + I + '?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+'; const z = '\\[' + I + '*(' + L + ')(?:' + I + '*([*^$|!~]?=)' + I + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + L + '))|)' + I + '*\\]'; const F = ':(' + L + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + z + ')*)|.*)\\)|)'; const $ = new RegExp(I + '+', 'g'); const H = new RegExp('^' + I + '+|((?:^|[^\\\\])(?:\\\\.)*)' + I + '+$', 'g'); const q = new RegExp('^' + I + '*,' + I + '*'); const W = new RegExp('^' + I + '*([>+~]|' + I + ')' + I + '*'); const G = new RegExp(I + '|>'); const U = new RegExp(F); const V = new RegExp('^' + L + '$'); const Q = {
            ID: new RegExp('^#(' + L + ')'),
            CLASS: new RegExp('^\\.(' + L + ')'),
            TAG: new RegExp('^(' + L + '|[*])'),
            ATTR: new RegExp('^' + z),
            PSEUDO: new RegExp('^' + F),
            CHILD: new RegExp('^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(' + I + '*(even|odd|(([+-]|)(\\d*)n|)' + I + '*(?:([+-]|)' + I + '*(\\d+)|))' + I + '*\\)|)', 'i'),
            bool: new RegExp('^(?:' + M + ')$', 'i'),
            needsContext: new RegExp('^' + I + '*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(' + I + '*((?:-\\d)?\\d*)' + I + '*\\)|)(?=[^-]|$)', 'i')
          }; const Y = /HTML$/i; const K = /^(?:input|select|textarea|button)$/i; const J = /^h\d$/i; const X = /^[^{]+\{\s*\[native \w/; const Z = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/; const ee = /[+~]/; const te = new RegExp('\\\\[\\da-fA-F]{1,6}' + I + '?|\\\\([^\\r\\n\\f])', 'g'); const ne = function (e, t) {
            const n = '0x' + e.slice(1) - 65536
            return t || (n < 0 ? String.fromCharCode(n + 65536) : String.fromCharCode(n >> 10 | 55296, 1023 & n | 56320))
          }; const re = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g; const oe = function (e, t) {
            return t ? e === '\0' ? '�' : e.slice(0, -1) + '\\' + e.charCodeAt(e.length - 1).toString(16) + ' ' : '\\' + e
          }; const ie = function () {
            d()
          }; const ae = Ae(function (e) {
            return !0 === e.disabled && e.nodeName.toLowerCase() === 'fieldset'
          }
          , {
            dir: 'parentNode',
            next: 'legend'
          })
          try {
            T.apply(D = R.call(E.childNodes), E.childNodes),
            D[E.childNodes.length].nodeType
          } catch (e) {
            T = {
              apply: D.length
                ? function (e, t) {
                  O.apply(e, R.call(t))
                }
                : function (e, t) {
                  for (var n = e.length, r = 0; e[n++] = t[r++];)
                    ;
                  e.length = n - 1
                }
            }
          }
          function se (e, t, r, o) {
            let i; let s; let l; let p; let u; let h; let g; let y = t && t.ownerDocument; const E = t ? t.nodeType : 9
            if (r = r || [],
            typeof e !== 'string' || !e || E !== 1 && E !== 9 && E !== 11) { return r }
            if (!o && (d(t),
            t = t || f,
            m)) {
              if (E !== 11 && (u = Z.exec(e))) {
                if (i = u[1]) {
                  if (E === 9) {
                    if (!(l = t.getElementById(i))) { return r }
                    if (l.id === i) {
                      return r.push(l),
                      r
                    }
                  } else if (y && (l = y.getElementById(i)) && b(t, l) && l.id === i) {
                    return r.push(l),
                    r
                  }
                } else {
                  if (u[2]) {
                    return T.apply(r, t.getElementsByTagName(e)),
                    r
                  }
                  if ((i = u[3]) && n.getElementsByClassName && t.getElementsByClassName) {
                    return T.apply(r, t.getElementsByClassName(i)),
                    r
                  }
                }
              }
              if (n.qsa && !k[e + ' '] && (!v || !v.test(e)) && (E !== 1 || t.nodeName.toLowerCase() !== 'object')) {
                if (g = e,
                y = t,
                E === 1 && (G.test(e) || W.test(e))) {
                  for ((y = ee.test(e) && ge(t.parentNode) || t) === t && n.scope || ((p = t.getAttribute('id')) ? p = p.replace(re, oe) : t.setAttribute('id', p = A)),
                  s = (h = a(e)).length; s--;) { h[s] = (p ? '#' + p : ':scope') + ' ' + be(h[s]) }
                  g = h.join(',')
                }
                try {
                  return T.apply(r, y.querySelectorAll(g)),
                  r
                } catch (t) {
                  k(e, !0)
                } finally {
                  p === A && t.removeAttribute('id')
                }
              }
            }
            return c(e.replace(H, '$1'), t, r, o)
          }
          function ce () {
            const e = []
            return function t (n, o) {
              return e.push(n + ' ') > r.cacheLength && delete t[e.shift()],
              t[n + ' '] = o
            }
          }
          function le (e) {
            return e[A] = !0,
            e
          }
          function pe (e) {
            let t = f.createElement('fieldset')
            try {
              return !!e(t)
            } catch (e) {
              return !1
            } finally {
              t.parentNode && t.parentNode.removeChild(t),
              t = null
            }
          }
          function ue (e, t) {
            for (let n = e.split('|'), o = n.length; o--;) { r.attrHandle[n[o]] = t }
          }
          function de (e, t) {
            let n = t && e
            const r = n && e.nodeType === 1 && t.nodeType === 1 && e.sourceIndex - t.sourceIndex
            if (r) { return r }
            if (n) {
              for (; n = n.nextSibling;) {
                if (n === t) { return -1 }
              }
            }
            return e ? 1 : -1
          }
          function fe (e) {
            return function (t) {
              return t.nodeName.toLowerCase() === 'input' && t.type === e
            }
          }
          function he (e) {
            return function (t) {
              const n = t.nodeName.toLowerCase()
              return (n === 'input' || n === 'button') && t.type === e
            }
          }
          function me (e) {
            return function (t) {
              return 'form' in t ? t.parentNode && !1 === t.disabled ? 'label' in t ? 'label' in t.parentNode ? t.parentNode.disabled === e : t.disabled === e : t.isDisabled === e || t.isDisabled !== !e && ae(t) === e : t.disabled === e : 'label' in t && t.disabled === e
            }
          }
          function ve (e) {
            return le(function (t) {
              return t = +t,
              le(function (n, r) {
                for (var o, i = e([], n.length, t), a = i.length; a--;) { n[o = i[a]] && (n[o] = !(r[o] = n[o])) }
              }
              )
            }
            )
          }
          function ge (e) {
            return e && void 0 !== e.getElementsByTagName && e
          }
          for (t in n = se.support = {},
          i = se.isXML = function (e) {
            const t = e && e.namespaceURI
            const n = e && (e.ownerDocument || e).documentElement
            return !Y.test(t || n && n.nodeName || 'HTML')
          }
          ,
          d = se.setDocument = function (e) {
            let t; let o; const a = e ? e.ownerDocument || e : E
            return a != f && a.nodeType === 9 && a.documentElement
              ? (h = (f = a).documentElement,
                m = !i(f),
                E != f && (o = f.defaultView) && o.top !== o && (o.addEventListener ? o.addEventListener('unload', ie, !1) : o.attachEvent && o.attachEvent('onunload', ie)),
                n.scope = pe(function (e) {
                  return h.appendChild(e).appendChild(f.createElement('div')),
                  void 0 !== e.querySelectorAll && !e.querySelectorAll(':scope fieldset div').length
                }
                ),
                n.attributes = pe(function (e) {
                  return e.className = 'i',
                  !e.getAttribute('className')
                }
                ),
                n.getElementsByTagName = pe(function (e) {
                  return e.appendChild(f.createComment('')),
                  !e.getElementsByTagName('*').length
                }
                ),
                n.getElementsByClassName = X.test(f.getElementsByClassName),
                n.getById = pe(function (e) {
                  return h.appendChild(e).id = A,
                  !f.getElementsByName || !f.getElementsByName(A).length
                }
                ),
                n.getById
                  ? (r.filter.ID = function (e) {
                      const t = e.replace(te, ne)
                      return function (e) {
                        return e.getAttribute('id') === t
                      }
                    }
                    ,
                    r.find.ID = function (e, t) {
                      if (void 0 !== t.getElementById && m) {
                        const n = t.getElementById(e)
                        return n ? [n] : []
                      }
                    }
                    )
                  : (r.filter.ID = function (e) {
                      const t = e.replace(te, ne)
                      return function (e) {
                        const n = void 0 !== e.getAttributeNode && e.getAttributeNode('id')
                        return n && n.value === t
                      }
                    }
                    ,
                    r.find.ID = function (e, t) {
                      if (void 0 !== t.getElementById && m) {
                        let n; let r; let o; let i = t.getElementById(e)
                        if (i) {
                          if ((n = i.getAttributeNode('id')) && n.value === e) { return [i] }
                          for (o = t.getElementsByName(e),
                          r = 0; i = o[r++];) {
                            if ((n = i.getAttributeNode('id')) && n.value === e) { return [i] }
                          }
                        }
                        return []
                      }
                    }
                    ),
                r.find.TAG = n.getElementsByTagName
                  ? function (e, t) {
                    return void 0 !== t.getElementsByTagName ? t.getElementsByTagName(e) : n.qsa ? t.querySelectorAll(e) : void 0
                  }
                  : function (e, t) {
                    let n; const r = []; let o = 0; const i = t.getElementsByTagName(e)
                    if (e === '*') {
                      for (; n = i[o++];) { n.nodeType === 1 && r.push(n) }
                      return r
                    }
                    return i
                  }
                ,
                r.find.CLASS = n.getElementsByClassName && function (e, t) {
                  if (void 0 !== t.getElementsByClassName && m) { return t.getElementsByClassName(e) }
                }
                ,
                g = [],
                v = [],
                (n.qsa = X.test(f.querySelectorAll)) && (pe(function (e) {
                  let t
                  h.appendChild(e).innerHTML = "<a id='" + A + "'></a><select id='" + A + "-\r\\' msallowcapture=''><option selected=''></option></select>",
                  e.querySelectorAll("[msallowcapture^='']").length && v.push('[*^$]=' + I + "*(?:''|\"\")"),
                  e.querySelectorAll('[selected]').length || v.push('\\[' + I + '*(?:value|' + M + ')'),
                  e.querySelectorAll('[id~=' + A + '-]').length || v.push('~='),
                  (t = f.createElement('input')).setAttribute('name', ''),
                  e.appendChild(t),
                  e.querySelectorAll("[name='']").length || v.push('\\[' + I + '*name' + I + '*=' + I + "*(?:''|\"\")"),
                  e.querySelectorAll(':checked').length || v.push(':checked'),
                  e.querySelectorAll('a#' + A + '+*').length || v.push('.#.+[+~]'),
                  e.querySelectorAll('\\\f'),
                  v.push('[\\r\\n\\f]')
                }
                ),
                pe(function (e) {
                  e.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>"
                  const t = f.createElement('input')
                  t.setAttribute('type', 'hidden'),
                  e.appendChild(t).setAttribute('name', 'D'),
                  e.querySelectorAll('[name=d]').length && v.push('name' + I + '*[*^$|!~]?='),
                  e.querySelectorAll(':enabled').length !== 2 && v.push(':enabled', ':disabled'),
                  h.appendChild(e).disabled = !0,
                  e.querySelectorAll(':disabled').length !== 2 && v.push(':enabled', ':disabled'),
                  e.querySelectorAll('*,:x'),
                  v.push(',.*:')
                }
                )),
                (n.matchesSelector = X.test(y = h.matches || h.webkitMatchesSelector || h.mozMatchesSelector || h.oMatchesSelector || h.msMatchesSelector)) && pe(function (e) {
                  n.disconnectedMatch = y.call(e, '*'),
                  y.call(e, "[s!='']:x"),
                  g.push('!=', F)
                }
                ),
                v = v.length && new RegExp(v.join('|')),
                g = g.length && new RegExp(g.join('|')),
                t = X.test(h.compareDocumentPosition),
                b = t || X.test(h.contains)
                  ? function (e, t) {
                    const n = e.nodeType === 9 ? e.documentElement : e
                    const r = t && t.parentNode
                    return e === r || !(!r || r.nodeType !== 1 || !(n.contains ? n.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r)))
                  }
                  : function (e, t) {
                    if (t) {
                      for (; t = t.parentNode;) {
                        if (t === e) { return !0 }
                      }
                    }
                    return !1
                  }
                ,
                j = t
                  ? function (e, t) {
                    if (e === t) {
                      return u = !0,
                      0
                    }
                    let r = !e.compareDocumentPosition - !t.compareDocumentPosition
                    return r || (1 & (r = (e.ownerDocument || e) == (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1) || !n.sortDetached && t.compareDocumentPosition(e) === r ? e == f || e.ownerDocument == E && b(E, e) ? -1 : t == f || t.ownerDocument == E && b(E, t) ? 1 : p ? N(p, e) - N(p, t) : 0 : 4 & r ? -1 : 1)
                  }
                  : function (e, t) {
                    if (e === t) {
                      return u = !0,
                      0
                    }
                    let n; let r = 0; const o = e.parentNode; const i = t.parentNode; const a = [e]; const s = [t]
                    if (!o || !i) { return e == f ? -1 : t == f ? 1 : o ? -1 : i ? 1 : p ? N(p, e) - N(p, t) : 0 }
                    if (o === i) { return de(e, t) }
                    for (n = e; n = n.parentNode;) { a.unshift(n) }
                    for (n = t; n = n.parentNode;) { s.unshift(n) }
                    for (; a[r] === s[r];) { r++ }
                    return r ? de(a[r], s[r]) : a[r] == E ? -1 : s[r] == E ? 1 : 0
                  }
                ,
                f)
              : f
          }
          ,
          se.matches = function (e, t) {
            return se(e, null, null, t)
          }
          ,
          se.matchesSelector = function (e, t) {
            if (d(e),
            n.matchesSelector && m && !k[t + ' '] && (!g || !g.test(t)) && (!v || !v.test(t))) {
              try {
                const r = y.call(e, t)
                if (r || n.disconnectedMatch || e.document && e.document.nodeType !== 11) { return r }
              } catch (e) {
                k(t, !0)
              }
            }
            return se(t, f, null, [e]).length > 0
          }
          ,
          se.contains = function (e, t) {
            return (e.ownerDocument || e) != f && d(e),
            b(e, t)
          }
          ,
          se.attr = function (e, t) {
            (e.ownerDocument || e) != f && d(e)
            const o = r.attrHandle[t.toLowerCase()]
            let i = o && B.call(r.attrHandle, t.toLowerCase()) ? o(e, t, !m) : void 0
            return void 0 !== i ? i : n.attributes || !m ? e.getAttribute(t) : (i = e.getAttributeNode(t)) && i.specified ? i.value : null
          }
          ,
          se.escape = function (e) {
            return (e + '').replace(re, oe)
          }
          ,
          se.error = function (e) {
            throw new Error('Syntax error, unrecognized expression: ' + e)
          }
          ,
          se.uniqueSort = function (e) {
            let t; const r = []; let o = 0; let i = 0
            if (u = !n.detectDuplicates,
            p = !n.sortStable && e.slice(0),
            e.sort(j),
            u) {
              for (; t = e[i++];) { t === e[i] && (o = r.push(i)) }
              for (; o--;) { e.splice(r[o], 1) }
            }
            return p = null,
            e
          }
          ,
          o = se.getText = function (e) {
            let t; let n = ''; let r = 0; const i = e.nodeType
            if (i) {
              if (i === 1 || i === 9 || i === 11) {
                if (typeof e.textContent === 'string') { return e.textContent }
                for (e = e.firstChild; e; e = e.nextSibling) { n += o(e) }
              } else if (i === 3 || i === 4) { return e.nodeValue }
            } else {
              for (; t = e[r++];) { n += o(t) }
            }
            return n
          }
          ,
          r = se.selectors = {
            cacheLength: 50,
            createPseudo: le,
            match: Q,
            attrHandle: {},
            find: {},
            relative: {
              '>': {
                dir: 'parentNode',
                first: !0
              },
              ' ': {
                dir: 'parentNode'
              },
              '+': {
                dir: 'previousSibling',
                first: !0
              },
              '~': {
                dir: 'previousSibling'
              }
            },
            preFilter: {
              ATTR: function (e) {
                return e[1] = e[1].replace(te, ne),
                e[3] = (e[3] || e[4] || e[5] || '').replace(te, ne),
                e[2] === '~=' && (e[3] = ' ' + e[3] + ' '),
                e.slice(0, 4)
              },
              CHILD: function (e) {
                return e[1] = e[1].toLowerCase(),
                e[1].slice(0, 3) === 'nth'
                  ? (e[3] || se.error(e[0]),
                    e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * (e[3] === 'even' || e[3] === 'odd')),
                    e[5] = +(e[7] + e[8] || e[3] === 'odd'))
                  : e[3] && se.error(e[0]),
                e
              },
              PSEUDO: function (e) {
                let t; const n = !e[6] && e[2]
                return Q.CHILD.test(e[0])
                  ? null
                  : (e[3]
                      ? e[2] = e[4] || e[5] || ''
                      : n && U.test(n) && (t = a(n, !0)) && (t = n.indexOf(')', n.length - t) - n.length) && (e[0] = e[0].slice(0, t),
                      e[2] = n.slice(0, t)),
                    e.slice(0, 3))
              }
            },
            filter: {
              TAG: function (e) {
                const t = e.replace(te, ne).toLowerCase()
                return e === '*'
                  ? function () {
                    return !0
                  }
                  : function (e) {
                    return e.nodeName && e.nodeName.toLowerCase() === t
                  }
              },
              CLASS: function (e) {
                let t = _[e + ' ']
                return t || (t = new RegExp('(^|' + I + ')' + e + '(' + I + '|$)')) && _(e, function (e) {
                  return t.test(typeof e.className === 'string' && e.className || void 0 !== e.getAttribute && e.getAttribute('class') || '')
                }
                )
              },
              ATTR: function (e, t, n) {
                return function (r) {
                  let o = se.attr(r, e)
                  return o == null
                    ? t === '!='
                    : !t || (o += '',
                      t === '=' ? o === n : t === '!=' ? o !== n : t === '^=' ? n && o.indexOf(n) === 0 : t === '*=' ? n && o.indexOf(n) > -1 : t === '$=' ? n && o.slice(-n.length) === n : t === '~=' ? (' ' + o.replace($, ' ') + ' ').indexOf(n) > -1 : t === '|=' && (o === n || o.slice(0, n.length + 1) === n + '-'))
                }
              },
              CHILD: function (e, t, n, r, o) {
                const i = e.slice(0, 3) !== 'nth'
                const a = e.slice(-4) !== 'last'
                const s = t === 'of-type'
                return r === 1 && o === 0
                  ? function (e) {
                    return !!e.parentNode
                  }
                  : function (t, n, c) {
                    let l; let p; let u; let d; let f; let h; let m = i !== a ? 'nextSibling' : 'previousSibling'; const v = t.parentNode; const g = s && t.nodeName.toLowerCase(); const y = !c && !s; let b = !1
                    if (v) {
                      if (i) {
                        for (; m;) {
                          for (d = t; d = d[m];) {
                            if (s ? d.nodeName.toLowerCase() === g : d.nodeType === 1) { return !1 }
                          }
                          h = m = e === 'only' && !h && 'nextSibling'
                        }
                        return !0
                      }
                      if (h = [a ? v.firstChild : v.lastChild],
                      a && y) {
                        for (b = (f = (l = (p = (u = (d = v)[A] || (d[A] = {}))[d.uniqueID] || (u[d.uniqueID] = {}))[e] || [])[0] === x && l[1]) && l[2],
                        d = f && v.childNodes[f]; d = ++f && d && d[m] || (b = f = 0) || h.pop();) {
                          if (d.nodeType === 1 && ++b && d === t) {
                            p[e] = [x, f, b]
                            break
                          }
                        }
                      } else if (y && (b = f = (l = (p = (u = (d = t)[A] || (d[A] = {}))[d.uniqueID] || (u[d.uniqueID] = {}))[e] || [])[0] === x && l[1]),
                      !1 === b) {
                        for (; (d = ++f && d && d[m] || (b = f = 0) || h.pop()) && ((s ? d.nodeName.toLowerCase() !== g : d.nodeType !== 1) || !++b || (y && ((p = (u = d[A] || (d[A] = {}))[d.uniqueID] || (u[d.uniqueID] = {}))[e] = [x, b]),
                        d !== t));)
                          ;
                      }
                      return (b -= o) === r || b % r == 0 && b / r >= 0
                    }
                  }
              },
              PSEUDO: function (e, t) {
                let n; const o = r.pseudos[e] || r.setFilters[e.toLowerCase()] || se.error('unsupported pseudo: ' + e)
                return o[A]
                  ? o(t)
                  : o.length > 1
                    ? (n = [e, e, '', t],
                      r.setFilters.hasOwnProperty(e.toLowerCase())
                        ? le(function (e, n) {
                          for (var r, i = o(e, t), a = i.length; a--;) { e[r = N(e, i[a])] = !(n[r] = i[a]) }
                        }
                        )
                        : function (e) {
                          return o(e, 0, n)
                        }
                      )
                    : o
              }
            },
            pseudos: {
              not: le(function (e) {
                const t = []
                const n = []
                const r = s(e.replace(H, '$1'))
                return r[A]
                  ? le(function (e, t, n, o) {
                    for (var i, a = r(e, null, o, []), s = e.length; s--;) { (i = a[s]) && (e[s] = !(t[s] = i)) }
                  }
                  )
                  : function (e, o, i) {
                    return t[0] = e,
                    r(t, null, i, n),
                    t[0] = null,
                    !n.pop()
                  }
              }
              ),
              has: le(function (e) {
                return function (t) {
                  return se(e, t).length > 0
                }
              }
              ),
              contains: le(function (e) {
                return e = e.replace(te, ne),
                function (t) {
                  return (t.textContent || o(t)).indexOf(e) > -1
                }
              }
              ),
              lang: le(function (e) {
                return V.test(e || '') || se.error('unsupported lang: ' + e),
                e = e.replace(te, ne).toLowerCase(),
                function (t) {
                  let n
                  do {
                    if (n = m ? t.lang : t.getAttribute('xml:lang') || t.getAttribute('lang')) { return (n = n.toLowerCase()) === e || n.indexOf(e + '-') === 0 }
                  } while ((t = t.parentNode) && t.nodeType === 1)
                  return !1
                }
              }
              ),
              target: function (t) {
                const n = e.location && e.location.hash
                return n && n.slice(1) === t.id
              },
              root: function (e) {
                return e === h
              },
              focus: function (e) {
                return e === f.activeElement && (!f.hasFocus || f.hasFocus()) && !!(e.type || e.href || ~e.tabIndex)
              },
              enabled: me(!1),
              disabled: me(!0),
              checked: function (e) {
                const t = e.nodeName.toLowerCase()
                return t === 'input' && !!e.checked || t === 'option' && !!e.selected
              },
              selected: function (e) {
                return e.parentNode && e.parentNode.selectedIndex,
                !0 === e.selected
              },
              empty: function (e) {
                for (e = e.firstChild; e; e = e.nextSibling) {
                  if (e.nodeType < 6) { return !1 }
                }
                return !0
              },
              parent: function (e) {
                return !r.pseudos.empty(e)
              },
              header: function (e) {
                return J.test(e.nodeName)
              },
              input: function (e) {
                return K.test(e.nodeName)
              },
              button: function (e) {
                const t = e.nodeName.toLowerCase()
                return t === 'input' && e.type === 'button' || t === 'button'
              },
              text: function (e) {
                let t
                return e.nodeName.toLowerCase() === 'input' && e.type === 'text' && ((t = e.getAttribute('type')) == null || t.toLowerCase() === 'text')
              },
              first: ve(function () {
                return [0]
              }
              ),
              last: ve(function (e, t) {
                return [t - 1]
              }
              ),
              eq: ve(function (e, t, n) {
                return [n < 0 ? n + t : n]
              }
              ),
              even: ve(function (e, t) {
                for (let n = 0; n < t; n += 2) { e.push(n) }
                return e
              }
              ),
              odd: ve(function (e, t) {
                for (let n = 1; n < t; n += 2) { e.push(n) }
                return e
              }
              ),
              lt: ve(function (e, t, n) {
                for (let r = n < 0 ? n + t : n > t ? t : n; --r >= 0;) { e.push(r) }
                return e
              }
              ),
              gt: ve(function (e, t, n) {
                for (let r = n < 0 ? n + t : n; ++r < t;) { e.push(r) }
                return e
              }
              )
            }
          },
          r.pseudos.nth = r.pseudos.eq,
          {
            radio: !0,
            checkbox: !0,
            file: !0,
            password: !0,
            image: !0
          }) { r.pseudos[t] = fe(t) }
          for (t in {
            submit: !0,
            reset: !0
          }) { r.pseudos[t] = he(t) }
          function ye () {}
          function be (e) {
            for (var t = 0, n = e.length, r = ''; t < n; t++) { r += e[t].value }
            return r
          }
          function Ae (e, t, n) {
            const r = t.dir
            const o = t.next
            const i = o || r
            const a = n && i === 'parentNode'
            const s = w++
            return t.first
              ? function (t, n, o) {
                for (; t = t[r];) {
                  if (t.nodeType === 1 || a) { return e(t, n, o) }
                }
                return !1
              }
              : function (t, n, c) {
                let l; let p; let u; const d = [x, s]
                if (c) {
                  for (; t = t[r];) {
                    if ((t.nodeType === 1 || a) && e(t, n, c)) { return !0 }
                  }
                } else {
                  for (; t = t[r];) {
                    if (t.nodeType === 1 || a) {
                      if (p = (u = t[A] || (t[A] = {}))[t.uniqueID] || (u[t.uniqueID] = {}),
                      o && o === t.nodeName.toLowerCase()) { t = t[r] || t } else {
                        if ((l = p[i]) && l[0] === x && l[1] === s) { return d[2] = l[2] }
                        if (p[i] = d,
                        d[2] = e(t, n, c)) { return !0 }
                      }
                    }
                  }
                }
                return !1
              }
          }
          function Ee (e) {
            return e.length > 1
              ? function (t, n, r) {
                for (let o = e.length; o--;) {
                  if (!e[o](t, n, r)) { return !1 }
                }
                return !0
              }
              : e[0]
          }
          function xe (e, t, n, r, o) {
            for (var i, a = [], s = 0, c = e.length, l = t != null; s < c; s++) {
              (i = e[s]) && (n && !n(i, r, o) || (a.push(i),
              l && t.push(s)))
            }
            return a
          }
          function we (e, t, n, r, o, i) {
            return r && !r[A] && (r = we(r)),
            o && !o[A] && (o = we(o, i)),
            le(function (i, a, s, c) {
              let l; let p; let u; const d = []; const f = []; const h = a.length; const m = i || (function (e, t, n) {
                for (let r = 0, o = t.length; r < o; r++) { se(e, t[r], n) }
                return n
              }(t || '*', s.nodeType ? [s] : s, [])); const v = !e || !i && t ? m : xe(m, d, e, s, c); let g = n ? o || (i ? e : h || r) ? [] : a : v
              if (n && n(v, g, s, c),
              r) {
                for (l = xe(g, f),
                r(l, [], s, c),
                p = l.length; p--;) { (u = l[p]) && (g[f[p]] = !(v[f[p]] = u)) }
              }
              if (i) {
                if (o || e) {
                  if (o) {
                    for (l = [],
                    p = g.length; p--;) { (u = g[p]) && l.push(v[p] = u) }
                    o(null, g = [], l, c)
                  }
                  for (p = g.length; p--;) { (u = g[p]) && (l = o ? N(i, u) : d[p]) > -1 && (i[l] = !(a[l] = u)) }
                }
              } else {
                g = xe(g === a ? g.splice(h, g.length) : g),
                o ? o(null, a, g, c) : T.apply(a, g)
              }
            }
            )
          }
          function _e (e) {
            for (var t, n, o, i = e.length, a = r.relative[e[0].type], s = a || r.relative[' '], c = a ? 1 : 0, p = Ae(function (e) {
                return e === t
              }
              , s, !0), u = Ae(function (e) {
                return N(t, e) > -1
              }
              , s, !0), d = [function (e, n, r) {
                const o = !a && (r || n !== l) || ((t = n).nodeType ? p(e, n, r) : u(e, n, r))
                return t = null,
                o
              }
              ]; c < i; c++) {
              if (n = r.relative[e[c].type]) { d = [Ae(Ee(d), n)] } else {
                if ((n = r.filter[e[c].type].apply(null, e[c].matches))[A]) {
                  for (o = ++c; o < i && !r.relative[e[o].type]; o++)
                    ;
                  return we(c > 1 && Ee(d), c > 1 && be(e.slice(0, c - 1).concat({
                    value: e[c - 2].type === ' ' ? '*' : ''
                  })).replace(H, '$1'), n, c < o && _e(e.slice(c, o)), o < i && _e(e = e.slice(o)), o < i && be(e))
                }
                d.push(n)
              }
            }
            return Ee(d)
          }
          return ye.prototype = r.filters = r.pseudos,
          r.setFilters = new ye(),
          a = se.tokenize = function (e, t) {
            let n; let o; let i; let a; let s; let c; let l; const p = C[e + ' ']
            if (p) { return t ? 0 : p.slice(0) }
            for (s = e,
            c = [],
            l = r.preFilter; s;) {
              for (a in n && !(o = q.exec(s)) || (o && (s = s.slice(o[0].length) || s),
              c.push(i = [])),
              n = !1,
              (o = W.exec(s)) && (n = o.shift(),
              i.push({
                value: n,
                type: o[0].replace(H, ' ')
              }),
              s = s.slice(n.length)),
              r.filter) {
                !(o = Q[a].exec(s)) || l[a] && !(o = l[a](o)) || (n = o.shift(),
                i.push({
                  value: n,
                  type: a,
                  matches: o
                }),
                s = s.slice(n.length))
              }
              if (!n) { break }
            }
            return t ? s.length : s ? se.error(e) : C(e, c).slice(0)
          }
          ,
          s = se.compile = function (e, t) {
            let n; const o = []; const i = []; let s = S[e + ' ']
            if (!s) {
              for (t || (t = a(e)),
              n = t.length; n--;) { (s = _e(t[n]))[A] ? o.push(s) : i.push(s) }
              s = S(e, (function (e, t) {
                const n = t.length > 0
                const o = e.length > 0
                const i = function (i, a, s, c, p) {
                  let u; let h; let v; let g = 0; let y = '0'; const b = i && []; let A = []; const E = l; const w = i || o && r.find.TAG('*', p); const _ = x += E == null ? 1 : Math.random() || 0.1; const C = w.length
                  for (p && (l = a == f || a || p); y !== C && (u = w[y]) != null; y++) {
                    if (o && u) {
                      for (h = 0,
                      a || u.ownerDocument == f || (d(u),
                      s = !m); v = e[h++];) {
                        if (v(u, a || f, s)) {
                          c.push(u)
                          break
                        }
                      }
                      p && (x = _)
                    }
                    n && ((u = !v && u) && g--,
                    i && b.push(u))
                  }
                  if (g += y,
                  n && y !== g) {
                    for (h = 0; v = t[h++];) { v(b, A, a, s) }
                    if (i) {
                      if (g > 0) {
                        for (; y--;) { b[y] || A[y] || (A[y] = P.call(c)) }
                      }
                      A = xe(A)
                    }
                    T.apply(c, A),
                    p && !i && A.length > 0 && g + t.length > 1 && se.uniqueSort(c)
                  }
                  return p && (x = _,
                  l = E),
                  b
                }
                return n ? le(i) : i
              }(i, o))),
              s.selector = e
            }
            return s
          }
          ,
          c = se.select = function (e, t, n, o) {
            let i; let c; let l; let p; let u; const d = typeof e === 'function' && e; const f = !o && a(e = d.selector || e)
            if (n = n || [],
            f.length === 1) {
              if ((c = f[0] = f[0].slice(0)).length > 2 && (l = c[0]).type === 'ID' && t.nodeType === 9 && m && r.relative[c[1].type]) {
                if (!(t = (r.find.ID(l.matches[0].replace(te, ne), t) || [])[0])) { return n }
                d && (t = t.parentNode),
                e = e.slice(c.shift().value.length)
              }
              for (i = Q.needsContext.test(e) ? 0 : c.length; i-- && (l = c[i],
              !r.relative[p = l.type]);) {
                if ((u = r.find[p]) && (o = u(l.matches[0].replace(te, ne), ee.test(c[0].type) && ge(t.parentNode) || t))) {
                  if (c.splice(i, 1),
                  !(e = o.length && be(c))) {
                    return T.apply(n, o),
                    n
                  }
                  break
                }
              }
            }
            return (d || s(e, f))(o, t, !m, n, !t || ee.test(e) && ge(t.parentNode) || t),
            n
          }
          ,
          n.sortStable = A.split('').sort(j).join('') === A,
          n.detectDuplicates = !!u,
          d(),
          n.sortDetached = pe(function (e) {
            return 1 & e.compareDocumentPosition(f.createElement('fieldset'))
          }
          ),
          pe(function (e) {
            return e.innerHTML = "<a href='#'></a>",
            e.firstChild.getAttribute('href') === '#'
          }
          ) || ue('type|href|height|width', function (e, t, n) {
            if (!n) { return e.getAttribute(t, t.toLowerCase() === 'type' ? 1 : 2) }
          }
          ),
          n.attributes && pe(function (e) {
            return e.innerHTML = '<input/>',
            e.firstChild.setAttribute('value', ''),
            e.firstChild.getAttribute('value') === ''
          }
          ) || ue('value', function (e, t, n) {
            if (!n && e.nodeName.toLowerCase() === 'input') { return e.defaultValue }
          }
          ),
          pe(function (e) {
            return e.getAttribute('disabled') == null
          }
          ) || ue(M, function (e, t, n) {
            let r
            if (!n) { return !0 === e[t] ? t.toLowerCase() : (r = e.getAttributeNode(t)) && r.specified ? r.value : null }
          }
          ),
          se
        }(n))
        C.find = k,
        C.expr = k.selectors,
        C.expr[':'] = C.expr.pseudos,
        C.uniqueSort = C.unique = k.uniqueSort,
        C.text = k.getText,
        C.isXMLDoc = k.isXML,
        C.contains = k.contains,
        C.escapeSelector = k.escape
        const j = function (e, t, n) {
          for (var r = [], o = void 0 !== n; (e = e[t]) && e.nodeType !== 9;) {
            if (e.nodeType === 1) {
              if (o && C(e).is(n)) { break }
              r.push(e)
            }
          }
          return r
        }
        const B = function (e, t) {
          for (var n = []; e; e = e.nextSibling) { e.nodeType === 1 && e !== t && n.push(e) }
          return n
        }
        const D = C.expr.match.needsContext
        function P (e, t) {
          return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase()
        }
        const O = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i
        function T (e, t, n) {
          return y(t)
            ? C.grep(e, function (e, r) {
              return !!t.call(e, r, e) !== n
            }
            )
            : t.nodeType
              ? C.grep(e, function (e) {
                return e === t !== n
              }
              )
              : typeof t !== 'string'
                ? C.grep(e, function (e) {
                  return u.call(t, e) > -1 !== n
                }
                )
                : C.filter(t, e, n)
        }
        C.filter = function (e, t, n) {
          const r = t[0]
          return n && (e = ':not(' + e + ')'),
          t.length === 1 && r.nodeType === 1
            ? C.find.matchesSelector(r, e) ? [r] : []
            : C.find.matches(e, C.grep(t, function (e) {
              return e.nodeType === 1
            }
            ))
        }
        ,
        C.fn.extend({
          find: function (e) {
            let t; let n; const r = this.length; const o = this
            if (typeof e !== 'string') {
              return this.pushStack(C(e).filter(function () {
                for (t = 0; t < r; t++) {
                  if (C.contains(o[t], this)) { return !0 }
                }
              }
              ))
            }
            for (n = this.pushStack([]),
            t = 0; t < r; t++) { C.find(e, o[t], n) }
            return r > 1 ? C.uniqueSort(n) : n
          },
          filter: function (e) {
            return this.pushStack(T(this, e || [], !1))
          },
          not: function (e) {
            return this.pushStack(T(this, e || [], !0))
          },
          is: function (e) {
            return !!T(this, typeof e === 'string' && D.test(e) ? C(e) : e || [], !1).length
          }
        })
        let R; const N = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
        (C.fn.init = function (e, t, n) {
          let r, o
          if (!e) { return this }
          if (n = n || R,
          typeof e === 'string') {
            if (!(r = e[0] === '<' && e[e.length - 1] === '>' && e.length >= 3 ? [null, e, null] : N.exec(e)) || !r[1] && t) { return !t || t.jquery ? (t || n).find(e) : this.constructor(t).find(e) }
            if (r[1]) {
              if (t = t instanceof C ? t[0] : t,
              C.merge(this, C.parseHTML(r[1], t && t.nodeType ? t.ownerDocument || t : A, !0)),
              O.test(r[1]) && C.isPlainObject(t)) {
                for (r in t) { y(this[r]) ? this[r](t[r]) : this.attr(r, t[r]) }
              }
              return this
            }
            return (o = A.getElementById(r[2])) && (this[0] = o,
            this.length = 1),
            this
          }
          return e.nodeType
            ? (this[0] = e,
              this.length = 1,
              this)
            : y(e) ? void 0 !== n.ready ? n.ready(e) : e(C) : C.makeArray(e, this)
        }
        ).prototype = C.fn,
        R = C(A)
        const M = /^(?:parents|prev(?:Until|All))/
        const I = {
          children: !0,
          contents: !0,
          next: !0,
          prev: !0
        }
        function L (e, t) {
          for (; (e = e[t]) && e.nodeType !== 1;)
            ;
          return e
        }
        C.fn.extend({
          has: function (e) {
            const t = C(e, this)
            const n = t.length
            return this.filter(function () {
              for (let e = 0; e < n; e++) {
                if (C.contains(this, t[e])) { return !0 }
              }
            }
            )
          },
          closest: function (e, t) {
            let n; let r = 0; const o = this.length; const i = []; const a = typeof e !== 'string' && C(e)
            if (!D.test(e)) {
              for (; r < o; r++) {
                for (n = this[r]; n && n !== t; n = n.parentNode) {
                  if (n.nodeType < 11 && (a ? a.index(n) > -1 : n.nodeType === 1 && C.find.matchesSelector(n, e))) {
                    i.push(n)
                    break
                  }
                }
              }
            }
            return this.pushStack(i.length > 1 ? C.uniqueSort(i) : i)
          },
          index: function (e) {
            return e ? typeof e === 'string' ? u.call(C(e), this[0]) : u.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
          },
          add: function (e, t) {
            return this.pushStack(C.uniqueSort(C.merge(this.get(), C(e, t))))
          },
          addBack: function (e) {
            return this.add(e == null ? this.prevObject : this.prevObject.filter(e))
          }
        }),
        C.each({
          parent: function (e) {
            const t = e.parentNode
            return t && t.nodeType !== 11 ? t : null
          },
          parents: function (e) {
            return j(e, 'parentNode')
          },
          parentsUntil: function (e, t, n) {
            return j(e, 'parentNode', n)
          },
          next: function (e) {
            return L(e, 'nextSibling')
          },
          prev: function (e) {
            return L(e, 'previousSibling')
          },
          nextAll: function (e) {
            return j(e, 'nextSibling')
          },
          prevAll: function (e) {
            return j(e, 'previousSibling')
          },
          nextUntil: function (e, t, n) {
            return j(e, 'nextSibling', n)
          },
          prevUntil: function (e, t, n) {
            return j(e, 'previousSibling', n)
          },
          siblings: function (e) {
            return B((e.parentNode || {}).firstChild, e)
          },
          children: function (e) {
            return B(e.firstChild)
          },
          contents: function (e) {
            return e.contentDocument != null && s(e.contentDocument)
              ? e.contentDocument
              : (P(e, 'template') && (e = e.content || e),
                C.merge([], e.childNodes))
          }
        }, function (e, t) {
          C.fn[e] = function (n, r) {
            let o = C.map(this, t, n)
            return e.slice(-5) !== 'Until' && (r = n),
            r && typeof r === 'string' && (o = C.filter(r, o)),
            this.length > 1 && (I[e] || C.uniqueSort(o),
            M.test(e) && o.reverse()),
            this.pushStack(o)
          }
        }
        )
        const z = /[^\x20\t\r\n\f]+/g
        function F (e) {
          return e
        }
        function $ (e) {
          throw e
        }
        function H (e, t, n, r) {
          let o
          try {
            e && y(o = e.promise) ? o.call(e).done(t).fail(n) : e && y(o = e.then) ? o.call(e, t, n) : t.apply(void 0, [e].slice(r))
          } catch (e) {
            n.apply(void 0, [e])
          }
        }
        C.Callbacks = function (e) {
          e = typeof e === 'string'
            ? (function (e) {
                const t = {}
                return C.each(e.match(z) || [], function (e, n) {
                  t[n] = !0
                }
                ),
                t
              }(e))
            : C.extend({}, e)
          let t; let n; let r; let o; let i = []; let a = []; let s = -1; const c = function () {
            for (o = o || e.once,
            r = t = !0; a.length; s = -1) {
              for (n = a.shift(); ++s < i.length;) {
                !1 === i[s].apply(n[0], n[1]) && e.stopOnFalse && (s = i.length,
                n = !1)
              }
            }
            e.memory || (n = !1),
            t = !1,
            o && (i = n ? [] : '')
          }; var l = {
            add: function () {
              return i && (n && !t && (s = i.length - 1,
              a.push(n)),
              (function t (n) {
                C.each(n, function (n, r) {
                  y(r) ? e.unique && l.has(r) || i.push(r) : r && r.length && w(r) !== 'string' && t(r)
                }
                )
              }(arguments)),
              n && !t && c()),
              this
            },
            remove: function () {
              return C.each(arguments, function (e, t) {
                for (var n; (n = C.inArray(t, i, n)) > -1;) {
                  i.splice(n, 1),
                  n <= s && s--
                }
              }
              ),
              this
            },
            has: function (e) {
              return e ? C.inArray(e, i) > -1 : i.length > 0
            },
            empty: function () {
              return i && (i = []),
              this
            },
            disable: function () {
              return o = a = [],
              i = n = '',
              this
            },
            disabled: function () {
              return !i
            },
            lock: function () {
              return o = a = [],
              n || t || (i = n = ''),
              this
            },
            locked: function () {
              return !!o
            },
            fireWith: function (e, n) {
              return o || (n = [e, (n = n || []).slice ? n.slice() : n],
              a.push(n),
              t || c()),
              this
            },
            fire: function () {
              return l.fireWith(this, arguments),
              this
            },
            fired: function () {
              return !!r
            }
          }
          return l
        }
        ,
        C.extend({
          Deferred: function (e) {
            const t = [['notify', 'progress', C.Callbacks('memory'), C.Callbacks('memory'), 2], ['resolve', 'done', C.Callbacks('once memory'), C.Callbacks('once memory'), 0, 'resolved'], ['reject', 'fail', C.Callbacks('once memory'), C.Callbacks('once memory'), 1, 'rejected']]
            let r = 'pending'
            var i = {
              state: function () {
                return r
              },
              always: function () {
                return a.done(arguments).fail(arguments),
                this
              },
              catch: function (e) {
                return i.then(null, e)
              },
              pipe: function () {
                let e = arguments
                return C.Deferred(function (n) {
                  C.each(t, function (t, r) {
                    const o = y(e[r[4]]) && e[r[4]]
                    a[r[1]](function () {
                      const e = o && o.apply(this, arguments)
                      e && y(e.promise) ? e.promise().progress(n.notify).done(n.resolve).fail(n.reject) : n[r[0] + 'With'](this, o ? [e] : arguments)
                    }
                    )
                  }
                  ),
                  e = null
                }
                ).promise()
              },
              then: function (e, r, i) {
                let a = 0
                function s (e, t, r, i) {
                  return function () {
                    let c = this
                    let l = arguments
                    const p = function () {
                      let n, p
                      if (!(e < a)) {
                        if ((n = r.apply(c, l)) === t.promise()) { throw new TypeError('Thenable self-resolution') }
                        p = n && (o(n) === 'object' || typeof n === 'function') && n.then,
                        y(p)
                          ? i
                            ? p.call(n, s(a, t, F, i), s(a, t, $, i))
                            : (a++,
                              p.call(n, s(a, t, F, i), s(a, t, $, i), s(a, t, F, t.notifyWith)))
                          : (r !== F && (c = void 0,
                            l = [n]),
                            (i || t.resolveWith)(c, l))
                      }
                    }
                    var u = i
                      ? p
                      : function () {
                        try {
                          p()
                        } catch (n) {
                          C.Deferred.exceptionHook && C.Deferred.exceptionHook(n, u.stackTrace),
                          e + 1 >= a && (r !== $ && (c = void 0,
                          l = [n]),
                          t.rejectWith(c, l))
                        }
                      }

                    e
                      ? u()
                      : (C.Deferred.getStackHook && (u.stackTrace = C.Deferred.getStackHook()),
                        n.setTimeout(u))
                  }
                }
                return C.Deferred(function (n) {
                  t[0][3].add(s(0, n, y(i) ? i : F, n.notifyWith)),
                  t[1][3].add(s(0, n, y(e) ? e : F)),
                  t[2][3].add(s(0, n, y(r) ? r : $))
                }
                ).promise()
              },
              promise: function (e) {
                return e != null ? C.extend(e, i) : i
              }
            }
            var a = {}
            return C.each(t, function (e, n) {
              const o = n[2]
              const s = n[5]
              i[n[1]] = o.add,
              s && o.add(function () {
                r = s
              }
              , t[3 - e][2].disable, t[3 - e][3].disable, t[0][2].lock, t[0][3].lock),
              o.add(n[3].fire),
              a[n[0]] = function () {
                return a[n[0] + 'With'](this === a ? void 0 : this, arguments),
                this
              }
              ,
              a[n[0] + 'With'] = o.fireWith
            }
            ),
            i.promise(a),
            e && e.call(a, a),
            a
          },
          when: function (e) {
            let t = arguments.length
            let n = t
            const r = Array(n)
            const o = c.call(arguments)
            const i = C.Deferred()
            const a = function (e) {
              return function (n) {
                r[e] = this,
                o[e] = arguments.length > 1 ? c.call(arguments) : n,
                --t || i.resolveWith(r, o)
              }
            }
            if (t <= 1 && (H(e, i.done(a(n)).resolve, i.reject, !t),
            i.state() === 'pending' || y(o[n] && o[n].then))) { return i.then() }
            for (; n--;) { H(o[n], a(n), i.reject) }
            return i.promise()
          }
        })
        const q = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/
        C.Deferred.exceptionHook = function (e, t) {
          n.console && n.console.warn && e && q.test(e.name) && n.console.warn('jQuery.Deferred exception: ' + e.message, e.stack, t)
        }
        ,
        C.readyException = function (e) {
          n.setTimeout(function () {
            throw e
          }
          )
        }

        const W = C.Deferred()
        function G () {
          A.removeEventListener('DOMContentLoaded', G),
          n.removeEventListener('load', G),
          C.ready()
        }
        C.fn.ready = function (e) {
          return W.then(e).catch(function (e) {
            C.readyException(e)
          }
          ),
          this
        }
        ,
        C.extend({
          isReady: !1,
          readyWait: 1,
          ready: function (e) {
            (!0 === e ? --C.readyWait : C.isReady) || (C.isReady = !0,
            !0 !== e && --C.readyWait > 0 || W.resolveWith(A, [C]))
          }
        }),
        C.ready.then = W.then,
        A.readyState === 'complete' || A.readyState !== 'loading' && !A.documentElement.doScroll
          ? n.setTimeout(C.ready)
          : (A.addEventListener('DOMContentLoaded', G),
            n.addEventListener('load', G))
        const U = function e (t, n, r, o, i, a, s) {
          let c = 0
          const l = t.length
          let p = r == null
          if (w(r) === 'object') {
            for (c in i = !0,
            r) { e(t, n, c, r[c], !0, a, s) }
          } else if (void 0 !== o && (i = !0,
          y(o) || (s = !0),
          p && (s
            ? (n.call(t, o),
              n = null)
            : (p = n,
              n = function (e, t, n) {
                return p.call(C(e), n)
              }
              )),
          n)) {
            for (; c < l; c++) { n(t[c], r, s ? o : o.call(t[c], c, n(t[c], r))) }
          }
          return i ? t : p ? n.call(t) : l ? n(t[0], r) : a
        }
        const V = /^-ms-/
        const Q = /-([a-z])/g
        function Y (e, t) {
          return t.toUpperCase()
        }
        function K (e) {
          return e.replace(V, 'ms-').replace(Q, Y)
        }
        const J = function (e) {
          return e.nodeType === 1 || e.nodeType === 9 || !+e.nodeType
        }
        function X () {
          this.expando = C.expando + X.uid++
        }
        X.uid = 1,
        X.prototype = {
          cache: function (e) {
            let t = e[this.expando]
            return t || (t = {},
            J(e) && (e.nodeType
              ? e[this.expando] = t
              : Object.defineProperty(e, this.expando, {
                value: t,
                configurable: !0
              }))),
            t
          },
          set: function (e, t, n) {
            let r; const o = this.cache(e)
            if (typeof t === 'string') { o[K(t)] = n } else {
              for (r in t) { o[K(r)] = t[r] }
            }
            return o
          },
          get: function (e, t) {
            return void 0 === t ? this.cache(e) : e[this.expando] && e[this.expando][K(t)]
          },
          access: function (e, t, n) {
            return void 0 === t || t && typeof t === 'string' && void 0 === n
              ? this.get(e, t)
              : (this.set(e, t, n),
                void 0 !== n ? n : t)
          },
          remove: function (e, t) {
            let n; const r = e[this.expando]
            if (void 0 !== r) {
              if (void 0 !== t) {
                n = (t = Array.isArray(t) ? t.map(K) : (t = K(t)) in r ? [t] : t.match(z) || []).length
                for (; n--;) { delete r[t[n]] }
              }
              (void 0 === t || C.isEmptyObject(r)) && (e.nodeType ? e[this.expando] = void 0 : delete e[this.expando])
            }
          },
          hasData: function (e) {
            const t = e[this.expando]
            return void 0 !== t && !C.isEmptyObject(t)
          }
        }
        const Z = new X()
        const ee = new X()
        const te = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/
        const ne = /[A-Z]/g
        function re (e, t, n) {
          let r
          if (void 0 === n && e.nodeType === 1) {
            if (r = 'data-' + t.replace(ne, '-$&').toLowerCase(),
            typeof (n = e.getAttribute(r)) === 'string') {
              try {
                n = (function (e) {
                  return e === 'true' || e !== 'false' && (e === 'null' ? null : e === +e + '' ? +e : te.test(e) ? JSON.parse(e) : e)
                }(n))
              } catch (e) {}
              ee.set(e, t, n)
            } else { n = void 0 }
          }
          return n
        }
        C.extend({
          hasData: function (e) {
            return ee.hasData(e) || Z.hasData(e)
          },
          data: function (e, t, n) {
            return ee.access(e, t, n)
          },
          removeData: function (e, t) {
            ee.remove(e, t)
          },
          _data: function (e, t, n) {
            return Z.access(e, t, n)
          },
          _removeData: function (e, t) {
            Z.remove(e, t)
          }
        }),
        C.fn.extend({
          data: function (e, t) {
            let n; let r; let i; const a = this[0]; const s = a && a.attributes
            if (void 0 === e) {
              if (this.length && (i = ee.get(a),
              a.nodeType === 1 && !Z.get(a, 'hasDataAttrs'))) {
                for (n = s.length; n--;) {
                  s[n] && (r = s[n].name).indexOf('data-') === 0 && (r = K(r.slice(5)),
                  re(a, r, i[r]))
                }
                Z.set(a, 'hasDataAttrs', !0)
              }
              return i
            }
            return o(e) === 'object'
              ? this.each(function () {
                ee.set(this, e)
              }
              )
              : U(this, function (t) {
                let n
                if (a && void 0 === t) { return void 0 !== (n = ee.get(a, e)) || void 0 !== (n = re(a, e)) ? n : void 0 }
                this.each(function () {
                  ee.set(this, e, t)
                }
                )
              }
              , null, t, arguments.length > 1, null, !0)
          },
          removeData: function (e) {
            return this.each(function () {
              ee.remove(this, e)
            }
            )
          }
        }),
        C.extend({
          queue: function (e, t, n) {
            let r
            if (e) {
              return t = (t || 'fx') + 'queue',
              r = Z.get(e, t),
              n && (!r || Array.isArray(n) ? r = Z.access(e, t, C.makeArray(n)) : r.push(n)),
              r || []
            }
          },
          dequeue: function (e, t) {
            t = t || 'fx'
            const n = C.queue(e, t)
            let r = n.length
            let o = n.shift()
            const i = C._queueHooks(e, t)
            o === 'inprogress' && (o = n.shift(),
            r--),
            o && (t === 'fx' && n.unshift('inprogress'),
            delete i.stop,
            o.call(e, function () {
              C.dequeue(e, t)
            }
            , i)),
            !r && i && i.empty.fire()
          },
          _queueHooks: function (e, t) {
            const n = t + 'queueHooks'
            return Z.get(e, n) || Z.access(e, n, {
              empty: C.Callbacks('once memory').add(function () {
                Z.remove(e, [t + 'queue', n])
              }
              )
            })
          }
        }),
        C.fn.extend({
          queue: function (e, t) {
            let n = 2
            return typeof e !== 'string' && (t = e,
            e = 'fx',
            n--),
            arguments.length < n
              ? C.queue(this[0], e)
              : void 0 === t
                ? this
                : this.each(function () {
                  const n = C.queue(this, e, t)
                  C._queueHooks(this, e),
                  e === 'fx' && n[0] !== 'inprogress' && C.dequeue(this, e)
                }
                )
          },
          dequeue: function (e) {
            return this.each(function () {
              C.dequeue(this, e)
            }
            )
          },
          clearQueue: function (e) {
            return this.queue(e || 'fx', [])
          },
          promise: function (e, t) {
            let n; let r = 1; const o = C.Deferred(); const i = this; let a = this.length; const s = function () {
              --r || o.resolveWith(i, [i])
            }
            for (typeof e !== 'string' && (t = e,
            e = void 0),
            e = e || 'fx'; a--;) {
              (n = Z.get(i[a], e + 'queueHooks')) && n.empty && (r++,
              n.empty.add(s))
            }
            return s(),
            o.promise(t)
          }
        })
        const oe = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source
        const ie = new RegExp('^(?:([+-])=|)(' + oe + ')([a-z%]*)$', 'i')
        const ae = ['Top', 'Right', 'Bottom', 'Left']
        const se = A.documentElement
        let ce = function (e) {
          return C.contains(e.ownerDocument, e)
        }
        const le = {
          composed: !0
        }
        se.getRootNode && (ce = function (e) {
          return C.contains(e.ownerDocument, e) || e.getRootNode(le) === e.ownerDocument
        }
        )
        const pe = function (e, t) {
          return (e = t || e).style.display === 'none' || e.style.display === '' && ce(e) && C.css(e, 'display') === 'none'
        }
        function ue (e, t, n, r) {
          let o; let i; let a = 20; const s = r
            ? function () {
              return r.cur()
            }
            : function () {
              return C.css(e, t, '')
            }
          let c = s(); let l = n && n[3] || (C.cssNumber[t] ? '' : 'px'); let p = e.nodeType && (C.cssNumber[t] || l !== 'px' && +c) && ie.exec(C.css(e, t))
          if (p && p[3] !== l) {
            for (c /= 2,
            l = l || p[3],
            p = +c || 1; a--;) {
              C.style(e, t, p + l),
              (1 - i) * (1 - (i = s() / c || 0.5)) <= 0 && (a = 0),
              p /= i
            }
            p *= 2,
            C.style(e, t, p + l),
            n = n || []
          }
          return n && (p = +p || +c || 0,
          o = n[1] ? p + (n[1] + 1) * n[2] : +n[2],
          r && (r.unit = l,
          r.start = p,
          r.end = o)),
          o
        }
        const de = {}
        function fe (e) {
          let t; const n = e.ownerDocument; const r = e.nodeName; let o = de[r]
          return o || (t = n.body.appendChild(n.createElement(r)),
          o = C.css(t, 'display'),
          t.parentNode.removeChild(t),
          o === 'none' && (o = 'block'),
          de[r] = o,
          o)
        }
        function he (e, t) {
          for (var n, r, o = [], i = 0, a = e.length; i < a; i++) {
            (r = e[i]).style && (n = r.style.display,
            t
              ? (n === 'none' && (o[i] = Z.get(r, 'display') || null,
                o[i] || (r.style.display = '')),
                r.style.display === '' && pe(r) && (o[i] = fe(r)))
              : n !== 'none' && (o[i] = 'none',
              Z.set(r, 'display', n)))
          }
          for (i = 0; i < a; i++) { o[i] != null && (e[i].style.display = o[i]) }
          return e
        }
        C.fn.extend({
          show: function () {
            return he(this, !0)
          },
          hide: function () {
            return he(this)
          },
          toggle: function (e) {
            return typeof e === 'boolean'
              ? e ? this.show() : this.hide()
              : this.each(function () {
                pe(this) ? C(this).show() : C(this).hide()
              }
              )
          }
        })
        let me; let ve; const ge = /^(?:checkbox|radio)$/i; const ye = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i; const be = /^$|^module$|\/(?:java|ecma)script/i
        me = A.createDocumentFragment().appendChild(A.createElement('div')),
        (ve = A.createElement('input')).setAttribute('type', 'radio'),
        ve.setAttribute('checked', 'checked'),
        ve.setAttribute('name', 't'),
        me.appendChild(ve),
        g.checkClone = me.cloneNode(!0).cloneNode(!0).lastChild.checked,
        me.innerHTML = '<textarea>x</textarea>',
        g.noCloneChecked = !!me.cloneNode(!0).lastChild.defaultValue,
        me.innerHTML = '<option></option>',
        g.option = !!me.lastChild
        const Ae = {
          thead: [1, '<table>', '</table>'],
          col: [2, '<table><colgroup>', '</colgroup></table>'],
          tr: [2, '<table><tbody>', '</tbody></table>'],
          td: [3, '<table><tbody><tr>', '</tr></tbody></table>'],
          _default: [0, '', '']
        }
        function Ee (e, t) {
          let n
          return n = void 0 !== e.getElementsByTagName ? e.getElementsByTagName(t || '*') : void 0 !== e.querySelectorAll ? e.querySelectorAll(t || '*') : [],
          void 0 === t || t && P(e, t) ? C.merge([e], n) : n
        }
        function xe (e, t) {
          for (let n = 0, r = e.length; n < r; n++) { Z.set(e[n], 'globalEval', !t || Z.get(t[n], 'globalEval')) }
        }
        Ae.tbody = Ae.tfoot = Ae.colgroup = Ae.caption = Ae.thead,
        Ae.th = Ae.td,
        g.option || (Ae.optgroup = Ae.option = [1, "<select multiple='multiple'>", '</select>'])
        const we = /<|&#?\w+;/
        function _e (e, t, n, r, o) {
          for (var i, a, s, c, l, p, u = t.createDocumentFragment(), d = [], f = 0, h = e.length; f < h; f++) {
            if ((i = e[f]) || i === 0) {
              if (w(i) === 'object') { C.merge(d, i.nodeType ? [i] : i) } else if (we.test(i)) {
                for (a = a || u.appendChild(t.createElement('div')),
                s = (ye.exec(i) || ['', ''])[1].toLowerCase(),
                c = Ae[s] || Ae._default,
                a.innerHTML = c[1] + C.htmlPrefilter(i) + c[2],
                p = c[0]; p--;) { a = a.lastChild }
                C.merge(d, a.childNodes),
                (a = u.firstChild).textContent = ''
              } else { d.push(t.createTextNode(i)) }
            }
          }
          for (u.textContent = '',
          f = 0; i = d[f++];) {
            if (r && C.inArray(i, r) > -1) { o && o.push(i) } else if (l = ce(i),
            a = Ee(u.appendChild(i), 'script'),
            l && xe(a),
            n) {
              for (p = 0; i = a[p++];) { be.test(i.type || '') && n.push(i) }
            }
          }
          return u
        }
        const Ce = /^([^.]*)(?:\.(.+)|)/
        function Se () {
          return !0
        }
        function ke () {
          return !1
        }
        function je (e, t) {
          return e === (function () {
            try {
              return A.activeElement
            } catch (e) {}
          }()) == (t === 'focus')
        }
        function Be (e, t, n, r, i, a) {
          let s, c
          if (o(t) === 'object') {
            for (c in typeof n !== 'string' && (r = r || n,
            n = void 0),
            t) { Be(e, c, n, r, t[c], a) }
            return e
          }
          if (r == null && i == null
            ? (i = n,
              r = n = void 0)
            : i == null && (typeof n === 'string'
              ? (i = r,
                r = void 0)
              : (i = r,
                r = n,
                n = void 0)),
          !1 === i) { i = ke } else if (!i) { return e }
          return a === 1 && (s = i,
          i = function (e) {
            return C().off(e),
            s.apply(this, arguments)
          }
          ,
          i.guid = s.guid || (s.guid = C.guid++)),
          e.each(function () {
            C.event.add(this, t, i, r, n)
          }
          )
        }
        function De (e, t, n) {
          n
            ? (Z.set(e, t, !1),
              C.event.add(e, t, {
                namespace: !1,
                handler: function (e) {
                  let r; let o; let i = Z.get(this, t)
                  if (1 & e.isTrigger && this[t]) {
                    if (i.length) { (C.event.special[t] || {}).delegateType && e.stopPropagation() } else if (i = c.call(arguments),
                    Z.set(this, t, i),
                    r = n(this, t),
                    this[t](),
                    i !== (o = Z.get(this, t)) || r ? Z.set(this, t, !1) : o = {},
                    i !== o) {
                      return e.stopImmediatePropagation(),
                      e.preventDefault(),
                      o && o.value
                    }
                  } else {
                    i.length && (Z.set(this, t, {
                      value: C.event.trigger(C.extend(i[0], C.Event.prototype), i.slice(1), this)
                    }),
                    e.stopImmediatePropagation())
                  }
                }
              }))
            : void 0 === Z.get(e, t) && C.event.add(e, t, Se)
        }
        C.event = {
          global: {},
          add: function (e, t, n, r, o) {
            let i; let a; let s; let c; let l; let p; let u; let d; let f; let h; let m; const v = Z.get(e)
            if (J(e)) {
              for (n.handler && (n = (i = n).handler,
              o = i.selector),
              o && C.find.matchesSelector(se, o),
              n.guid || (n.guid = C.guid++),
              (c = v.events) || (c = v.events = Object.create(null)),
              (a = v.handle) || (a = v.handle = function (t) {
                return void 0 !== C && C.event.triggered !== t.type ? C.event.dispatch.apply(e, arguments) : void 0
              }
              ),
              l = (t = (t || '').match(z) || ['']).length; l--;) {
                f = m = (s = Ce.exec(t[l]) || [])[1],
                h = (s[2] || '').split('.').sort(),
                f && (u = C.event.special[f] || {},
                f = (o ? u.delegateType : u.bindType) || f,
                u = C.event.special[f] || {},
                p = C.extend({
                  type: f,
                  origType: m,
                  data: r,
                  handler: n,
                  guid: n.guid,
                  selector: o,
                  needsContext: o && C.expr.match.needsContext.test(o),
                  namespace: h.join('.')
                }, i),
                (d = c[f]) || ((d = c[f] = []).delegateCount = 0,
                u.setup && !1 !== u.setup.call(e, r, h, a) || e.addEventListener && e.addEventListener(f, a)),
                u.add && (u.add.call(e, p),
                p.handler.guid || (p.handler.guid = n.guid)),
                o ? d.splice(d.delegateCount++, 0, p) : d.push(p),
                C.event.global[f] = !0)
              }
            }
          },
          remove: function (e, t, n, r, o) {
            let i; let a; let s; let c; let l; let p; let u; let d; let f; let h; let m; const v = Z.hasData(e) && Z.get(e)
            if (v && (c = v.events)) {
              for (l = (t = (t || '').match(z) || ['']).length; l--;) {
                if (f = m = (s = Ce.exec(t[l]) || [])[1],
                h = (s[2] || '').split('.').sort(),
                f) {
                  for (u = C.event.special[f] || {},
                  d = c[f = (r ? u.delegateType : u.bindType) || f] || [],
                  s = s[2] && new RegExp('(^|\\.)' + h.join('\\.(?:.*\\.|)') + '(\\.|$)'),
                  a = i = d.length; i--;) {
                    p = d[i],
                    !o && m !== p.origType || n && n.guid !== p.guid || s && !s.test(p.namespace) || r && r !== p.selector && (r !== '**' || !p.selector) || (d.splice(i, 1),
                    p.selector && d.delegateCount--,
                    u.remove && u.remove.call(e, p))
                  }
                  a && !d.length && (u.teardown && !1 !== u.teardown.call(e, h, v.handle) || C.removeEvent(e, f, v.handle),
                  delete c[f])
                } else {
                  for (f in c) { C.event.remove(e, f + t[l], n, r, !0) }
                }
              }
              C.isEmptyObject(c) && Z.remove(e, 'handle events')
            }
          },
          dispatch: function (e) {
            let t; let n; let r; let o; let i; let a; const s = new Array(arguments.length); const c = C.event.fix(e); const l = (Z.get(this, 'events') || Object.create(null))[c.type] || []; const p = C.event.special[c.type] || {}
            for (s[0] = c,
            t = 1; t < arguments.length; t++) { s[t] = arguments[t] }
            if (c.delegateTarget = this,
            !p.preDispatch || !1 !== p.preDispatch.call(this, c)) {
              for (a = C.event.handlers.call(this, c, l),
              t = 0; (o = a[t++]) && !c.isPropagationStopped();) {
                for (c.currentTarget = o.elem,
                n = 0; (i = o.handlers[n++]) && !c.isImmediatePropagationStopped();) {
                  c.rnamespace && !1 !== i.namespace && !c.rnamespace.test(i.namespace) || (c.handleObj = i,
                  c.data = i.data,
                  void 0 !== (r = ((C.event.special[i.origType] || {}).handle || i.handler).apply(o.elem, s)) && !1 === (c.result = r) && (c.preventDefault(),
                  c.stopPropagation()))
                }
              }
              return p.postDispatch && p.postDispatch.call(this, c),
              c.result
            }
          },
          handlers: function (e, t) {
            let n; let r; let o; let i; let a; const s = []; const c = t.delegateCount; let l = e.target
            if (c && l.nodeType && !(e.type === 'click' && e.button >= 1)) {
              for (; l !== this; l = l.parentNode || this) {
                if (l.nodeType === 1 && (e.type !== 'click' || !0 !== l.disabled)) {
                  for (i = [],
                  a = {},
                  n = 0; n < c; n++) {
                    void 0 === a[o = (r = t[n]).selector + ' '] && (a[o] = r.needsContext ? C(o, this).index(l) > -1 : C.find(o, this, null, [l]).length),
                    a[o] && i.push(r)
                  }
                  i.length && s.push({
                    elem: l,
                    handlers: i
                  })
                }
              }
            }
            return l = this,
            c < t.length && s.push({
              elem: l,
              handlers: t.slice(c)
            }),
            s
          },
          addProp: function (e, t) {
            Object.defineProperty(C.Event.prototype, e, {
              enumerable: !0,
              configurable: !0,
              get: y(t)
                ? function () {
                  if (this.originalEvent) { return t(this.originalEvent) }
                }
                : function () {
                  if (this.originalEvent) { return this.originalEvent[e] }
                },
              set: function (t) {
                Object.defineProperty(this, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: t
                })
              }
            })
          },
          fix: function (e) {
            return e[C.expando] ? e : new C.Event(e)
          },
          special: {
            load: {
              noBubble: !0
            },
            click: {
              setup: function (e) {
                const t = this || e
                return ge.test(t.type) && t.click && P(t, 'input') && De(t, 'click', Se),
                !1
              },
              trigger: function (e) {
                const t = this || e
                return ge.test(t.type) && t.click && P(t, 'input') && De(t, 'click'),
                !0
              },
              _default: function (e) {
                const t = e.target
                return ge.test(t.type) && t.click && P(t, 'input') && Z.get(t, 'click') || P(t, 'a')
              }
            },
            beforeunload: {
              postDispatch: function (e) {
                void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result)
              }
            }
          }
        },
        C.removeEvent = function (e, t, n) {
          e.removeEventListener && e.removeEventListener(t, n)
        }
        ,
        C.Event = function (e, t) {
          if (!(this instanceof C.Event)) { return new C.Event(e, t) }
          e && e.type
            ? (this.originalEvent = e,
              this.type = e.type,
              this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && !1 === e.returnValue ? Se : ke,
              this.target = e.target && e.target.nodeType === 3 ? e.target.parentNode : e.target,
              this.currentTarget = e.currentTarget,
              this.relatedTarget = e.relatedTarget)
            : this.type = e,
          t && C.extend(this, t),
          this.timeStamp = e && e.timeStamp || Date.now(),
          this[C.expando] = !0
        }
        ,
        C.Event.prototype = {
          constructor: C.Event,
          isDefaultPrevented: ke,
          isPropagationStopped: ke,
          isImmediatePropagationStopped: ke,
          isSimulated: !1,
          preventDefault: function () {
            const e = this.originalEvent
            this.isDefaultPrevented = Se,
            e && !this.isSimulated && e.preventDefault()
          },
          stopPropagation: function () {
            const e = this.originalEvent
            this.isPropagationStopped = Se,
            e && !this.isSimulated && e.stopPropagation()
          },
          stopImmediatePropagation: function () {
            const e = this.originalEvent
            this.isImmediatePropagationStopped = Se,
            e && !this.isSimulated && e.stopImmediatePropagation(),
            this.stopPropagation()
          }
        },
        C.each({
          altKey: !0,
          bubbles: !0,
          cancelable: !0,
          changedTouches: !0,
          ctrlKey: !0,
          detail: !0,
          eventPhase: !0,
          metaKey: !0,
          pageX: !0,
          pageY: !0,
          shiftKey: !0,
          view: !0,
          char: !0,
          code: !0,
          charCode: !0,
          key: !0,
          keyCode: !0,
          button: !0,
          buttons: !0,
          clientX: !0,
          clientY: !0,
          offsetX: !0,
          offsetY: !0,
          pointerId: !0,
          pointerType: !0,
          screenX: !0,
          screenY: !0,
          targetTouches: !0,
          toElement: !0,
          touches: !0,
          which: !0
        }, C.event.addProp),
        C.each({
          focus: 'focusin',
          blur: 'focusout'
        }, function (e, t) {
          C.event.special[e] = {
            setup: function () {
              return De(this, e, je),
              !1
            },
            trigger: function () {
              return De(this, e),
              !0
            },
            _default: function (t) {
              return Z.get(t.target, e)
            },
            delegateType: t
          }
        }
        ),
        C.each({
          mouseenter: 'mouseover',
          mouseleave: 'mouseout',
          pointerenter: 'pointerover',
          pointerleave: 'pointerout'
        }, function (e, t) {
          C.event.special[e] = {
            delegateType: t,
            bindType: t,
            handle: function (e) {
              let n; const r = e.relatedTarget; const o = e.handleObj
              return r && (r === this || C.contains(this, r)) || (e.type = o.origType,
              n = o.handler.apply(this, arguments),
              e.type = t),
              n
            }
          }
        }
        ),
        C.fn.extend({
          on: function (e, t, n, r) {
            return Be(this, e, t, n, r)
          },
          one: function (e, t, n, r) {
            return Be(this, e, t, n, r, 1)
          },
          off: function (e, t, n) {
            let r, i
            if (e && e.preventDefault && e.handleObj) {
              return r = e.handleObj,
              C(e.delegateTarget).off(r.namespace ? r.origType + '.' + r.namespace : r.origType, r.selector, r.handler),
              this
            }
            if (o(e) === 'object') {
              for (i in e) { this.off(i, t, e[i]) }
              return this
            }
            return !1 !== t && typeof t !== 'function' || (n = t,
            t = void 0),
            !1 === n && (n = ke),
            this.each(function () {
              C.event.remove(this, e, n, t)
            }
            )
          }
        })
        const Pe = /<script|<style|<link/i
        const Oe = /checked\s*(?:[^=]|=\s*.checked.)/i
        const Te = /^\s*<!\[CDATA\[|\]\]>\s*$/g
        function Re (e, t) {
          return P(e, 'table') && P(t.nodeType !== 11 ? t : t.firstChild, 'tr') && C(e).children('tbody')[0] || e
        }
        function Ne (e) {
          return e.type = (e.getAttribute('type') !== null) + '/' + e.type,
          e
        }
        function Me (e) {
          return (e.type || '').slice(0, 5) === 'true/' ? e.type = e.type.slice(5) : e.removeAttribute('type'),
          e
        }
        function Ie (e, t) {
          let n, r, o, i, a, s
          if (t.nodeType === 1) {
            if (Z.hasData(e) && (s = Z.get(e).events)) {
              for (o in Z.remove(t, 'handle events'),
              s) {
                for (n = 0,
                r = s[o].length; n < r; n++) { C.event.add(t, o, s[o][n]) }
              }
            }
            ee.hasData(e) && (i = ee.access(e),
            a = C.extend({}, i),
            ee.set(t, a))
          }
        }
        function Le (e, t) {
          const n = t.nodeName.toLowerCase()
          n === 'input' && ge.test(e.type) ? t.checked = e.checked : n !== 'input' && n !== 'textarea' || (t.defaultValue = e.defaultValue)
        }
        function ze (e, t, n, r) {
          t = l(t)
          let o; let i; let a; let s; let c; let p; let u = 0; const d = e.length; const f = d - 1; const h = t[0]; const m = y(h)
          if (m || d > 1 && typeof h === 'string' && !g.checkClone && Oe.test(h)) {
            return e.each(function (o) {
              const i = e.eq(o)
              m && (t[0] = h.call(this, o, i.html())),
              ze(i, t, n, r)
            }
            )
          }
          if (d && (i = (o = _e(t, e[0].ownerDocument, !1, e, r)).firstChild,
          o.childNodes.length === 1 && (o = i),
          i || r)) {
            for (s = (a = C.map(Ee(o, 'script'), Ne)).length; u < d; u++) {
              c = o,
              u !== f && (c = C.clone(c, !0, !0),
              s && C.merge(a, Ee(c, 'script'))),
              n.call(e[u], c, u)
            }
            if (s) {
              for (p = a[a.length - 1].ownerDocument,
              C.map(a, Me),
              u = 0; u < s; u++) {
                c = a[u],
                be.test(c.type || '') && !Z.access(c, 'globalEval') && C.contains(p, c) && (c.src && (c.type || '').toLowerCase() !== 'module'
                  ? C._evalUrl && !c.noModule && C._evalUrl(c.src, {
                    nonce: c.nonce || c.getAttribute('nonce')
                  }, p)
                  : x(c.textContent.replace(Te, ''), c, p))
              }
            }
          }
          return e
        }
        function Fe (e, t, n) {
          for (var r, o = t ? C.filter(t, e) : e, i = 0; (r = o[i]) != null; i++) {
            n || r.nodeType !== 1 || C.cleanData(Ee(r)),
            r.parentNode && (n && ce(r) && xe(Ee(r, 'script')),
            r.parentNode.removeChild(r))
          }
          return e
        }
        C.extend({
          htmlPrefilter: function (e) {
            return e
          },
          clone: function (e, t, n) {
            let r; let o; let i; let a; const s = e.cloneNode(!0); const c = ce(e)
            if (!(g.noCloneChecked || e.nodeType !== 1 && e.nodeType !== 11 || C.isXMLDoc(e))) {
              for (a = Ee(s),
              r = 0,
              o = (i = Ee(e)).length; r < o; r++) { Le(i[r], a[r]) }
            }
            if (t) {
              if (n) {
                for (i = i || Ee(e),
                a = a || Ee(s),
                r = 0,
                o = i.length; r < o; r++) { Ie(i[r], a[r]) }
              } else { Ie(e, s) }
            }
            return (a = Ee(s, 'script')).length > 0 && xe(a, !c && Ee(e, 'script')),
            s
          },
          cleanData: function (e) {
            for (var t, n, r, o = C.event.special, i = 0; void 0 !== (n = e[i]); i++) {
              if (J(n)) {
                if (t = n[Z.expando]) {
                  if (t.events) {
                    for (r in t.events) { o[r] ? C.event.remove(n, r) : C.removeEvent(n, r, t.handle) }
                  }
                  n[Z.expando] = void 0
                }
                n[ee.expando] && (n[ee.expando] = void 0)
              }
            }
          }
        }),
        C.fn.extend({
          detach: function (e) {
            return Fe(this, e, !0)
          },
          remove: function (e) {
            return Fe(this, e)
          },
          text: function (e) {
            return U(this, function (e) {
              return void 0 === e
                ? C.text(this)
                : this.empty().each(function () {
                  this.nodeType !== 1 && this.nodeType !== 11 && this.nodeType !== 9 || (this.textContent = e)
                }
                )
            }
            , null, e, arguments.length)
          },
          append: function () {
            return ze(this, arguments, function (e) {
              this.nodeType !== 1 && this.nodeType !== 11 && this.nodeType !== 9 || Re(this, e).appendChild(e)
            }
            )
          },
          prepend: function () {
            return ze(this, arguments, function (e) {
              if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                const t = Re(this, e)
                t.insertBefore(e, t.firstChild)
              }
            }
            )
          },
          before: function () {
            return ze(this, arguments, function (e) {
              this.parentNode && this.parentNode.insertBefore(e, this)
            }
            )
          },
          after: function () {
            return ze(this, arguments, function (e) {
              this.parentNode && this.parentNode.insertBefore(e, this.nextSibling)
            }
            )
          },
          empty: function () {
            for (var e, t = 0; (e = this[t]) != null; t++) {
              e.nodeType === 1 && (C.cleanData(Ee(e, !1)),
              e.textContent = '')
            }
            return this
          },
          clone: function (e, t) {
            return e = e != null && e,
            t = t == null ? e : t,
            this.map(function () {
              return C.clone(this, e, t)
            }
            )
          },
          html: function (e) {
            return U(this, function (e) {
              let t = this[0] || {}
              let n = 0
              const r = this.length
              if (void 0 === e && t.nodeType === 1) { return t.innerHTML }
              if (typeof e === 'string' && !Pe.test(e) && !Ae[(ye.exec(e) || ['', ''])[1].toLowerCase()]) {
                e = C.htmlPrefilter(e)
                try {
                  for (; n < r; n++) {
                    (t = this[n] || {}).nodeType === 1 && (C.cleanData(Ee(t, !1)),
                    t.innerHTML = e)
                  }
                  t = 0
                } catch (e) {}
              }
              t && this.empty().append(e)
            }
            , null, e, arguments.length)
          },
          replaceWith: function () {
            const e = []
            return ze(this, arguments, function (t) {
              const n = this.parentNode
              C.inArray(this, e) < 0 && (C.cleanData(Ee(this)),
              n && n.replaceChild(t, this))
            }
            , e)
          }
        }),
        C.each({
          appendTo: 'append',
          prependTo: 'prepend',
          insertBefore: 'before',
          insertAfter: 'after',
          replaceAll: 'replaceWith'
        }, function (e, t) {
          C.fn[e] = function (e) {
            for (var n, r = [], o = C(e), i = o.length - 1, a = 0; a <= i; a++) {
              n = a === i ? this : this.clone(!0),
              C(o[a])[t](n),
              p.apply(r, n.get())
            }
            return this.pushStack(r)
          }
        }
        )
        const $e = new RegExp('^(' + oe + ')(?!px)[a-z%]+$', 'i')
        const He = /^--/
        const qe = function (e) {
          let t = e.ownerDocument.defaultView
          return t && t.opener || (t = n),
          t.getComputedStyle(e)
        }
        const We = function (e, t, n) {
          let r; let o; const i = {}
          for (o in t) {
            i[o] = e.style[o],
            e.style[o] = t[o]
          }
          for (o in r = n.call(e),
          t) { e.style[o] = i[o] }
          return r
        }
        const Ge = new RegExp(ae.join('|'), 'i')
        const Ue = '[\\x20\\t\\r\\n\\f]'
        const Ve = new RegExp('^' + Ue + '+|((?:^|[^\\\\])(?:\\\\.)*)' + Ue + '+$', 'g')
        function Qe (e, t, n) {
          let r; let o; let i; let a; const s = He.test(t); const c = e.style
          return (n = n || qe(e)) && (a = n.getPropertyValue(t) || n[t],
          s && (a = a.replace(Ve, '$1')),
          a !== '' || ce(e) || (a = C.style(e, t)),
          !g.pixelBoxStyles() && $e.test(a) && Ge.test(t) && (r = c.width,
          o = c.minWidth,
          i = c.maxWidth,
          c.minWidth = c.maxWidth = c.width = a,
          a = n.width,
          c.width = r,
          c.minWidth = o,
          c.maxWidth = i)),
          void 0 !== a ? a + '' : a
        }
        function Ye (e, t) {
          return {
            get: function () {
              if (!e()) { return (this.get = t).apply(this, arguments) }
              delete this.get
            }
          }
        }
        !(function () {
          function e () {
            if (p) {
              l.style.cssText = 'position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0',
              p.style.cssText = 'position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%',
              se.appendChild(l).appendChild(p)
              const e = n.getComputedStyle(p)
              r = e.top !== '1%',
              c = t(e.marginLeft) === 12,
              p.style.right = '60%',
              a = t(e.right) === 36,
              o = t(e.width) === 36,
              p.style.position = 'absolute',
              i = t(p.offsetWidth / 3) === 12,
              se.removeChild(l),
              p = null
            }
          }
          function t (e) {
            return Math.round(parseFloat(e))
          }
          let r; let o; let i; let a; let s; let c; var l = A.createElement('div'); var p = A.createElement('div')
          p.style && (p.style.backgroundClip = 'content-box',
          p.cloneNode(!0).style.backgroundClip = '',
          g.clearCloneStyle = p.style.backgroundClip === 'content-box',
          C.extend(g, {
            boxSizingReliable: function () {
              return e(),
              o
            },
            pixelBoxStyles: function () {
              return e(),
              a
            },
            pixelPosition: function () {
              return e(),
              r
            },
            reliableMarginLeft: function () {
              return e(),
              c
            },
            scrollboxSize: function () {
              return e(),
              i
            },
            reliableTrDimensions: function () {
              let e, t, r, o
              return s == null && (e = A.createElement('table'),
              t = A.createElement('tr'),
              r = A.createElement('div'),
              e.style.cssText = 'position:absolute;left:-11111px;border-collapse:separate',
              t.style.cssText = 'border:1px solid',
              t.style.height = '1px',
              r.style.height = '9px',
              r.style.display = 'block',
              se.appendChild(e).appendChild(t).appendChild(r),
              o = n.getComputedStyle(t),
              s = parseInt(o.height, 10) + parseInt(o.borderTopWidth, 10) + parseInt(o.borderBottomWidth, 10) === t.offsetHeight,
              se.removeChild(e)),
              s
            }
          }))
        }())
        const Ke = ['Webkit', 'Moz', 'ms']
        const Je = A.createElement('div').style
        const Xe = {}
        function Ze (e) {
          return C.cssProps[e] || Xe[e] || (e in Je
            ? e
            : Xe[e] = (function (e) {
              for (let t = e[0].toUpperCase() + e.slice(1), n = Ke.length; n--;) {
                if ((e = Ke[n] + t) in Je) { return e }
              }
            }(e)) || e)
        }
        const et = /^(none|table(?!-c[ea]).+)/
        const tt = {
          position: 'absolute',
          visibility: 'hidden',
          display: 'block'
        }
        const nt = {
          letterSpacing: '0',
          fontWeight: '400'
        }
        function rt (e, t, n) {
          const r = ie.exec(t)
          return r ? Math.max(0, r[2] - (n || 0)) + (r[3] || 'px') : t
        }
        function ot (e, t, n, r, o, i) {
          let a = t === 'width' ? 1 : 0
          let s = 0
          let c = 0
          if (n === (r ? 'border' : 'content')) { return 0 }
          for (; a < 4; a += 2) {
            n === 'margin' && (c += C.css(e, n + ae[a], !0, o)),
            r
              ? (n === 'content' && (c -= C.css(e, 'padding' + ae[a], !0, o)),
                n !== 'margin' && (c -= C.css(e, 'border' + ae[a] + 'Width', !0, o)))
              : (c += C.css(e, 'padding' + ae[a], !0, o),
                n !== 'padding' ? c += C.css(e, 'border' + ae[a] + 'Width', !0, o) : s += C.css(e, 'border' + ae[a] + 'Width', !0, o))
          }
          return !r && i >= 0 && (c += Math.max(0, Math.ceil(e['offset' + t[0].toUpperCase() + t.slice(1)] - i - c - s - 0.5)) || 0),
          c
        }
        function it (e, t, n) {
          const r = qe(e)
          let o = (!g.boxSizingReliable() || n) && C.css(e, 'boxSizing', !1, r) === 'border-box'
          let i = o
          let a = Qe(e, t, r)
          const s = 'offset' + t[0].toUpperCase() + t.slice(1)
          if ($e.test(a)) {
            if (!n) { return a }
            a = 'auto'
          }
          return (!g.boxSizingReliable() && o || !g.reliableTrDimensions() && P(e, 'tr') || a === 'auto' || !parseFloat(a) && C.css(e, 'display', !1, r) === 'inline') && e.getClientRects().length && (o = C.css(e, 'boxSizing', !1, r) === 'border-box',
          (i = s in e) && (a = e[s])),
          (a = parseFloat(a) || 0) + ot(e, t, n || (o ? 'border' : 'content'), i, r, a) + 'px'
        }
        function at (e, t, n, r, o) {
          return new at.prototype.init(e, t, n, r, o)
        }
        C.extend({
          cssHooks: {
            opacity: {
              get: function (e, t) {
                if (t) {
                  const n = Qe(e, 'opacity')
                  return n === '' ? '1' : n
                }
              }
            }
          },
          cssNumber: {
            animationIterationCount: !0,
            columnCount: !0,
            fillOpacity: !0,
            flexGrow: !0,
            flexShrink: !0,
            fontWeight: !0,
            gridArea: !0,
            gridColumn: !0,
            gridColumnEnd: !0,
            gridColumnStart: !0,
            gridRow: !0,
            gridRowEnd: !0,
            gridRowStart: !0,
            lineHeight: !0,
            opacity: !0,
            order: !0,
            orphans: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0
          },
          cssProps: {},
          style: function (e, t, n, r) {
            if (e && e.nodeType !== 3 && e.nodeType !== 8 && e.style) {
              let i; let a; let s; const c = K(t); const l = He.test(t); const p = e.style
              if (l || (t = Ze(c)),
              s = C.cssHooks[t] || C.cssHooks[c],
              void 0 === n) { return s && 'get' in s && void 0 !== (i = s.get(e, !1, r)) ? i : p[t] }
              (a = o(n)) === 'string' && (i = ie.exec(n)) && i[1] && (n = ue(e, t, i),
              a = 'number'),
              n != null && n == n && (a !== 'number' || l || (n += i && i[3] || (C.cssNumber[c] ? '' : 'px')),
              g.clearCloneStyle || n !== '' || t.indexOf('background') !== 0 || (p[t] = 'inherit'),
              s && 'set' in s && void 0 === (n = s.set(e, n, r)) || (l ? p.setProperty(t, n) : p[t] = n))
            }
          },
          css: function (e, t, n, r) {
            let o; let i; let a; const s = K(t)
            return He.test(t) || (t = Ze(s)),
            (a = C.cssHooks[t] || C.cssHooks[s]) && 'get' in a && (o = a.get(e, !0, n)),
            void 0 === o && (o = Qe(e, t, r)),
            o === 'normal' && t in nt && (o = nt[t]),
            n === '' || n
              ? (i = parseFloat(o),
                !0 === n || isFinite(i) ? i || 0 : o)
              : o
          }
        }),
        C.each(['height', 'width'], function (e, t) {
          C.cssHooks[t] = {
            get: function (e, n, r) {
              if (n) {
                return !et.test(C.css(e, 'display')) || e.getClientRects().length && e.getBoundingClientRect().width
                  ? it(e, t, r)
                  : We(e, tt, function () {
                    return it(e, t, r)
                  }
                  )
              }
            },
            set: function (e, n, r) {
              let o; const i = qe(e); const a = !g.scrollboxSize() && i.position === 'absolute'; const s = (a || r) && C.css(e, 'boxSizing', !1, i) === 'border-box'; let c = r ? ot(e, t, r, s, i) : 0
              return s && a && (c -= Math.ceil(e['offset' + t[0].toUpperCase() + t.slice(1)] - parseFloat(i[t]) - ot(e, t, 'border', !1, i) - 0.5)),
              c && (o = ie.exec(n)) && (o[3] || 'px') !== 'px' && (e.style[t] = n,
              n = C.css(e, t)),
              rt(0, n, c)
            }
          }
        }
        ),
        C.cssHooks.marginLeft = Ye(g.reliableMarginLeft, function (e, t) {
          if (t) {
            return (parseFloat(Qe(e, 'marginLeft')) || e.getBoundingClientRect().left - We(e, {
              marginLeft: 0
            }, function () {
              return e.getBoundingClientRect().left
            }
            )) + 'px'
          }
        }
        ),
        C.each({
          margin: '',
          padding: '',
          border: 'Width'
        }, function (e, t) {
          C.cssHooks[e + t] = {
            expand: function (n) {
              for (var r = 0, o = {}, i = typeof n === 'string' ? n.split(' ') : [n]; r < 4; r++) { o[e + ae[r] + t] = i[r] || i[r - 2] || i[0] }
              return o
            }
          },
          e !== 'margin' && (C.cssHooks[e + t].set = rt)
        }
        ),
        C.fn.extend({
          css: function (e, t) {
            return U(this, function (e, t, n) {
              let r; let o; const i = {}; let a = 0
              if (Array.isArray(t)) {
                for (r = qe(e),
                o = t.length; a < o; a++) { i[t[a]] = C.css(e, t[a], !1, r) }
                return i
              }
              return void 0 !== n ? C.style(e, t, n) : C.css(e, t)
            }
            , e, t, arguments.length > 1)
          }
        }),
        C.Tween = at,
        at.prototype = {
          constructor: at,
          init: function (e, t, n, r, o, i) {
            this.elem = e,
            this.prop = n,
            this.easing = o || C.easing._default,
            this.options = t,
            this.start = this.now = this.cur(),
            this.end = r,
            this.unit = i || (C.cssNumber[n] ? '' : 'px')
          },
          cur: function () {
            const e = at.propHooks[this.prop]
            return e && e.get ? e.get(this) : at.propHooks._default.get(this)
          },
          run: function (e) {
            let t; const n = at.propHooks[this.prop]
            return this.options.duration ? this.pos = t = C.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : this.pos = t = e,
            this.now = (this.end - this.start) * t + this.start,
            this.options.step && this.options.step.call(this.elem, this.now, this),
            n && n.set ? n.set(this) : at.propHooks._default.set(this),
            this
          }
        },
        at.prototype.init.prototype = at.prototype,
        at.propHooks = {
          _default: {
            get: function (e) {
              let t
              return e.elem.nodeType !== 1 || e.elem[e.prop] != null && e.elem.style[e.prop] == null ? e.elem[e.prop] : (t = C.css(e.elem, e.prop, '')) && t !== 'auto' ? t : 0
            },
            set: function (e) {
              C.fx.step[e.prop] ? C.fx.step[e.prop](e) : e.elem.nodeType !== 1 || !C.cssHooks[e.prop] && e.elem.style[Ze(e.prop)] == null ? e.elem[e.prop] = e.now : C.style(e.elem, e.prop, e.now + e.unit)
            }
          }
        },
        at.propHooks.scrollTop = at.propHooks.scrollLeft = {
          set: function (e) {
            e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now)
          }
        },
        C.easing = {
          linear: function (e) {
            return e
          },
          swing: function (e) {
            return 0.5 - Math.cos(e * Math.PI) / 2
          },
          _default: 'swing'
        },
        C.fx = at.prototype.init,
        C.fx.step = {}
        let st; let ct; const lt = /^(?:toggle|show|hide)$/; const pt = /queueHooks$/
        function ut () {
          ct && (!1 === A.hidden && n.requestAnimationFrame ? n.requestAnimationFrame(ut) : n.setTimeout(ut, C.fx.interval),
          C.fx.tick())
        }
        function dt () {
          return n.setTimeout(function () {
            st = void 0
          }
          ),
          st = Date.now()
        }
        function ft (e, t) {
          let n; let r = 0; const o = {
            height: e
          }
          for (t = t ? 1 : 0; r < 4; r += 2 - t) { o['margin' + (n = ae[r])] = o['padding' + n] = e }
          return t && (o.opacity = o.width = e),
          o
        }
        function ht (e, t, n) {
          for (var r, o = (mt.tweeners[t] || []).concat(mt.tweeners['*']), i = 0, a = o.length; i < a; i++) {
            if (r = o[i].call(n, t, e)) { return r }
          }
        }
        function mt (e, t, n) {
          let r; let o; let i = 0; const a = mt.prefilters.length; const s = C.Deferred().always(function () {
            delete c.elem
          }
          ); var c = function () {
            if (o) { return !1 }
            for (var t = st || dt(), n = Math.max(0, l.startTime + l.duration - t), r = 1 - (n / l.duration || 0), i = 0, a = l.tweens.length; i < a; i++) { l.tweens[i].run(r) }
            return s.notifyWith(e, [l, r, n]),
            r < 1 && a
              ? n
              : (a || s.notifyWith(e, [l, 1, 0]),
                s.resolveWith(e, [l]),
                !1)
          }; var l = s.promise({
            elem: e,
            props: C.extend({}, t),
            opts: C.extend(!0, {
              specialEasing: {},
              easing: C.easing._default
            }, n),
            originalProperties: t,
            originalOptions: n,
            startTime: st || dt(),
            duration: n.duration,
            tweens: [],
            createTween: function (t, n) {
              const r = C.Tween(e, l.opts, t, n, l.opts.specialEasing[t] || l.opts.easing)
              return l.tweens.push(r),
              r
            },
            stop: function (t) {
              let n = 0
              const r = t ? l.tweens.length : 0
              if (o) { return this }
              for (o = !0; n < r; n++) { l.tweens[n].run(1) }
              return t
                ? (s.notifyWith(e, [l, 1, 0]),
                  s.resolveWith(e, [l, t]))
                : s.rejectWith(e, [l, t]),
              this
            }
          }); const p = l.props
          for ((function (e, t) {
            let n, r, o, i, a
            for (n in e) {
              if (o = t[r = K(n)],
              i = e[n],
              Array.isArray(i) && (o = i[1],
              i = e[n] = i[0]),
              n !== r && (e[r] = i,
              delete e[n]),
              (a = C.cssHooks[r]) && 'expand' in a) {
                for (n in i = a.expand(i),
                delete e[r],
                i) {
                  n in e || (e[n] = i[n],
                  t[n] = o)
                }
              } else { t[r] = o }
            }
          }(p, l.opts.specialEasing)); i < a; i++) {
            if (r = mt.prefilters[i].call(l, e, p, l.opts)) {
              return y(r.stop) && (C._queueHooks(l.elem, l.opts.queue).stop = r.stop.bind(r)),
              r
            }
          }
          return C.map(p, ht, l),
          y(l.opts.start) && l.opts.start.call(e, l),
          l.progress(l.opts.progress).done(l.opts.done, l.opts.complete).fail(l.opts.fail).always(l.opts.always),
          C.fx.timer(C.extend(c, {
            elem: e,
            anim: l,
            queue: l.opts.queue
          })),
          l
        }
        C.Animation = C.extend(mt, {
          tweeners: {
            '*': [function (e, t) {
              const n = this.createTween(e, t)
              return ue(n.elem, e, ie.exec(t), n),
              n
            }
            ]
          },
          tweener: function (e, t) {
            y(e)
              ? (t = e,
                e = ['*'])
              : e = e.match(z)
            for (var n, r = 0, o = e.length; r < o; r++) {
              n = e[r],
              mt.tweeners[n] = mt.tweeners[n] || [],
              mt.tweeners[n].unshift(t)
            }
          },
          prefilters: [function (e, t, n) {
            let r; let o; let i; let a; let s; let c; let l; let p; const u = 'width' in t || 'height' in t; const d = this; const f = {}; const h = e.style; let m = e.nodeType && pe(e); let v = Z.get(e, 'fxshow')
            for (r in n.queue || ((a = C._queueHooks(e, 'fx')).unqueued == null && (a.unqueued = 0,
            s = a.empty.fire,
            a.empty.fire = function () {
              a.unqueued || s()
            }
            ),
            a.unqueued++,
            d.always(function () {
              d.always(function () {
                a.unqueued--,
                C.queue(e, 'fx').length || a.empty.fire()
              }
              )
            }
            )),
            t) {
              if (o = t[r],
              lt.test(o)) {
                if (delete t[r],
                i = i || o === 'toggle',
                o === (m ? 'hide' : 'show')) {
                  if (o !== 'show' || !v || void 0 === v[r]) { continue }
                  m = !0
                }
                f[r] = v && v[r] || C.style(e, r)
              }
            }
            if ((c = !C.isEmptyObject(t)) || !C.isEmptyObject(f)) {
              for (r in u && e.nodeType === 1 && (n.overflow = [h.overflow, h.overflowX, h.overflowY],
              (l = v && v.display) == null && (l = Z.get(e, 'display')),
              (p = C.css(e, 'display')) === 'none' && (l
                ? p = l
                : (he([e], !0),
                  l = e.style.display || l,
                  p = C.css(e, 'display'),
                  he([e]))),
              (p === 'inline' || p === 'inline-block' && l != null) && C.css(e, 'float') === 'none' && (c || (d.done(function () {
                h.display = l
              }
              ),
              l == null && (p = h.display,
              l = p === 'none' ? '' : p)),
              h.display = 'inline-block')),
              n.overflow && (h.overflow = 'hidden',
              d.always(function () {
                h.overflow = n.overflow[0],
                h.overflowX = n.overflow[1],
                h.overflowY = n.overflow[2]
              }
              )),
              c = !1,
              f) {
                c || (v
                  ? 'hidden' in v && (m = v.hidden)
                  : v = Z.access(e, 'fxshow', {
                    display: l
                  }),
                i && (v.hidden = !m),
                m && he([e], !0),
                d.done(function () {
                  for (r in m || he([e]),
                  Z.remove(e, 'fxshow'),
                  f) { C.style(e, r, f[r]) }
                }
                )),
                c = ht(m ? v[r] : 0, r, d),
                r in v || (v[r] = c.start,
                m && (c.end = c.start,
                c.start = 0))
              }
            }
          }
          ],
          prefilter: function (e, t) {
            t ? mt.prefilters.unshift(e) : mt.prefilters.push(e)
          }
        }),
        C.speed = function (e, t, n) {
          const r = e && o(e) === 'object'
            ? C.extend({}, e)
            : {
                complete: n || !n && t || y(e) && e,
                duration: e,
                easing: n && t || t && !y(t) && t
              }
          return C.fx.off ? r.duration = 0 : typeof r.duration !== 'number' && (r.duration in C.fx.speeds ? r.duration = C.fx.speeds[r.duration] : r.duration = C.fx.speeds._default),
          r.queue != null && !0 !== r.queue || (r.queue = 'fx'),
          r.old = r.complete,
          r.complete = function () {
            y(r.old) && r.old.call(this),
            r.queue && C.dequeue(this, r.queue)
          }
          ,
          r
        }
        ,
        C.fn.extend({
          fadeTo: function (e, t, n, r) {
            return this.filter(pe).css('opacity', 0).show().end().animate({
              opacity: t
            }, e, n, r)
          },
          animate: function (e, t, n, r) {
            const o = C.isEmptyObject(e)
            const i = C.speed(t, n, r)
            const a = function () {
              const t = mt(this, C.extend({}, e), i);
              (o || Z.get(this, 'finish')) && t.stop(!0)
            }
            return a.finish = a,
            o || !1 === i.queue ? this.each(a) : this.queue(i.queue, a)
          },
          stop: function (e, t, n) {
            const r = function (e) {
              const t = e.stop
              delete e.stop,
              t(n)
            }
            return typeof e !== 'string' && (n = t,
            t = e,
            e = void 0),
            t && this.queue(e || 'fx', []),
            this.each(function () {
              let t = !0
              let o = e != null && e + 'queueHooks'
              const i = C.timers
              const a = Z.get(this)
              if (o) { a[o] && a[o].stop && r(a[o]) } else {
                for (o in a) { a[o] && a[o].stop && pt.test(o) && r(a[o]) }
              }
              for (o = i.length; o--;) {
                i[o].elem !== this || e != null && i[o].queue !== e || (i[o].anim.stop(n),
                t = !1,
                i.splice(o, 1))
              }
              !t && n || C.dequeue(this, e)
            }
            )
          },
          finish: function (e) {
            return !1 !== e && (e = e || 'fx'),
            this.each(function () {
              let t; const n = Z.get(this); const r = n[e + 'queue']; const o = n[e + 'queueHooks']; const i = C.timers; const a = r ? r.length : 0
              for (n.finish = !0,
              C.queue(this, e, []),
              o && o.stop && o.stop.call(this, !0),
              t = i.length; t--;) {
                i[t].elem === this && i[t].queue === e && (i[t].anim.stop(!0),
                i.splice(t, 1))
              }
              for (t = 0; t < a; t++) { r[t] && r[t].finish && r[t].finish.call(this) }
              delete n.finish
            }
            )
          }
        }),
        C.each(['toggle', 'show', 'hide'], function (e, t) {
          const n = C.fn[t]
          C.fn[t] = function (e, r, o) {
            return e == null || typeof e === 'boolean' ? n.apply(this, arguments) : this.animate(ft(t, !0), e, r, o)
          }
        }
        ),
        C.each({
          slideDown: ft('show'),
          slideUp: ft('hide'),
          slideToggle: ft('toggle'),
          fadeIn: {
            opacity: 'show'
          },
          fadeOut: {
            opacity: 'hide'
          },
          fadeToggle: {
            opacity: 'toggle'
          }
        }, function (e, t) {
          C.fn[e] = function (e, n, r) {
            return this.animate(t, e, n, r)
          }
        }
        ),
        C.timers = [],
        C.fx.tick = function () {
          let e; let t = 0; const n = C.timers
          for (st = Date.now(); t < n.length; t++) { (e = n[t])() || n[t] !== e || n.splice(t--, 1) }
          n.length || C.fx.stop(),
          st = void 0
        }
        ,
        C.fx.timer = function (e) {
          C.timers.push(e),
          C.fx.start()
        }
        ,
        C.fx.interval = 13,
        C.fx.start = function () {
          ct || (ct = !0,
          ut())
        }
        ,
        C.fx.stop = function () {
          ct = null
        }
        ,
        C.fx.speeds = {
          slow: 600,
          fast: 200,
          _default: 400
        },
        C.fn.delay = function (e, t) {
          return e = C.fx && C.fx.speeds[e] || e,
          t = t || 'fx',
          this.queue(t, function (t, r) {
            const o = n.setTimeout(t, e)
            r.stop = function () {
              n.clearTimeout(o)
            }
          }
          )
        }
        ,
        (function () {
          let e = A.createElement('input')
          const t = A.createElement('select').appendChild(A.createElement('option'))
          e.type = 'checkbox',
          g.checkOn = e.value !== '',
          g.optSelected = t.selected,
          (e = A.createElement('input')).value = 't',
          e.type = 'radio',
          g.radioValue = e.value === 't'
        }())
        let vt; const gt = C.expr.attrHandle
        C.fn.extend({
          attr: function (e, t) {
            return U(this, C.attr, e, t, arguments.length > 1)
          },
          removeAttr: function (e) {
            return this.each(function () {
              C.removeAttr(this, e)
            }
            )
          }
        }),
        C.extend({
          attr: function (e, t, n) {
            let r; let o; const i = e.nodeType
            if (i !== 3 && i !== 8 && i !== 2) {
              return void 0 === e.getAttribute
                ? C.prop(e, t, n)
                : (i === 1 && C.isXMLDoc(e) || (o = C.attrHooks[t.toLowerCase()] || (C.expr.match.bool.test(t) ? vt : void 0)),
                  void 0 !== n
                    ? n === null
                      ? void C.removeAttr(e, t)
                      : o && 'set' in o && void 0 !== (r = o.set(e, n, t))
                        ? r
                        : (e.setAttribute(t, n + ''),
                          n)
                    : o && 'get' in o && (r = o.get(e, t)) !== null ? r : (r = C.find.attr(e, t)) == null ? void 0 : r)
            }
          },
          attrHooks: {
            type: {
              set: function (e, t) {
                if (!g.radioValue && t === 'radio' && P(e, 'input')) {
                  const n = e.value
                  return e.setAttribute('type', t),
                  n && (e.value = n),
                  t
                }
              }
            }
          },
          removeAttr: function (e, t) {
            let n; let r = 0; const o = t && t.match(z)
            if (o && e.nodeType === 1) {
              for (; n = o[r++];) { e.removeAttribute(n) }
            }
          }
        }),
        vt = {
          set: function (e, t, n) {
            return !1 === t ? C.removeAttr(e, n) : e.setAttribute(n, n),
            n
          }
        },
        C.each(C.expr.match.bool.source.match(/\w+/g), function (e, t) {
          const n = gt[t] || C.find.attr
          gt[t] = function (e, t, r) {
            let o; let i; const a = t.toLowerCase()
            return r || (i = gt[a],
            gt[a] = o,
            o = n(e, t, r) != null ? a : null,
            gt[a] = i),
            o
          }
        }
        )
        const yt = /^(?:input|select|textarea|button)$/i
        const bt = /^(?:a|area)$/i
        function At (e) {
          return (e.match(z) || []).join(' ')
        }
        function Et (e) {
          return e.getAttribute && e.getAttribute('class') || ''
        }
        function xt (e) {
          return Array.isArray(e) ? e : typeof e === 'string' && e.match(z) || []
        }
        C.fn.extend({
          prop: function (e, t) {
            return U(this, C.prop, e, t, arguments.length > 1)
          },
          removeProp: function (e) {
            return this.each(function () {
              delete this[C.propFix[e] || e]
            }
            )
          }
        }),
        C.extend({
          prop: function (e, t, n) {
            let r; let o; const i = e.nodeType
            if (i !== 3 && i !== 8 && i !== 2) {
              return i === 1 && C.isXMLDoc(e) || (t = C.propFix[t] || t,
              o = C.propHooks[t]),
              void 0 !== n ? o && 'set' in o && void 0 !== (r = o.set(e, n, t)) ? r : e[t] = n : o && 'get' in o && (r = o.get(e, t)) !== null ? r : e[t]
            }
          },
          propHooks: {
            tabIndex: {
              get: function (e) {
                const t = C.find.attr(e, 'tabindex')
                return t ? parseInt(t, 10) : yt.test(e.nodeName) || bt.test(e.nodeName) && e.href ? 0 : -1
              }
            }
          },
          propFix: {
            for: 'htmlFor',
            class: 'className'
          }
        }),
        g.optSelected || (C.propHooks.selected = {
          get: function (e) {
            const t = e.parentNode
            return t && t.parentNode && t.parentNode.selectedIndex,
            null
          },
          set: function (e) {
            const t = e.parentNode
            t && (t.selectedIndex,
            t.parentNode && t.parentNode.selectedIndex)
          }
        }),
        C.each(['tabIndex', 'readOnly', 'maxLength', 'cellSpacing', 'cellPadding', 'rowSpan', 'colSpan', 'useMap', 'frameBorder', 'contentEditable'], function () {
          C.propFix[this.toLowerCase()] = this
        }
        ),
        C.fn.extend({
          addClass: function (e) {
            let t, n, r, o, i, a
            return y(e)
              ? this.each(function (t) {
                C(this).addClass(e.call(this, t, Et(this)))
              }
              )
              : (t = xt(e)).length
                  ? this.each(function () {
                    if (r = Et(this),
                    n = this.nodeType === 1 && ' ' + At(r) + ' ') {
                      for (i = 0; i < t.length; i++) {
                        o = t[i],
                        n.indexOf(' ' + o + ' ') < 0 && (n += o + ' ')
                      }
                      a = At(n),
                      r !== a && this.setAttribute('class', a)
                    }
                  }
                  )
                  : this
          },
          removeClass: function (e) {
            let t, n, r, o, i, a
            return y(e)
              ? this.each(function (t) {
                C(this).removeClass(e.call(this, t, Et(this)))
              }
              )
              : arguments.length
                ? (t = xt(e)).length
                    ? this.each(function () {
                      if (r = Et(this),
                      n = this.nodeType === 1 && ' ' + At(r) + ' ') {
                        for (i = 0; i < t.length; i++) {
                          for (o = t[i]; n.indexOf(' ' + o + ' ') > -1;) { n = n.replace(' ' + o + ' ', ' ') }
                        }
                        a = At(n),
                        r !== a && this.setAttribute('class', a)
                      }
                    }
                    )
                    : this
                : this.attr('class', '')
          },
          toggleClass: function (e, t) {
            let n; let r; let i; let a; const s = o(e); const c = s === 'string' || Array.isArray(e)
            return y(e)
              ? this.each(function (n) {
                C(this).toggleClass(e.call(this, n, Et(this), t), t)
              }
              )
              : typeof t === 'boolean' && c
                ? t ? this.addClass(e) : this.removeClass(e)
                : (n = xt(e),
                  this.each(function () {
                    if (c) {
                      for (a = C(this),
                      i = 0; i < n.length; i++) {
                        r = n[i],
                        a.hasClass(r) ? a.removeClass(r) : a.addClass(r)
                      }
                    } else {
                      void 0 !== e && s !== 'boolean' || ((r = Et(this)) && Z.set(this, '__className__', r),
                      this.setAttribute && this.setAttribute('class', r || !1 === e ? '' : Z.get(this, '__className__') || ''))
                    }
                  }
                  ))
          },
          hasClass: function (e) {
            let t; let n; let r = 0
            for (t = ' ' + e + ' '; n = this[r++];) {
              if (n.nodeType === 1 && (' ' + At(Et(n)) + ' ').indexOf(t) > -1) { return !0 }
            }
            return !1
          }
        })
        const wt = /\r/g
        C.fn.extend({
          val: function (e) {
            let t; let n; let r; const o = this[0]
            return arguments.length
              ? (r = y(e),
                this.each(function (n) {
                  let o
                  this.nodeType === 1 && ((o = r ? e.call(this, n, C(this).val()) : e) == null
                    ? o = ''
                    : typeof o === 'number'
                      ? o += ''
                      : Array.isArray(o) && (o = C.map(o, function (e) {
                        return e == null ? '' : e + ''
                      }
                      )),
                  (t = C.valHooks[this.type] || C.valHooks[this.nodeName.toLowerCase()]) && 'set' in t && void 0 !== t.set(this, o, 'value') || (this.value = o))
                }
                ))
              : o ? (t = C.valHooks[o.type] || C.valHooks[o.nodeName.toLowerCase()]) && 'get' in t && void 0 !== (n = t.get(o, 'value')) ? n : typeof (n = o.value) === 'string' ? n.replace(wt, '') : n == null ? '' : n : void 0
          }
        }),
        C.extend({
          valHooks: {
            option: {
              get: function (e) {
                const t = C.find.attr(e, 'value')
                return t != null ? t : At(C.text(e))
              }
            },
            select: {
              get: function (e) {
                let t; let n; let r; const o = e.options; const i = e.selectedIndex; const a = e.type === 'select-one'; const s = a ? null : []; const c = a ? i + 1 : o.length
                for (r = i < 0 ? c : a ? i : 0; r < c; r++) {
                  if (((n = o[r]).selected || r === i) && !n.disabled && (!n.parentNode.disabled || !P(n.parentNode, 'optgroup'))) {
                    if (t = C(n).val(),
                    a) { return t }
                    s.push(t)
                  }
                }
                return s
              },
              set: function (e, t) {
                for (var n, r, o = e.options, i = C.makeArray(t), a = o.length; a--;) { ((r = o[a]).selected = C.inArray(C.valHooks.option.get(r), i) > -1) && (n = !0) }
                return n || (e.selectedIndex = -1),
                i
              }
            }
          }
        }),
        C.each(['radio', 'checkbox'], function () {
          C.valHooks[this] = {
            set: function (e, t) {
              if (Array.isArray(t)) { return e.checked = C.inArray(C(e).val(), t) > -1 }
            }
          },
          g.checkOn || (C.valHooks[this].get = function (e) {
            return e.getAttribute('value') === null ? 'on' : e.value
          }
          )
        }
        ),
        g.focusin = 'onfocusin' in n
        const _t = /^(?:focusinfocus|focusoutblur)$/
        const Ct = function (e) {
          e.stopPropagation()
        }
        C.extend(C.event, {
          trigger: function (e, t, r, i) {
            let a; let s; let c; let l; let p; let u; let d; let f; const m = [r || A]; let v = h.call(e, 'type') ? e.type : e; let g = h.call(e, 'namespace') ? e.namespace.split('.') : []
            if (s = f = c = r = r || A,
            r.nodeType !== 3 && r.nodeType !== 8 && !_t.test(v + C.event.triggered) && (v.indexOf('.') > -1 && (g = v.split('.'),
            v = g.shift(),
            g.sort()),
            p = v.indexOf(':') < 0 && 'on' + v,
            (e = e[C.expando] ? e : new C.Event(v, o(e) === 'object' && e)).isTrigger = i ? 2 : 3,
            e.namespace = g.join('.'),
            e.rnamespace = e.namespace ? new RegExp('(^|\\.)' + g.join('\\.(?:.*\\.|)') + '(\\.|$)') : null,
            e.result = void 0,
            e.target || (e.target = r),
            t = t == null ? [e] : C.makeArray(t, [e]),
            d = C.event.special[v] || {},
            i || !d.trigger || !1 !== d.trigger.apply(r, t))) {
              if (!i && !d.noBubble && !b(r)) {
                for (l = d.delegateType || v,
                _t.test(l + v) || (s = s.parentNode); s; s = s.parentNode) {
                  m.push(s),
                  c = s
                }
                c === (r.ownerDocument || A) && m.push(c.defaultView || c.parentWindow || n)
              }
              for (a = 0; (s = m[a++]) && !e.isPropagationStopped();) {
                f = s,
                e.type = a > 1 ? l : d.bindType || v,
                (u = (Z.get(s, 'events') || Object.create(null))[e.type] && Z.get(s, 'handle')) && u.apply(s, t),
                (u = p && s[p]) && u.apply && J(s) && (e.result = u.apply(s, t),
                !1 === e.result && e.preventDefault())
              }
              return e.type = v,
              i || e.isDefaultPrevented() || d._default && !1 !== d._default.apply(m.pop(), t) || !J(r) || p && y(r[v]) && !b(r) && ((c = r[p]) && (r[p] = null),
              C.event.triggered = v,
              e.isPropagationStopped() && f.addEventListener(v, Ct),
              r[v](),
              e.isPropagationStopped() && f.removeEventListener(v, Ct),
              C.event.triggered = void 0,
              c && (r[p] = c)),
              e.result
            }
          },
          simulate: function (e, t, n) {
            const r = C.extend(new C.Event(), n, {
              type: e,
              isSimulated: !0
            })
            C.event.trigger(r, null, t)
          }
        }),
        C.fn.extend({
          trigger: function (e, t) {
            return this.each(function () {
              C.event.trigger(e, t, this)
            }
            )
          },
          triggerHandler: function (e, t) {
            const n = this[0]
            if (n) { return C.event.trigger(e, t, n, !0) }
          }
        }),
        g.focusin || C.each({
          focus: 'focusin',
          blur: 'focusout'
        }, function (e, t) {
          const n = function (e) {
            C.event.simulate(t, e.target, C.event.fix(e))
          }
          C.event.special[t] = {
            setup: function () {
              const r = this.ownerDocument || this.document || this
              const o = Z.access(r, t)
              o || r.addEventListener(e, n, !0),
              Z.access(r, t, (o || 0) + 1)
            },
            teardown: function () {
              const r = this.ownerDocument || this.document || this
              const o = Z.access(r, t) - 1
              o
                ? Z.access(r, t, o)
                : (r.removeEventListener(e, n, !0),
                  Z.remove(r, t))
            }
          }
        }
        )
        const St = n.location
        const kt = {
          guid: Date.now()
        }
        const jt = /\?/
        C.parseXML = function (e) {
          let t, r
          if (!e || typeof e !== 'string') { return null }
          try {
            t = (new n.DOMParser()).parseFromString(e, 'text/xml')
          } catch (e) {}
          return r = t && t.getElementsByTagName('parsererror')[0],
          t && !r || C.error('Invalid XML: ' + (r
            ? C.map(r.childNodes, function (e) {
              return e.textContent
            }
            ).join('\n')
            : e)),
          t
        }

        const Bt = /\[\]$/
        const Dt = /\r?\n/g
        const Pt = /^(?:submit|button|image|reset|file)$/i
        const Ot = /^(?:input|select|textarea|keygen)/i
        function Tt (e, t, n, r) {
          let i
          if (Array.isArray(t)) {
            C.each(t, function (t, i) {
              n || Bt.test(e) ? r(e, i) : Tt(e + '[' + (o(i) === 'object' && i != null ? t : '') + ']', i, n, r)
            }
            )
          } else if (n || w(t) !== 'object') { r(e, t) } else {
            for (i in t) { Tt(e + '[' + i + ']', t[i], n, r) }
          }
        }
        C.param = function (e, t) {
          let n; const r = []; const o = function (e, t) {
            const n = y(t) ? t() : t
            r[r.length] = encodeURIComponent(e) + '=' + encodeURIComponent(n == null ? '' : n)
          }
          if (e == null) { return '' }
          if (Array.isArray(e) || e.jquery && !C.isPlainObject(e)) {
            C.each(e, function () {
              o(this.name, this.value)
            }
            )
          } else {
            for (n in e) { Tt(n, e[n], t, o) }
          }
          return r.join('&')
        }
        ,
        C.fn.extend({
          serialize: function () {
            return C.param(this.serializeArray())
          },
          serializeArray: function () {
            return this.map(function () {
              const e = C.prop(this, 'elements')
              return e ? C.makeArray(e) : this
            }
            ).filter(function () {
              const e = this.type
              return this.name && !C(this).is(':disabled') && Ot.test(this.nodeName) && !Pt.test(e) && (this.checked || !ge.test(e))
            }
            ).map(function (e, t) {
              const n = C(this).val()
              return n == null
                ? null
                : Array.isArray(n)
                  ? C.map(n, function (e) {
                    return {
                      name: t.name,
                      value: e.replace(Dt, '\r\n')
                    }
                  }
                  )
                  : {
                      name: t.name,
                      value: n.replace(Dt, '\r\n')
                    }
            }
            ).get()
          }
        })
        const Rt = /%20/g
        const Nt = /#.*$/
        const Mt = /([?&])_=[^&]*/
        const It = /^(.*?):[ \t]*([^\r\n]*)$/gm
        const Lt = /^(?:GET|HEAD)$/
        const zt = /^\/\//
        const Ft = {}
        const $t = {}
        const Ht = '*/'.concat('*')
        const qt = A.createElement('a')
        function Wt (e) {
          return function (t, n) {
            typeof t !== 'string' && (n = t,
            t = '*')
            let r; let o = 0; const i = t.toLowerCase().match(z) || []
            if (y(n)) {
              for (; r = i[o++];) {
                r[0] === '+'
                  ? (r = r.slice(1) || '*',
                    (e[r] = e[r] || []).unshift(n))
                  : (e[r] = e[r] || []).push(n)
              }
            }
          }
        }
        function Gt (e, t, n, r) {
          const o = {}
          const i = e === $t
          function a (s) {
            let c
            return o[s] = !0,
            C.each(e[s] || [], function (e, s) {
              const l = s(t, n, r)
              return typeof l !== 'string' || i || o[l]
                ? i ? !(c = l) : void 0
                : (t.dataTypes.unshift(l),
                  a(l),
                  !1)
            }
            ),
            c
          }
          return a(t.dataTypes[0]) || !o['*'] && a('*')
        }
        function Ut (e, t) {
          let n; let r; const o = C.ajaxSettings.flatOptions || {}
          for (n in t) { void 0 !== t[n] && ((o[n] ? e : r || (r = {}))[n] = t[n]) }
          return r && C.extend(!0, e, r),
          e
        }
        qt.href = St.href,
        C.extend({
          active: 0,
          lastModified: {},
          etag: {},
          ajaxSettings: {
            url: St.href,
            type: 'GET',
            isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(St.protocol),
            global: !0,
            processData: !0,
            async: !0,
            contentType: 'application/x-www-form-urlencoded; charset=UTF-8',
            accepts: {
              '*': Ht,
              text: 'text/plain',
              html: 'text/html',
              xml: 'application/xml, text/xml',
              json: 'application/json, text/javascript'
            },
            contents: {
              xml: /\bxml\b/,
              html: /\bhtml/,
              json: /\bjson\b/
            },
            responseFields: {
              xml: 'responseXML',
              text: 'responseText',
              json: 'responseJSON'
            },
            converters: {
              '* text': String,
              'text html': !0,
              'text json': JSON.parse,
              'text xml': C.parseXML
            },
            flatOptions: {
              url: !0,
              context: !0
            }
          },
          ajaxSetup: function (e, t) {
            return t ? Ut(Ut(e, C.ajaxSettings), t) : Ut(C.ajaxSettings, e)
          },
          ajaxPrefilter: Wt(Ft),
          ajaxTransport: Wt($t),
          ajax: function (e, t) {
            o(e) === 'object' && (t = e,
            e = void 0),
            t = t || {}
            let r; let i; let a; let s; let c; let l; let p; let u; let d; let f; const h = C.ajaxSetup({}, t); const m = h.context || h; const v = h.context && (m.nodeType || m.jquery) ? C(m) : C.event; const g = C.Deferred(); const y = C.Callbacks('once memory'); let b = h.statusCode || {}; const E = {}; const x = {}; let w = 'canceled'; var _ = {
              readyState: 0,
              getResponseHeader: function (e) {
                let t
                if (p) {
                  if (!s) {
                    for (s = {}; t = It.exec(a);) { s[t[1].toLowerCase() + ' '] = (s[t[1].toLowerCase() + ' '] || []).concat(t[2]) }
                  }
                  t = s[e.toLowerCase() + ' ']
                }
                return t == null ? null : t.join(', ')
              },
              getAllResponseHeaders: function () {
                return p ? a : null
              },
              setRequestHeader: function (e, t) {
                return p == null && (e = x[e.toLowerCase()] = x[e.toLowerCase()] || e,
                E[e] = t),
                this
              },
              overrideMimeType: function (e) {
                return p == null && (h.mimeType = e),
                this
              },
              statusCode: function (e) {
                let t
                if (e) {
                  if (p) { _.always(e[_.status]) } else {
                    for (t in e) { b[t] = [b[t], e[t]] }
                  }
                }
                return this
              },
              abort: function (e) {
                const t = e || w
                return r && r.abort(t),
                S(0, t),
                this
              }
            }
            if (g.promise(_),
            h.url = ((e || h.url || St.href) + '').replace(zt, St.protocol + '//'),
            h.type = t.method || t.type || h.method || h.type,
            h.dataTypes = (h.dataType || '*').toLowerCase().match(z) || [''],
            h.crossDomain == null) {
              l = A.createElement('a')
              try {
                l.href = h.url,
                l.href = l.href,
                h.crossDomain = qt.protocol + '//' + qt.host != l.protocol + '//' + l.host
              } catch (e) {
                h.crossDomain = !0
              }
            }
            if (h.data && h.processData && typeof h.data !== 'string' && (h.data = C.param(h.data, h.traditional)),
            Gt(Ft, h, t, _),
            p) { return _ }
            for (d in (u = C.event && h.global) && C.active++ == 0 && C.event.trigger('ajaxStart'),
            h.type = h.type.toUpperCase(),
            h.hasContent = !Lt.test(h.type),
            i = h.url.replace(Nt, ''),
            h.hasContent
              ? h.data && h.processData && (h.contentType || '').indexOf('application/x-www-form-urlencoded') === 0 && (h.data = h.data.replace(Rt, '+'))
              : (f = h.url.slice(i.length),
                h.data && (h.processData || typeof h.data === 'string') && (i += (jt.test(i) ? '&' : '?') + h.data,
                delete h.data),
                !1 === h.cache && (i = i.replace(Mt, '$1'),
                f = (jt.test(i) ? '&' : '?') + '_=' + kt.guid++ + f),
                h.url = i + f),
            h.ifModified && (C.lastModified[i] && _.setRequestHeader('If-Modified-Since', C.lastModified[i]),
            C.etag[i] && _.setRequestHeader('If-None-Match', C.etag[i])),
            (h.data && h.hasContent && !1 !== h.contentType || t.contentType) && _.setRequestHeader('Content-Type', h.contentType),
            _.setRequestHeader('Accept', h.dataTypes[0] && h.accepts[h.dataTypes[0]] ? h.accepts[h.dataTypes[0]] + (h.dataTypes[0] !== '*' ? ', ' + Ht + '; q=0.01' : '') : h.accepts['*']),
            h.headers) { _.setRequestHeader(d, h.headers[d]) }
            if (h.beforeSend && (!1 === h.beforeSend.call(m, _, h) || p)) { return _.abort() }
            if (w = 'abort',
            y.add(h.complete),
            _.done(h.success),
            _.fail(h.error),
            r = Gt($t, h, t, _)) {
              if (_.readyState = 1,
              u && v.trigger('ajaxSend', [_, h]),
              p) { return _ }
              h.async && h.timeout > 0 && (c = n.setTimeout(function () {
                _.abort('timeout')
              }
              , h.timeout))
              try {
                p = !1,
                r.send(E, S)
              } catch (e) {
                if (p) { throw e }
                S(-1, e)
              }
            } else { S(-1, 'No Transport') }
            function S (e, t, o, s) {
              let l; let d; let f; let A; let E; let x = t
              p || (p = !0,
              c && n.clearTimeout(c),
              r = void 0,
              a = s || '',
              _.readyState = e > 0 ? 4 : 0,
              l = e >= 200 && e < 300 || e === 304,
              o && (A = (function (e, t, n) {
                for (var r, o, i, a, s = e.contents, c = e.dataTypes; c[0] === '*';) {
                  c.shift(),
                  void 0 === r && (r = e.mimeType || t.getResponseHeader('Content-Type'))
                }
                if (r) {
                  for (o in s) {
                    if (s[o] && s[o].test(r)) {
                      c.unshift(o)
                      break
                    }
                  }
                }
                if (c[0] in n) { i = c[0] } else {
                  for (o in n) {
                    if (!c[0] || e.converters[o + ' ' + c[0]]) {
                      i = o
                      break
                    }
                    a || (a = o)
                  }
                  i = i || a
                }
                if (i) {
                  return i !== c[0] && c.unshift(i),
                  n[i]
                }
              }(h, _, o))),
              !l && C.inArray('script', h.dataTypes) > -1 && C.inArray('json', h.dataTypes) < 0 && (h.converters['text script'] = function () {}
              ),
              A = (function (e, t, n, r) {
                let o; let i; let a; let s; let c; const l = {}; const p = e.dataTypes.slice()
                if (p[1]) {
                  for (a in e.converters) { l[a.toLowerCase()] = e.converters[a] }
                }
                for (i = p.shift(); i;) {
                  if (e.responseFields[i] && (n[e.responseFields[i]] = t),
                  !c && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)),
                  c = i,
                  i = p.shift()) {
                    if (i === '*') { i = c } else if (c !== '*' && c !== i) {
                      if (!(a = l[c + ' ' + i] || l['* ' + i])) {
                        for (o in l) {
                          if ((s = o.split(' '))[1] === i && (a = l[c + ' ' + s[0]] || l['* ' + s[0]])) {
                            !0 === a
                              ? a = l[o]
                              : !0 !== l[o] && (i = s[0],
                                p.unshift(s[1]))
                            break
                          }
                        }
                      }
                      if (!0 !== a) {
                        if (a && e.throws) { t = a(t) } else {
                          try {
                            t = a(t)
                          } catch (e) {
                            return {
                              state: 'parsererror',
                              error: a ? e : 'No conversion from ' + c + ' to ' + i
                            }
                          }
                        }
                      }
                    }
                  }
                }
                return {
                  state: 'success',
                  data: t
                }
              }(h, A, _, l)),
              l
                ? (h.ifModified && ((E = _.getResponseHeader('Last-Modified')) && (C.lastModified[i] = E),
                  (E = _.getResponseHeader('etag')) && (C.etag[i] = E)),
                  e === 204 || h.type === 'HEAD'
                    ? x = 'nocontent'
                    : e === 304
                      ? x = 'notmodified'
                      : (x = A.state,
                        d = A.data,
                        l = !(f = A.error)))
                : (f = x,
                  !e && x || (x = 'error',
                  e < 0 && (e = 0))),
              _.status = e,
              _.statusText = (t || x) + '',
              l ? g.resolveWith(m, [d, x, _]) : g.rejectWith(m, [_, x, f]),
              _.statusCode(b),
              b = void 0,
              u && v.trigger(l ? 'ajaxSuccess' : 'ajaxError', [_, h, l ? d : f]),
              y.fireWith(m, [_, x]),
              u && (v.trigger('ajaxComplete', [_, h]),
              --C.active || C.event.trigger('ajaxStop')))
            }
            return _
          },
          getJSON: function (e, t, n) {
            return C.get(e, t, n, 'json')
          },
          getScript: function (e, t) {
            return C.get(e, void 0, t, 'script')
          }
        }),
        C.each(['get', 'post'], function (e, t) {
          C[t] = function (e, n, r, o) {
            return y(n) && (o = o || r,
            r = n,
            n = void 0),
            C.ajax(C.extend({
              url: e,
              type: t,
              dataType: o,
              data: n,
              success: r
            }, C.isPlainObject(e) && e))
          }
        }
        ),
        C.ajaxPrefilter(function (e) {
          let t
          for (t in e.headers) { t.toLowerCase() === 'content-type' && (e.contentType = e.headers[t] || '') }
        }
        ),
        C._evalUrl = function (e, t, n) {
          return C.ajax({
            url: e,
            type: 'GET',
            dataType: 'script',
            cache: !0,
            async: !1,
            global: !1,
            converters: {
              'text script': function () {}
            },
            dataFilter: function (e) {
              C.globalEval(e, t, n)
            }
          })
        }
        ,
        C.fn.extend({
          wrapAll: function (e) {
            let t
            return this[0] && (y(e) && (e = e.call(this[0])),
            t = C(e, this[0].ownerDocument).eq(0).clone(!0),
            this[0].parentNode && t.insertBefore(this[0]),
            t.map(function () {
              for (var e = this; e.firstElementChild;) { e = e.firstElementChild }
              return e
            }
            ).append(this)),
            this
          },
          wrapInner: function (e) {
            return y(e)
              ? this.each(function (t) {
                C(this).wrapInner(e.call(this, t))
              }
              )
              : this.each(function () {
                const t = C(this)
                const n = t.contents()
                n.length ? n.wrapAll(e) : t.append(e)
              }
              )
          },
          wrap: function (e) {
            const t = y(e)
            return this.each(function (n) {
              C(this).wrapAll(t ? e.call(this, n) : e)
            }
            )
          },
          unwrap: function (e) {
            return this.parent(e).not('body').each(function () {
              C(this).replaceWith(this.childNodes)
            }
            ),
            this
          }
        }),
        C.expr.pseudos.hidden = function (e) {
          return !C.expr.pseudos.visible(e)
        }
        ,
        C.expr.pseudos.visible = function (e) {
          return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length)
        }
        ,
        C.ajaxSettings.xhr = function () {
          try {
            return new n.XMLHttpRequest()
          } catch (e) {}
        }

        const Vt = {
          0: 200,
          1223: 204
        }
        let Qt = C.ajaxSettings.xhr()
        g.cors = !!Qt && 'withCredentials' in Qt,
        g.ajax = Qt = !!Qt,
        C.ajaxTransport(function (e) {
          let t, r
          if (g.cors || Qt && !e.crossDomain) {
            return {
              send: function (o, i) {
                let a; const s = e.xhr()
                if (s.open(e.type, e.url, e.async, e.username, e.password),
                e.xhrFields) {
                  for (a in e.xhrFields) { s[a] = e.xhrFields[a] }
                }
                for (a in e.mimeType && s.overrideMimeType && s.overrideMimeType(e.mimeType),
                e.crossDomain || o['X-Requested-With'] || (o['X-Requested-With'] = 'XMLHttpRequest'),
                o) { s.setRequestHeader(a, o[a]) }
                t = function (e) {
                  return function () {
                    t && (t = r = s.onload = s.onerror = s.onabort = s.ontimeout = s.onreadystatechange = null,
                    e === 'abort'
                      ? s.abort()
                      : e === 'error'
                        ? typeof s.status !== 'number' ? i(0, 'error') : i(s.status, s.statusText)
                        : i(Vt[s.status] || s.status, s.statusText, (s.responseType || 'text') !== 'text' || typeof s.responseText !== 'string'
                          ? {
                              binary: s.response
                            }
                          : {
                              text: s.responseText
                            }, s.getAllResponseHeaders()))
                  }
                }
                ,
                s.onload = t(),
                r = s.onerror = s.ontimeout = t('error'),
                void 0 !== s.onabort
                  ? s.onabort = r
                  : s.onreadystatechange = function () {
                    s.readyState === 4 && n.setTimeout(function () {
                      t && r()
                    }
                    )
                  }
                ,
                t = t('abort')
                try {
                  s.send(e.hasContent && e.data || null)
                } catch (e) {
                  if (t) { throw e }
                }
              },
              abort: function () {
                t && t()
              }
            }
          }
        }
        ),
        C.ajaxPrefilter(function (e) {
          e.crossDomain && (e.contents.script = !1)
        }
        ),
        C.ajaxSetup({
          accepts: {
            script: 'text/javascript, application/javascript, application/ecmascript, application/x-ecmascript'
          },
          contents: {
            script: /\b(?:java|ecma)script\b/
          },
          converters: {
            'text script': function (e) {
              return C.globalEval(e),
              e
            }
          }
        }),
        C.ajaxPrefilter('script', function (e) {
          void 0 === e.cache && (e.cache = !1),
          e.crossDomain && (e.type = 'GET')
        }
        ),
        C.ajaxTransport('script', function (e) {
          let t, n
          if (e.crossDomain || e.scriptAttrs) {
            return {
              send: function (r, o) {
                t = C('<script>').attr(e.scriptAttrs || {}).prop({
                  charset: e.scriptCharset,
                  src: e.url
                }).on('load error', n = function (e) {
                  t.remove(),
                  n = null,
                  e && o(e.type === 'error' ? 404 : 200, e.type)
                }
                ),
                A.head.appendChild(t[0])
              },
              abort: function () {
                n && n()
              }
            }
          }
        }
        )
        let Yt; const Kt = []; const Jt = /(=)\?(?=&|$)|\?\?/
        C.ajaxSetup({
          jsonp: 'callback',
          jsonpCallback: function () {
            const e = Kt.pop() || C.expando + '_' + kt.guid++
            return this[e] = !0,
            e
          }
        }),
        C.ajaxPrefilter('json jsonp', function (e, t, r) {
          let o; let i; let a; const s = !1 !== e.jsonp && (Jt.test(e.url) ? 'url' : typeof e.data === 'string' && (e.contentType || '').indexOf('application/x-www-form-urlencoded') === 0 && Jt.test(e.data) && 'data')
          if (s || e.dataTypes[0] === 'jsonp') {
            return o = e.jsonpCallback = y(e.jsonpCallback) ? e.jsonpCallback() : e.jsonpCallback,
            s ? e[s] = e[s].replace(Jt, '$1' + o) : !1 !== e.jsonp && (e.url += (jt.test(e.url) ? '&' : '?') + e.jsonp + '=' + o),
            e.converters['script json'] = function () {
              return a || C.error(o + ' was not called'),
              a[0]
            }
            ,
            e.dataTypes[0] = 'json',
            i = n[o],
            n[o] = function () {
              a = arguments
            }
            ,
            r.always(function () {
              void 0 === i ? C(n).removeProp(o) : n[o] = i,
              e[o] && (e.jsonpCallback = t.jsonpCallback,
              Kt.push(o)),
              a && y(i) && i(a[0]),
              a = i = void 0
            }
            ),
            'script'
          }
        }
        ),
        g.createHTMLDocument = ((Yt = A.implementation.createHTMLDocument('').body).innerHTML = '<form></form><form></form>',
        Yt.childNodes.length === 2),
        C.parseHTML = function (e, t, n) {
          return typeof e !== 'string'
            ? []
            : (typeof t === 'boolean' && (n = t,
              t = !1),
              t || (g.createHTMLDocument
                ? ((r = (t = A.implementation.createHTMLDocument('')).createElement('base')).href = A.location.href,
                  t.head.appendChild(r))
                : t = A),
              i = !n && [],
              (o = O.exec(e))
                ? [t.createElement(o[1])]
                : (o = _e([e], t, i),
                  i && i.length && C(i).remove(),
                  C.merge([], o.childNodes)))
          let r, o, i
        }
        ,
        C.fn.load = function (e, t, n) {
          let r; let i; let a; const s = this; const c = e.indexOf(' ')
          return c > -1 && (r = At(e.slice(c)),
          e = e.slice(0, c)),
          y(t)
            ? (n = t,
              t = void 0)
            : t && o(t) === 'object' && (i = 'POST'),
          s.length > 0 && C.ajax({
            url: e,
            type: i || 'GET',
            dataType: 'html',
            data: t
          }).done(function (e) {
            a = arguments,
            s.html(r ? C('<div>').append(C.parseHTML(e)).find(r) : e)
          }
          ).always(n && function (e, t) {
            s.each(function () {
              n.apply(this, a || [e.responseText, t, e])
            }
            )
          }
          ),
          this
        }
        ,
        C.expr.pseudos.animated = function (e) {
          return C.grep(C.timers, function (t) {
            return e === t.elem
          }
          ).length
        }
        ,
        C.offset = {
          setOffset: function (e, t, n) {
            let r; let o; let i; let a; let s; let c; const l = C.css(e, 'position'); const p = C(e); const u = {}
            l === 'static' && (e.style.position = 'relative'),
            s = p.offset(),
            i = C.css(e, 'top'),
            c = C.css(e, 'left'),
            (l === 'absolute' || l === 'fixed') && (i + c).indexOf('auto') > -1
              ? (a = (r = p.position()).top,
                o = r.left)
              : (a = parseFloat(i) || 0,
                o = parseFloat(c) || 0),
            y(t) && (t = t.call(e, n, C.extend({}, s))),
            t.top != null && (u.top = t.top - s.top + a),
            t.left != null && (u.left = t.left - s.left + o),
            'using' in t ? t.using.call(e, u) : p.css(u)
          }
        },
        C.fn.extend({
          offset: function (e) {
            if (arguments.length) {
              return void 0 === e
                ? this
                : this.each(function (t) {
                  C.offset.setOffset(this, e, t)
                }
                )
            }
            let t; let n; const r = this[0]
            return r
              ? r.getClientRects().length
                ? (t = r.getBoundingClientRect(),
                  n = r.ownerDocument.defaultView,
                  {
                    top: t.top + n.pageYOffset,
                    left: t.left + n.pageXOffset
                  })
                : {
                    top: 0,
                    left: 0
                  }
              : void 0
          },
          position: function () {
            if (this[0]) {
              let e; let t; let n; const r = this[0]; let o = {
                top: 0,
                left: 0
              }
              if (C.css(r, 'position') === 'fixed') { t = r.getBoundingClientRect() } else {
                for (t = this.offset(),
                n = r.ownerDocument,
                e = r.offsetParent || n.documentElement; e && (e === n.body || e === n.documentElement) && C.css(e, 'position') === 'static';) { e = e.parentNode }
                e && e !== r && e.nodeType === 1 && ((o = C(e).offset()).top += C.css(e, 'borderTopWidth', !0),
                o.left += C.css(e, 'borderLeftWidth', !0))
              }
              return {
                top: t.top - o.top - C.css(r, 'marginTop', !0),
                left: t.left - o.left - C.css(r, 'marginLeft', !0)
              }
            }
          },
          offsetParent: function () {
            return this.map(function () {
              for (var e = this.offsetParent; e && C.css(e, 'position') === 'static';) { e = e.offsetParent }
              return e || se
            }
            )
          }
        }),
        C.each({
          scrollLeft: 'pageXOffset',
          scrollTop: 'pageYOffset'
        }, function (e, t) {
          const n = t === 'pageYOffset'
          C.fn[e] = function (r) {
            return U(this, function (e, r, o) {
              let i
              if (b(e) ? i = e : e.nodeType === 9 && (i = e.defaultView),
              void 0 === o) { return i ? i[t] : e[r] }
              i ? i.scrollTo(n ? i.pageXOffset : o, n ? o : i.pageYOffset) : e[r] = o
            }
            , e, r, arguments.length)
          }
        }
        ),
        C.each(['top', 'left'], function (e, t) {
          C.cssHooks[t] = Ye(g.pixelPosition, function (e, n) {
            if (n) {
              return n = Qe(e, t),
              $e.test(n) ? C(e).position()[t] + 'px' : n
            }
          }
          )
        }
        ),
        C.each({
          Height: 'height',
          Width: 'width'
        }, function (e, t) {
          C.each({
            padding: 'inner' + e,
            content: t,
            '': 'outer' + e
          }, function (n, r) {
            C.fn[r] = function (o, i) {
              const a = arguments.length && (n || typeof o !== 'boolean')
              const s = n || (!0 === o || !0 === i ? 'margin' : 'border')
              return U(this, function (t, n, o) {
                let i
                return b(t)
                  ? r.indexOf('outer') === 0 ? t['inner' + e] : t.document.documentElement['client' + e]
                  : t.nodeType === 9
                    ? (i = t.documentElement,
                      Math.max(t.body['scroll' + e], i['scroll' + e], t.body['offset' + e], i['offset' + e], i['client' + e]))
                    : void 0 === o ? C.css(t, n, s) : C.style(t, n, o, s)
              }
              , t, a ? o : void 0, a)
            }
          }
          )
        }
        ),
        C.each(['ajaxStart', 'ajaxStop', 'ajaxComplete', 'ajaxError', 'ajaxSuccess', 'ajaxSend'], function (e, t) {
          C.fn[t] = function (e) {
            return this.on(t, e)
          }
        }
        ),
        C.fn.extend({
          bind: function (e, t, n) {
            return this.on(e, null, t, n)
          },
          unbind: function (e, t) {
            return this.off(e, null, t)
          },
          delegate: function (e, t, n, r) {
            return this.on(t, e, n, r)
          },
          undelegate: function (e, t, n) {
            return arguments.length === 1 ? this.off(e, '**') : this.off(t, e || '**', n)
          },
          hover: function (e, t) {
            return this.mouseenter(e).mouseleave(t || e)
          }
        }),
        C.each('blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu'.split(' '), function (e, t) {
          C.fn[t] = function (e, n) {
            return arguments.length > 0 ? this.on(t, null, e, n) : this.trigger(t)
          }
        }
        )
        const Xt = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g
        C.proxy = function (e, t) {
          let n, r, o
          if (typeof t === 'string' && (n = e[t],
          t = e,
          e = n),
          y(e)) {
            return r = c.call(arguments, 2),
            o = function () {
              return e.apply(t || this, r.concat(c.call(arguments)))
            }
            ,
            o.guid = e.guid = e.guid || C.guid++,
            o
          }
        }
        ,
        C.holdReady = function (e) {
          e ? C.readyWait++ : C.ready(!0)
        }
        ,
        C.isArray = Array.isArray,
        C.parseJSON = JSON.parse,
        C.nodeName = P,
        C.isFunction = y,
        C.isWindow = b,
        C.camelCase = K,
        C.type = w,
        C.now = Date.now,
        C.isNumeric = function (e) {
          const t = C.type(e)
          return (t === 'number' || t === 'string') && !isNaN(e - parseFloat(e))
        }
        ,
        C.trim = function (e) {
          return e == null ? '' : (e + '').replace(Xt, '$1')
        }
        ,
        void 0 === (r = (function () {
          return C
        }
          .apply(t, []))) || (e.exports = r)
        const Zt = n.jQuery
        const en = n.$
        return C.noConflict = function (e) {
          return n.$ === C && (n.$ = en),
          e && n.jQuery === C && (n.jQuery = Zt),
          C
        }
        ,
        void 0 === i && (n.jQuery = n.$ = C),
        C
      }
      ))
    },
    9745: (e, t, n) => {
      'use strict'
      n.d(t, {
        A: () => s
      })
      const r = n(2017)
      const o = n.n(r)
      const i = n(3527)
      const a = n.n(i)()(o())
      a.push([e.id, '/* COLOR PICKER */\n\n.djs-popup.color-picker .entry {\n    margin: 0;\n}\n\n.djs-popup.color-picker .djs-popup-group {\n  display: grid;\n  grid: auto-flow / 1fr 1fr 1fr;\n}', '', {
        version: 3,
        sources: ['webpack://./node_modules/bpmn-js-color-picker/colors/color-picker.css'],
        names: [],
        mappings: 'AAAA,iBAAiB;;AAEjB;IACI,SAAS;AACb;;AAEA;EACE,aAAa;EACb,6BAA6B;AAC/B',
        sourcesContent: ['/* COLOR PICKER */\n\n.djs-popup.color-picker .entry {\n    margin: 0;\n}\n\n.djs-popup.color-picker .djs-popup-group {\n  display: grid;\n  grid: auto-flow / 1fr 1fr 1fr;\n}'],
        sourceRoot: ''
      }])
      const s = a
    },
    75: (e, t, n) => {
      'use strict'
      n.d(t, {
        A: () => E
      })
      const r = n(2017)
      const o = n.n(r)
      const i = n(3527)
      const a = n.n(i)
      const s = n(9038)
      const c = n.n(s)
      const l = new URL(n(7948), n.b)
      const p = new URL(n(3816), n.b)
      const u = new URL(n(6474), n.b)
      const d = new URL(n(6426), n.b)
      const f = new URL(n(7046), n.b)
      const h = a()(o())
      const m = c()(l)
      const v = c()(l, {
        hash: '#iefix'
      })
      const g = c()(p)
      const y = c()(u)
      const b = c()(d)
      const A = c()(f, {
        hash: '#bpmn'
      })
      h.push([e.id, `@charset "utf-8";\n@font-face {\n  font-family: 'bpmn';\n  src: url(${m});\n  src: url(${v}) format('embedded-opentype'),\n       url(${g}) format('woff2'),\n       url(${y}) format('woff'),\n       url(${b}) format('truetype'),\n       url(${A}) format('svg');\n  font-weight: normal;\n  font-style: normal;\n}\n/* Chrome hack: SVG is rendered more smooth in Windozze. 100% magic, uncomment if you need it. */\n/* Note, that will break hinting! In other OS-es font will be not as sharp as it could be */\n/*\n@media screen and (-webkit-min-device-pixel-ratio:0) {\n  @font-face {\n    font-family: 'bpmn';\n    src: url('../font/bpmn.svg?21877404#bpmn') format('svg');\n  }\n}\n*/\n[class^="bpmn-icon-"]:before, [class*=" bpmn-icon-"]:before {\n  font-family: "bpmn";\n  font-style: normal;\n  font-weight: normal;\n  speak: never;\n\n  display: inline-block;\n  text-decoration: inherit;\n  width: 1em;\n  /* margin-right: .2em; */\n  text-align: center;\n  /* opacity: .8; */\n\n  /* For safety - reset parent styles, that can break glyph codes*/\n  font-variant: normal;\n  text-transform: none;\n\n  /* fix buttons height, for twitter bootstrap */\n  line-height: 1em;\n\n  /* Animation center compensation - margins should be symmetric */\n  /* remove if not needed */\n  /* margin-left: .2em; */\n\n  /* you can be more comfortable with increased icons size */\n  /* font-size: 120%; */\n\n  /* Font smoothing. That was taken from TWBS */\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n\n  /* Uncomment for 3D effect */\n  /* text-shadow: 1px 1px 1px rgba(127, 127, 127, 0.3); */\n}\n\n.bpmn-icon-trash:before { content: '\\e801'; } /* '' */\n.bpmn-icon-gateway-parallel:before { content: '\\e804'; } /* '' */\n.bpmn-icon-intermediate-event-catch-cancel:before { content: '\\e805'; } /* '' */\n.bpmn-icon-intermediate-event-catch-non-interrupting-message:before { content: '\\e806'; } /* '' */\n.bpmn-icon-start-event-compensation:before { content: '\\e807'; } /* '' */\n.bpmn-icon-start-event-non-interrupting-parallel-multiple:before { content: '\\e808'; } /* '' */\n.bpmn-icon-loop-marker:before { content: '\\e809'; } /* '' */\n.bpmn-icon-parallel-mi-marker:before { content: '\\e80a'; } /* '' */\n.bpmn-icon-start-event-non-interrupting-signal:before { content: '\\e80b'; } /* '' */\n.bpmn-icon-intermediate-event-catch-non-interrupting-timer:before { content: '\\e80c'; } /* '' */\n.bpmn-icon-intermediate-event-catch-parallel-multiple:before { content: '\\e80d'; } /* '' */\n.bpmn-icon-intermediate-event-catch-compensation:before { content: '\\e80e'; } /* '' */\n.bpmn-icon-gateway-xor:before { content: '\\e80f'; } /* '' */\n.bpmn-icon-end-event-cancel:before { content: '\\e811'; } /* '' */\n.bpmn-icon-intermediate-event-catch-condition:before { content: '\\e812'; } /* '' */\n.bpmn-icon-intermediate-event-catch-non-interrupting-parallel-multiple:before { content: '\\e813'; } /* '' */\n.bpmn-icon-start-event-condition:before { content: '\\e814'; } /* '' */\n.bpmn-icon-start-event-non-interrupting-timer:before { content: '\\e815'; } /* '' */\n.bpmn-icon-sequential-mi-marker:before { content: '\\e816'; } /* '' */\n.bpmn-icon-user-task:before { content: '\\e817'; } /* '' */\n.bpmn-icon-business-rule:before { content: '\\e818'; } /* '' */\n.bpmn-icon-sub-process-marker:before { content: '\\e819'; } /* '' */\n.bpmn-icon-start-event-parallel-multiple:before { content: '\\e81a'; } /* '' */\n.bpmn-icon-start-event-error:before { content: '\\e81b'; } /* '' */\n.bpmn-icon-intermediate-event-catch-signal:before { content: '\\e81c'; } /* '' */\n.bpmn-icon-intermediate-event-catch-error:before { content: '\\e81d'; } /* '' */\n.bpmn-icon-end-event-compensation:before { content: '\\e81e'; } /* '' */\n.bpmn-icon-subprocess-collapsed:before { content: '\\e81f'; } /* '' */\n.bpmn-icon-subprocess-expanded:before { content: '\\e820'; } /* '' */\n.bpmn-icon-task:before { content: '\\e821'; } /* '' */\n.bpmn-icon-end-event-error:before { content: '\\e822'; } /* '' */\n.bpmn-icon-intermediate-event-catch-escalation:before { content: '\\e823'; } /* '' */\n.bpmn-icon-intermediate-event-catch-timer:before { content: '\\e824'; } /* '' */\n.bpmn-icon-start-event-escalation:before { content: '\\e825'; } /* '' */\n.bpmn-icon-start-event-signal:before { content: '\\e826'; } /* '' */\n.bpmn-icon-business-rule-task:before { content: '\\e827'; } /* '' */\n.bpmn-icon-manual:before { content: '\\e828'; } /* '' */\n.bpmn-icon-receive:before { content: '\\e829'; } /* '' */\n.bpmn-icon-call-activity:before { content: '\\e82a'; } /* '' */\n.bpmn-icon-start-event-timer:before { content: '\\e82b'; } /* '' */\n.bpmn-icon-start-event-message:before { content: '\\e82c'; } /* '' */\n.bpmn-icon-intermediate-event-none:before { content: '\\e82d'; } /* '' */\n.bpmn-icon-intermediate-event-catch-link:before { content: '\\e82e'; } /* '' */\n.bpmn-icon-end-event-escalation:before { content: '\\e82f'; } /* '' */\n.bpmn-icon-bpmn-io:before { content: '\\e831'; } /* '' */\n.bpmn-icon-gateway-complex:before { content: '\\e832'; } /* '' */\n.bpmn-icon-gateway-eventbased:before { content: '\\e833'; } /* '' */\n.bpmn-icon-gateway-none:before { content: '\\e834'; } /* '' */\n.bpmn-icon-gateway-or:before { content: '\\e835'; } /* '' */\n.bpmn-icon-end-event-terminate:before { content: '\\e836'; } /* '' */\n.bpmn-icon-end-event-signal:before { content: '\\e837'; } /* '' */\n.bpmn-icon-end-event-none:before { content: '\\e838'; } /* '' */\n.bpmn-icon-end-event-multiple:before { content: '\\e839'; } /* '' */\n.bpmn-icon-end-event-message:before { content: '\\e83a'; } /* '' */\n.bpmn-icon-end-event-link:before { content: '\\e83b'; } /* '' */\n.bpmn-icon-intermediate-event-catch-message:before { content: '\\e83c'; } /* '' */\n.bpmn-icon-intermediate-event-throw-compensation:before { content: '\\e83d'; } /* '' */\n.bpmn-icon-start-event-multiple:before { content: '\\e83e'; } /* '' */\n.bpmn-icon-script:before { content: '\\e83f'; } /* '' */\n.bpmn-icon-manual-task:before { content: '\\e840'; } /* '' */\n.bpmn-icon-send:before { content: '\\e841'; } /* '' */\n.bpmn-icon-service:before { content: '\\e842'; } /* '' */\n.bpmn-icon-receive-task:before { content: '\\e843'; } /* '' */\n.bpmn-icon-user:before { content: '\\e844'; } /* '' */\n.bpmn-icon-start-event-none:before { content: '\\e845'; } /* '' */\n.bpmn-icon-intermediate-event-throw-escalation:before { content: '\\e846'; } /* '' */\n.bpmn-icon-intermediate-event-catch-multiple:before { content: '\\e847'; } /* '' */\n.bpmn-icon-intermediate-event-catch-non-interrupting-escalation:before { content: '\\e848'; } /* '' */\n.bpmn-icon-intermediate-event-throw-link:before { content: '\\e849'; } /* '' */\n.bpmn-icon-start-event-non-interrupting-condition:before { content: '\\e84a'; } /* '' */\n.bpmn-icon-data-object:before { content: '\\e84b'; } /* '' */\n.bpmn-icon-script-task:before { content: '\\e84c'; } /* '' */\n.bpmn-icon-send-task:before { content: '\\e84d'; } /* '' */\n.bpmn-icon-data-store:before { content: '\\e84e'; } /* '' */\n.bpmn-icon-start-event-non-interrupting-escalation:before { content: '\\e84f'; } /* '' */\n.bpmn-icon-intermediate-event-throw-message:before { content: '\\e850'; } /* '' */\n.bpmn-icon-intermediate-event-catch-non-interrupting-multiple:before { content: '\\e851'; } /* '' */\n.bpmn-icon-intermediate-event-catch-non-interrupting-signal:before { content: '\\e852'; } /* '' */\n.bpmn-icon-intermediate-event-throw-multiple:before { content: '\\e853'; } /* '' */\n.bpmn-icon-start-event-non-interrupting-message:before { content: '\\e854'; } /* '' */\n.bpmn-icon-ad-hoc-marker:before { content: '\\e855'; } /* '' */\n.bpmn-icon-service-task:before { content: '\\e856'; } /* '' */\n.bpmn-icon-task-none:before { content: '\\e857'; } /* '' */\n.bpmn-icon-compensation-marker:before { content: '\\e858'; } /* '' */\n.bpmn-icon-start-event-non-interrupting-multiple:before { content: '\\e859'; } /* '' */\n.bpmn-icon-intermediate-event-throw-signal:before { content: '\\e85a'; } /* '' */\n.bpmn-icon-intermediate-event-catch-non-interrupting-condition:before { content: '\\e85b'; } /* '' */\n.bpmn-icon-participant:before { content: '\\e85c'; } /* '' */\n.bpmn-icon-event-subprocess-expanded:before { content: '\\e85d'; } /* '' */\n.bpmn-icon-lane-insert-below:before { content: '\\e85e'; } /* '' */\n.bpmn-icon-space-tool:before { content: '\\e85f'; } /* '' */\n.bpmn-icon-connection-multi:before { content: '\\e860'; } /* '' */\n.bpmn-icon-lane:before { content: '\\e861'; } /* '' */\n.bpmn-icon-lasso-tool:before { content: '\\e862'; } /* '' */\n.bpmn-icon-lane-insert-above:before { content: '\\e863'; } /* '' */\n.bpmn-icon-lane-divide-three:before { content: '\\e864'; } /* '' */\n.bpmn-icon-lane-divide-two:before { content: '\\e865'; } /* '' */\n.bpmn-icon-data-input:before { content: '\\e866'; } /* '' */\n.bpmn-icon-data-output:before { content: '\\e867'; } /* '' */\n.bpmn-icon-hand-tool:before { content: '\\e868'; } /* '' */\n.bpmn-icon-group:before { content: '\\e869'; } /* '' */\n.bpmn-icon-text-annotation:before { content: '\\e86b'; } /* '' */\n.bpmn-icon-transaction:before { content: '\\e8c4'; } /* '' */\n.bpmn-icon-screw-wrench:before { content: '\\e8db'; } /* '' */\n.bpmn-icon-connection:before { content: '\\e8dc'; } /* '' */\n.bpmn-icon-conditional-flow:before { content: '\\e8e0'; } /* '' */\n.bpmn-icon-default-flow:before { content: '\\e8e1'; } /* '' */\n`, '', {
        version: 3,
        sources: ['webpack://./node_modules/bpmn-js/dist/assets/bpmn-font/css/bpmn.css'],
        names: [],
        mappings: 'AAAA,gBAAgB;AAChB;EACE,mBAAmB;EACnB,4CAAqC;EACrC;;;;4DAIwD;EACxD,mBAAmB;EACnB,kBAAkB;AACpB;AACA,gGAAgG;AAChG,2FAA2F;AAC3F;;;;;;;CAOC;AACD;EACE,mBAAmB;EACnB,kBAAkB;EAClB,mBAAmB;EACnB,YAAY;;EAEZ,qBAAqB;EACrB,wBAAwB;EACxB,UAAU;EACV,wBAAwB;EACxB,kBAAkB;EAClB,iBAAiB;;EAEjB,gEAAgE;EAChE,oBAAoB;EACpB,oBAAoB;;EAEpB,8CAA8C;EAC9C,gBAAgB;;EAEhB,gEAAgE;EAChE,yBAAyB;EACzB,uBAAuB;;EAEvB,0DAA0D;EAC1D,qBAAqB;;EAErB,6CAA6C;EAC7C,mCAAmC;EACnC,kCAAkC;;EAElC,4BAA4B;EAC5B,uDAAuD;AACzD;;AAEA,0BAA0B,gBAAgB,EAAE,EAAE,QAAQ;AACtD,qCAAqC,gBAAgB,EAAE,EAAE,QAAQ;AACjE,oDAAoD,gBAAgB,EAAE,EAAE,QAAQ;AAChF,sEAAsE,gBAAgB,EAAE,EAAE,QAAQ;AAClG,6CAA6C,gBAAgB,EAAE,EAAE,QAAQ;AACzE,mEAAmE,gBAAgB,EAAE,EAAE,QAAQ;AAC/F,gCAAgC,gBAAgB,EAAE,EAAE,QAAQ;AAC5D,uCAAuC,gBAAgB,EAAE,EAAE,QAAQ;AACnE,wDAAwD,gBAAgB,EAAE,EAAE,QAAQ;AACpF,oEAAoE,gBAAgB,EAAE,EAAE,QAAQ;AAChG,+DAA+D,gBAAgB,EAAE,EAAE,QAAQ;AAC3F,0DAA0D,gBAAgB,EAAE,EAAE,QAAQ;AACtF,gCAAgC,gBAAgB,EAAE,EAAE,QAAQ;AAC5D,qCAAqC,gBAAgB,EAAE,EAAE,QAAQ;AACjE,uDAAuD,gBAAgB,EAAE,EAAE,QAAQ;AACnF,gFAAgF,gBAAgB,EAAE,EAAE,QAAQ;AAC5G,0CAA0C,gBAAgB,EAAE,EAAE,QAAQ;AACtE,uDAAuD,gBAAgB,EAAE,EAAE,QAAQ;AACnF,yCAAyC,gBAAgB,EAAE,EAAE,QAAQ;AACrE,8BAA8B,gBAAgB,EAAE,EAAE,QAAQ;AAC1D,kCAAkC,gBAAgB,EAAE,EAAE,QAAQ;AAC9D,uCAAuC,gBAAgB,EAAE,EAAE,QAAQ;AACnE,kDAAkD,gBAAgB,EAAE,EAAE,QAAQ;AAC9E,sCAAsC,gBAAgB,EAAE,EAAE,QAAQ;AAClE,oDAAoD,gBAAgB,EAAE,EAAE,QAAQ;AAChF,mDAAmD,gBAAgB,EAAE,EAAE,QAAQ;AAC/E,2CAA2C,gBAAgB,EAAE,EAAE,QAAQ;AACvE,yCAAyC,gBAAgB,EAAE,EAAE,QAAQ;AACrE,wCAAwC,gBAAgB,EAAE,EAAE,QAAQ;AACpE,yBAAyB,gBAAgB,EAAE,EAAE,QAAQ;AACrD,oCAAoC,gBAAgB,EAAE,EAAE,QAAQ;AAChE,wDAAwD,gBAAgB,EAAE,EAAE,QAAQ;AACpF,mDAAmD,gBAAgB,EAAE,EAAE,QAAQ;AAC/E,2CAA2C,gBAAgB,EAAE,EAAE,QAAQ;AACvE,uCAAuC,gBAAgB,EAAE,EAAE,QAAQ;AACnE,uCAAuC,gBAAgB,EAAE,EAAE,QAAQ;AACnE,2BAA2B,gBAAgB,EAAE,EAAE,QAAQ;AACvD,4BAA4B,gBAAgB,EAAE,EAAE,QAAQ;AACxD,kCAAkC,gBAAgB,EAAE,EAAE,QAAQ;AAC9D,sCAAsC,gBAAgB,EAAE,EAAE,QAAQ;AAClE,wCAAwC,gBAAgB,EAAE,EAAE,QAAQ;AACpE,4CAA4C,gBAAgB,EAAE,EAAE,QAAQ;AACxE,kDAAkD,gBAAgB,EAAE,EAAE,QAAQ;AAC9E,yCAAyC,gBAAgB,EAAE,EAAE,QAAQ;AACrE,4BAA4B,gBAAgB,EAAE,EAAE,QAAQ;AACxD,oCAAoC,gBAAgB,EAAE,EAAE,QAAQ;AAChE,uCAAuC,gBAAgB,EAAE,EAAE,QAAQ;AACnE,iCAAiC,gBAAgB,EAAE,EAAE,QAAQ;AAC7D,+BAA+B,gBAAgB,EAAE,EAAE,QAAQ;AAC3D,wCAAwC,gBAAgB,EAAE,EAAE,QAAQ;AACpE,qCAAqC,gBAAgB,EAAE,EAAE,QAAQ;AACjE,mCAAmC,gBAAgB,EAAE,EAAE,QAAQ;AAC/D,uCAAuC,gBAAgB,EAAE,EAAE,QAAQ;AACnE,sCAAsC,gBAAgB,EAAE,EAAE,QAAQ;AAClE,mCAAmC,gBAAgB,EAAE,EAAE,QAAQ;AAC/D,qDAAqD,gBAAgB,EAAE,EAAE,QAAQ;AACjF,0DAA0D,gBAAgB,EAAE,EAAE,QAAQ;AACtF,yCAAyC,gBAAgB,EAAE,EAAE,QAAQ;AACrE,2BAA2B,gBAAgB,EAAE,EAAE,QAAQ;AACvD,gCAAgC,gBAAgB,EAAE,EAAE,QAAQ;AAC5D,yBAAyB,gBAAgB,EAAE,EAAE,QAAQ;AACrD,4BAA4B,gBAAgB,EAAE,EAAE,QAAQ;AACxD,iCAAiC,gBAAgB,EAAE,EAAE,QAAQ;AAC7D,yBAAyB,gBAAgB,EAAE,EAAE,QAAQ;AACrD,qCAAqC,gBAAgB,EAAE,EAAE,QAAQ;AACjE,wDAAwD,gBAAgB,EAAE,EAAE,QAAQ;AACpF,sDAAsD,gBAAgB,EAAE,EAAE,QAAQ;AAClF,yEAAyE,gBAAgB,EAAE,EAAE,QAAQ;AACrG,kDAAkD,gBAAgB,EAAE,EAAE,QAAQ;AAC9E,2DAA2D,gBAAgB,EAAE,EAAE,QAAQ;AACvF,gCAAgC,gBAAgB,EAAE,EAAE,QAAQ;AAC5D,gCAAgC,gBAAgB,EAAE,EAAE,QAAQ;AAC5D,8BAA8B,gBAAgB,EAAE,EAAE,QAAQ;AAC1D,+BAA+B,gBAAgB,EAAE,EAAE,QAAQ;AAC3D,4DAA4D,gBAAgB,EAAE,EAAE,QAAQ;AACxF,qDAAqD,gBAAgB,EAAE,EAAE,QAAQ;AACjF,uEAAuE,gBAAgB,EAAE,EAAE,QAAQ;AACnG,qEAAqE,gBAAgB,EAAE,EAAE,QAAQ;AACjG,sDAAsD,gBAAgB,EAAE,EAAE,QAAQ;AAClF,yDAAyD,gBAAgB,EAAE,EAAE,QAAQ;AACrF,kCAAkC,gBAAgB,EAAE,EAAE,QAAQ;AAC9D,iCAAiC,gBAAgB,EAAE,EAAE,QAAQ;AAC7D,8BAA8B,gBAAgB,EAAE,EAAE,QAAQ;AAC1D,wCAAwC,gBAAgB,EAAE,EAAE,QAAQ;AACpE,0DAA0D,gBAAgB,EAAE,EAAE,QAAQ;AACtF,oDAAoD,gBAAgB,EAAE,EAAE,QAAQ;AAChF,wEAAwE,gBAAgB,EAAE,EAAE,QAAQ;AACpG,gCAAgC,gBAAgB,EAAE,EAAE,QAAQ;AAC5D,8CAA8C,gBAAgB,EAAE,EAAE,QAAQ;AAC1E,sCAAsC,gBAAgB,EAAE,EAAE,QAAQ;AAClE,+BAA+B,gBAAgB,EAAE,EAAE,QAAQ;AAC3D,qCAAqC,gBAAgB,EAAE,EAAE,QAAQ;AACjE,yBAAyB,gBAAgB,EAAE,EAAE,QAAQ;AACrD,+BAA+B,gBAAgB,EAAE,EAAE,QAAQ;AAC3D,sCAAsC,gBAAgB,EAAE,EAAE,QAAQ;AAClE,sCAAsC,gBAAgB,EAAE,EAAE,QAAQ;AAClE,oCAAoC,gBAAgB,EAAE,EAAE,QAAQ;AAChE,+BAA+B,gBAAgB,EAAE,EAAE,QAAQ;AAC3D,gCAAgC,gBAAgB,EAAE,EAAE,QAAQ;AAC5D,8BAA8B,gBAAgB,EAAE,EAAE,QAAQ;AAC1D,0BAA0B,gBAAgB,EAAE,EAAE,QAAQ;AACtD,oCAAoC,gBAAgB,EAAE,EAAE,QAAQ;AAChE,gCAAgC,gBAAgB,EAAE,EAAE,QAAQ;AAC5D,iCAAiC,gBAAgB,EAAE,EAAE,QAAQ;AAC7D,+BAA+B,gBAAgB,EAAE,EAAE,QAAQ;AAC3D,qCAAqC,gBAAgB,EAAE,EAAE,QAAQ;AACjE,iCAAiC,gBAAgB,EAAE,EAAE,QAAQ',
        sourcesContent: ["@charset \"utf-8\";\n@font-face {\n  font-family: 'bpmn';\n  src: url('../font/bpmn.eot?21877404');\n  src: url('../font/bpmn.eot?21877404#iefix') format('embedded-opentype'),\n       url('../font/bpmn.woff2?21877404') format('woff2'),\n       url('../font/bpmn.woff?21877404') format('woff'),\n       url('../font/bpmn.ttf?21877404') format('truetype'),\n       url('../font/bpmn.svg?21877404#bpmn') format('svg');\n  font-weight: normal;\n  font-style: normal;\n}\n/* Chrome hack: SVG is rendered more smooth in Windozze. 100% magic, uncomment if you need it. */\n/* Note, that will break hinting! In other OS-es font will be not as sharp as it could be */\n/*\n@media screen and (-webkit-min-device-pixel-ratio:0) {\n  @font-face {\n    font-family: 'bpmn';\n    src: url('../font/bpmn.svg?21877404#bpmn') format('svg');\n  }\n}\n*/\n[class^=\"bpmn-icon-\"]:before, [class*=\" bpmn-icon-\"]:before {\n  font-family: \"bpmn\";\n  font-style: normal;\n  font-weight: normal;\n  speak: never;\n\n  display: inline-block;\n  text-decoration: inherit;\n  width: 1em;\n  /* margin-right: .2em; */\n  text-align: center;\n  /* opacity: .8; */\n\n  /* For safety - reset parent styles, that can break glyph codes*/\n  font-variant: normal;\n  text-transform: none;\n\n  /* fix buttons height, for twitter bootstrap */\n  line-height: 1em;\n\n  /* Animation center compensation - margins should be symmetric */\n  /* remove if not needed */\n  /* margin-left: .2em; */\n\n  /* you can be more comfortable with increased icons size */\n  /* font-size: 120%; */\n\n  /* Font smoothing. That was taken from TWBS */\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n\n  /* Uncomment for 3D effect */\n  /* text-shadow: 1px 1px 1px rgba(127, 127, 127, 0.3); */\n}\n\n.bpmn-icon-trash:before { content: '\\e801'; } /* '' */\n.bpmn-icon-gateway-parallel:before { content: '\\e804'; } /* '' */\n.bpmn-icon-intermediate-event-catch-cancel:before { content: '\\e805'; } /* '' */\n.bpmn-icon-intermediate-event-catch-non-interrupting-message:before { content: '\\e806'; } /* '' */\n.bpmn-icon-start-event-compensation:before { content: '\\e807'; } /* '' */\n.bpmn-icon-start-event-non-interrupting-parallel-multiple:before { content: '\\e808'; } /* '' */\n.bpmn-icon-loop-marker:before { content: '\\e809'; } /* '' */\n.bpmn-icon-parallel-mi-marker:before { content: '\\e80a'; } /* '' */\n.bpmn-icon-start-event-non-interrupting-signal:before { content: '\\e80b'; } /* '' */\n.bpmn-icon-intermediate-event-catch-non-interrupting-timer:before { content: '\\e80c'; } /* '' */\n.bpmn-icon-intermediate-event-catch-parallel-multiple:before { content: '\\e80d'; } /* '' */\n.bpmn-icon-intermediate-event-catch-compensation:before { content: '\\e80e'; } /* '' */\n.bpmn-icon-gateway-xor:before { content: '\\e80f'; } /* '' */\n.bpmn-icon-end-event-cancel:before { content: '\\e811'; } /* '' */\n.bpmn-icon-intermediate-event-catch-condition:before { content: '\\e812'; } /* '' */\n.bpmn-icon-intermediate-event-catch-non-interrupting-parallel-multiple:before { content: '\\e813'; } /* '' */\n.bpmn-icon-start-event-condition:before { content: '\\e814'; } /* '' */\n.bpmn-icon-start-event-non-interrupting-timer:before { content: '\\e815'; } /* '' */\n.bpmn-icon-sequential-mi-marker:before { content: '\\e816'; } /* '' */\n.bpmn-icon-user-task:before { content: '\\e817'; } /* '' */\n.bpmn-icon-business-rule:before { content: '\\e818'; } /* '' */\n.bpmn-icon-sub-process-marker:before { content: '\\e819'; } /* '' */\n.bpmn-icon-start-event-parallel-multiple:before { content: '\\e81a'; } /* '' */\n.bpmn-icon-start-event-error:before { content: '\\e81b'; } /* '' */\n.bpmn-icon-intermediate-event-catch-signal:before { content: '\\e81c'; } /* '' */\n.bpmn-icon-intermediate-event-catch-error:before { content: '\\e81d'; } /* '' */\n.bpmn-icon-end-event-compensation:before { content: '\\e81e'; } /* '' */\n.bpmn-icon-subprocess-collapsed:before { content: '\\e81f'; } /* '' */\n.bpmn-icon-subprocess-expanded:before { content: '\\e820'; } /* '' */\n.bpmn-icon-task:before { content: '\\e821'; } /* '' */\n.bpmn-icon-end-event-error:before { content: '\\e822'; } /* '' */\n.bpmn-icon-intermediate-event-catch-escalation:before { content: '\\e823'; } /* '' */\n.bpmn-icon-intermediate-event-catch-timer:before { content: '\\e824'; } /* '' */\n.bpmn-icon-start-event-escalation:before { content: '\\e825'; } /* '' */\n.bpmn-icon-start-event-signal:before { content: '\\e826'; } /* '' */\n.bpmn-icon-business-rule-task:before { content: '\\e827'; } /* '' */\n.bpmn-icon-manual:before { content: '\\e828'; } /* '' */\n.bpmn-icon-receive:before { content: '\\e829'; } /* '' */\n.bpmn-icon-call-activity:before { content: '\\e82a'; } /* '' */\n.bpmn-icon-start-event-timer:before { content: '\\e82b'; } /* '' */\n.bpmn-icon-start-event-message:before { content: '\\e82c'; } /* '' */\n.bpmn-icon-intermediate-event-none:before { content: '\\e82d'; } /* '' */\n.bpmn-icon-intermediate-event-catch-link:before { content: '\\e82e'; } /* '' */\n.bpmn-icon-end-event-escalation:before { content: '\\e82f'; } /* '' */\n.bpmn-icon-bpmn-io:before { content: '\\e831'; } /* '' */\n.bpmn-icon-gateway-complex:before { content: '\\e832'; } /* '' */\n.bpmn-icon-gateway-eventbased:before { content: '\\e833'; } /* '' */\n.bpmn-icon-gateway-none:before { content: '\\e834'; } /* '' */\n.bpmn-icon-gateway-or:before { content: '\\e835'; } /* '' */\n.bpmn-icon-end-event-terminate:before { content: '\\e836'; } /* '' */\n.bpmn-icon-end-event-signal:before { content: '\\e837'; } /* '' */\n.bpmn-icon-end-event-none:before { content: '\\e838'; } /* '' */\n.bpmn-icon-end-event-multiple:before { content: '\\e839'; } /* '' */\n.bpmn-icon-end-event-message:before { content: '\\e83a'; } /* '' */\n.bpmn-icon-end-event-link:before { content: '\\e83b'; } /* '' */\n.bpmn-icon-intermediate-event-catch-message:before { content: '\\e83c'; } /* '' */\n.bpmn-icon-intermediate-event-throw-compensation:before { content: '\\e83d'; } /* '' */\n.bpmn-icon-start-event-multiple:before { content: '\\e83e'; } /* '' */\n.bpmn-icon-script:before { content: '\\e83f'; } /* '' */\n.bpmn-icon-manual-task:before { content: '\\e840'; } /* '' */\n.bpmn-icon-send:before { content: '\\e841'; } /* '' */\n.bpmn-icon-service:before { content: '\\e842'; } /* '' */\n.bpmn-icon-receive-task:before { content: '\\e843'; } /* '' */\n.bpmn-icon-user:before { content: '\\e844'; } /* '' */\n.bpmn-icon-start-event-none:before { content: '\\e845'; } /* '' */\n.bpmn-icon-intermediate-event-throw-escalation:before { content: '\\e846'; } /* '' */\n.bpmn-icon-intermediate-event-catch-multiple:before { content: '\\e847'; } /* '' */\n.bpmn-icon-intermediate-event-catch-non-interrupting-escalation:before { content: '\\e848'; } /* '' */\n.bpmn-icon-intermediate-event-throw-link:before { content: '\\e849'; } /* '' */\n.bpmn-icon-start-event-non-interrupting-condition:before { content: '\\e84a'; } /* '' */\n.bpmn-icon-data-object:before { content: '\\e84b'; } /* '' */\n.bpmn-icon-script-task:before { content: '\\e84c'; } /* '' */\n.bpmn-icon-send-task:before { content: '\\e84d'; } /* '' */\n.bpmn-icon-data-store:before { content: '\\e84e'; } /* '' */\n.bpmn-icon-start-event-non-interrupting-escalation:before { content: '\\e84f'; } /* '' */\n.bpmn-icon-intermediate-event-throw-message:before { content: '\\e850'; } /* '' */\n.bpmn-icon-intermediate-event-catch-non-interrupting-multiple:before { content: '\\e851'; } /* '' */\n.bpmn-icon-intermediate-event-catch-non-interrupting-signal:before { content: '\\e852'; } /* '' */\n.bpmn-icon-intermediate-event-throw-multiple:before { content: '\\e853'; } /* '' */\n.bpmn-icon-start-event-non-interrupting-message:before { content: '\\e854'; } /* '' */\n.bpmn-icon-ad-hoc-marker:before { content: '\\e855'; } /* '' */\n.bpmn-icon-service-task:before { content: '\\e856'; } /* '' */\n.bpmn-icon-task-none:before { content: '\\e857'; } /* '' */\n.bpmn-icon-compensation-marker:before { content: '\\e858'; } /* '' */\n.bpmn-icon-start-event-non-interrupting-multiple:before { content: '\\e859'; } /* '' */\n.bpmn-icon-intermediate-event-throw-signal:before { content: '\\e85a'; } /* '' */\n.bpmn-icon-intermediate-event-catch-non-interrupting-condition:before { content: '\\e85b'; } /* '' */\n.bpmn-icon-participant:before { content: '\\e85c'; } /* '' */\n.bpmn-icon-event-subprocess-expanded:before { content: '\\e85d'; } /* '' */\n.bpmn-icon-lane-insert-below:before { content: '\\e85e'; } /* '' */\n.bpmn-icon-space-tool:before { content: '\\e85f'; } /* '' */\n.bpmn-icon-connection-multi:before { content: '\\e860'; } /* '' */\n.bpmn-icon-lane:before { content: '\\e861'; } /* '' */\n.bpmn-icon-lasso-tool:before { content: '\\e862'; } /* '' */\n.bpmn-icon-lane-insert-above:before { content: '\\e863'; } /* '' */\n.bpmn-icon-lane-divide-three:before { content: '\\e864'; } /* '' */\n.bpmn-icon-lane-divide-two:before { content: '\\e865'; } /* '' */\n.bpmn-icon-data-input:before { content: '\\e866'; } /* '' */\n.bpmn-icon-data-output:before { content: '\\e867'; } /* '' */\n.bpmn-icon-hand-tool:before { content: '\\e868'; } /* '' */\n.bpmn-icon-group:before { content: '\\e869'; } /* '' */\n.bpmn-icon-text-annotation:before { content: '\\e86b'; } /* '' */\n.bpmn-icon-transaction:before { content: '\\e8c4'; } /* '' */\n.bpmn-icon-screw-wrench:before { content: '\\e8db'; } /* '' */\n.bpmn-icon-connection:before { content: '\\e8dc'; } /* '' */\n.bpmn-icon-conditional-flow:before { content: '\\e8e0'; } /* '' */\n.bpmn-icon-default-flow:before { content: '\\e8e1'; } /* '' */\n"],
        sourceRoot: ''
      }])
      const E = h
    },
    2961: (e, t, n) => {
      'use strict'
      n.d(t, {
        A: () => d
      })
      const r = n(2017)
      const o = n.n(r)
      const i = n(3527)
      const a = n.n(i)
      const s = n(9038)
      const c = n.n(s)
      const l = new URL(n(1958), n.b)
      const p = a()(o())
      const u = c()(l)
      p.push([e.id, `.bjs-container {\n  --bjs-font-family: Arial, sans-serif;\n\n  --color-grey-225-10-15: hsl(225, 10%, 15%);\n  --color-grey-225-10-35: hsl(225, 10%, 35%);\n  --color-grey-225-10-55: hsl(225, 10%, 55%);\n  --color-grey-225-10-75: hsl(225, 10%, 75%);\n  --color-grey-225-10-80: hsl(225, 10%, 80%);\n  --color-grey-225-10-85: hsl(225, 10%, 85%);\n  --color-grey-225-10-90: hsl(225, 10%, 90%);\n  --color-grey-225-10-95: hsl(225, 10%, 95%);\n  --color-grey-225-10-97: hsl(225, 10%, 97%);\n\n  --color-blue-205-100-45: hsl(205, 100%, 45%);\n  --color-blue-205-100-45-opacity-30: hsla(205, 100%, 45%, 30%);\n  --color-blue-205-100-50: hsl(205, 100%, 50%);\n  --color-blue-205-100-95: hsl(205, 100%, 95%);\n\n  --color-green-150-86-44: hsl(150, 86%, 44%);\n\n  --color-red-360-100-40: hsl(360, 100%, 40%);\n  --color-red-360-100-45: hsl(360, 100%, 45%);\n  --color-red-360-100-92: hsl(360, 100%, 92%);\n  --color-red-360-100-97: hsl(360, 100%, 97%);\n\n  --color-white: hsl(0, 0%, 100%);\n  --color-black: hsl(0, 0%, 0%);\n  --color-black-opacity-05: hsla(0, 0%, 0%, 5%);\n  --color-black-opacity-10: hsla(0, 0%, 0%, 10%);\n\n  --breadcrumbs-font-family: var(--bjs-font-family);\n  --breadcrumbs-item-color: var(--color-blue-205-100-50);\n  --breadcrumbs-arrow-color: var(--color-black);\n  --drilldown-fill-color: var(--color-white);\n  --drilldown-background-color: var(--color-blue-205-100-50);\n}\n\n.bjs-breadcrumbs {\n  position: absolute;\n  display: none;\n  flex-wrap: wrap;\n  align-items: center;\n  top: 30px;\n  left: 30px;\n  padding: 0px;\n  margin: 0px;\n  font-family: var(--breadcrumbs-font-family);\n  font-size: 16px;\n  line-height: normal;\n}\n\n.bjs-breadcrumbs-shown .bjs-breadcrumbs {\n  display: flex;\n}\n\n.djs-palette-shown .bjs-breadcrumbs {\n  left: 90px;\n}\n\n.djs-palette-shown.djs-palette-two-column .bjs-breadcrumbs {\n  left: 140px;\n}\n\n.bjs-breadcrumbs li {\n  display: inline-flex;\n  padding-bottom: 5px;\n  align-items: center;\n}\n\n.bjs-breadcrumbs li a {\n  cursor: pointer;\n  color: var(--breadcrumbs-item-color);\n}\n\n.bjs-breadcrumbs li:last-of-type a {\n  color: inherit;\n  cursor: default;\n}\n\n.bjs-breadcrumbs li:not(:first-child)::before {\n  content: url(${u});\n  padding: 0 8px;\n  color: var(--breadcrumbs-arrow-color);\n  height: 1em;\n}\n\n.bjs-breadcrumbs .bjs-crumb {\n  display: inline-block;\n  max-width: 200px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n\n.bjs-drilldown {\n  width: 20px;\n  height: 20px;\n\n  padding: 0px;\n  margin-left: -20px;\n\n  cursor: pointer;\n  border: none;\n  border-radius: 2px;\n  outline: none;\n\n  fill: var(--drilldown-fill-color);\n  background-color: var(--drilldown-background-color);\n}\n\n.bjs-drilldown-empty {\n  display: none;\n}\n\n.selected .bjs-drilldown-empty {\n  display: inherit;\n}\n\n[data-popup="align-elements"] .djs-popup-results {\n  display: flex;\n}\n\n[data-popup="align-elements"] .djs-popup-body [data-group] + [data-group] {\n  border-left: 1px solid var(--popup-border-color);\n}\n\n[data-popup="align-elements"] [data-group="align"] {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n}\n\n[data-popup="align-elements"] .djs-popup-body .entry {\n  padding: 6px 8px;\n}\n\n[data-popup="align-elements"] .djs-popup-body .entry:not(:first-child) {\n  margin-top: 0;\n}\n\n[data-popup="align-elements"] .djs-popup-entry-icon {\n  display: block;\n  margin: 0;\n  height: 20px;\n  width: 20px;\n}\n`, '', {
        version: 3,
        sources: ['webpack://./node_modules/bpmn-js/dist/assets/bpmn-js.css'],
        names: [],
        mappings: 'AAAA;EACE,oCAAoC;;EAEpC,0CAA0C;EAC1C,0CAA0C;EAC1C,0CAA0C;EAC1C,0CAA0C;EAC1C,0CAA0C;EAC1C,0CAA0C;EAC1C,0CAA0C;EAC1C,0CAA0C;EAC1C,0CAA0C;;EAE1C,4CAA4C;EAC5C,6DAA6D;EAC7D,4CAA4C;EAC5C,4CAA4C;;EAE5C,2CAA2C;;EAE3C,2CAA2C;EAC3C,2CAA2C;EAC3C,2CAA2C;EAC3C,2CAA2C;;EAE3C,+BAA+B;EAC/B,6BAA6B;EAC7B,6CAA6C;EAC7C,8CAA8C;;EAE9C,iDAAiD;EACjD,sDAAsD;EACtD,6CAA6C;EAC7C,0CAA0C;EAC1C,0DAA0D;AAC5D;;AAEA;EACE,kBAAkB;EAClB,aAAa;EACb,eAAe;EACf,mBAAmB;EACnB,SAAS;EACT,UAAU;EACV,YAAY;EACZ,WAAW;EACX,2CAA2C;EAC3C,eAAe;EACf,mBAAmB;AACrB;;AAEA;EACE,aAAa;AACf;;AAEA;EACE,UAAU;AACZ;;AAEA;EACE,WAAW;AACb;;AAEA;EACE,oBAAoB;EACpB,mBAAmB;EACnB,mBAAmB;AACrB;;AAEA;EACE,eAAe;EACf,oCAAoC;AACtC;;AAEA;EACE,cAAc;EACd,eAAe;AACjB;;AAEA;EACE,gDAAkO;EAClO,cAAc;EACd,qCAAqC;EACrC,WAAW;AACb;;AAEA;EACE,qBAAqB;EACrB,gBAAgB;EAChB,gBAAgB;EAChB,uBAAuB;EACvB,mBAAmB;AACrB;;AAEA;EACE,WAAW;EACX,YAAY;;EAEZ,YAAY;EACZ,kBAAkB;;EAElB,eAAe;EACf,YAAY;EACZ,kBAAkB;EAClB,aAAa;;EAEb,iCAAiC;EACjC,mDAAmD;AACrD;;AAEA;EACE,aAAa;AACf;;AAEA;EACE,gBAAgB;AAClB;;AAEA;EACE,aAAa;AACf;;AAEA;EACE,gDAAgD;AAClD;;AAEA;EACE,aAAa;EACb,qCAAqC;AACvC;;AAEA;EACE,gBAAgB;AAClB;;AAEA;EACE,aAAa;AACf;;AAEA;EACE,cAAc;EACd,SAAS;EACT,YAAY;EACZ,WAAW;AACb',
        sourcesContent: ['.bjs-container {\n  --bjs-font-family: Arial, sans-serif;\n\n  --color-grey-225-10-15: hsl(225, 10%, 15%);\n  --color-grey-225-10-35: hsl(225, 10%, 35%);\n  --color-grey-225-10-55: hsl(225, 10%, 55%);\n  --color-grey-225-10-75: hsl(225, 10%, 75%);\n  --color-grey-225-10-80: hsl(225, 10%, 80%);\n  --color-grey-225-10-85: hsl(225, 10%, 85%);\n  --color-grey-225-10-90: hsl(225, 10%, 90%);\n  --color-grey-225-10-95: hsl(225, 10%, 95%);\n  --color-grey-225-10-97: hsl(225, 10%, 97%);\n\n  --color-blue-205-100-45: hsl(205, 100%, 45%);\n  --color-blue-205-100-45-opacity-30: hsla(205, 100%, 45%, 30%);\n  --color-blue-205-100-50: hsl(205, 100%, 50%);\n  --color-blue-205-100-95: hsl(205, 100%, 95%);\n\n  --color-green-150-86-44: hsl(150, 86%, 44%);\n\n  --color-red-360-100-40: hsl(360, 100%, 40%);\n  --color-red-360-100-45: hsl(360, 100%, 45%);\n  --color-red-360-100-92: hsl(360, 100%, 92%);\n  --color-red-360-100-97: hsl(360, 100%, 97%);\n\n  --color-white: hsl(0, 0%, 100%);\n  --color-black: hsl(0, 0%, 0%);\n  --color-black-opacity-05: hsla(0, 0%, 0%, 5%);\n  --color-black-opacity-10: hsla(0, 0%, 0%, 10%);\n\n  --breadcrumbs-font-family: var(--bjs-font-family);\n  --breadcrumbs-item-color: var(--color-blue-205-100-50);\n  --breadcrumbs-arrow-color: var(--color-black);\n  --drilldown-fill-color: var(--color-white);\n  --drilldown-background-color: var(--color-blue-205-100-50);\n}\n\n.bjs-breadcrumbs {\n  position: absolute;\n  display: none;\n  flex-wrap: wrap;\n  align-items: center;\n  top: 30px;\n  left: 30px;\n  padding: 0px;\n  margin: 0px;\n  font-family: var(--breadcrumbs-font-family);\n  font-size: 16px;\n  line-height: normal;\n}\n\n.bjs-breadcrumbs-shown .bjs-breadcrumbs {\n  display: flex;\n}\n\n.djs-palette-shown .bjs-breadcrumbs {\n  left: 90px;\n}\n\n.djs-palette-shown.djs-palette-two-column .bjs-breadcrumbs {\n  left: 140px;\n}\n\n.bjs-breadcrumbs li {\n  display: inline-flex;\n  padding-bottom: 5px;\n  align-items: center;\n}\n\n.bjs-breadcrumbs li a {\n  cursor: pointer;\n  color: var(--breadcrumbs-item-color);\n}\n\n.bjs-breadcrumbs li:last-of-type a {\n  color: inherit;\n  cursor: default;\n}\n\n.bjs-breadcrumbs li:not(:first-child)::before {\n  content: url(\'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="17" height="17" viewBox="0 0 24 24"><path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z" /><path d="M0 0h24v24H0z" fill="none" /></svg>\');\n  padding: 0 8px;\n  color: var(--breadcrumbs-arrow-color);\n  height: 1em;\n}\n\n.bjs-breadcrumbs .bjs-crumb {\n  display: inline-block;\n  max-width: 200px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n\n.bjs-drilldown {\n  width: 20px;\n  height: 20px;\n\n  padding: 0px;\n  margin-left: -20px;\n\n  cursor: pointer;\n  border: none;\n  border-radius: 2px;\n  outline: none;\n\n  fill: var(--drilldown-fill-color);\n  background-color: var(--drilldown-background-color);\n}\n\n.bjs-drilldown-empty {\n  display: none;\n}\n\n.selected .bjs-drilldown-empty {\n  display: inherit;\n}\n\n[data-popup="align-elements"] .djs-popup-results {\n  display: flex;\n}\n\n[data-popup="align-elements"] .djs-popup-body [data-group] + [data-group] {\n  border-left: 1px solid var(--popup-border-color);\n}\n\n[data-popup="align-elements"] [data-group="align"] {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n}\n\n[data-popup="align-elements"] .djs-popup-body .entry {\n  padding: 6px 8px;\n}\n\n[data-popup="align-elements"] .djs-popup-body .entry:not(:first-child) {\n  margin-top: 0;\n}\n\n[data-popup="align-elements"] .djs-popup-entry-icon {\n  display: block;\n  margin: 0;\n  height: 20px;\n  width: 20px;\n}\n'],
        sourceRoot: ''
      }])
      const d = p
    },
    7491: (e, t, n) => {
      'use strict'
      n.d(t, {
        A: () => s
      })
      const r = n(2017)
      const o = n.n(r)
      const i = n(3527)
      const a = n.n(i)()(o())
      a.push([e.id, '/**\n * color definitions\n */\n.djs-parent {\n  --color-grey-225-10-15: hsl(225, 10%, 15%);\n  --color-grey-225-10-35: hsl(225, 10%, 35%);\n  --color-grey-225-10-55: hsl(225, 10%, 55%);\n  --color-grey-225-10-75: hsl(225, 10%, 75%);\n  --color-grey-225-10-80: hsl(225, 10%, 80%);\n  --color-grey-225-10-85: hsl(225, 10%, 85%);\n  --color-grey-225-10-90: hsl(225, 10%, 90%);\n  --color-grey-225-10-95: hsl(225, 10%, 95%);\n  --color-grey-225-10-97: hsl(225, 10%, 97%);\n\n  --color-blue-205-100-45: hsl(205, 100%, 45%);\n  --color-blue-205-100-45-opacity-30: hsla(205, 100%, 45%, 30%);\n  --color-blue-205-100-50: hsl(205, 100%, 50%);\n  --color-blue-205-100-50-opacity-15: hsla(205, 100%, 50%, 15%);\n  --color-blue-205-100-70: hsl(205, 100%, 75%);\n  --color-blue-205-100-95: hsl(205, 100%, 95%);\n\n  --color-green-150-86-44: hsl(150, 86%, 44%);\n\n  --color-red-360-100-40: hsl(360, 100%, 40%);\n  --color-red-360-100-45: hsl(360, 100%, 45%);\n  --color-red-360-100-92: hsl(360, 100%, 92%);\n  --color-red-360-100-97: hsl(360, 100%, 97%);\n\n  --color-white: hsl(0, 0%, 100%);\n  --color-black: hsl(0, 0%, 0%);\n  --color-black-opacity-10: hsla(0, 0%, 0%, 10%);\n  --color-black-opacity-30: hsla(0, 0%, 0%, 30%);\n\n  --canvas-fill-color: var(--color-white);\n\n  --bendpoint-fill-color: var(--color-blue-205-100-45);\n  --bendpoint-stroke-color: var(--canvas-fill-color);\n\n  --context-pad-entry-background-color: var(--color-white);\n  --context-pad-entry-hover-background-color: var(--color-grey-225-10-95);\n\n  --element-dragger-color: var(--color-blue-205-100-50);\n  --element-hover-outline-fill-color: var(--color-blue-205-100-45);\n  --element-selected-outline-stroke-color: var(--color-blue-205-100-50);\n  --element-selected-outline-secondary-stroke-color: var(--color-blue-205-100-70);\n\n  --lasso-fill-color: var(--color-blue-205-100-50-opacity-15);\n  --lasso-stroke-color: var(--element-selected-outline-stroke-color);\n\n  --palette-entry-color: var(--color-grey-225-10-15);\n  --palette-entry-hover-color: var(--color-blue-205-100-45);\n  --palette-entry-selected-color: var(--color-blue-205-100-50);\n  --palette-separator-color: var(--color-grey-225-10-75);\n  --palette-toggle-hover-background-color: var(--color-grey-225-10-55);\n  --palette-background-color: var(--color-grey-225-10-97);\n  --palette-border-color: var(--color-grey-225-10-75);\n\n  --popup-font-family: "IBM Plex Sans", sans-serif;\n  --popup-font-size: 14px;\n  --popup-header-entry-selected-color: var(--color-blue-205-100-50);\n  --popup-header-font-weight: bolder;\n  --popup-background-color: var(--color-white);\n  --popup-border-color: transparent;\n  --popup-shadow-color: var(--color-black-opacity-30);\n  --popup-description-color: var(--color-grey-225-10-55);\n  --popup-no-results-color: var(--color-grey-225-10-55);\n  --popup-entry-title-color: var(--color-grey-225-10-55);\n  --popup-entry-hover-color:  var(--color-grey-225-10-95);\n  --popup-search-border-color: var(--color-grey-225-10-75);\n  --popup-search-focus-border-color: var(--color-blue-205-100-50);\n  --popup-search-focus-background-color: var(--color-blue-205-100-95);\n\n  --resizer-fill-color: var(--color-blue-205-100-45);\n  --resizer-stroke-color: var(--canvas-fill-color);\n\n  --search-container-background-color: var(--color-grey-225-10-97);\n  --search-container-border-color: var(--color-blue-205-100-50);\n  --search-container-box-shadow-color: var(--color-blue-205-100-95);\n  --search-container-box-shadow-inset-color: var(--color-grey-225-10-80);\n  --search-input-border-color: var(--color-grey-225-10-75);\n  --search-result-border-color: var(--color-grey-225-10-75);\n  --search-result-highlight-color: var(--color-black);\n  --search-result-selected-color: var(--color-blue-205-100-45-opacity-30);\n\n  --shape-attach-allowed-stroke-color: var(--color-blue-205-100-50);\n  --shape-connect-allowed-fill-color: var(--color-grey-225-10-97);\n  --shape-drop-allowed-fill-color: var(--color-grey-225-10-97);\n  --shape-drop-not-allowed-fill-color: var(--color-red-360-100-97);\n  --shape-resize-preview-stroke-color: var(--color-blue-205-100-50);\n\n  --snap-line-stroke-color: var(--color-blue-205-100-45-opacity-30);\n\n  --space-tool-crosshair-stroke-color: var(--color-black);\n\n  --tooltip-error-background-color: var(--color-red-360-100-97);\n  --tooltip-error-border-color: var(--color-red-360-100-45);\n  --tooltip-error-color: var(--color-red-360-100-45);\n}\n\n/**\n * outline styles\n */\n\n.djs-outline,\n.djs-selection-outline {\n  fill: none;\n  shape-rendering: geometricPrecision;\n  stroke-width: 2px;\n}\n\n.djs-outline {\n  visibility: hidden;\n}\n\n.djs-selection-outline {\n  stroke: var(--element-selected-outline-stroke-color);\n}\n\n.djs-element.selected .djs-outline {\n  visibility: visible;\n\n  stroke: var(--element-selected-outline-stroke-color);\n}\n\n.djs-connection.selected .djs-outline {\n  display: none;\n}\n\n.djs-multi-select .djs-element.selected .djs-outline {\n  stroke: var(--element-selected-outline-secondary-stroke-color);\n  display: block;\n}\n\n.djs-shape.connect-ok .djs-visual > :nth-child(1) {\n  fill: var(--shape-connect-allowed-fill-color) !important;\n}\n\n.djs-shape.connect-not-ok .djs-visual > :nth-child(1),\n.djs-shape.drop-not-ok .djs-visual > :nth-child(1) {\n  fill: var(--shape-drop-not-allowed-fill-color) !important;\n}\n\n.djs-shape.new-parent .djs-visual > :nth-child(1) {\n  fill: var(--shape-drop-allowed-fill-color) !important;\n}\n\nsvg.drop-not-ok {\n  background: var(--shape-drop-not-allowed-fill-color) !important;\n}\n\nsvg.new-parent {\n  background: var(--shape-drop-allowed-fill-color) !important;\n}\n\n\n/* Override move cursor during drop and connect */\n.drop-not-ok,\n.connect-not-ok,\n.drop-not-ok *,\n.connect-not-ok * {\n  cursor: not-allowed !important;\n}\n\n.drop-ok,\n.connect-ok,\n.drop-ok *,\n.connect-ok * {\n  cursor: default !important;\n}\n\n.djs-element.attach-ok .djs-visual > :nth-child(1) {\n  stroke-width: 5px !important;\n  stroke: var(--shape-attach-allowed-stroke-color) !important;\n}\n\n.djs-frame.connect-not-ok .djs-visual > :nth-child(1),\n.djs-frame.drop-not-ok .djs-visual > :nth-child(1) {\n  stroke-width: 3px !important;\n  stroke: var(--shape-drop-not-allowed-fill-color) !important;\n  fill: none !important;\n}\n\n/**\n* Selection box style\n*\n*/\n.djs-lasso-overlay {\n  fill: var(--lasso-fill-color);\n  stroke: var(--lasso-stroke-color);\n  stroke-width: 2px;\n  shape-rendering: geometricPrecision;\n  pointer-events: none;\n}\n\n/**\n * Resize styles\n */\n.djs-resize-overlay {\n  fill: none;\n\n  stroke-dasharray: 5 1 3 1;\n  stroke: var(--shape-resize-preview-stroke-color);\n\n  pointer-events: none;\n}\n\n.djs-resizer-hit {\n  fill: none;\n  pointer-events: all;\n}\n\n.djs-resizer-visual {\n  fill: var(--resizer-fill-color);\n  stroke-width: 1px;\n  stroke: var(--resizer-stroke-color);\n  shape-rendering: geometricPrecision;\n}\n\n.djs-resizer:hover .djs-resizer-visual {\n  stroke: var(--resizer-stroke-color);\n  stroke-opacity: 1;\n}\n\n.djs-cursor-resize-ns,\n.djs-resizer-n,\n.djs-resizer-s {\n  cursor: ns-resize;\n}\n\n.djs-cursor-resize-ew,\n.djs-resizer-e,\n.djs-resizer-w {\n  cursor: ew-resize;\n}\n\n.djs-cursor-resize-nwse,\n.djs-resizer-nw,\n.djs-resizer-se {\n  cursor: nwse-resize;\n}\n\n.djs-cursor-resize-nesw,\n.djs-resizer-ne,\n.djs-resizer-sw {\n  cursor: nesw-resize;\n}\n\n.djs-shape.djs-resizing > .djs-outline {\n  visibility: hidden !important;\n}\n\n.djs-shape.djs-resizing > .djs-resizer {\n  visibility: hidden;\n}\n\n.djs-dragger > .djs-resizer {\n  visibility: hidden;\n}\n\n/**\n * drag styles\n */\n.djs-dragger * {\n  fill: none !important;\n  stroke: var(--element-dragger-color) !important;\n}\n\n.djs-dragger tspan,\n.djs-dragger text {\n  fill: var(--element-dragger-color) !important;\n  stroke: none !important;\n}\n\nmarker.djs-dragger circle,\nmarker.djs-dragger path,\nmarker.djs-dragger polygon,\nmarker.djs-dragger polyline,\nmarker.djs-dragger rect {\n  fill: var(--element-dragger-color) !important;\n  stroke: none !important;\n}\n\nmarker.djs-dragger text,\nmarker.djs-dragger tspan {\n  fill: none !important;\n  stroke: var(--element-dragger-color) !important;\n}\n\n.djs-dragging,\n.djs-dragging > * {\n  opacity: 0.3 !important;\n  pointer-events: none !important;\n}\n\n/**\n * no pointer events for visual\n */\n.djs-visual,\n.djs-outline {\n  pointer-events: none;\n}\n\n.djs-element.attach-ok .djs-hit {\n  stroke-width: 60px !important;\n}\n\n/**\n * all pointer events for hit shape\n */\n.djs-element > .djs-hit-all,\n.djs-element > .djs-hit-no-move {\n  pointer-events: all;\n}\n\n.djs-element > .djs-hit-stroke,\n.djs-element > .djs-hit-click-stroke {\n  pointer-events: stroke;\n}\n\n/**\n * shape / connection basic styles\n */\n.djs-connection .djs-visual {\n  stroke-width: 2px;\n  fill: none;\n}\n\n.djs-cursor-grab {\n  cursor: -webkit-grab;\n  cursor: -moz-grab;\n  cursor: grab;\n}\n\n.djs-cursor-grabbing {\n  cursor: -webkit-grabbing;\n  cursor: -moz-grabbing;\n  cursor: grabbing;\n}\n\n.djs-cursor-crosshair {\n  cursor: crosshair;\n}\n\n.djs-cursor-move {\n  cursor: move;\n}\n\n.djs-cursor-resize-ns {\n  cursor: ns-resize;\n}\n\n.djs-cursor-resize-ew {\n  cursor: ew-resize;\n}\n\n\n/**\n * snapping\n */\n.djs-snap-line {\n  stroke: var(--snap-line-stroke-color);\n  stroke-linecap: round;\n  stroke-width: 2px;\n  pointer-events: none;\n}\n\n/**\n * snapping\n */\n.djs-crosshair {\n  stroke: var(--space-tool-crosshair-stroke-color);\n  stroke-linecap: round;\n  stroke-width: 1px;\n  pointer-events: none;\n  shape-rendering: geometricPrecision;\n  stroke-dasharray: 5, 5;\n}\n\n/**\n * palette\n */\n\n.djs-palette {\n  position: absolute;\n  left: 20px;\n  top: 20px;\n\n  box-sizing: border-box;\n  width: 48px;\n}\n\n.djs-palette .separator {\n  margin: 5px;\n  padding-top: 5px;\n\n  border: none;\n  border-bottom: solid 1px var(--palette-separator-color);\n\n  clear: both;\n}\n\n.djs-palette .entry:before {\n  vertical-align: initial;\n}\n\n.djs-palette .djs-palette-toggle {\n  cursor: pointer;\n}\n\n.djs-palette .entry,\n.djs-palette .djs-palette-toggle {\n  color: var(--palette-entry-color);\n  font-size: 30px;\n\n  text-align: center;\n}\n\n.djs-palette .entry {\n  float: left;\n}\n\n.djs-palette .entry img {\n  max-width: 100%;\n}\n\n.djs-palette .djs-palette-entries:after {\n  content: \'\';\n  display: table;\n  clear: both;\n}\n\n.djs-palette .djs-palette-toggle:hover {\n  background: var(--palette-toggle-hover-background-color);\n}\n\n.djs-palette .entry:hover {\n  color: var(--palette-entry-hover-color);\n}\n\n.djs-palette .highlighted-entry {\n  color: var(--palette-entry-selected-color) !important;\n}\n\n.djs-palette .entry,\n.djs-palette .djs-palette-toggle {\n  width: 46px;\n  height: 46px;\n  line-height: 46px;\n  cursor: default;\n}\n\n/**\n * Palette open / two-column layout is controlled via\n * classes on the palette. Events to hook into palette\n * changed life-cycle are available in addition.\n */\n.djs-palette.two-column.open {\n  width: 94px;\n}\n\n.djs-palette:not(.open) .djs-palette-entries {\n  display: none;\n}\n\n.djs-palette:not(.open) {\n  overflow: hidden;\n}\n\n.djs-palette.open .djs-palette-toggle {\n  display: none;\n}\n\n/**\n * context-pad\n */\n.djs-overlay-context-pad {\n  width: 72px;\n  z-index: 100;\n}\n\n.djs-context-pad {\n  position: absolute;\n  display: none;\n  pointer-events: none;\n  line-height: 1;\n}\n\n.djs-context-pad .entry {\n  width: 22px;\n  height: 22px;\n  text-align: center;\n  display: inline-block;\n  font-size: 22px;\n  margin: 0 2px 2px 0;\n\n  border-radius: 3px;\n\n  cursor: default;\n\n  background-color: var(--context-pad-entry-background-color);\n  box-shadow: 0 0 2px 1px var(--context-pad-entry-background-color);\n  pointer-events: all;\n  vertical-align: middle;\n}\n\n.djs-context-pad .entry:hover {\n  background: var(--context-pad-entry-hover-background-color);\n}\n\n.djs-context-pad.open {\n  display: block;\n}\n\n/**\n * popup styles\n */\n.djs-popup {\n  line-height: 1;\n  box-sizing: border-box;\n  width: min-content;\n  background: var(--popup-background-color);\n  overflow: hidden;\n  position: fixed;\n  z-index: 200;\n  box-shadow: 0px 2px 6px var(--popup-shadow-color);\n  border: solid 1px var(--popup-border-color);\n  min-width: 120px;\n  outline: none;\n  font-size: var(--popup-font-size);\n  font-family: var(--popup-font-family);\n}\n\n.djs-popup-search input {\n  width: 100%;\n  box-sizing: border-box;\n  font-size: var(--popup-font-size);\n  padding: 3px 6px;\n  border-radius: 2px;\n  border: solid 1px var(--popup-search-border-color);\n  line-height: 21px;\n}\n\n.djs-popup-search input:focus {\n  background-color: var(--popup-search-focus-background-color);\n  border: solid 1px var(--popup-search-focus-border-color);\n  outline: none;\n}\n\n.djs-popup-header {\n  display: flex;\n  align-items: stretch;\n  line-height: 20px;\n  margin: 10px 12px 10px 12px;\n}\n\n.djs-popup-header .entry {\n  border-radius: 2px;\n}\n\n.djs-popup button.entry {\n  padding: 0;\n  background: transparent;\n  border: 0;\n}\n\n.djs-popup-header .entry.active {\n  color: var(--popup-header-entry-selected-color);\n}\n\n.djs-popup-header .entry.disabled {\n  color: inherit;\n}\n\n.djs-popup-search {\n  margin: 10px 12px;\n}\n\n.djs-popup-title {\n  font-size: var(--popup-font-size);\n  font-weight: var(--popup-header-font-weight);\n  flex: 1;\n  margin: 0;\n}\n\n.djs-popup-search {\n  position: relative;\n  width: auto;\n}\n\n.djs-popup-search-icon {\n  position: absolute;\n  left: 8px;\n  top: 7px;\n}\n\n.djs-popup-search input {\n  padding-left: 25px;\n}\n\n.djs-popup-results {\n  margin: 7px 3px 7px 12px;\n  list-style: none;\n  max-height: 280px;\n  overflow: auto;\n  padding-right: 9px;\n}\n\n.djs-popup-group {\n  margin: 0;\n  padding: 0;\n  width: 100%;\n}\n\n.djs-popup-body .entry,\n.djs-popup-body .entry-header {\n  padding: 5px 7px;\n  cursor: default;\n  border-radius: 4px;\n}\n\n.djs-popup-body .entry-header {\n  font-weight: var(--popup-header-font-weight);\n  color: var(--popup-entry-title-color);\n  padding-left: 0;\n}\n\n.djs-popup [class*="icon"] .djs-popup-label,\n.djs-popup-label:not(:first-child) {\n  margin-left: .5em;\n}\n\n.djs-popup [class*="icon"]:before,\n.djs-popup-entry-icon {\n  width: 1em;\n  height: 1em;\n  display: inline-block;\n  font-size: 1.4em;\n  vertical-align: middle;\n}\n\n.djs-popup-body .entry-header:not(:first-child) {\n  margin-top: 8px;\n  margin-bottom: 2px;\n}\n\n.djs-popup-body .entry {\n  display: flex;\n  flex-direction: row;\n  align-items: stretch;\n  height: min-content;\n}\n\n.djs-popup .entry.selected {\n  background-color: var(--popup-entry-hover-color);\n}\n\n.djs-popup-body .entry:not(:first-child) {\n  margin-top: 2px;\n}\n\n.djs-popup-entry-content {\n  display: flex;\n  flex-direction: column;\n  flex: 1;\n  overflow: hidden;\n}\n\n.djs-popup-entry-description {\n  color: var(--popup-description-color);\n}\n\n.djs-popup-label,\n.djs-popup-entry-description {\n  line-height: 1.4em;\n}\n\n.djs-popup .entry,\n.djs-popup .entry-header {\n  margin: 1px;\n}\n\n.djs-popup-title,\n.djs-popup-label,\n.djs-popup-entry-description,\n.djs-popup .entry-header {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n\n.djs-popup-entry-name {\n  display: flex;\n}\n\n.djs-popup-body {\n  flex-direction: column;\n  width: auto;\n}\n\n.djs-popup *::-webkit-scrollbar {\n  width: 6px;\n}\n\n.djs-popup *::-webkit-scrollbar-thumb {\n  border-radius: 3px;\n  background-color: rgba(0, 0, 0, 0.2);\n}\n\n.djs-popup *::-webkit-scrollbar-track {\n  box-shadow: none;\n  background: transparent;\n  margin: 0;\n  padding: 5px;\n}\n\n.djs-popup-no-results {\n  padding: 0 12px 12px 12px;\n  color: var(--popup-no-results-color);\n}\n\n.djs-popup-entry-docs {\n  flex: 0;\n  flex-direction: row;\n  align-items: center;\n  padding-left: 5px;\n  display: none;\n}\n\n.djs-popup-body .entry:hover .djs-popup-entry-docs {\n  display: flex;\n}\n\n.djs-popup-entry-docs svg {\n  vertical-align: middle;\n  margin: auto 2px auto 5px;\n}\n\n/**\n *  palette styles\n */\n.djs-palette {\n  background: var(--palette-background-color);\n  border: solid 1px var(--palette-border-color);\n  border-radius: 2px;\n}\n\n/**\n * bendpoints\n */\n.djs-segment-dragger,\n.djs-bendpoint {\n  display: none;\n}\n\n.djs-segment-dragger .djs-visual {\n  display: none;\n\n  fill: var(--bendpoint-fill-color);\n  stroke: var(--bendpoint-stroke-color);\n  stroke-width: 1px;\n  stroke-opacity: 1;\n}\n\n.djs-segment-dragger:hover .djs-visual {\n  display: block;\n}\n\n.djs-bendpoint .djs-visual {\n  fill: var(--bendpoint-fill-color);\n  stroke: var(--bendpoint-stroke-color);\n  stroke-width: 1px;\n}\n\n.djs-segment-dragger:hover,\n.djs-bendpoints.hover .djs-segment-dragger,\n.djs-bendpoints.selected .djs-segment-dragger,\n.djs-bendpoint:hover,\n.djs-bendpoints.hover .djs-bendpoint,\n.djs-bendpoints.selected .djs-bendpoidisplay: block;nt {\n  \n}\n\n.djs-drag-active .djs-bendpoints * {\n  display: none;\n}\n\n.djs-bendpoints:not(.hover) .floating {\n  display: none;\n}\n\n.djs-segment-dragger:hover .djs-visual,\n.djs-segment-dragger.djs-dragging .djs-visual,\n.djs-bendpoint:hover .djs-visual,\n.djs-bendpoint.floating .djs-visual {\n  fill: var(--bendpoint-fill-color);\n  stroke: var(--bendpoint-stroke-color);\n  stroke-opacity: 1;\n}\n\n.djs-bendpoint.floating .djs-hit {\n  pointer-events: none;\n}\n\n.djs-segment-dragger .djs-hit,\n.djs-bendpoint .djs-hit {\n  fill: none;\n  pointer-events: all;\n}\n\n.djs-segment-dragger.horizontal .djs-hit {\n  cursor: ns-resize;\n}\n\n.djs-segment-dragger.vertical .djs-hit {\n  cursor: ew-resize;\n}\n\n.djs-segment-dragger.djs-dragging .djs-hit {\n  pointer-events: none;\n}\n\n.djs-updating,\n.djs-updating > * {\n  pointer-events: none !important;\n}\n\n.djs-updating .djs-context-pad,\n.djs-updating .djs-outline,\n.djs-updating .djs-bendpoint,\n.djs-multi-select .djs-bendpoint,\n.djs-multi-select .djs-segment-dragger,\n.connect-ok .djs-bendpoint,\n.connect-not-ok .djs-bendpoint,\n.drop-ok .djs-bendpoint,\n.drop-not-ok .djs-bendpoint {\n  display: none !important;\n}\n\n.djs-segment-dragger.djs-dragging,\n.djs-bendpoint.djs-dragging {\n  display: block;\n  opacity: 1.0;\n}\n\n\n/**\n * tooltips\n */\n.djs-tooltip-error {\n  width: 160px;\n  padding: 6px;\n\n  background: var(--tooltip-error-background-color);\n  border: solid 1px var(--tooltip-error-border-color);\n  border-radius: 2px;\n  color: var(--tooltip-error-color);\n  font-size: 12px;\n  line-height: 16px;\n\n  opacity: 0.75;\n}\n\n.djs-tooltip-error:hover {\n  opacity: 1;\n}\n\n\n/**\n * search pad\n */\n.djs-search-container {\n  position: absolute;\n  top: 20px;\n  left: 0;\n  right: 0;\n  margin-left: auto;\n  margin-right: auto;\n\n  width: 25%;\n  min-width: 300px;\n  max-width: 400px;\n  z-index: 10;\n\n  font-size: 1.05em;\n  opacity: 0.9;\n  background: var(--search-container-background-color);\n  border: solid 1px var(--search-container-border-color);\n  border-radius: 2px;\n  box-shadow: 0 0 0 2px var(--search-container-box-shadow-color), 0 0 0 1px var(--search-container-box-shadow-inset-color) inset;\n}\n\n.djs-search-container:not(.open) {\n  display: none;\n}\n\n.djs-search-input input {\n  font-size: 1.05em;\n  width: 100%;\n  padding: 6px 10px;\n  border: 1px solid var(--search-input-border-color);\n  box-sizing: border-box;\n}\n\n.djs-search-input input:focus {\n  outline: none;\n  border-color: var(--search-input-border-color);\n}\n\n.djs-search-results {\n  position: relative;\n  overflow-y: auto;\n  max-height: 200px;\n}\n\n.djs-search-results:hover {\n  cursor: pointer;\n}\n\n.djs-search-result {\n  width: 100%;\n  padding: 6px 10px;\n  background: white;\n  border-bottom: solid 1px var(--search-result-border-color);\n  border-radius: 1px;\n}\n\n.djs-search-highlight {\n  color: var(--search-result-highlight-color);\n}\n\n.djs-search-result-primary {\n  margin: 0 0 10px;\n}\n\n.djs-search-result-secondary {\n  font-family: monospace;\n  margin: 0;\n}\n\n.djs-search-result:hover {\n  background: var(--search-result-selected-color);\n}\n\n.djs-search-result-selected {\n  background: var(--search-result-selected-color);\n}\n\n.djs-search-result-selected:hover {\n  background: var(--search-result-selected-color);\n}\n\n.djs-search-overlay {\n  background: var(--search-result-selected-color);\n}\n\n/**\n * hidden styles\n */\n.djs-element-hidden,\n.djs-element-hidden .djs-hit,\n.djs-element-hidden .djs-outline,\n.djs-label-hidden .djs-label {\n  display: none !important;\n}\n\n.djs-element .djs-hit-stroke,\n.djs-element .djs-hit-click-stroke,\n.djs-element .djs-hit-all {\n  cursor: move;\n}', '', {
        version: 3,
        sources: ['webpack://./node_modules/bpmn-js/dist/assets/diagram-js.css'],
        names: [],
        mappings: 'AAAA;;EAEE;AACF;EACE,0CAA0C;EAC1C,0CAA0C;EAC1C,0CAA0C;EAC1C,0CAA0C;EAC1C,0CAA0C;EAC1C,0CAA0C;EAC1C,0CAA0C;EAC1C,0CAA0C;EAC1C,0CAA0C;;EAE1C,4CAA4C;EAC5C,6DAA6D;EAC7D,4CAA4C;EAC5C,6DAA6D;EAC7D,4CAA4C;EAC5C,4CAA4C;;EAE5C,2CAA2C;;EAE3C,2CAA2C;EAC3C,2CAA2C;EAC3C,2CAA2C;EAC3C,2CAA2C;;EAE3C,+BAA+B;EAC/B,6BAA6B;EAC7B,8CAA8C;EAC9C,8CAA8C;;EAE9C,uCAAuC;;EAEvC,oDAAoD;EACpD,kDAAkD;;EAElD,wDAAwD;EACxD,uEAAuE;;EAEvE,qDAAqD;EACrD,gEAAgE;EAChE,qEAAqE;EACrE,+EAA+E;;EAE/E,2DAA2D;EAC3D,kEAAkE;;EAElE,kDAAkD;EAClD,yDAAyD;EACzD,4DAA4D;EAC5D,sDAAsD;EACtD,oEAAoE;EACpE,uDAAuD;EACvD,mDAAmD;;EAEnD,gDAAgD;EAChD,uBAAuB;EACvB,iEAAiE;EACjE,kCAAkC;EAClC,4CAA4C;EAC5C,iCAAiC;EACjC,mDAAmD;EACnD,sDAAsD;EACtD,qDAAqD;EACrD,sDAAsD;EACtD,uDAAuD;EACvD,wDAAwD;EACxD,+DAA+D;EAC/D,mEAAmE;;EAEnE,kDAAkD;EAClD,gDAAgD;;EAEhD,gEAAgE;EAChE,6DAA6D;EAC7D,iEAAiE;EACjE,sEAAsE;EACtE,wDAAwD;EACxD,yDAAyD;EACzD,mDAAmD;EACnD,uEAAuE;;EAEvE,iEAAiE;EACjE,+DAA+D;EAC/D,4DAA4D;EAC5D,gEAAgE;EAChE,iEAAiE;;EAEjE,iEAAiE;;EAEjE,uDAAuD;;EAEvD,6DAA6D;EAC7D,yDAAyD;EACzD,kDAAkD;AACpD;;AAEA;;EAEE;;AAEF;;EAEE,UAAU;EACV,mCAAmC;EACnC,iBAAiB;AACnB;;AAEA;EACE,kBAAkB;AACpB;;AAEA;EACE,oDAAoD;AACtD;;AAEA;EACE,mBAAmB;;EAEnB,oDAAoD;AACtD;;AAEA;EACE,aAAa;AACf;;AAEA;EACE,8DAA8D;EAC9D,cAAc;AAChB;;AAEA;EACE,wDAAwD;AAC1D;;AAEA;;EAEE,yDAAyD;AAC3D;;AAEA;EACE,qDAAqD;AACvD;;AAEA;EACE,+DAA+D;AACjE;;AAEA;EACE,2DAA2D;AAC7D;;;AAGA,iDAAiD;AACjD;;;;EAIE,8BAA8B;AAChC;;AAEA;;;;EAIE,0BAA0B;AAC5B;;AAEA;EACE,4BAA4B;EAC5B,2DAA2D;AAC7D;;AAEA;;EAEE,4BAA4B;EAC5B,2DAA2D;EAC3D,qBAAqB;AACvB;;AAEA;;;CAGC;AACD;EACE,6BAA6B;EAC7B,iCAAiC;EACjC,iBAAiB;EACjB,mCAAmC;EACnC,oBAAoB;AACtB;;AAEA;;EAEE;AACF;EACE,UAAU;;EAEV,yBAAyB;EACzB,gDAAgD;;EAEhD,oBAAoB;AACtB;;AAEA;EACE,UAAU;EACV,mBAAmB;AACrB;;AAEA;EACE,+BAA+B;EAC/B,iBAAiB;EACjB,mCAAmC;EACnC,mCAAmC;AACrC;;AAEA;EACE,mCAAmC;EACnC,iBAAiB;AACnB;;AAEA;;;EAGE,iBAAiB;AACnB;;AAEA;;;EAGE,iBAAiB;AACnB;;AAEA;;;EAGE,mBAAmB;AACrB;;AAEA;;;EAGE,mBAAmB;AACrB;;AAEA;EACE,6BAA6B;AAC/B;;AAEA;EACE,kBAAkB;AACpB;;AAEA;EACE,kBAAkB;AACpB;;AAEA;;EAEE;AACF;EACE,qBAAqB;EACrB,+CAA+C;AACjD;;AAEA;;EAEE,6CAA6C;EAC7C,uBAAuB;AACzB;;AAEA;;;;;EAKE,6CAA6C;EAC7C,uBAAuB;AACzB;;AAEA;;EAEE,qBAAqB;EACrB,+CAA+C;AACjD;;AAEA;;EAEE,uBAAuB;EACvB,+BAA+B;AACjC;;AAEA;;EAEE;AACF;;EAEE,oBAAoB;AACtB;;AAEA;EACE,6BAA6B;AAC/B;;AAEA;;EAEE;AACF;;EAEE,mBAAmB;AACrB;;AAEA;;EAEE,sBAAsB;AACxB;;AAEA;;EAEE;AACF;EACE,iBAAiB;EACjB,UAAU;AACZ;;AAEA;EACE,oBAAoB;EACpB,iBAAiB;EACjB,YAAY;AACd;;AAEA;EACE,wBAAwB;EACxB,qBAAqB;EACrB,gBAAgB;AAClB;;AAEA;EACE,iBAAiB;AACnB;;AAEA;EACE,YAAY;AACd;;AAEA;EACE,iBAAiB;AACnB;;AAEA;EACE,iBAAiB;AACnB;;;AAGA;;EAEE;AACF;EACE,qCAAqC;EACrC,qBAAqB;EACrB,iBAAiB;EACjB,oBAAoB;AACtB;;AAEA;;EAEE;AACF;EACE,gDAAgD;EAChD,qBAAqB;EACrB,iBAAiB;EACjB,oBAAoB;EACpB,mCAAmC;EACnC,sBAAsB;AACxB;;AAEA;;EAEE;;AAEF;EACE,kBAAkB;EAClB,UAAU;EACV,SAAS;;EAET,sBAAsB;EACtB,WAAW;AACb;;AAEA;EACE,WAAW;EACX,gBAAgB;;EAEhB,YAAY;EACZ,uDAAuD;;EAEvD,WAAW;AACb;;AAEA;EACE,uBAAuB;AACzB;;AAEA;EACE,eAAe;AACjB;;AAEA;;EAEE,iCAAiC;EACjC,eAAe;;EAEf,kBAAkB;AACpB;;AAEA;EACE,WAAW;AACb;;AAEA;EACE,eAAe;AACjB;;AAEA;EACE,WAAW;EACX,cAAc;EACd,WAAW;AACb;;AAEA;EACE,wDAAwD;AAC1D;;AAEA;EACE,uCAAuC;AACzC;;AAEA;EACE,qDAAqD;AACvD;;AAEA;;EAEE,WAAW;EACX,YAAY;EACZ,iBAAiB;EACjB,eAAe;AACjB;;AAEA;;;;EAIE;AACF;EACE,WAAW;AACb;;AAEA;EACE,aAAa;AACf;;AAEA;EACE,gBAAgB;AAClB;;AAEA;EACE,aAAa;AACf;;AAEA;;EAEE;AACF;EACE,WAAW;EACX,YAAY;AACd;;AAEA;EACE,kBAAkB;EAClB,aAAa;EACb,oBAAoB;EACpB,cAAc;AAChB;;AAEA;EACE,WAAW;EACX,YAAY;EACZ,kBAAkB;EAClB,qBAAqB;EACrB,eAAe;EACf,mBAAmB;;EAEnB,kBAAkB;;EAElB,eAAe;;EAEf,2DAA2D;EAC3D,iEAAiE;EACjE,mBAAmB;EACnB,sBAAsB;AACxB;;AAEA;EACE,2DAA2D;AAC7D;;AAEA;EACE,cAAc;AAChB;;AAEA;;EAEE;AACF;EACE,cAAc;EACd,sBAAsB;EACtB,kBAAkB;EAClB,yCAAyC;EACzC,gBAAgB;EAChB,eAAe;EACf,YAAY;EACZ,iDAAiD;EACjD,2CAA2C;EAC3C,gBAAgB;EAChB,aAAa;EACb,iCAAiC;EACjC,qCAAqC;AACvC;;AAEA;EACE,WAAW;EACX,sBAAsB;EACtB,iCAAiC;EACjC,gBAAgB;EAChB,kBAAkB;EAClB,kDAAkD;EAClD,iBAAiB;AACnB;;AAEA;EACE,4DAA4D;EAC5D,wDAAwD;EACxD,aAAa;AACf;;AAEA;EACE,aAAa;EACb,oBAAoB;EACpB,iBAAiB;EACjB,2BAA2B;AAC7B;;AAEA;EACE,kBAAkB;AACpB;;AAEA;EACE,UAAU;EACV,uBAAuB;EACvB,SAAS;AACX;;AAEA;EACE,+CAA+C;AACjD;;AAEA;EACE,cAAc;AAChB;;AAEA;EACE,iBAAiB;AACnB;;AAEA;EACE,iCAAiC;EACjC,4CAA4C;EAC5C,OAAO;EACP,SAAS;AACX;;AAEA;EACE,kBAAkB;EAClB,WAAW;AACb;;AAEA;EACE,kBAAkB;EAClB,SAAS;EACT,QAAQ;AACV;;AAEA;EACE,kBAAkB;AACpB;;AAEA;EACE,wBAAwB;EACxB,gBAAgB;EAChB,iBAAiB;EACjB,cAAc;EACd,kBAAkB;AACpB;;AAEA;EACE,SAAS;EACT,UAAU;EACV,WAAW;AACb;;AAEA;;EAEE,gBAAgB;EAChB,eAAe;EACf,kBAAkB;AACpB;;AAEA;EACE,4CAA4C;EAC5C,qCAAqC;EACrC,eAAe;AACjB;;AAEA;;EAEE,iBAAiB;AACnB;;AAEA;;EAEE,UAAU;EACV,WAAW;EACX,qBAAqB;EACrB,gBAAgB;EAChB,sBAAsB;AACxB;;AAEA;EACE,eAAe;EACf,kBAAkB;AACpB;;AAEA;EACE,aAAa;EACb,mBAAmB;EACnB,oBAAoB;EACpB,mBAAmB;AACrB;;AAEA;EACE,gDAAgD;AAClD;;AAEA;EACE,eAAe;AACjB;;AAEA;EACE,aAAa;EACb,sBAAsB;EACtB,OAAO;EACP,gBAAgB;AAClB;;AAEA;EACE,qCAAqC;AACvC;;AAEA;;EAEE,kBAAkB;AACpB;;AAEA;;EAEE,WAAW;AACb;;AAEA;;;;EAIE,gBAAgB;EAChB,uBAAuB;EACvB,mBAAmB;AACrB;;AAEA;EACE,aAAa;AACf;;AAEA;EACE,sBAAsB;EACtB,WAAW;AACb;;AAEA;EACE,UAAU;AACZ;;AAEA;EACE,kBAAkB;EAClB,oCAAoC;AACtC;;AAEA;EACE,gBAAgB;EAChB,uBAAuB;EACvB,SAAS;EACT,YAAY;AACd;;AAEA;EACE,yBAAyB;EACzB,oCAAoC;AACtC;;AAEA;EACE,OAAO;EACP,mBAAmB;EACnB,mBAAmB;EACnB,iBAAiB;EACjB,aAAa;AACf;;AAEA;EACE,aAAa;AACf;;AAEA;EACE,sBAAsB;EACtB,yBAAyB;AAC3B;;AAEA;;EAEE;AACF;EACE,2CAA2C;EAC3C,6CAA6C;EAC7C,kBAAkB;AACpB;;AAEA;;EAEE;AACF;;EAEE,aAAa;AACf;;AAEA;EACE,aAAa;;EAEb,iCAAiC;EACjC,qCAAqC;EACrC,iBAAiB;EACjB,iBAAiB;AACnB;;AAEA;EACE,cAAc;AAChB;;AAEA;EACE,iCAAiC;EACjC,qCAAqC;EACrC,iBAAiB;AACnB;;AAEA;;;;;;EAME,cAAc;AAChB;;AAEA;EACE,aAAa;AACf;;AAEA;EACE,aAAa;AACf;;AAEA;;;;EAIE,iCAAiC;EACjC,qCAAqC;EACrC,iBAAiB;AACnB;;AAEA;EACE,oBAAoB;AACtB;;AAEA;;EAEE,UAAU;EACV,mBAAmB;AACrB;;AAEA;EACE,iBAAiB;AACnB;;AAEA;EACE,iBAAiB;AACnB;;AAEA;EACE,oBAAoB;AACtB;;AAEA;;EAEE,+BAA+B;AACjC;;AAEA;;;;;;;;;EASE,wBAAwB;AAC1B;;AAEA;;EAEE,cAAc;EACd,YAAY;AACd;;;AAGA;;EAEE;AACF;EACE,YAAY;EACZ,YAAY;;EAEZ,iDAAiD;EACjD,mDAAmD;EACnD,kBAAkB;EAClB,iCAAiC;EACjC,eAAe;EACf,iBAAiB;;EAEjB,aAAa;AACf;;AAEA;EACE,UAAU;AACZ;;;AAGA;;EAEE;AACF;EACE,kBAAkB;EAClB,SAAS;EACT,OAAO;EACP,QAAQ;EACR,iBAAiB;EACjB,kBAAkB;;EAElB,UAAU;EACV,gBAAgB;EAChB,gBAAgB;EAChB,WAAW;;EAEX,iBAAiB;EACjB,YAAY;EACZ,oDAAoD;EACpD,sDAAsD;EACtD,kBAAkB;EAClB,8HAA8H;AAChI;;AAEA;EACE,aAAa;AACf;;AAEA;EACE,iBAAiB;EACjB,WAAW;EACX,iBAAiB;EACjB,kDAAkD;EAClD,sBAAsB;AACxB;;AAEA;EACE,aAAa;EACb,8CAA8C;AAChD;;AAEA;EACE,kBAAkB;EAClB,gBAAgB;EAChB,iBAAiB;AACnB;;AAEA;EACE,eAAe;AACjB;;AAEA;EACE,WAAW;EACX,iBAAiB;EACjB,iBAAiB;EACjB,0DAA0D;EAC1D,kBAAkB;AACpB;;AAEA;EACE,2CAA2C;AAC7C;;AAEA;EACE,gBAAgB;AAClB;;AAEA;EACE,sBAAsB;EACtB,SAAS;AACX;;AAEA;EACE,+CAA+C;AACjD;;AAEA;EACE,+CAA+C;AACjD;;AAEA;EACE,+CAA+C;AACjD;;AAEA;EACE,+CAA+C;AACjD;;AAEA;;EAEE;AACF;;;;EAIE,wBAAwB;AAC1B;;AAEA;;;EAGE,YAAY;AACd',
        sourcesContent: ['/**\n * color definitions\n */\n.djs-parent {\n  --color-grey-225-10-15: hsl(225, 10%, 15%);\n  --color-grey-225-10-35: hsl(225, 10%, 35%);\n  --color-grey-225-10-55: hsl(225, 10%, 55%);\n  --color-grey-225-10-75: hsl(225, 10%, 75%);\n  --color-grey-225-10-80: hsl(225, 10%, 80%);\n  --color-grey-225-10-85: hsl(225, 10%, 85%);\n  --color-grey-225-10-90: hsl(225, 10%, 90%);\n  --color-grey-225-10-95: hsl(225, 10%, 95%);\n  --color-grey-225-10-97: hsl(225, 10%, 97%);\n\n  --color-blue-205-100-45: hsl(205, 100%, 45%);\n  --color-blue-205-100-45-opacity-30: hsla(205, 100%, 45%, 30%);\n  --color-blue-205-100-50: hsl(205, 100%, 50%);\n  --color-blue-205-100-50-opacity-15: hsla(205, 100%, 50%, 15%);\n  --color-blue-205-100-70: hsl(205, 100%, 75%);\n  --color-blue-205-100-95: hsl(205, 100%, 95%);\n\n  --color-green-150-86-44: hsl(150, 86%, 44%);\n\n  --color-red-360-100-40: hsl(360, 100%, 40%);\n  --color-red-360-100-45: hsl(360, 100%, 45%);\n  --color-red-360-100-92: hsl(360, 100%, 92%);\n  --color-red-360-100-97: hsl(360, 100%, 97%);\n\n  --color-white: hsl(0, 0%, 100%);\n  --color-black: hsl(0, 0%, 0%);\n  --color-black-opacity-10: hsla(0, 0%, 0%, 10%);\n  --color-black-opacity-30: hsla(0, 0%, 0%, 30%);\n\n  --canvas-fill-color: var(--color-white);\n\n  --bendpoint-fill-color: var(--color-blue-205-100-45);\n  --bendpoint-stroke-color: var(--canvas-fill-color);\n\n  --context-pad-entry-background-color: var(--color-white);\n  --context-pad-entry-hover-background-color: var(--color-grey-225-10-95);\n\n  --element-dragger-color: var(--color-blue-205-100-50);\n  --element-hover-outline-fill-color: var(--color-blue-205-100-45);\n  --element-selected-outline-stroke-color: var(--color-blue-205-100-50);\n  --element-selected-outline-secondary-stroke-color: var(--color-blue-205-100-70);\n\n  --lasso-fill-color: var(--color-blue-205-100-50-opacity-15);\n  --lasso-stroke-color: var(--element-selected-outline-stroke-color);\n\n  --palette-entry-color: var(--color-grey-225-10-15);\n  --palette-entry-hover-color: var(--color-blue-205-100-45);\n  --palette-entry-selected-color: var(--color-blue-205-100-50);\n  --palette-separator-color: var(--color-grey-225-10-75);\n  --palette-toggle-hover-background-color: var(--color-grey-225-10-55);\n  --palette-background-color: var(--color-grey-225-10-97);\n  --palette-border-color: var(--color-grey-225-10-75);\n\n  --popup-font-family: "IBM Plex Sans", sans-serif;\n  --popup-font-size: 14px;\n  --popup-header-entry-selected-color: var(--color-blue-205-100-50);\n  --popup-header-font-weight: bolder;\n  --popup-background-color: var(--color-white);\n  --popup-border-color: transparent;\n  --popup-shadow-color: var(--color-black-opacity-30);\n  --popup-description-color: var(--color-grey-225-10-55);\n  --popup-no-results-color: var(--color-grey-225-10-55);\n  --popup-entry-title-color: var(--color-grey-225-10-55);\n  --popup-entry-hover-color:  var(--color-grey-225-10-95);\n  --popup-search-border-color: var(--color-grey-225-10-75);\n  --popup-search-focus-border-color: var(--color-blue-205-100-50);\n  --popup-search-focus-background-color: var(--color-blue-205-100-95);\n\n  --resizer-fill-color: var(--color-blue-205-100-45);\n  --resizer-stroke-color: var(--canvas-fill-color);\n\n  --search-container-background-color: var(--color-grey-225-10-97);\n  --search-container-border-color: var(--color-blue-205-100-50);\n  --search-container-box-shadow-color: var(--color-blue-205-100-95);\n  --search-container-box-shadow-inset-color: var(--color-grey-225-10-80);\n  --search-input-border-color: var(--color-grey-225-10-75);\n  --search-result-border-color: var(--color-grey-225-10-75);\n  --search-result-highlight-color: var(--color-black);\n  --search-result-selected-color: var(--color-blue-205-100-45-opacity-30);\n\n  --shape-attach-allowed-stroke-color: var(--color-blue-205-100-50);\n  --shape-connect-allowed-fill-color: var(--color-grey-225-10-97);\n  --shape-drop-allowed-fill-color: var(--color-grey-225-10-97);\n  --shape-drop-not-allowed-fill-color: var(--color-red-360-100-97);\n  --shape-resize-preview-stroke-color: var(--color-blue-205-100-50);\n\n  --snap-line-stroke-color: var(--color-blue-205-100-45-opacity-30);\n\n  --space-tool-crosshair-stroke-color: var(--color-black);\n\n  --tooltip-error-background-color: var(--color-red-360-100-97);\n  --tooltip-error-border-color: var(--color-red-360-100-45);\n  --tooltip-error-color: var(--color-red-360-100-45);\n}\n\n/**\n * outline styles\n */\n\n.djs-outline,\n.djs-selection-outline {\n  fill: none;\n  shape-rendering: geometricPrecision;\n  stroke-width: 2px;\n}\n\n.djs-outline {\n  visibility: hidden;\n}\n\n.djs-selection-outline {\n  stroke: var(--element-selected-outline-stroke-color);\n}\n\n.djs-element.selected .djs-outline {\n  visibility: visible;\n\n  stroke: var(--element-selected-outline-stroke-color);\n}\n\n.djs-connection.selected .djs-outline {\n  display: none;\n}\n\n.djs-multi-select .djs-element.selected .djs-outline {\n  stroke: var(--element-selected-outline-secondary-stroke-color);\n  display: block;\n}\n\n.djs-shape.connect-ok .djs-visual > :nth-child(1) {\n  fill: var(--shape-connect-allowed-fill-color) !important;\n}\n\n.djs-shape.connect-not-ok .djs-visual > :nth-child(1),\n.djs-shape.drop-not-ok .djs-visual > :nth-child(1) {\n  fill: var(--shape-drop-not-allowed-fill-color) !important;\n}\n\n.djs-shape.new-parent .djs-visual > :nth-child(1) {\n  fill: var(--shape-drop-allowed-fill-color) !important;\n}\n\nsvg.drop-not-ok {\n  background: var(--shape-drop-not-allowed-fill-color) !important;\n}\n\nsvg.new-parent {\n  background: var(--shape-drop-allowed-fill-color) !important;\n}\n\n\n/* Override move cursor during drop and connect */\n.drop-not-ok,\n.connect-not-ok,\n.drop-not-ok *,\n.connect-not-ok * {\n  cursor: not-allowed !important;\n}\n\n.drop-ok,\n.connect-ok,\n.drop-ok *,\n.connect-ok * {\n  cursor: default !important;\n}\n\n.djs-element.attach-ok .djs-visual > :nth-child(1) {\n  stroke-width: 5px !important;\n  stroke: var(--shape-attach-allowed-stroke-color) !important;\n}\n\n.djs-frame.connect-not-ok .djs-visual > :nth-child(1),\n.djs-frame.drop-not-ok .djs-visual > :nth-child(1) {\n  stroke-width: 3px !important;\n  stroke: var(--shape-drop-not-allowed-fill-color) !important;\n  fill: none !important;\n}\n\n/**\n* Selection box style\n*\n*/\n.djs-lasso-overlay {\n  fill: var(--lasso-fill-color);\n  stroke: var(--lasso-stroke-color);\n  stroke-width: 2px;\n  shape-rendering: geometricPrecision;\n  pointer-events: none;\n}\n\n/**\n * Resize styles\n */\n.djs-resize-overlay {\n  fill: none;\n\n  stroke-dasharray: 5 1 3 1;\n  stroke: var(--shape-resize-preview-stroke-color);\n\n  pointer-events: none;\n}\n\n.djs-resizer-hit {\n  fill: none;\n  pointer-events: all;\n}\n\n.djs-resizer-visual {\n  fill: var(--resizer-fill-color);\n  stroke-width: 1px;\n  stroke: var(--resizer-stroke-color);\n  shape-rendering: geometricPrecision;\n}\n\n.djs-resizer:hover .djs-resizer-visual {\n  stroke: var(--resizer-stroke-color);\n  stroke-opacity: 1;\n}\n\n.djs-cursor-resize-ns,\n.djs-resizer-n,\n.djs-resizer-s {\n  cursor: ns-resize;\n}\n\n.djs-cursor-resize-ew,\n.djs-resizer-e,\n.djs-resizer-w {\n  cursor: ew-resize;\n}\n\n.djs-cursor-resize-nwse,\n.djs-resizer-nw,\n.djs-resizer-se {\n  cursor: nwse-resize;\n}\n\n.djs-cursor-resize-nesw,\n.djs-resizer-ne,\n.djs-resizer-sw {\n  cursor: nesw-resize;\n}\n\n.djs-shape.djs-resizing > .djs-outline {\n  visibility: hidden !important;\n}\n\n.djs-shape.djs-resizing > .djs-resizer {\n  visibility: hidden;\n}\n\n.djs-dragger > .djs-resizer {\n  visibility: hidden;\n}\n\n/**\n * drag styles\n */\n.djs-dragger * {\n  fill: none !important;\n  stroke: var(--element-dragger-color) !important;\n}\n\n.djs-dragger tspan,\n.djs-dragger text {\n  fill: var(--element-dragger-color) !important;\n  stroke: none !important;\n}\n\nmarker.djs-dragger circle,\nmarker.djs-dragger path,\nmarker.djs-dragger polygon,\nmarker.djs-dragger polyline,\nmarker.djs-dragger rect {\n  fill: var(--element-dragger-color) !important;\n  stroke: none !important;\n}\n\nmarker.djs-dragger text,\nmarker.djs-dragger tspan {\n  fill: none !important;\n  stroke: var(--element-dragger-color) !important;\n}\n\n.djs-dragging,\n.djs-dragging > * {\n  opacity: 0.3 !important;\n  pointer-events: none !important;\n}\n\n/**\n * no pointer events for visual\n */\n.djs-visual,\n.djs-outline {\n  pointer-events: none;\n}\n\n.djs-element.attach-ok .djs-hit {\n  stroke-width: 60px !important;\n}\n\n/**\n * all pointer events for hit shape\n */\n.djs-element > .djs-hit-all,\n.djs-element > .djs-hit-no-move {\n  pointer-events: all;\n}\n\n.djs-element > .djs-hit-stroke,\n.djs-element > .djs-hit-click-stroke {\n  pointer-events: stroke;\n}\n\n/**\n * shape / connection basic styles\n */\n.djs-connection .djs-visual {\n  stroke-width: 2px;\n  fill: none;\n}\n\n.djs-cursor-grab {\n  cursor: -webkit-grab;\n  cursor: -moz-grab;\n  cursor: grab;\n}\n\n.djs-cursor-grabbing {\n  cursor: -webkit-grabbing;\n  cursor: -moz-grabbing;\n  cursor: grabbing;\n}\n\n.djs-cursor-crosshair {\n  cursor: crosshair;\n}\n\n.djs-cursor-move {\n  cursor: move;\n}\n\n.djs-cursor-resize-ns {\n  cursor: ns-resize;\n}\n\n.djs-cursor-resize-ew {\n  cursor: ew-resize;\n}\n\n\n/**\n * snapping\n */\n.djs-snap-line {\n  stroke: var(--snap-line-stroke-color);\n  stroke-linecap: round;\n  stroke-width: 2px;\n  pointer-events: none;\n}\n\n/**\n * snapping\n */\n.djs-crosshair {\n  stroke: var(--space-tool-crosshair-stroke-color);\n  stroke-linecap: round;\n  stroke-width: 1px;\n  pointer-events: none;\n  shape-rendering: geometricPrecision;\n  stroke-dasharray: 5, 5;\n}\n\n/**\n * palette\n */\n\n.djs-palette {\n  position: absolute;\n  left: 20px;\n  top: 20px;\n\n  box-sizing: border-box;\n  width: 48px;\n}\n\n.djs-palette .separator {\n  margin: 5px;\n  padding-top: 5px;\n\n  border: none;\n  border-bottom: solid 1px var(--palette-separator-color);\n\n  clear: both;\n}\n\n.djs-palette .entry:before {\n  vertical-align: initial;\n}\n\n.djs-palette .djs-palette-toggle {\n  cursor: pointer;\n}\n\n.djs-palette .entry,\n.djs-palette .djs-palette-toggle {\n  color: var(--palette-entry-color);\n  font-size: 30px;\n\n  text-align: center;\n}\n\n.djs-palette .entry {\n  float: left;\n}\n\n.djs-palette .entry img {\n  max-width: 100%;\n}\n\n.djs-palette .djs-palette-entries:after {\n  content: \'\';\n  display: table;\n  clear: both;\n}\n\n.djs-palette .djs-palette-toggle:hover {\n  background: var(--palette-toggle-hover-background-color);\n}\n\n.djs-palette .entry:hover {\n  color: var(--palette-entry-hover-color);\n}\n\n.djs-palette .highlighted-entry {\n  color: var(--palette-entry-selected-color) !important;\n}\n\n.djs-palette .entry,\n.djs-palette .djs-palette-toggle {\n  width: 46px;\n  height: 46px;\n  line-height: 46px;\n  cursor: default;\n}\n\n/**\n * Palette open / two-column layout is controlled via\n * classes on the palette. Events to hook into palette\n * changed life-cycle are available in addition.\n */\n.djs-palette.two-column.open {\n  width: 94px;\n}\n\n.djs-palette:not(.open) .djs-palette-entries {\n  display: none;\n}\n\n.djs-palette:not(.open) {\n  overflow: hidden;\n}\n\n.djs-palette.open .djs-palette-toggle {\n  display: none;\n}\n\n/**\n * context-pad\n */\n.djs-overlay-context-pad {\n  width: 72px;\n  z-index: 100;\n}\n\n.djs-context-pad {\n  position: absolute;\n  display: none;\n  pointer-events: none;\n  line-height: 1;\n}\n\n.djs-context-pad .entry {\n  width: 22px;\n  height: 22px;\n  text-align: center;\n  display: inline-block;\n  font-size: 22px;\n  margin: 0 2px 2px 0;\n\n  border-radius: 3px;\n\n  cursor: default;\n\n  background-color: var(--context-pad-entry-background-color);\n  box-shadow: 0 0 2px 1px var(--context-pad-entry-background-color);\n  pointer-events: all;\n  vertical-align: middle;\n}\n\n.djs-context-pad .entry:hover {\n  background: var(--context-pad-entry-hover-background-color);\n}\n\n.djs-context-pad.open {\n  display: block;\n}\n\n/**\n * popup styles\n */\n.djs-popup {\n  line-height: 1;\n  box-sizing: border-box;\n  width: min-content;\n  background: var(--popup-background-color);\n  overflow: hidden;\n  position: fixed;\n  z-index: 200;\n  box-shadow: 0px 2px 6px var(--popup-shadow-color);\n  border: solid 1px var(--popup-border-color);\n  min-width: 120px;\n  outline: none;\n  font-size: var(--popup-font-size);\n  font-family: var(--popup-font-family);\n}\n\n.djs-popup-search input {\n  width: 100%;\n  box-sizing: border-box;\n  font-size: var(--popup-font-size);\n  padding: 3px 6px;\n  border-radius: 2px;\n  border: solid 1px var(--popup-search-border-color);\n  line-height: 21px;\n}\n\n.djs-popup-search input:focus {\n  background-color: var(--popup-search-focus-background-color);\n  border: solid 1px var(--popup-search-focus-border-color);\n  outline: none;\n}\n\n.djs-popup-header {\n  display: flex;\n  align-items: stretch;\n  line-height: 20px;\n  margin: 10px 12px 10px 12px;\n}\n\n.djs-popup-header .entry {\n  border-radius: 2px;\n}\n\n.djs-popup button.entry {\n  padding: 0;\n  background: transparent;\n  border: 0;\n}\n\n.djs-popup-header .entry.active {\n  color: var(--popup-header-entry-selected-color);\n}\n\n.djs-popup-header .entry.disabled {\n  color: inherit;\n}\n\n.djs-popup-search {\n  margin: 10px 12px;\n}\n\n.djs-popup-title {\n  font-size: var(--popup-font-size);\n  font-weight: var(--popup-header-font-weight);\n  flex: 1;\n  margin: 0;\n}\n\n.djs-popup-search {\n  position: relative;\n  width: auto;\n}\n\n.djs-popup-search-icon {\n  position: absolute;\n  left: 8px;\n  top: 7px;\n}\n\n.djs-popup-search input {\n  padding-left: 25px;\n}\n\n.djs-popup-results {\n  margin: 7px 3px 7px 12px;\n  list-style: none;\n  max-height: 280px;\n  overflow: auto;\n  padding-right: 9px;\n}\n\n.djs-popup-group {\n  margin: 0;\n  padding: 0;\n  width: 100%;\n}\n\n.djs-popup-body .entry,\n.djs-popup-body .entry-header {\n  padding: 5px 7px;\n  cursor: default;\n  border-radius: 4px;\n}\n\n.djs-popup-body .entry-header {\n  font-weight: var(--popup-header-font-weight);\n  color: var(--popup-entry-title-color);\n  padding-left: 0;\n}\n\n.djs-popup [class*="icon"] .djs-popup-label,\n.djs-popup-label:not(:first-child) {\n  margin-left: .5em;\n}\n\n.djs-popup [class*="icon"]:before,\n.djs-popup-entry-icon {\n  width: 1em;\n  height: 1em;\n  display: inline-block;\n  font-size: 1.4em;\n  vertical-align: middle;\n}\n\n.djs-popup-body .entry-header:not(:first-child) {\n  margin-top: 8px;\n  margin-bottom: 2px;\n}\n\n.djs-popup-body .entry {\n  display: flex;\n  flex-direction: row;\n  align-items: stretch;\n  height: min-content;\n}\n\n.djs-popup .entry.selected {\n  background-color: var(--popup-entry-hover-color);\n}\n\n.djs-popup-body .entry:not(:first-child) {\n  margin-top: 2px;\n}\n\n.djs-popup-entry-content {\n  display: flex;\n  flex-direction: column;\n  flex: 1;\n  overflow: hidden;\n}\n\n.djs-popup-entry-description {\n  color: var(--popup-description-color);\n}\n\n.djs-popup-label,\n.djs-popup-entry-description {\n  line-height: 1.4em;\n}\n\n.djs-popup .entry,\n.djs-popup .entry-header {\n  margin: 1px;\n}\n\n.djs-popup-title,\n.djs-popup-label,\n.djs-popup-entry-description,\n.djs-popup .entry-header {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n\n.djs-popup-entry-name {\n  display: flex;\n}\n\n.djs-popup-body {\n  flex-direction: column;\n  width: auto;\n}\n\n.djs-popup *::-webkit-scrollbar {\n  width: 6px;\n}\n\n.djs-popup *::-webkit-scrollbar-thumb {\n  border-radius: 3px;\n  background-color: rgba(0, 0, 0, 0.2);\n}\n\n.djs-popup *::-webkit-scrollbar-track {\n  box-shadow: none;\n  background: transparent;\n  margin: 0;\n  padding: 5px;\n}\n\n.djs-popup-no-results {\n  padding: 0 12px 12px 12px;\n  color: var(--popup-no-results-color);\n}\n\n.djs-popup-entry-docs {\n  flex: 0;\n  flex-direction: row;\n  align-items: center;\n  padding-left: 5px;\n  display: none;\n}\n\n.djs-popup-body .entry:hover .djs-popup-entry-docs {\n  display: flex;\n}\n\n.djs-popup-entry-docs svg {\n  vertical-align: middle;\n  margin: auto 2px auto 5px;\n}\n\n/**\n *  palette styles\n */\n.djs-palette {\n  background: var(--palette-background-color);\n  border: solid 1px var(--palette-border-color);\n  border-radius: 2px;\n}\n\n/**\n * bendpoints\n */\n.djs-segment-dragger,\n.djs-bendpoint {\n  display: none;\n}\n\n.djs-segment-dragger .djs-visual {\n  display: none;\n\n  fill: var(--bendpoint-fill-color);\n  stroke: var(--bendpoint-stroke-color);\n  stroke-width: 1px;\n  stroke-opacity: 1;\n}\n\n.djs-segment-dragger:hover .djs-visual {\n  display: block;\n}\n\n.djs-bendpoint .djs-visual {\n  fill: var(--bendpoint-fill-color);\n  stroke: var(--bendpoint-stroke-color);\n  stroke-width: 1px;\n}\n\n.djs-segment-dragger:hover,\n.djs-bendpoints.hover .djs-segment-dragger,\n.djs-bendpoints.selected .djs-segment-dragger,\n.djs-bendpoint:hover,\n.djs-bendpoints.hover .djs-bendpoint,\n.djs-bendpoints.selected .djs-bendpoint {\n  display: block;\n}\n\n.djs-drag-active .djs-bendpoints * {\n  display: none;\n}\n\n.djs-bendpoints:not(.hover) .floating {\n  display: none;\n}\n\n.djs-segment-dragger:hover .djs-visual,\n.djs-segment-dragger.djs-dragging .djs-visual,\n.djs-bendpoint:hover .djs-visual,\n.djs-bendpoint.floating .djs-visual {\n  fill: var(--bendpoint-fill-color);\n  stroke: var(--bendpoint-stroke-color);\n  stroke-opacity: 1;\n}\n\n.djs-bendpoint.floating .djs-hit {\n  pointer-events: none;\n}\n\n.djs-segment-dragger .djs-hit,\n.djs-bendpoint .djs-hit {\n  fill: none;\n  pointer-events: all;\n}\n\n.djs-segment-dragger.horizontal .djs-hit {\n  cursor: ns-resize;\n}\n\n.djs-segment-dragger.vertical .djs-hit {\n  cursor: ew-resize;\n}\n\n.djs-segment-dragger.djs-dragging .djs-hit {\n  pointer-events: none;\n}\n\n.djs-updating,\n.djs-updating > * {\n  pointer-events: none !important;\n}\n\n.djs-updating .djs-context-pad,\n.djs-updating .djs-outline,\n.djs-updating .djs-bendpoint,\n.djs-multi-select .djs-bendpoint,\n.djs-multi-select .djs-segment-dragger,\n.connect-ok .djs-bendpoint,\n.connect-not-ok .djs-bendpoint,\n.drop-ok .djs-bendpoint,\n.drop-not-ok .djs-bendpoint {\n  display: none !important;\n}\n\n.djs-segment-dragger.djs-dragging,\n.djs-bendpoint.djs-dragging {\n  display: block;\n  opacity: 1.0;\n}\n\n\n/**\n * tooltips\n */\n.djs-tooltip-error {\n  width: 160px;\n  padding: 6px;\n\n  background: var(--tooltip-error-background-color);\n  border: solid 1px var(--tooltip-error-border-color);\n  border-radius: 2px;\n  color: var(--tooltip-error-color);\n  font-size: 12px;\n  line-height: 16px;\n\n  opacity: 0.75;\n}\n\n.djs-tooltip-error:hover {\n  opacity: 1;\n}\n\n\n/**\n * search pad\n */\n.djs-search-container {\n  position: absolute;\n  top: 20px;\n  left: 0;\n  right: 0;\n  margin-left: auto;\n  margin-right: auto;\n\n  width: 25%;\n  min-width: 300px;\n  max-width: 400px;\n  z-index: 10;\n\n  font-size: 1.05em;\n  opacity: 0.9;\n  background: var(--search-container-background-color);\n  border: solid 1px var(--search-container-border-color);\n  border-radius: 2px;\n  box-shadow: 0 0 0 2px var(--search-container-box-shadow-color), 0 0 0 1px var(--search-container-box-shadow-inset-color) inset;\n}\n\n.djs-search-container:not(.open) {\n  display: none;\n}\n\n.djs-search-input input {\n  font-size: 1.05em;\n  width: 100%;\n  padding: 6px 10px;\n  border: 1px solid var(--search-input-border-color);\n  box-sizing: border-box;\n}\n\n.djs-search-input input:focus {\n  outline: none;\n  border-color: var(--search-input-border-color);\n}\n\n.djs-search-results {\n  position: relative;\n  overflow-y: auto;\n  max-height: 200px;\n}\n\n.djs-search-results:hover {\n  cursor: pointer;\n}\n\n.djs-search-result {\n  width: 100%;\n  padding: 6px 10px;\n  background: white;\n  border-bottom: solid 1px var(--search-result-border-color);\n  border-radius: 1px;\n}\n\n.djs-search-highlight {\n  color: var(--search-result-highlight-color);\n}\n\n.djs-search-result-primary {\n  margin: 0 0 10px;\n}\n\n.djs-search-result-secondary {\n  font-family: monospace;\n  margin: 0;\n}\n\n.djs-search-result:hover {\n  background: var(--search-result-selected-color);\n}\n\n.djs-search-result-selected {\n  background: var(--search-result-selected-color);\n}\n\n.djs-search-result-selected:hover {\n  background: var(--search-result-selected-color);\n}\n\n.djs-search-overlay {\n  background: var(--search-result-selected-color);\n}\n\n/**\n * hidden styles\n */\n.djs-element-hidden,\n.djs-element-hidden .djs-hit,\n.djs-element-hidden .djs-outline,\n.djs-label-hidden .djs-label {\n  display: none !important;\n}\n\n.djs-element .djs-hit-stroke,\n.djs-element .djs-hit-click-stroke,\n.djs-element .djs-hit-all {\n  cursor: move;\n}'],
        sourceRoot: ''
      }])
      const s = a
    },
    9348: (e, t, n) => {
      'use strict'
      n.d(t, {
        A: () => b
      })
      const r = n(2017)
      const o = n.n(r)
      const i = n(3527)
      const a = n.n(i)
      const s = n(9038)
      const c = n.n(s)
      const l = new URL(n(4506), n.b)
      const p = new URL(n(8536), n.b)
      const u = new URL(n(5064), n.b)
      const d = new URL(n(6788), n.b)
      const f = a()(o())
      const h = c()(l)
      const m = c()(l, {
        hash: '#iefix'
      })
      const v = c()(p)
      const g = c()(u)
      const y = c()(d, {
        hash: '#bpmnio'
      })
      f.push([e.id, `/**\n * color scheme: https://color.adobe.com/create/color-wheel/?base=2&rule=Complementary&selected=4&name=My%20Color%20Theme&mode=rgb&rgbvalues=0.17030891601918655,0.4058823529411765,0.023676470588235302,0.5171907756812364,1,0.21666666666666667,0.3215686274509804,0.7058823529411765,0.08235294117647059,0.39483604076295736,0,0.4058823529411765,0.6889126559717383,0.08235294117647061,0.7058823529411765&swatchOrder=0,1,2,3,4\n */\n* {\n  box-sizing: border-box;\n}\nbody,\nhtml {\n  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;\n  font-size: 12px;\n  color: #444;\n  height: 100%;\n  padding: 0;\n  margin: 0;\n}\nh1,\nh2,\nh3,\nh4 {\n  font-weight: normal;\n}\nh2 {\n  margin-top: 30px;\n  margin-bottom: 10px;\n}\nul {\n  padding-left: 30px;\n}\nol {\n  padding-left: 30px;\n}\n/**\n * bpmn + custom icon definitions\n */\n@font-face {\n  font-family: 'app';\n  src: url(${h});\n  src: url(${m}) format('embedded-opentype'), url(${v}) format('woff'), url(${g}) format('truetype'), url(${y}) format('svg');\n  font-weight: normal;\n  font-style: normal;\n}\n[class^="icon-"]:before,\n[class*=" icon-"]:before {\n  font-style: normal;\n  font-weight: normal;\n  speak: none;\n  display: inline-block;\n  text-decoration: inherit;\n  width: 1em;\n  text-align: center;\n  font-variant: normal;\n  text-transform: none;\n  line-height: 1em;\n}\n[class^="icon-"]:before,\n[class*=" icon-"]:before {\n  font-family: "app";\n}\n.icon-bpmn-io-logo:before {\n  content: '\\e800';\n}\n/* '' */\n.icon-loading:before {\n  content: '\\f415';\n}\n/* '' */\n.icon-picture:before {\n  content: '\\f416';\n}\n/* '' */\n.icon-plus:before {\n  content: '\\f417';\n}\n/* '' */\n.icon-plus-circled:before {\n  content: '\\f418';\n}\n/* '' */\n.icon-minus:before {\n  content: '\\f419';\n}\n/* '' */\n.icon-info:before {\n  content: '\\f41a';\n}\n/* '' */\n.icon-download:before {\n  content: '\\f41b';\n}\n/* '' */\n.icon-undo:before {\n  content: '\\f41c';\n}\n/* '' */\n.icon-redo:before {\n  content: '\\f41d';\n}\n/* '' */\n.icon-open:before {\n  content: '\\f41e';\n}\n/* '' */\n.icon-size-reset:before {\n  content: '\\f41f';\n}\n/* '' */\n.icon-comment:before {\n  content: '\\f420';\n}\n/* '' */\n.icon-keyboard:before {\n  content: '\\f423';\n}\n/* '' */\n.icon-resize-full:before {\n  content: '\\f425';\n}\n/* '' */\n.icon-resize-small:before {\n  content: '\\f426';\n}\n/* '' */\n/**\n * reset\n */\nbody {\n  font-family: "IBM Plex Sans", sans-serif;\n  font-size: 14px;\n}\na:link,\na:visited {\n  color: #0e9663;\n  font-weight: bold;\n  text-decoration: none;\n}\na:hover,\na:focus {\n  color: #075035;\n}\n/**\n * project logo\n */\n.project-logo {\n  margin: 50px auto;\n}\n.project-logo a {\n  display: inline-block;\n  height: 4em;\n  width: auto;\n  color: #404040;\n  margin: 0 auto;\n}\n.project-logo a svg {\n  height: 100%;\n}\n.content,\n.content > div {\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.content > .screen {\n  text-align: center;\n  display: table;\n  font-size: 16px;\n}\n.content > .screen .note {\n  vertical-align: middle;\n  text-align: center;\n  display: table-cell;\n}\n.content .error .details {\n  max-width: 500px;\n  font-size: 12px;\n  margin: 20px auto;\n  text-align: left;\n  color: #BD2828;\n}\n.content .error .error-log {\n  border: solid 1px #BD2828;\n  background: #fdf6f6;\n  color: #BD2828;\n}\n.content .error .error-log:hover {\n  background: #fefafa;\n}\nbody:not(.error) .screen.error,\nbody:not(.intro) .screen.intro,\nbody:not(.loading) .screen.loading {\n  display: none;\n}\nbody.loading,\nbody.intro {\n  opacity: 0;\n  transition: opacity 1s;\n}\nbody.loading.animate,\nbody.intro.animate {\n  opacity: 1;\n}\n.screen.loading img {\n  width: 48px;\n}\n.canvas {\n  display: block;\n}\nbody.shown .canvas,\nbody.loaded .canvas {\n  display: block;\n}\nbody.loaded .canvas svg {\n  visibility: hidden;\n}\nbody:not(.shown) .io-export,\nbody:not(.shown) .io-zoom-controls {\n  display: none;\n}\n/** front page / drop zone */\n.samples,\n.message {\n  max-width: 700px;\n  margin: 15px auto;\n}\n@media (max-width: 720px) {\n  .samples,\n  .message {\n    margin: 20px;\n  }\n  .samples {\n    margin-bottom: 60px;\n  }\n}\n.message {\n  font-size: 20px;\n}\n.samples {\n  margin-top: 80px;\n  margin-bottom: 60px;\n  opacity: 0.4;\n  transition: ease-in 0.1s;\n}\n.samples:hover {\n  opacity: 1;\n}\n.samples .sample {\n  display: inline-block;\n  max-width: 100%;\n  vertical-align: top;\n  position: relative;\n}\n.samples .caption {\n  font-size: 13px;\n  font-weight: normal;\n  color: #666;\n}\n.samples .img {\n  border: solid 5px #E9E9E9;\n  border-radius: 5px;\n  padding: 5px;\n  width: 100%;\n}\n.samples .sample > a {\n  display: block;\n}\n/** widgets **/\n.io-control {\n  background: #FAFAFA;\n  border-radius: 2px;\n  border: solid 1px #E0E0E0;\n  padding: 5px;\n}\n.cjs-powered-by,\n.bjs-powered-by {\n  padding-bottom: 2px;\n}\n.close {\n  color: #333 !important;\n  font-size: 21px;\n  font-weight: 700 !important;\n  opacity: 0.6;\n  line-height: 1;\n  vertical-align: middle;\n  margin-left: 5px;\n}\n.close:hover {\n  opacity: 1;\n}\n.io-control .vr {\n  height: 15px;\n  display: inline-block;\n  border-right: solid 1px #DDD;\n}\n.io-control hr {\n  border: none;\n  border-top: solid 1px #DDD;\n  width: 15px;\n}\n.io-control-list .vr {\n  margin-right: 0;\n}\n.io-control-list {\n  list-style: none;\n  padding: 5px;\n  margin: 0;\n}\n.io-control-list a,\n.io-control-list a:visited,\n.io-control-list button {\n  padding: 0;\n  outline: none;\n  cursor: pointer;\n  font-size: 22px;\n  line-height: 26px;\n  color: #555555;\n  background: none;\n  border: none;\n}\n.io-control-list a:hover,\n.io-control-list a:visited:hover,\n.io-control-list button:hover {\n  color: #333333;\n}\n.io-control-list a.inactive,\n.io-control-list a:visited.inactive,\n.io-control-list button.inactive {\n  color: #E0E0E0;\n  cursor: default;\n}\n.io-control-list.io-horizontal,\n.io-control-list.io-horizontal li {\n  display: inline-block;\n}\n.io-control-list.io-horizontal li + li {\n  margin-left: 10px;\n}\n.io-control-list.io-horizontal a {\n  padding: 2px;\n}\n.io-about {\n  position: fixed;\n  right: 10px;\n}\n.io-about li + li {\n  margin-left: 15px;\n}\nbody.shown .io-about {\n  right: 90px;\n}\n.io-about a {\n  font-size: 13px;\n  line-height: 20px;\n  font-weight: normal;\n}\n.io-about a:hover {\n  background: #F0F0F0;\n  border-radius: 2px;\n}\n.io-import-export {\n  position: fixed;\n  left: 10px;\n}\n.djs-palette {\n  left: 10px !important;\n  top: 10px !important;\n}\n.io-about {\n  bottom: 8px;\n}\n.io-import-export {\n  bottom: 10px;\n}\n.io-import {\n  margin-right: 10px;\n}\n.io-zoom-controls {\n  width: auto;\n  position: fixed;\n  right: 10px;\n  bottom: 80px;\n}\n.io-editing-tools {\n  width: auto;\n  position: fixed;\n  right: 5px;\n  top: 5px;\n  display: none;\n}\n.io-editing-tools .io-control {\n  margin-left: 10px;\n}\n.io-editing-tools .io-control button {\n  margin: 0;\n}\n.io-zoom-reset {\n  margin-bottom: 10px;\n}\n.io-import-export .inactive {\n  opacity: 0.3;\n}\n/**\n * import warnings dialog\n */\n.import-warnings .error-log {\n  width: 100%;\n}\n/**\n * utilities\n */\n.hidden {\n  display: none;\n}\n/**\n * alerts\n */\n.io-alerts {\n  position: fixed;\n  top: 10px;\n  width: 450px;\n  text-align: center;\n  left: 50%;\n  margin-left: -450px / 2;\n}\n.io-alerts .alert {\n  display: none;\n  background: #eeefdf;\n  padding: 10px 20px;\n  line-height: 20px;\n  margin: 0 auto 10px;\n}\n.io-alerts .alert.open {\n  display: inline-flex;\n}\n.io-toggle-fullscreen {\n  display: none;\n}\n.io-toggle-fullscreen.open {\n  display: inline-block;\n}\n@media (max-width: 500px) {\n  .io-alerts {\n    width: 100%;\n    text-align: center;\n    left: 0;\n    margin: 0;\n  }\n}\n/**\n * dialogs\n */\n.io-dialog {\n  display: none;\n}\n.io-dialog.open {\n  display: block;\n}\n.io-dialog.open:before {\n  content: '';\n  position: fixed;\n  left: 0;\n  top: 0;\n  bottom: 0;\n  right: 0;\n  background: #666;\n  opacity: 0.2;\n  z-index: 1001;\n}\n.io-dialog .content {\n  position: fixed;\n  width: 600px;\n  left: 50%;\n  transform: translateX(-50%);\n  top: 100px;\n  background: white;\n  padding: 10px 30px 20px 30px;\n  box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);\n  border-radius: 2px;\n  height: auto;\n  z-index: 1001;\n}\n.keybindings-dialog .content {\n  width: 450px;\n  margin-left: -450px / 2;\n}\n.keybindings-dialog .binding {\n  padding: 5px 10px;\n  font-family: monospace;\n}\ntextarea.error-log {\n  border: solid 1px #CCC;\n  background: #F6F6F6;\n  padding: 10px;\n  margin: 10px auto;\n  width: 100%;\n  min-height: 150px;\n  display: block;\n}\ntextarea.error-log:hover {\n  background: #f9f9f9;\n}\n@media (max-width: 600px) {\n  .io-dialog .content {\n    left: 20px;\n    right: 20px;\n    top: 20px;\n    width: auto;\n    margin: 0;\n  }\n}\n.spinner-border {\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  background: white;\n  z-index: 200;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n@keyframes spinner-keyframe {\n  0% {\n    transform: rotate(0deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n}\n.spinner-border:after {\n  width: 22px;\n  height: 22px;\n  border: 4px solid #404040;\n  content: " ";\n  display: block;\n  border-radius: 50%;\n  border-color: #404040 #404040 #404040 transparent;\n  animation: spinner-keyframe 0.7s linear infinite;\n}\n:full-screen .icon-resize:before {\n  content: '\\e86e';\n  /* see .icon-resize-small:before */\n}\n:-moz-full-screen .icon-resize:before {\n  content: '\\e86e';\n  /* see .icon-resize-small:before */\n}\n:-ms-full-screen .icon-resize:before {\n  content: '\\e86e';\n  /* see .icon-resize-small:before */\n}\n:-webkit-full-screen .icon-resize:before {\n  content: '\\e86e';\n  /* see .icon-resize-small:before */\n}\n.icon-resize:before {\n  content: '\\e86d';\n  /* see .icon-resize-full:before */\n}\n.icon-resize:before {\n  content: '\\e86d';\n  /* see .icon-resize-full:before */\n}\n.icon-resize:before {\n  content: '\\e86d';\n  /* see .icon-resize-full:before */\n}\n.icon-resize:before {\n  content: '\\e86d';\n  /* see .icon-resize-full:before */\n}\n.drop-overlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  bottom: 0;\n  right: 0;\n  padding: 50px;\n  background: rgba(255, 255, 255, 0.9);\n  z-index: 1000;\n}\n.drop-overlay .box {\n  text-align: center;\n  border: dashed 4px #CCC;\n  height: 100%;\n  width: 100%;\n  display: table;\n}\n.drop-overlay .label {\n  font-size: 26px;\n  color: #888;\n  margin: auto;\n  display: table-cell;\n  vertical-align: middle;\n}\n`, '', {
        version: 3,
        sources: ['webpack://./client/less/app.less', 'webpack://./client/less/_normalize.less', 'webpack://./client/less/_icons.less', 'webpack://./client/less/_icons_codes.less', 'webpack://./client/less/_style.less', 'webpack://./client/less/_fullscreen.less', 'webpack://./client/less/file-drop.css'],
        names: [],
        mappings: 'AAAA;;EAEE;ACFF;EACE,sBAAA;ADIF;ACDA;;EACE,2DAAA;EAEA,eAAA;EACA,WAAA;EAEA,YAAA;EACA,UAAA;EACA,SAAA;ADEF;ACCA;;;;EACE,mBAAA;ADIF;ACDA;EACE,gBAAA;EACA,mBAAA;ADGF;ACAA;EACE,kBAAA;ADEF;ACCA;EACE,kBAAA;ADCF;AACA;;EAEE;AE7BF;EACE,kBAAA;EACA,4CAAA;EACA,mPAAA;EAIA,mBAAA;EACA,kBAAA;AF4BF;AExBA;;EAEE,kBAAA;EACA,mBAAA;EACA,WAAA;EAEA,qBAAA;EACA,wBAAA;EACA,UAAA;EACA,kBAAA;EAEA,oBAAA;EACA,oBAAA;EAEA,gBAAA;AFuBF;AEpBA;;EAEE,kBAAA;AFsBF;AGzDA;EAA4B,gBAAA;AH4D5B;AACA,QAAQ;AG5DR;EAAuB,gBAAA;AH+DvB;AACA,QAAQ;AG/DR;EAAuB,gBAAA;AHkEvB;AACA,QAAQ;AGlER;EAAoB,gBAAA;AHqEpB;AACA,QAAQ;AGrER;EAA4B,gBAAA;AHwE5B;AACA,QAAQ;AGxER;EAAqB,gBAAA;AH2ErB;AACA,QAAQ;AG3ER;EAAoB,gBAAA;AH8EpB;AACA,QAAQ;AG9ER;EAAwB,gBAAA;AHiFxB;AACA,QAAQ;AGjFR;EAAoB,gBAAA;AHoFpB;AACA,QAAQ;AGpFR;EAAoB,gBAAA;AHuFpB;AACA,QAAQ;AGvFR;EAAoB,gBAAA;AH0FpB;AACA,QAAQ;AG1FR;EAA0B,gBAAA;AH6F1B;AACA,QAAQ;AG7FR;EAAuB,gBAAA;AHgGvB;AACA,QAAQ;AGhGR;EAAwB,gBAAA;AHmGxB;AACA,QAAQ;AGnGR;EAA2B,gBAAA;AHsG3B;AACA,QAAQ;AGtGR;EAA4B,gBAAA;AHyG5B;AACA,QAAQ;AACR;;EAEE;AIzHF;EACE,wCAAA;EACA,eAAA;AJ2HF;AIxHA;;EAEE,cAAA;EAEA,iBAAA;EACA,qBAAA;AJyHF;AItHA;;EAEE,cAAA;AJwHF;AACA;;EAEE;AIrHF;EACE,iBAAA;AJuHF;AIxHA;EAII,qBAAA;EACA,WAAA;EACA,WAAA;EACA,cAAA;EACA,cAAA;AJuHJ;AI/HA;EAWM,YAAA;AJuHN;AIlHA;;EAEE,WAAA;EACA,YAAA;EAEA,gBAAA;AJmHF;AIhHA;EACE,kBAAA;EACA,cAAA;EAEA,eAAA;AJiHF;AI9GA;EACE,sBAAA;EACA,kBAAA;EACA,mBAAA;AJgHF;AI7GA;EAGI,gBAAA;EACA,eAAA;EACA,iBAAA;EACA,gBAAA;EAEA,cAAA;AJ4GJ;AIpHA;EAYI,yBAAA;EACA,mBAAA;EAEA,cAAA;AJ0GJ;AIxGI;EACE,mBAAA;AJ0GN;AIrGA;;;EAGE,aAAA;AJuGF;AIpGA;;EAEE,UAAA;EACA,sBAAA;AJsGF;AIpGE;;EACE,UAAA;AJuGJ;AInGA;EAEI,WAAA;AJoGJ;AIhGA;EACE,cAAA;AJkGF;AI/FA;;EAEE,cAAA;AJiGF;AI9FA;EACE,kBAAA;AJgGF;AI5FA;;EAEE,aAAA;AJ8FF;AACA,4BAA4B;AI1F5B;;EAEE,gBAAA;EACA,iBAAA;AJ4FF;AIzFA;EACE;;IAEE,YAAA;EJ2FF;EIxFA;IACE,mBAAA;EJ0FF;AACF;AIvFA;EACE,eAAA;AJyFF;AItFA;EACE,gBAAA;EACA,mBAAA;EAEA,YAAA;EACA,wBAAA;AJuFF;AIpFA;EACE,UAAA;AJsFF;AInFA;EACE,qBAAA;EACA,eAAA;EACA,mBAAA;EAEA,kBAAA;AJoFF;AIjFA;EACE,eAAA;EACA,mBAAA;EACA,WAAA;AJmFF;AIhFA;EACE,yBAAA;EACA,kBAAA;EACA,YAAA;EACA,WAAA;AJkFF;AI/EA;EACE,cAAA;AJiFF;AACA,cAAc;AI7Ed;EACE,mBAAA;EACA,kBAAA;EACA,yBAAA;EACA,YAAA;AJ+EF;AI5EA;;EAEE,mBAAA;AJ8EF;AI3EA;EACE,sBAAA;EACA,eAAA;EACA,2BAAA;EACA,YAAA;EACA,cAAA;EACA,sBAAA;EACA,gBAAA;AJ6EF;AI1EA;EACE,UAAA;AJ4EF;AIzEA;EACE,YAAA;EACA,qBAAA;EACA,4BAAA;AJ2EF;AIxEA;EACE,YAAA;EACA,0BAAA;EACA,WAAA;AJ0EF;AIvEA;EACE,eAAA;AJyEF;AItEA;EACE,gBAAA;EAEA,YAAA;EACA,SAAA;AJuEF;AI3EA;;;EASI,UAAA;EACA,aAAA;EAEA,eAAA;EACA,eAAA;EACA,iBAAA;EAEA,cAAA;EAEA,gBAAA;EACA,YAAA;AJoEJ;AIlEI;;;EACE,cAAA;AJsEN;AInEI;;;EACE,cAAA;EACA,eAAA;AJuEN;AInEE;;EAEE,qBAAA;AJqEJ;AIlEE;EAGI,iBAAA;AJkEN;AIrEE;EAOI,YAAA;AJiEN;AI5DA;EACE,eAAA;EACA,WAAA;AJ8DF;AIhEA;EAKI,iBAAA;AJ8DJ;AIzDA;EACE,WAAA;AJ2DF;AIxDA;EACE,eAAA;EACA,iBAAA;EACA,mBAAA;AJ0DF;AIvDA;EACE,mBAAA;EACA,kBAAA;AJyDF;AItDA;EACE,eAAA;EACA,UAAA;AJwDF;AIrDA;EACE,qBAAA;EACA,oBAAA;AJuDF;AIpDA;EACE,WAAA;AJsDF;AInDA;EACE,YAAA;AJqDF;AIlDA;EACE,kBAAA;AJoDF;AIjDA;EACE,WAAA;EACA,eAAA;EACA,WAAA;EACA,YAAA;AJmDF;AIhDA;EACE,WAAA;EACA,eAAA;EACA,UAAA;EACA,QAAA;EAEA,aAAA;AJiDF;AIvDA;EASI,iBAAA;AJiDJ;AI1DA;EAYM,SAAA;AJiDN;AI5CA;EACE,mBAAA;AJ8CF;AI3CA;EACE,YAAA;AJ6CF;AACA;;EAEE;AIzCF;EAEI,WAAA;AJ0CJ;AACA;;EAEE;AIrCF;EACE,aAAA;AJuCF;AACA;;EAEE;AIpCF;EACE,eAAA;EACA,SAAA;EACA,YAAA;EACA,kBAAA;EACA,SAAA;EACA,uBAAA;AJsCF;AI5CA;EASI,aAAA;EACA,mBAAA;EAEA,kBAAA;EAEA,iBAAA;EACA,mBAAA;AJoCJ;AIlCI;EACE,oBAAA;AJoCN;AI/BA;EACE,aAAA;AJiCF;AI/BE;EACE,qBAAA;AJiCJ;AI5BA;EACE;IACE,WAAA;IACA,kBAAA;IACA,OAAA;IACA,SAAA;EJ8BF;AACF;AACA;;EAEE;AI1BF;EACE,aAAA;AJ4BF;AI1BE;EACE,cAAA;AJ4BJ;AIzBE;EACE,WAAA;EACA,eAAA;EACA,OAAA;EACA,MAAA;EACA,SAAA;EACA,QAAA;EAEA,gBAAA;EACA,YAAA;EAEA,aAAA;AJyBJ;AI3CA;EAsBI,eAAA;EAEA,YAAA;EACA,SAAA;EACA,2BAAA;EACA,UAAA;EAEA,iBAAA;EACA,4BAAA;EAEA,wCAAA;EACA,kBAAA;EAEA,YAAA;EAEA,aAAA;AJmBJ;AIdA;EAGI,YAAA;EACA,uBAAA;AJcJ;AIlBA;EAQI,iBAAA;EACA,sBAAA;AJaJ;AITA;EACE,sBAAA;EACA,mBAAA;EACA,aAAA;EAEA,iBAAA;EAEA,WAAA;EAEA,iBAAA;EAEA,cAAA;AJOF;AILE;EACE,mBAAA;AJOJ;AIHA;EACE;IACE,UAAA;IACA,WAAA;IACA,SAAA;IACA,WAAA;IAEA,SAAA;EJIF;AACF;AIAA;EACE,kBAAA;EACA,MAAA;EACA,QAAA;EACA,SAAA;EACA,OAAA;EACA,iBAAA;EACA,YAAA;EACA,aAAA;EACA,uBAAA;EACA,mBAAA;AJEF;AICA;EACE;IACE,uBAAA;EJCF;EICA;IACE,yBAAA;EJCF;AACF;AIEA;EACE,WAAA;EACA,YAAA;EACA,yBAAA;EACA,YAAA;EACA,cAAA;EACA,kBAAA;EACA,iDAAA;EACA,gDAAA;AJAF;AKzhBA;EACE,gBAAA;EL2hBA,kCAAkC;AACpC;AKzhBA;EACE,gBAAA;EL2hBA,kCAAkC;AACpC;AKzhBA;EACE,gBAAA;EL2hBA,kCAAkC;AACpC;AKzhBA;EACE,gBAAA;EL2hBA,kCAAkC;AACpC;AKzhBA;EACE,gBAAA;EL2hBA,iCAAiC;AACnC;AKzhBA;EACE,gBAAA;EL2hBA,iCAAiC;AACnC;AKzhBA;EACE,gBAAA;EL2hBA,iCAAiC;AACnC;AKzhBA;EACE,gBAAA;EL2hBA,iCAAiC;AACnC;AMzjBA;EACE,eAAA;EACA,MAAA;EACA,OAAA;EACA,SAAA;EACA,QAAA;EAEA,aAAA;EAEA,oCAAA;EAEA,aAAA;ANwjBF;AMrjBA;EACE,kBAAA;EACA,uBAAA;EACA,YAAA;EACA,WAAA;EACA,cAAA;ANujBF;AMpjBA;EACE,eAAA;EACA,WAAA;EACA,YAAA;EAEA,mBAAA;EACA,sBAAA;ANqjBF',
        sourcesContent: ["/**\n * color scheme: https://color.adobe.com/create/color-wheel/?base=2&rule=Complementary&selected=4&name=My%20Color%20Theme&mode=rgb&rgbvalues=0.17030891601918655,0.4058823529411765,0.023676470588235302,0.5171907756812364,1,0.21666666666666667,0.3215686274509804,0.7058823529411765,0.08235294117647059,0.39483604076295736,0,0.4058823529411765,0.6889126559717383,0.08235294117647061,0.7058823529411765&swatchOrder=0,1,2,3,4\n */\n* {\n  box-sizing: border-box;\n}\nbody,\nhtml {\n  font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n  font-size: 12px;\n  color: #444;\n  height: 100%;\n  padding: 0;\n  margin: 0;\n}\nh1,\nh2,\nh3,\nh4 {\n  font-weight: normal;\n}\nh2 {\n  margin-top: 30px;\n  margin-bottom: 10px;\n}\nul {\n  padding-left: 30px;\n}\nol {\n  padding-left: 30px;\n}\n/**\n * bpmn + custom icon definitions\n */\n@font-face {\n  font-family: 'app';\n  src: url('../font/app.eot?42391129');\n  src: url('../font/app.eot?42391129#iefix') format('embedded-opentype'), url('../font/app.woff?42391129') format('woff'), url('../font/app.ttf?42391129') format('truetype'), url('../font/app.svg?42391129#bpmnio') format('svg');\n  font-weight: normal;\n  font-style: normal;\n}\n[class^=\"icon-\"]:before,\n[class*=\" icon-\"]:before {\n  font-style: normal;\n  font-weight: normal;\n  speak: none;\n  display: inline-block;\n  text-decoration: inherit;\n  width: 1em;\n  text-align: center;\n  font-variant: normal;\n  text-transform: none;\n  line-height: 1em;\n}\n[class^=\"icon-\"]:before,\n[class*=\" icon-\"]:before {\n  font-family: \"app\";\n}\n.icon-bpmn-io-logo:before {\n  content: '\\e800';\n}\n/* '' */\n.icon-loading:before {\n  content: '\\f415';\n}\n/* '' */\n.icon-picture:before {\n  content: '\\f416';\n}\n/* '' */\n.icon-plus:before {\n  content: '\\f417';\n}\n/* '' */\n.icon-plus-circled:before {\n  content: '\\f418';\n}\n/* '' */\n.icon-minus:before {\n  content: '\\f419';\n}\n/* '' */\n.icon-info:before {\n  content: '\\f41a';\n}\n/* '' */\n.icon-download:before {\n  content: '\\f41b';\n}\n/* '' */\n.icon-undo:before {\n  content: '\\f41c';\n}\n/* '' */\n.icon-redo:before {\n  content: '\\f41d';\n}\n/* '' */\n.icon-open:before {\n  content: '\\f41e';\n}\n/* '' */\n.icon-size-reset:before {\n  content: '\\f41f';\n}\n/* '' */\n.icon-comment:before {\n  content: '\\f420';\n}\n/* '' */\n.icon-keyboard:before {\n  content: '\\f423';\n}\n/* '' */\n.icon-resize-full:before {\n  content: '\\f425';\n}\n/* '' */\n.icon-resize-small:before {\n  content: '\\f426';\n}\n/* '' */\n/**\n * reset\n */\nbody {\n  font-family: \"IBM Plex Sans\", sans-serif;\n  font-size: 14px;\n}\na:link,\na:visited {\n  color: #0e9663;\n  font-weight: bold;\n  text-decoration: none;\n}\na:hover,\na:focus {\n  color: #075035;\n}\n/**\n * project logo\n */\n.project-logo {\n  margin: 50px auto;\n}\n.project-logo a {\n  display: inline-block;\n  height: 4em;\n  width: auto;\n  color: #404040;\n  margin: 0 auto;\n}\n.project-logo a svg {\n  height: 100%;\n}\n.content,\n.content > div {\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.content > .screen {\n  text-align: center;\n  display: table;\n  font-size: 16px;\n}\n.content > .screen .note {\n  vertical-align: middle;\n  text-align: center;\n  display: table-cell;\n}\n.content .error .details {\n  max-width: 500px;\n  font-size: 12px;\n  margin: 20px auto;\n  text-align: left;\n  color: #BD2828;\n}\n.content .error .error-log {\n  border: solid 1px #BD2828;\n  background: #fdf6f6;\n  color: #BD2828;\n}\n.content .error .error-log:hover {\n  background: #fefafa;\n}\nbody:not(.error) .screen.error,\nbody:not(.intro) .screen.intro,\nbody:not(.loading) .screen.loading {\n  display: none;\n}\nbody.loading,\nbody.intro {\n  opacity: 0;\n  transition: opacity 1s;\n}\nbody.loading.animate,\nbody.intro.animate {\n  opacity: 1;\n}\n.screen.loading img {\n  width: 48px;\n}\n.canvas {\n  display: block;\n}\nbody.shown .canvas,\nbody.loaded .canvas {\n  display: block;\n}\nbody.loaded .canvas svg {\n  visibility: hidden;\n}\nbody:not(.shown) .io-export,\nbody:not(.shown) .io-zoom-controls {\n  display: none;\n}\n/** front page / drop zone */\n.samples,\n.message {\n  max-width: 700px;\n  margin: 15px auto;\n}\n@media (max-width: 720px) {\n  .samples,\n  .message {\n    margin: 20px;\n  }\n  .samples {\n    margin-bottom: 60px;\n  }\n}\n.message {\n  font-size: 20px;\n}\n.samples {\n  margin-top: 80px;\n  margin-bottom: 60px;\n  opacity: 0.4;\n  transition: ease-in 0.1s;\n}\n.samples:hover {\n  opacity: 1;\n}\n.samples .sample {\n  display: inline-block;\n  max-width: 100%;\n  vertical-align: top;\n  position: relative;\n}\n.samples .caption {\n  font-size: 13px;\n  font-weight: normal;\n  color: #666;\n}\n.samples .img {\n  border: solid 5px #E9E9E9;\n  border-radius: 5px;\n  padding: 5px;\n  width: 100%;\n}\n.samples .sample > a {\n  display: block;\n}\n/** widgets **/\n.io-control {\n  background: #FAFAFA;\n  border-radius: 2px;\n  border: solid 1px #E0E0E0;\n  padding: 5px;\n}\n.cjs-powered-by,\n.bjs-powered-by {\n  padding-bottom: 2px;\n}\n.close {\n  color: #333 !important;\n  font-size: 21px;\n  font-weight: 700 !important;\n  opacity: 0.6;\n  line-height: 1;\n  vertical-align: middle;\n  margin-left: 5px;\n}\n.close:hover {\n  opacity: 1;\n}\n.io-control .vr {\n  height: 15px;\n  display: inline-block;\n  border-right: solid 1px #DDD;\n}\n.io-control hr {\n  border: none;\n  border-top: solid 1px #DDD;\n  width: 15px;\n}\n.io-control-list .vr {\n  margin-right: 0;\n}\n.io-control-list {\n  list-style: none;\n  padding: 5px;\n  margin: 0;\n}\n.io-control-list a,\n.io-control-list a:visited,\n.io-control-list button {\n  padding: 0;\n  outline: none;\n  cursor: pointer;\n  font-size: 22px;\n  line-height: 26px;\n  color: #555555;\n  background: none;\n  border: none;\n}\n.io-control-list a:hover,\n.io-control-list a:visited:hover,\n.io-control-list button:hover {\n  color: #333333;\n}\n.io-control-list a.inactive,\n.io-control-list a:visited.inactive,\n.io-control-list button.inactive {\n  color: #E0E0E0;\n  cursor: default;\n}\n.io-control-list.io-horizontal,\n.io-control-list.io-horizontal li {\n  display: inline-block;\n}\n.io-control-list.io-horizontal li + li {\n  margin-left: 10px;\n}\n.io-control-list.io-horizontal a {\n  padding: 2px;\n}\n.io-about {\n  position: fixed;\n  right: 10px;\n}\n.io-about li + li {\n  margin-left: 15px;\n}\nbody.shown .io-about {\n  right: 90px;\n}\n.io-about a {\n  font-size: 13px;\n  line-height: 20px;\n  font-weight: normal;\n}\n.io-about a:hover {\n  background: #F0F0F0;\n  border-radius: 2px;\n}\n.io-import-export {\n  position: fixed;\n  left: 10px;\n}\n.djs-palette {\n  left: 10px !important;\n  top: 10px !important;\n}\n.io-about {\n  bottom: 8px;\n}\n.io-import-export {\n  bottom: 10px;\n}\n.io-import {\n  margin-right: 10px;\n}\n.io-zoom-controls {\n  width: auto;\n  position: fixed;\n  right: 10px;\n  bottom: 80px;\n}\n.io-editing-tools {\n  width: auto;\n  position: fixed;\n  right: 5px;\n  top: 5px;\n  display: none;\n}\n.io-editing-tools .io-control {\n  margin-left: 10px;\n}\n.io-editing-tools .io-control button {\n  margin: 0;\n}\n.io-zoom-reset {\n  margin-bottom: 10px;\n}\n.io-import-export .inactive {\n  opacity: 0.3;\n}\n/**\n * import warnings dialog\n */\n.import-warnings .error-log {\n  width: 100%;\n}\n/**\n * utilities\n */\n.hidden {\n  display: none;\n}\n/**\n * alerts\n */\n.io-alerts {\n  position: fixed;\n  top: 10px;\n  width: 450px;\n  text-align: center;\n  left: 50%;\n  margin-left: -450px / 2;\n}\n.io-alerts .alert {\n  display: none;\n  background: #eeefdf;\n  padding: 10px 20px;\n  line-height: 20px;\n  margin: 0 auto 10px;\n}\n.io-alerts .alert.open {\n  display: inline-flex;\n}\n.io-toggle-fullscreen {\n  display: none;\n}\n.io-toggle-fullscreen.open {\n  display: inline-block;\n}\n@media (max-width: 500px) {\n  .io-alerts {\n    width: 100%;\n    text-align: center;\n    left: 0;\n    margin: 0;\n  }\n}\n/**\n * dialogs\n */\n.io-dialog {\n  display: none;\n}\n.io-dialog.open {\n  display: block;\n}\n.io-dialog.open:before {\n  content: '';\n  position: fixed;\n  left: 0;\n  top: 0;\n  bottom: 0;\n  right: 0;\n  background: #666;\n  opacity: 0.2;\n  z-index: 1001;\n}\n.io-dialog .content {\n  position: fixed;\n  width: 600px;\n  left: 50%;\n  transform: translateX(-50%);\n  top: 100px;\n  background: white;\n  padding: 10px 30px 20px 30px;\n  box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);\n  border-radius: 2px;\n  height: auto;\n  z-index: 1001;\n}\n.keybindings-dialog .content {\n  width: 450px;\n  margin-left: -450px / 2;\n}\n.keybindings-dialog .binding {\n  padding: 5px 10px;\n  font-family: monospace;\n}\ntextarea.error-log {\n  border: solid 1px #CCC;\n  background: #F6F6F6;\n  padding: 10px;\n  margin: 10px auto;\n  width: 100%;\n  min-height: 150px;\n  display: block;\n}\ntextarea.error-log:hover {\n  background: #f9f9f9;\n}\n@media (max-width: 600px) {\n  .io-dialog .content {\n    left: 20px;\n    right: 20px;\n    top: 20px;\n    width: auto;\n    margin: 0;\n  }\n}\n.spinner-border {\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  background: white;\n  z-index: 200;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n@keyframes spinner-keyframe {\n  0% {\n    transform: rotate(0deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n}\n.spinner-border:after {\n  width: 22px;\n  height: 22px;\n  border: 4px solid #404040;\n  content: \" \";\n  display: block;\n  border-radius: 50%;\n  border-color: #404040 #404040 #404040 transparent;\n  animation: spinner-keyframe 0.7s linear infinite;\n}\n:full-screen .icon-resize:before {\n  content: '\\e86e';\n  /* see .icon-resize-small:before */\n}\n:-moz-full-screen .icon-resize:before {\n  content: '\\e86e';\n  /* see .icon-resize-small:before */\n}\n:-ms-full-screen .icon-resize:before {\n  content: '\\e86e';\n  /* see .icon-resize-small:before */\n}\n:-webkit-full-screen .icon-resize:before {\n  content: '\\e86e';\n  /* see .icon-resize-small:before */\n}\n.icon-resize:before {\n  content: '\\e86d';\n  /* see .icon-resize-full:before */\n}\n.icon-resize:before {\n  content: '\\e86d';\n  /* see .icon-resize-full:before */\n}\n.icon-resize:before {\n  content: '\\e86d';\n  /* see .icon-resize-full:before */\n}\n.icon-resize:before {\n  content: '\\e86d';\n  /* see .icon-resize-full:before */\n}\n.drop-overlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  bottom: 0;\n  right: 0;\n  padding: 50px;\n  background: rgba(255, 255, 255, 0.9);\n  z-index: 1000;\n}\n.drop-overlay .box {\n  text-align: center;\n  border: dashed 4px #CCC;\n  height: 100%;\n  width: 100%;\n  display: table;\n}\n.drop-overlay .label {\n  font-size: 26px;\n  color: #888;\n  margin: auto;\n  display: table-cell;\n  vertical-align: middle;\n}\n", '* {\n  box-sizing: border-box;\n}\n\nbody, html {\n  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;\n\n  font-size: 12px;\n  color: #444;\n\n  height: 100%;\n  padding: 0;\n  margin: 0;\n}\n\nh1, h2, h3, h4 {\n  font-weight: normal;\n}\n\nh2 {\n  margin-top: 30px;\n  margin-bottom: 10px;\n}\n\nul {\n  padding-left: 30px;\n}\n\nol {\n  padding-left: 30px;\n}', "/**\n * bpmn + custom icon definitions\n */\n\n@font-face {\n  font-family: 'app';\n  src: url('../font/app.eot?42391129');\n  src: url('../font/app.eot?42391129#iefix') format('embedded-opentype'),\n       url('../font/app.woff?42391129') format('woff'),\n       url('../font/app.ttf?42391129') format('truetype'),\n       url('../font/app.svg?42391129#bpmnio') format('svg');\n  font-weight: normal;\n  font-style: normal;\n}\n\n\n[class^=\"icon-\"]:before,\n[class*=\" icon-\"]:before {\n  font-style: normal;\n  font-weight: normal;\n  speak: none;\n\n  display: inline-block;\n  text-decoration: inherit;\n  width: 1em;\n  text-align: center;\n\n  font-variant: normal;\n  text-transform: none;\n\n  line-height: 1em;\n}\n\n[class^=\"icon-\"]:before,\n[class*=\" icon-\"]:before {\n  font-family: \"app\";\n}\n\n@import \"_icons_codes\";", ".icon-bpmn-io-logo:before { content: '\\e800'; } /* '' */\n.icon-loading:before { content: '\\f415'; } /* '' */\n.icon-picture:before { content: '\\f416'; } /* '' */\n.icon-plus:before { content: '\\f417'; } /* '' */\n.icon-plus-circled:before { content: '\\f418'; } /* '' */\n.icon-minus:before { content: '\\f419'; } /* '' */\n.icon-info:before { content: '\\f41a'; } /* '' */\n.icon-download:before { content: '\\f41b'; } /* '' */\n.icon-undo:before { content: '\\f41c'; } /* '' */\n.icon-redo:before { content: '\\f41d'; } /* '' */\n.icon-open:before { content: '\\f41e'; } /* '' */\n.icon-size-reset:before { content: '\\f41f'; } /* '' */\n.icon-comment:before { content: '\\f420'; } /* '' */\n.icon-keyboard:before { content: '\\f423'; } /* '' */\n.icon-resize-full:before { content: '\\f425'; } /* '' */\n.icon-resize-small:before { content: '\\f426'; } /* '' */", '/**\n * reset\n */\nbody {\n  font-family: "IBM Plex Sans",sans-serif;\n  font-size: 14px;\n}\n\na:link,\na:visited {\n  color: @link-color;\n\n  font-weight: bold;\n  text-decoration: none;\n}\n\na:hover,\na:focus {\n  color: @link-color-hover;\n}\n\n/**\n * project logo\n */\n.project-logo {\n  margin: 50px auto;\n\n  a {\n    display: inline-block;\n    height: 4em;\n    width: auto;\n    color: #404040;\n    margin: 0 auto;\n\n    svg {\n      height: 100%;\n    }\n  }\n}\n\n.content,\n.content > div {\n  width: 100%;\n  height: 100%;\n\n  overflow: hidden;\n}\n\n.content > .screen {\n  text-align: center;\n  display: table;\n\n  font-size: 16px;\n}\n\n.content > .screen .note {\n  vertical-align: middle;\n  text-align: center;\n  display: table-cell;\n}\n\n.content .error {\n\n  .details {\n    max-width: 500px;\n    font-size: 12px;\n    margin: 20px auto;\n    text-align: left;\n\n    color: #BD2828;\n  }\n\n  .error-log {\n    border: solid 1px #BD2828;\n    background: lighten(#BD2828, 53%);\n\n    color: #BD2828;\n\n    &:hover {\n      background: lighten(lighten(#BD2828, 53%), 1%);\n    }\n  }\n}\n\nbody:not(.error) .screen.error,\nbody:not(.intro) .screen.intro,\nbody:not(.loading) .screen.loading {\n  display: none;\n}\n\nbody.loading,\nbody.intro {\n  opacity: 0;\n  transition: opacity 1s;\n\n  &.animate {\n    opacity: 1;\n  }\n}\n\n.screen.loading {\n  img {\n    width: 48px;\n  }\n}\n\n.canvas {\n  display: block;\n}\n\nbody.shown .canvas,\nbody.loaded .canvas {\n  display: block;\n}\n\nbody.loaded .canvas svg {\n  visibility: hidden;\n}\n\n\nbody:not(.shown) .io-export,\nbody:not(.shown) .io-zoom-controls {\n  display: none;\n}\n\n/** front page / drop zone */\n\n.samples,\n.message {\n  max-width: 700px;\n  margin: 15px auto;\n}\n\n@media (max-width: 720px) {\n  .samples,\n  .message {\n    margin: 20px;\n  }\n\n  .samples {\n    margin-bottom: 60px;\n  }\n}\n\n.message {\n  font-size: 20px;\n}\n\n.samples {\n  margin-top: 80px;\n  margin-bottom: 60px;\n\n  opacity: 0.4;\n  transition: ease-in 0.1s;\n}\n\n.samples:hover {\n  opacity: 1;\n}\n\n.samples .sample {\n  display: inline-block;\n  max-width: 100%;\n  vertical-align: top;\n\n  position: relative;\n}\n\n.samples .caption {\n  font-size: 13px;\n  font-weight: normal;\n  color: #666;\n}\n\n.samples .img {\n  border: solid 5px #E9E9E9;\n  border-radius: 5px;\n  padding: 5px;\n  width: 100%;\n}\n\n.samples .sample > a {\n  display: block;\n}\n\n/** widgets **/\n\n.io-control {\n  background: #FAFAFA;\n  border-radius: 2px;\n  border: solid 1px #E0E0E0;\n  padding: 5px;\n}\n\n.cjs-powered-by,\n.bjs-powered-by {\n  padding-bottom: 2px;\n}\n\n.close {\n  color: #333 !important;\n  font-size: 21px;\n  font-weight: 700 !important;\n  opacity: .6;\n  line-height: 1;\n  vertical-align: middle;\n  margin-left: 5px;\n}\n\n.close:hover {\n  opacity: 1;\n}\n\n.io-control .vr {\n  height: 15px;\n  display: inline-block;\n  border-right: solid 1px #DDD;\n}\n\n.io-control hr {\n  border: none;\n  border-top: solid 1px #DDD;\n  width: 15px;\n}\n\n.io-control-list .vr {\n  margin-right: 0;\n}\n\n.io-control-list {\n  list-style: none;\n\n  padding: 5px;\n  margin: 0;\n\n  a,\n  a:visited,\n  button {\n    padding: 0;\n    outline: none;\n\n    cursor: pointer;\n    font-size: 22px;\n    line-height: 26px;\n\n    color: @button-color;\n\n    background: none;\n    border: none;\n\n    &:hover {\n      color: @button-color-hover;\n    }\n\n    &.inactive {\n      color: @button-color-inactive;\n      cursor: default;\n    }\n  }\n\n  &.io-horizontal,\n  &.io-horizontal li {\n    display: inline-block;\n  }\n\n  &.io-horizontal {\n\n    li + li {\n      margin-left: 10px;\n    }\n\n    a {\n      padding: 2px;\n    }\n  }\n}\n\n.io-about {\n  position: fixed;\n  right: 10px;\n\n  li + li {\n    margin-left: 15px;\n  }\n\n}\n\nbody.shown .io-about {\n  right: 90px;\n}\n\n.io-about a {\n  font-size: 13px;\n  line-height: 20px;\n  font-weight: normal;\n}\n\n.io-about a:hover {\n  background: #F0F0F0;\n  border-radius: 2px;\n}\n\n.io-import-export {\n  position: fixed;\n  left: 10px;\n}\n\n.djs-palette {\n  left: 10px !important;\n  top: 10px !important;\n}\n\n.io-about {\n  bottom: 8px;\n}\n\n.io-import-export {\n  bottom: 10px;\n}\n\n.io-import {\n  margin-right: 10px;\n}\n\n.io-zoom-controls {\n  width: auto;\n  position: fixed;\n  right: 10px;\n  bottom: 80px;\n}\n\n.io-editing-tools {\n  width: auto;\n  position: fixed;\n  right: 5px;\n  top: 5px;\n\n  display: none;\n\n  .io-control {\n    margin-left: 10px;\n\n    button {\n      margin: 0;\n    }\n  }\n}\n\n.io-zoom-reset {\n  margin-bottom: 10px;\n}\n\n.io-import-export .inactive {\n  opacity: 0.3;\n}\n\n\n/**\n * import warnings dialog\n */\n.import-warnings {\n  .error-log {\n    width: 100%;\n  }\n}\n\n/**\n * utilities\n */\n\n.hidden {\n  display: none;\n}\n\n/**\n * alerts\n */\n.io-alerts {\n  position: fixed;\n  top: 10px;\n  width: @alert-width;\n  text-align: center;\n  left: 50%;\n  margin-left: -@alert-width / 2;\n\n  .alert {\n    display: none;\n    background: #eeefdf;\n\n    padding: 10px 20px;\n\n    line-height: 20px;\n    margin: 0 auto 10px;\n\n    &.open {\n      display: inline-flex;\n    }\n  }\n}\n\n.io-toggle-fullscreen {\n  display: none;\n\n  &.open {\n    display: inline-block;\n  }\n}\n\n\n@media (max-width: (@alert-width + 50 )) {\n  .io-alerts {\n    width: 100%;\n    text-align: center;\n    left: 0;\n    margin: 0;\n  }\n}\n\n\n/**\n * dialogs\n */\n.io-dialog {\n  display: none;\n\n  &.open {\n    display: block;\n  }\n\n  &.open:before {\n    content: \'\';\n    position: fixed;\n    left: 0;\n    top: 0;\n    bottom: 0;\n    right: 0;\n\n    background: #666;\n    opacity: 0.2;\n\n    z-index: 1001;\n  }\n\n  .content {\n    position: fixed;\n\n    width: @dialog-width;\n    left: 50%;\n    transform: translateX(-50%);\n    top: 100px;\n\n    background: white;\n    padding: 10px 30px 20px 30px;\n\n    box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);\n    border-radius: 2px;\n\n    height: auto;\n\n    z-index: 1001;\n  }\n\n}\n\n.keybindings-dialog {\n\n  .content {\n    width: @alert-width;\n    margin-left: -@alert-width / 2;\n  }\n\n  .binding {\n    padding: 5px 10px;\n    font-family: monospace;\n  }\n}\n\ntextarea.error-log {\n  border: solid 1px #CCC;\n  background: #F6F6F6;\n  padding: 10px;\n\n  margin: 10px auto;\n\n  width: 100%;\n\n  min-height: 150px;\n\n  display: block;\n\n  &:hover {\n    background: lighten(#F6F6F6, 1%);\n  }\n}\n\n@media (max-width: @dialog-width) {\n  .io-dialog .content {\n    left: 20px;\n    right: 20px;\n    top: 20px;\n    width: auto;\n\n    margin: 0;\n  }\n}\n\n\n.spinner-border {\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  background: white;\n  z-index: 200;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n\n@keyframes spinner-keyframe {\n  0% {\n    transform: rotate(0deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n}\n\n.spinner-border:after {\n  width: 22px;\n  height: 22px;\n  border: 4px solid @loader-color;\n  content: " ";\n  display: block;\n  border-radius: 50%;\n  border-color: @loader-color @loader-color @loader-color transparent;\n  animation: spinner-keyframe 0.7s linear infinite;\n}', ":full-screen .icon-resize:before {\n  content: '\\e86e'; /* see .icon-resize-small:before */\n}\n\n:-moz-full-screen .icon-resize:before {\n  content: '\\e86e'; /* see .icon-resize-small:before */\n}\n\n:-ms-full-screen .icon-resize:before {\n  content: '\\e86e'; /* see .icon-resize-small:before */\n}\n\n:-webkit-full-screen .icon-resize:before {\n  content: '\\e86e'; /* see .icon-resize-small:before */\n}\n\n.icon-resize:before {\n  content: '\\e86d'; /* see .icon-resize-full:before */\n}\n\n.icon-resize:before {\n  content: '\\e86d'; /* see .icon-resize-full:before */\n}\n\n.icon-resize:before {\n  content: '\\e86d'; /* see .icon-resize-full:before */\n}\n\n.icon-resize:before {\n  content: '\\e86d'; /* see .icon-resize-full:before */\n}\n", '.drop-overlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  bottom: 0;\n  right: 0;\n\n  padding: 50px;\n\n  background: rgba(255, 255, 255, .9);\n\n  z-index: 1000;\n}\n\n.drop-overlay .box {\n  text-align: center;\n  border: dashed 4px #CCC;\n  height: 100%;\n  width: 100%;\n  display: table;\n}\n\n.drop-overlay .label {\n  font-size: 26px;\n  color: #888;\n  margin: auto;\n\n  display: table-cell;\n  vertical-align: middle;\n}'],
        sourceRoot: ''
      }])
      const b = f
    },
    5072: e => {
      'use strict'
      const t = []
      function n (e) {
        for (var n = -1, r = 0; r < t.length; r++) {
          if (t[r].identifier === e) {
            n = r
            break
          }
        }
        return n
      }
      function r (e, r) {
        for (var i = {}, a = [], s = 0; s < e.length; s++) {
          const c = e[s]
          const l = r.base ? c[0] + r.base : c[0]
          const p = i[l] || 0
          const u = ''.concat(l, ' ').concat(p)
          i[l] = p + 1
          const d = n(u)
          const f = {
            css: c[1],
            media: c[2],
            sourceMap: c[3],
            supports: c[4],
            layer: c[5]
          }
          if (d !== -1) {
            t[d].references++,
            t[d].updater(f)
          } else {
            const h = o(f, r)
            r.byIndex = s,
            t.splice(s, 0, {
              identifier: u,
              updater: h,
              references: 1
            })
          }
          a.push(u)
        }
        return a
      }
      function o (e, t) {
        const n = t.domAPI(t)
        return n.update(e),
        function (t) {
          if (t) {
            if (t.css === e.css && t.media === e.media && t.sourceMap === e.sourceMap && t.supports === e.supports && t.layer === e.layer) { return }
            n.update(e = t)
          } else { n.remove() }
        }
      }
      e.exports = function (e, o) {
        let i = r(e = e || [], o = o || {})
        return function (e) {
          e = e || []
          for (let a = 0; a < i.length; a++) {
            const s = n(i[a])
            t[s].references--
          }
          for (var c = r(e, o), l = 0; l < i.length; l++) {
            const p = n(i[l])
            t[p].references === 0 && (t[p].updater(),
            t.splice(p, 1))
          }
          i = c
        }
      }
    },
    7659: e => {
      'use strict'
      const t = {}
      e.exports = function (e, n) {
        const r = (function (e) {
          if (void 0 === t[e]) {
            let n = document.querySelector(e)
            if (window.HTMLIFrameElement && n instanceof window.HTMLIFrameElement) {
              try {
                n = n.contentDocument.head
              } catch (e) {
                n = null
              }
            }
            t[e] = n
          }
          return t[e]
        }(e))
        if (!r) { throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.") }
        r.appendChild(n)
      }
    },
    540: e => {
      'use strict'
      e.exports = function (e) {
        const t = document.createElement('style')
        return e.setAttributes(t, e.attributes),
        e.insert(t, e.options),
        t
      }
    },
    5056: (e, t, n) => {
      'use strict'
      e.exports = function (e) {
        const t = n.nc
        t && e.setAttribute('nonce', t)
      }
    },
    7825: e => {
      'use strict'
      e.exports = function (e) {
        if (typeof document === 'undefined') {
          return {
            update: function () {},
            remove: function () {}
          }
        }
        const t = e.insertStyleElement(e)
        return {
          update: function (n) {
            !(function (e, t, n) {
              let r = ''
              n.supports && (r += '@supports ('.concat(n.supports, ') {')),
              n.media && (r += '@media '.concat(n.media, ' {'))
              const o = void 0 !== n.layer
              o && (r += '@layer'.concat(n.layer.length > 0 ? ' '.concat(n.layer) : '', ' {')),
              r += n.css,
              o && (r += '}'),
              n.media && (r += '}'),
              n.supports && (r += '}')
              const i = n.sourceMap
              i && typeof btoa !== 'undefined' && (r += '\n/*# sourceMappingURL=data:application/json;base64,'.concat(btoa(unescape(encodeURIComponent(JSON.stringify(i)))), ' */')),
              t.styleTagTransform(r, e, t.options)
            }(t, e, n))
          },
          remove: function () {
            !(function (e) {
              if (e.parentNode === null) { return !1 }
              e.parentNode.removeChild(e)
            }(t))
          }
        }
      }
    },
    1113: e => {
      'use strict'
      e.exports = function (e, t) {
        if (t.styleSheet) { t.styleSheet.cssText = e } else {
          for (; t.firstChild;) { t.removeChild(t.firstChild) }
          t.appendChild(document.createTextNode(e))
        }
      }
    },
    4506: (e, t, n) => {
      'use strict'
      e.exports = n.p + '04571a21e4bc6c420f37.eot?42391129'
    },
    6788: (e, t, n) => {
      'use strict'
      e.exports = n.p + 'b3234f2e848581518630.svg?42391129'
    },
    5064: (e, t, n) => {
      'use strict'
      e.exports = n.p + 'a77bafbab2ad2d043094.ttf?42391129'
    },
    8536: (e, t, n) => {
      'use strict'
      e.exports = n.p + '8fc1bc750c78908c228d.woff?42391129'
    },
    7948: (e, t, n) => {
      'use strict'
      e.exports = n.p + '1e08c7f04f4855050724.eot?21877404'
    },
    7046: (e, t, n) => {
      'use strict'
      e.exports = n.p + 'cb4be0230caf509ac475.svg?21877404'
    },
    6426: (e, t, n) => {
      'use strict'
      e.exports = n.p + '2185c437d9db32386425.ttf?21877404'
    },
    3816: (e, t, n) => {
      'use strict'
      e.exports = n.p + '9c989372615cb2cfbaa6.woff2?21877404'
    },
    6474: (e, t, n) => {
      'use strict'
      e.exports = n.p + '8809b45a3f0566911799.woff?21877404'
    },
    1958: (e, t, n) => {
      'use strict'
      e.exports = n.p + '63c48a0f2165ec449481.svg'
    }
  }
  const t = {}
  function n (r) {
    const o = t[r]
    if (void 0 !== o) { return o.exports }
    const i = t[r] = {
      id: r,
      loaded: !1,
      exports: {}
    }
    return e[r].call(i.exports, i, i.exports, n),
    i.loaded = !0,
    i.exports
  }
  n.m = e,
  n.n = e => {
    const t = e && e.__esModule ? () => e.default : () => e
    return n.d(t, {
      a: t
    }),
    t
  }
  ,
  n.d = (e, t) => {
    for (const r in t) {
      n.o(t, r) && !n.o(e, r) && Object.defineProperty(e, r, {
        enumerable: !0,
        get: t[r]
      })
    }
  }
  ,
  n.g = (function () {
    if (typeof globalThis === 'object') { return globalThis }
    try {
      return this || new Function('return this')()
    } catch (e) {
      if (typeof window === 'object') { return window }
    }
  }()),
  n.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t),
  n.nmd = e => (e.paths = [],
  e.children || (e.children = []),
  e),
  (() => {
    let e
    n.g.importScripts && (e = n.g.location + '')
    const t = n.g.document
    if (!e && t && (t.currentScript && (e = t.currentScript.src),
    !e)) {
      const r = t.getElementsByTagName('script')
      if (r.length) {
        for (let o = r.length - 1; o > -1 && (!e || !/^http(s?):/.test(e));) { e = r[o--].src }
      }
    }
    if (!e) { throw new Error('Automatic publicPath is not supported in this browser') }
    e = e.replace(/#.*$/, '').replace(/\?.*$/, '').replace(/\/[^\/]+$/, '/'),
    n.p = e + '../'
  }
  )(),
  n.b = document.baseURI || self.location.href,
  n.nc = void 0,
  (() => {
    'use strict'
    const e = n(5072)
    const t = n.n(e)
    const r = n(7825)
    const o = n.n(r)
    const i = n(7659)
    const a = n.n(i)
    const s = n(5056)
    const c = n.n(s)
    const l = n(540)
    const p = n.n(l)
    const u = n(1113)
    const d = n.n(u)
    const f = n(9348)
    const h = {}
    h.styleTagTransform = d(),
    h.setAttributes = c(),
    h.insert = a().bind(null, 'head'),
    h.domAPI = o(),
    h.insertStyleElement = p(),
    t()(f.A, h),
    f.A && f.A.locals && f.A.locals
    const m = n(7491)
    const v = {}
    v.styleTagTransform = d(),
    v.setAttributes = c(),
    v.insert = a().bind(null, 'head'),
    v.domAPI = o(),
    v.insertStyleElement = p(),
    t()(m.A, v),
    m.A && m.A.locals && m.A.locals
    const g = n(2961)
    const y = {}
    y.styleTagTransform = d(),
    y.setAttributes = c(),
    y.insert = a().bind(null, 'head'),
    y.domAPI = o(),
    y.insertStyleElement = p(),
    t()(g.A, y),
    g.A && g.A.locals && g.A.locals
    const b = n(75)
    const A = {}
    A.styleTagTransform = d(),
    A.setAttributes = c(),
    A.insert = a().bind(null, 'head'),
    A.domAPI = o(),
    A.insertStyleElement = p(),
    t()(b.A, A),
    b.A && b.A.locals && b.A.locals
    const E = n(9745)
    const x = {}
    function w (e, t) {
      t && (e.super_ = t,
      e.prototype = Object.create(t.prototype, {
        constructor: {
          value: e,
          enumerable: !1,
          writable: !0,
          configurable: !0
        }
      }))
    }
    x.styleTagTransform = d(),
    x.setAttributes = c(),
    x.insert = a().bind(null, 'head'),
    x.domAPI = o(),
    x.insertStyleElement = p(),
    t()(E.A, x),
    E.A && E.A.locals && E.A.locals
    let _; let C; const S = (_ = function (e) {
      var t = e.exports = function (e, n) {
        if (n || (n = 16),
        void 0 === e && (e = 128),
        e <= 0) { return '0' }
        for (var r = Math.log(Math.pow(2, e)) / Math.log(n), o = 2; r === 1 / 0; o *= 2) { r = Math.log(Math.pow(2, e / o)) / Math.log(n) * o }
        const i = r - Math.floor(r)
        let a = ''
        for (o = 0; o < Math.floor(r); o++) { a = Math.floor(Math.random() * n).toString(n) + a }
        if (i) {
          const s = Math.pow(n, i)
          a = Math.floor(Math.random() * s).toString(n) + a
        }
        const c = parseInt(a, n)
        return c !== 1 / 0 && c >= Math.pow(2, e) ? t(e, n) : a
      }

      t.rack = function (e, n, r) {
        const o = function (o) {
          let a = 0
          do {
            if (a++ > 10) {
              if (!r) { throw new Error('too many ID collisions, use more bits') }
              e += r
            }
            var s = t(e, n)
          } while (Object.hasOwnProperty.call(i, s))
          return i[s] = o,
          s
        }
        var i = o.hats = {}
        return o.get = function (e) {
          return o.hats[e]
        }
        ,
        o.set = function (e, t) {
          return o.hats[e] = t,
          o
        }
        ,
        o.bits = e || 128,
        o.base = n || 16,
        o
      }
    }
    ,
    _(C = {
      exports: {}
    }),
    C.exports)
    function k (e) {
      if (!(this instanceof k)) { return new k(e) }
      e = e || [128, 36, 1],
      this._seed = e.length ? S.rack(e[0], e[1], e[2]) : e
    }
    k.prototype.next = function (e) {
      return this._seed(e || !0)
    }
    ,
    k.prototype.nextPrefixed = function (e, t) {
      let n
      do {
        n = e + this.next(!0)
      } while (this.assigned(n))
      return this.claim(n, t),
      n
    }
    ,
    k.prototype.claim = function (e, t) {
      this._seed.set(e, t || !0)
    }
    ,
    k.prototype.assigned = function (e) {
      return this._seed.get(e) || !1
    }
    ,
    k.prototype.unclaim = function (e) {
      delete this._seed.hats[e]
    }
    ,
    k.prototype.clear = function () {
      let e; const t = this._seed.hats
      for (e in t) { this.unclaim(e) }
    }

    const j = k
    function B (e) {
      return B = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      B(e)
    }
    function D (e) {
      return Array.prototype.concat.apply([], e)
    }
    const P = Object.prototype.toString
    const O = Object.prototype.hasOwnProperty
    function T (e) {
      return void 0 === e
    }
    function R (e) {
      return void 0 !== e
    }
    function N (e) {
      return e == null
    }
    function M (e) {
      return P.call(e) === '[object Array]'
    }
    function I (e) {
      return P.call(e) === '[object Object]'
    }
    function L (e) {
      return P.call(e) === '[object Number]'
    }
    function z (e) {
      const t = P.call(e)
      return t === '[object Function]' || t === '[object AsyncFunction]' || t === '[object GeneratorFunction]' || t === '[object AsyncGeneratorFunction]' || t === '[object Proxy]'
    }
    function F (e) {
      return P.call(e) === '[object String]'
    }
    function $ (e, t) {
      return O.call(e, t)
    }
    function H (e, t) {
      let n; const r = oe(t)
      return G(e, function (e, t) {
        if (r(e, t)) {
          return n = e,
          !1
        }
      }
      ),
      n
    }
    function q (e, t) {
      const n = oe(t)
      let r = M(e) ? -1 : void 0
      return G(e, function (e, t) {
        if (n(e, t)) {
          return r = t,
          !1
        }
      }
      ),
      r
    }
    function W (e, t) {
      const n = oe(t)
      const r = []
      return G(e, function (e, t) {
        n(e, t) && r.push(e)
      }
      ),
      r
    }
    function G (e, t) {
      let n
      if (!T(e)) {
        const r = M(e) ? ae : ie
        for (const o in e) {
          if ($(e, o) && !1 === t(n = e[o], r(o))) { return n }
        }
      }
    }
    function U (e, t, n) {
      return G(e, function (e, r) {
        n = t(n, e, r)
      }
      ),
      n
    }
    function V (e, t) {
      return !!U(e, function (e, n, r) {
        return e && t(n, r)
      }
      , !0)
    }
    function Q (e, t) {
      return !!H(e, t)
    }
    function Y (e, t) {
      const n = []
      return G(e, function (e, r) {
        n.push(t(e, r))
      }
      ),
      n
    }
    function K (e) {
      return e && Object.keys(e) || []
    }
    function J (e) {
      return Y(e, function (e) {
        return e
      }
      )
    }
    function X (e, t) {
      const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
      return t = re(t),
      G(e, function (e) {
        const r = t(e) || '_'
        let o = n[r]
        o || (o = n[r] = []),
        o.push(e)
      }
      ),
      n
    }
    function Z (e) {
      e = re(e)
      for (var t = {}, n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++) { r[o - 1] = arguments[o] }
      return G(r, function (n) {
        return X(n, e, t)
      }
      ),
      Y(t, function (e, t) {
        return e[0]
      }
      )
    }
    const ee = Z
    function te (e, t) {
      t = re(t)
      const n = []
      return G(e, function (e, r) {
        for (var o = t(e, r), i = {
            d: o,
            v: e
          }, a = 0; a < n.length; a++) {
          if (o < n[a].d) { return void n.splice(a, 0, i) }
        }
        n.push(i)
      }
      ),
      Y(n, function (e) {
        return e.v
      }
      )
    }
    function ne (e) {
      return function (t) {
        return V(e, function (e, n) {
          return t[n] === e
        }
        )
      }
    }
    function re (e) {
      return z(e)
        ? e
        : function (t) {
          return t[e]
        }
    }
    function oe (e) {
      return z(e)
        ? e
        : function (t) {
          return t === e
        }
    }
    function ie (e) {
      return e
    }
    function ae (e) {
      return Number(e)
    }
    function se (e, t) {
      let n, r, o, i
      function a (n) {
        const a = Date.now()
        const l = n ? 0 : i + t - a
        if (l > 0) { return s(l) }
        e.apply(o, r),
        c()
      }
      function s (e) {
        n = setTimeout(a, e)
      }
      function c () {
        n && clearTimeout(n),
        n = i = r = o = void 0
      }
      function l () {
        i = Date.now()
        for (var e = arguments.length, a = new Array(e), c = 0; c < e; c++) { a[c] = arguments[c] }
        r = a,
        o = this,
        n || s(t)
      }
      return l.flush = function () {
        n && a(!0),
        c()
      }
      ,
      l.cancel = c,
      l
    }
    function ce (e, t) {
      return e.bind(t)
    }
    function le (e) {
      for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) { n[r - 1] = arguments[r] }
      return Object.assign.apply(Object, [e].concat(n))
    }
    function pe (e, t) {
      const n = {}
      const r = Object(e)
      return G(t, function (t) {
        t in r && (n[t] = e[t])
      }
      ),
      n
    }
    function ue (e, t) {
      const n = {}
      return G(Object(e), function (e, r) {
        t.indexOf(r) === -1 && (n[r] = e)
      }
      ),
      n
    }
    function de (e, t) {
      return t.forEach(function (t) {
        t && typeof t !== 'string' && !Array.isArray(t) && Object.keys(t).forEach(function (n) {
          if (n !== 'default' && !(n in e)) {
            const r = Object.getOwnPropertyDescriptor(t, n)
            Object.defineProperty(e, n, r.get
              ? r
              : {
                  enumerable: !0,
                  get: function () {
                    return t[n]
                  }
                })
          }
        }
        )
      }
      ),
      Object.freeze(e)
    }
    const fe = Object.prototype.toString
    const he = Object.prototype.hasOwnProperty
    function me (e, t) {
      return he.call(e, t)
    }
    function ve (e, t) {
      let n, r
      if (void 0 !== e) {
        const o = (r = e,
        fe.call(r) === '[object Array]' ? ye : ge)
        for (const i in e) {
          if (me(e, i) && !1 === t(n = e[i], o(i))) { return n }
        }
      }
    }
    function ge (e) {
      return e
    }
    function ye (e) {
      return Number(e)
    }
    function be (e) {
      for (var t = e.style, n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++) { r[o - 1] = arguments[o] }
      return ve(r, function (e) {
        e && ve(e, function (e, n) {
          t[n] = e
        }
        )
      }
      ),
      e
    }
    const Ae = Object.prototype.toString
    function Ee (e) {
      return new xe(e)
    }
    function xe (e) {
      if (!e || !e.nodeType) { throw new Error('A DOM element reference is required') }
      this.el = e,
      this.list = e.classList
    }
    function we (e, t) {
      return e && typeof e.matches === 'function' && e.matches(t)
    }
    xe.prototype.add = function (e) {
      return this.list.add(e),
      this
    }
    ,
    xe.prototype.remove = function (e) {
      return Ae.call(e) == '[object RegExp]'
        ? this.removeMatching(e)
        : (this.list.remove(e),
          this)
    }
    ,
    xe.prototype.removeMatching = function (e) {
      for (let t = this.array(), n = 0; n < t.length; n++) { e.test(t[n]) && this.remove(t[n]) }
      return this
    }
    ,
    xe.prototype.toggle = function (e, t) {
      return void 0 !== t ? t !== this.list.toggle(e, t) && this.list.toggle(e) : this.list.toggle(e),
      this
    }
    ,
    xe.prototype.array = function () {
      return Array.from(this.list)
    }
    ,
    xe.prototype.has = xe.prototype.contains = function (e) {
      return this.list.contains(e)
    }

    let _e; let Ce; let Se; const ke = {}
    function je () {
      _e = window.addEventListener ? 'addEventListener' : 'attachEvent',
      Ce = window.removeEventListener ? 'removeEventListener' : 'detachEvent',
      Se = _e !== 'addEventListener' ? 'on' : ''
    }
    let Be; const De = ke.bind = function (e, t, n, r) {
      return _e || je(),
      e[_e](Se + t, n, r || !1),
      n
    }
    const Pe = ke.unbind = function (e, t, n, r) {
      return Ce || je(),
      e[Ce](Se + t, n, r || !1),
      n
    }
    const Oe = de({
      __proto__: null,
      bind: De,
      unbind: Pe,
      default: ke
    }, [ke]); const Te = ['focus', 'blur']; const Re = {
      bind: function (e, t, n, r, o) {
        return Te.indexOf(n) !== -1 && (o = !0),
        Oe.bind(e, n, function (n) {
          const o = n.target || n.srcElement
          n.delegateTarget = (function (e, t, n) {
            for (var r = e; r && r.nodeType !== document.DOCUMENT_NODE && r.nodeType !== document.DOCUMENT_FRAGMENT_NODE;) {
              if (we(r, t)) { return r }
              r = r.parentNode
            }
            return we(r, t) ? r : null
          }(o, t)),
          n.delegateTarget && r.call(e, n)
        }
        , o)
      },
      unbind: function (e, t, n, r) {
        return Te.indexOf(t) !== -1 && (r = !0),
        Oe.unbind(e, t, n, r)
      }
    }; let Ne = !1
    typeof document !== 'undefined' && ((Be = document.createElement('div')).innerHTML = '  <link/><table></table><a href="/a">a</a><input type="checkbox"/>',
    Ne = !Be.getElementsByTagName('link').length,
    Be = void 0)
    const Me = {
      legend: [1, '<fieldset>', '</fieldset>'],
      tr: [2, '<table><tbody>', '</tbody></table>'],
      col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
      _default: Ne ? [1, 'X<div>', '</div>'] : [0, '', '']
    }
    Me.td = Me.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'],
    Me.option = Me.optgroup = [1, '<select multiple="multiple">', '</select>'],
    Me.thead = Me.tbody = Me.colgroup = Me.caption = Me.tfoot = [1, '<table>', '</table>'],
    Me.polyline = Me.ellipse = Me.polygon = Me.circle = Me.text = Me.line = Me.path = Me.rect = Me.g = [1, '<svg xmlns="http://www.w3.org/2000/svg" version="1.1">', '</svg>']
    const Ie = function (e, t) {
      if (typeof e !== 'string') { throw new TypeError('String expected') }
      t || (t = document)
      const n = /<([\w:]+)/.exec(e)
      if (!n) { return t.createTextNode(e) }
      e = e.replace(/^\s+|\s+$/g, '')
      const r = n[1]
      if (r == 'body') {
        return (o = t.createElement('html')).innerHTML = e,
        o.removeChild(o.lastChild)
      }
      let o; const i = Object.prototype.hasOwnProperty.call(Me, r) ? Me[r] : Me._default; let a = i[0]; const s = i[1]; const c = i[2]
      for ((o = t.createElement('div')).innerHTML = s + e + c; a--;) { o = o.lastChild }
      if (o.firstChild == o.lastChild) { return o.removeChild(o.firstChild) }
      for (var l = t.createDocumentFragment(); o.firstChild;) { l.appendChild(o.removeChild(o.firstChild)) }
      return l
    }
    function Le (e, t) {
      return (t = t || document).querySelector(e)
    }
    function ze (e, t) {
      return t.appendChild(function (e, t) {
        if (e.ownerDocument !== t.ownerDocument) {
          try {
            return t.ownerDocument.importNode(e, !0)
          } catch (e) {}
        }
        return e
      }(e, t))
    }
    function Fe (e, t) {
      return ze(t, e),
      e
    }
    const $e = 2
    const He = {
      'alignment-baseline': 1,
      'baseline-shift': 1,
      clip: 1,
      'clip-path': 1,
      'clip-rule': 1,
      color: 1,
      'color-interpolation': 1,
      'color-interpolation-filters': 1,
      'color-profile': 1,
      'color-rendering': 1,
      cursor: 1,
      direction: 1,
      display: 1,
      'dominant-baseline': 1,
      'enable-background': 1,
      fill: 1,
      'fill-opacity': 1,
      'fill-rule': 1,
      filter: 1,
      'flood-color': 1,
      'flood-opacity': 1,
      font: 1,
      'font-family': 1,
      'font-size': $e,
      'font-size-adjust': 1,
      'font-stretch': 1,
      'font-style': 1,
      'font-variant': 1,
      'font-weight': 1,
      'glyph-orientation-horizontal': 1,
      'glyph-orientation-vertical': 1,
      'image-rendering': 1,
      kerning: 1,
      'letter-spacing': 1,
      'lighting-color': 1,
      marker: 1,
      'marker-end': 1,
      'marker-mid': 1,
      'marker-start': 1,
      mask: 1,
      opacity: 1,
      overflow: 1,
      'pointer-events': 1,
      'shape-rendering': 1,
      'stop-color': 1,
      'stop-opacity': 1,
      stroke: 1,
      'stroke-dasharray': 1,
      'stroke-dashoffset': 1,
      'stroke-linecap': 1,
      'stroke-linejoin': 1,
      'stroke-miterlimit': 1,
      'stroke-opacity': 1,
      'stroke-width': $e,
      'text-anchor': 1,
      'text-decoration': 1,
      'text-rendering': 1,
      'unicode-bidi': 1,
      visibility: 1,
      'word-spacing': 1,
      'writing-mode': 1
    }
    function qe (e, t, n) {
      const r = t.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase()
      const o = He[r]
      o
        ? (o === $e && typeof n === 'number' && (n = String(n) + 'px'),
          e.style[r] = n)
        : e.setAttributeNS(null, t, n)
    }
    function We (e, t, n) {
      if (typeof t === 'string') {
        if (void 0 === n) {
          return (function (e, t) {
            return He[t] ? e.style[t] : e.getAttributeNS(null, t)
          }(e, t))
        }
        qe(e, t, n)
      } else {
        !(function (e, t) {
          let n; let r; const o = Object.keys(t)
          for (n = 0; r = o[n]; n++) { qe(e, r, t[r]) }
        }(e, t))
      }
      return e
    }
    const Ge = Object.prototype.toString
    function Ue (e) {
      return new Ve(e)
    }
    function Ve (e) {
      if (!e || !e.nodeType) { throw new Error('A DOM element reference is required') }
      this.el = e,
      this.list = e.classList
    }
    function Qe (e) {
      const t = e.parentNode
      return t && t.removeChild(e),
      e
    }
    function Ye (e) {
      for (var t; t = e.firstChild;) { Qe(t) }
      return e
    }
    function Ke (e) {
      return e.cloneNode(!0)
    }
    Ve.prototype.add = function (e) {
      return this.list.add(e),
      this
    }
    ,
    Ve.prototype.remove = function (e) {
      return Ge.call(e) == '[object RegExp]'
        ? this.removeMatching(e)
        : (this.list.remove(e),
          this)
    }
    ,
    Ve.prototype.removeMatching = function (e) {
      for (let t = this.array(), n = 0; n < t.length; n++) { e.test(t[n]) && this.remove(t[n]) }
      return this
    }
    ,
    Ve.prototype.toggle = function (e, t) {
      return void 0 !== t ? t !== this.list.toggle(e, t) && this.list.toggle(e) : this.list.toggle(e),
      this
    }
    ,
    Ve.prototype.array = function () {
      return Array.from(this.list)
    }
    ,
    Ve.prototype.has = Ve.prototype.contains = function (e) {
      return this.list.contains(e)
    }

    const Je = {
      svg: 'http://www.w3.org/2000/svg'
    }
    const Xe = '<svg xmlns="' + Je.svg + '"'
    function Ze (e) {
      let t = !1
      e.substring(0, 4) === '<svg'
        ? e.indexOf(Je.svg) === -1 && (e = Xe + e.substring(4))
        : (e = Xe + '>' + e + '</svg>',
          t = !0)
      const n = (function (e) {
        let t
        return (t = new DOMParser()).async = !1,
        t.parseFromString(e, 'text/xml')
      }(e))
      if (!t) { return n }
      for (var r = document.createDocumentFragment(), o = n.firstChild; o.firstChild;) { r.appendChild(o.firstChild) }
      return r
    }
    function et (e, t) {
      let n
      return e.charAt(0) === '<'
        ? (n = Ze(e).firstChild,
          n = document.importNode(n, !0))
        : n = document.createElementNS(Je.svg, e),
      t && We(n, t),
      n
    }
    let tt = null
    function nt () {
      return tt === null && (tt = et('svg')),
      tt
    }
    function rt (e, t) {
      let n; let r; const o = Object.keys(t)
      for (n = 0; r = o[n]; n++) { e[r] = t[r] }
      return e
    }
    function ot (e) {
      return e ? nt().createSVGTransformFromMatrix(e) : nt().createSVGTransform()
    }
    const it = /([&<>]{1})/g
    const at = /([\n\r"]{1})/g
    const st = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': "'"
    }
    function ct (e, t) {
      return e.replace(t, function (e, t) {
        return st[t] || t
      }
      )
    }
    function lt (e, t) {
      let n, r, o, i, a
      switch (e.nodeType) {
        case 3:
          t.push(ct(e.textContent, it))
          break
        case 1:
          if (t.push('<', e.tagName),
          e.hasAttributes()) {
            for (n = 0,
            r = (o = e.attributes).length; n < r; ++n) {
              i = o.item(n),
              t.push(' ', i.name, '="', ct(i.value, at), '"')
            }
          }
          if (e.hasChildNodes()) {
            for (t.push('>'),
            n = 0,
            r = (a = e.childNodes).length; n < r; ++n) { lt(a.item(n), t) }
            t.push('</', e.tagName, '>')
          } else { t.push('/>') }
          break
        case 8:
          t.push('\x3c!--', ct(e.nodeValue, it), '--\x3e')
          break
        case 4:
          t.push('<![CDATA[', e.nodeValue, ']]>')
          break
        default:
          throw new Error('unable to handle node ' + e.nodeType)
      }
      return t
    }
    function pt (e, t) {
      if (void 0 !== t) {
        try {
          !(function (e, t) {
            let n = Ze(t)
            if (Ye(e),
            t) {
              n.nodeName === '#document-fragment' || (n = n.documentElement)
              for (var r, o = (r = n.childNodes,
                Array.prototype.slice.call(r)), i = 0; i < o.length; i++) { ze(o[i], e) }
            }
          }(e, t))
        } catch (e) {
          throw new Error('error parsing SVG: ' + e.message)
        }
        return e
      }
      return (function (e) {
        for (var t = e.firstChild, n = []; t;) {
          lt(t, n),
          t = t.nextSibling
        }
        return n.join('')
      }(e))
    }
    function ut (e, t) {
      return t instanceof SVGMatrix ? e.createSVGTransformFromMatrix(t) : t
    }
    function dt (e, t) {
      const n = e.transform.baseVal
      return t && (Array.isArray(t) || (t = [t]),
      (function (e, t) {
        let n, r
        for (e.clear(),
        n = 0; r = t[n]; n++) { e.appendItem(ut(e, r)) }
      }(n, t))),
      n.consolidate()
    }
    function ft (e) {
      return (function (e) {
        if (Array.isArray(e)) { return ht(e) }
      }(e)) || (function (e) {
        if (typeof Symbol !== 'undefined' && e[Symbol.iterator] != null || e['@@iterator'] != null) { return Array.from(e) }
      }(e)) || (function (e, t) {
        if (e) {
          if (typeof e === 'string') { return ht(e, t) }
          let n = Object.prototype.toString.call(e).slice(8, -1)
          return n === 'Object' && e.constructor && (n = e.constructor.name),
          n === 'Map' || n === 'Set' ? Array.from(e) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? ht(e, t) : void 0
        }
      }(e)) || (function () {
        throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
      }())
    }
    function ht (e, t) {
      (t == null || t > e.length) && (t = e.length)
      for (var n = 0, r = new Array(t); n < t; n++) { r[n] = e[n] }
      return r
    }
    const mt = /^class[ {]/
    function vt (e) {
      return Array.isArray(e)
    }
    function gt (e, t) {
      return Object.prototype.hasOwnProperty.call(e, t)
    }
    function yt () {
      for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) { t[n] = arguments[n] }
      t.length === 1 && vt(t[0]) && (t = t[0])
      const r = (t = ft(t)).pop()
      return r.$inject = t,
      r
    }
    const bt = /constructor\s*[^(]*\(\s*([^)]*)\)/m
    const At = /^(?:async\s+)?(?:function\s*[^(]*)?(?:\(\s*([^)]*)\)|(\w+))/m
    const Et = /\/\*([^*]*)\*\//m
    function xt (e) {
      if (typeof e !== 'function') { throw new Error('Cannot annotate "'.concat(e, '". Expected a function!')) }
      const t = e.toString().match((function (e) {
        return mt.test(e.toString())
      }(e))
        ? bt
        : At)
      if (!t) { return [] }
      const n = t[1] || t[2]
      return n && n.split(',').map(function (e) {
        const t = e.match(Et)
        return (t && t[1] || e).trim()
      }
      ) || []
    }
    function wt (e, t) {
      const n = t || {
        get: function (e, t) {
          if (r.push(e),
          !1 === t) { return null }
          throw s('No provider for "'.concat(e, '"!'))
        }
      }
      var r = []
      const o = this._providers = Object.create(n._providers || null)
      const i = this._instances = Object.create(null)
      const a = i.injector = this
      var s = function (e) {
        const t = r.join(' -> ')
        return r.length = 0,
        new Error(t ? ''.concat(e, ' (Resolving: ').concat(t, ')') : e)
      }
      function c (e, t) {
        if (!o[e] && e.includes('.')) {
          for (var a = e.split('.'), l = c(a.shift()); a.length;) { l = l[a.shift()] }
          return l
        }
        if (gt(i, e)) { return i[e] }
        if (gt(o, e)) {
          if (r.indexOf(e) !== -1) {
            throw r.push(e),
            s('Cannot resolve circular dependency!')
          }
          return r.push(e),
          i[e] = o[e][0](o[e][1]),
          r.pop(),
          i[e]
        }
        return n.get(e, t)
      }
      function l (e, t) {
        if (void 0 === t && (t = {}),
        typeof e !== 'function') {
          if (!vt(e)) { throw s('Cannot invoke "'.concat(e, '". Expected a function!')) }
          e = yt(e.slice())
        }
        return {
          fn: e,
          dependencies: (e.$inject || xt(e)).map(function (e) {
            return gt(t, e) ? t[e] : c(e)
          }
          )
        }
      }
      function p (e) {
        let t; const n = l(e); const r = n.fn; const o = n.dependencies
        return new ((t = Function.prototype.bind).call.apply(t, [r, null].concat(ft(o))))()
      }
      function u (e, t, n) {
        const r = l(e, n)
        const o = r.fn
        const i = r.dependencies
        return o.apply(t, i)
      }
      function d (e, t) {
        if (t && t.length) {
          let n; let r; let i; let s; const c = Object.create(null); const l = Object.create(null); const p = []; const u = []; const d = []; const f = function (e) {
            let a
            n = o[e],
            t.indexOf(e) !== -1 && (n[2] === 'private'
              ? (r = p.indexOf(n[3])) === -1
                  ? (i = n[3].createChild([], t),
                    a = i,
                    s = yt(function (e) {
                      return a.get(e)
                    }
                    ),
                    p.push(n[3]),
                    u.push(i),
                    d.push(s),
                    c[e] = [s, e, 'private', i])
                  : c[e] = [d[r], e, 'private', u[r]]
              : c[e] = [n[2], n[1]],
            l[e] = !0),
            n[2] !== 'factory' && n[2] !== 'type' || !n[1].$scope || t.forEach(function (t) {
              n[1].$scope.indexOf(t) !== -1 && (c[e] = [n[2], n[1]],
              l[t] = !0)
            }
            )
          }
          for (const h in o) { f(h) }
          t.forEach(function (e) {
            if (!l[e]) { throw new Error('No provider for "' + e + '". Cannot use provider from the parent!') }
          }
          ),
          e.unshift(c)
        }
        return new wt(e, a)
      }
      let f; let h; const m = {
        factory: u,
        type: p,
        value: function (e) {
          return e
        }
      }
      function v (e, t) {
        const n = e.__init__ || []
        return function () {
          n.forEach(function (e) {
            typeof e === 'string' ? t.get(e) : t.invoke(e)
          }
          )
        }
      }
      this.get = c,
      this.invoke = u,
      this.instantiate = p,
      this.createChild = d,
      this.init = (f = e.reduce(function e (t, n) {
        return t.indexOf(n) !== -1 || (t = (n.__depends__ || []).reduce(e, t)).indexOf(n) !== -1 ? t : t.concat(n)
      }
      , []).map(function (e) {
        const t = e.__exports__
        if (t) {
          const n = e.__modules__
          const r = Object.keys(e).reduce(function (t, n) {
            return n !== '__exports__' && n !== '__modules__' && n !== '__init__' && n !== '__depends__' && (t[n] = e[n]),
            t
          }
          , Object.create(null))
          const i = d((n || []).concat(r))
          const s = yt(function (e) {
            return i.get(e)
          }
          )
          t.forEach(function (e) {
            o[e] = [s, e, 'private', i]
          }
          )
          const c = (e.__init__ || []).slice()
          return c.unshift(function () {
            i.init()
          }
          ),
          v(e = Object.assign({}, e, {
            __init__: c
          }), i)
        }
        return Object.keys(e).forEach(function (t) {
          if (t !== '__init__' && t !== '__depends__') {
            const n = e[t]
            if (n[2] !== 'private') {
              const r = n[0]
              const i = n[1]
              o[t] = [m[r], _t(r, i), r]
            } else { o[t] = n }
          }
        }
        ),
        v(e, a)
      }
      ),
      h = !1,
      function () {
        h || (h = !0,
        f.forEach(function (e) {
          return e()
        }
        ))
      }
      )
    }
    function _t (e, t) {
      return e !== 'value' && vt(t) && (t = yt(t.slice())),
      t
    }
    const Ct = 1e3
    function St (e, t) {
      const n = this
      t = t || Ct,
      e.on(['render.shape', 'render.connection'], t, function (e, t) {
        const r = e.type
        const o = t.element
        const i = t.gfx
        const a = t.attrs
        if (n.canRender(o)) { return r === 'render.shape' ? n.drawShape(i, o, a) : n.drawConnection(i, o, a) }
      }
      ),
      e.on(['render.getShapePath', 'render.getConnectionPath'], t, function (e, t) {
        if (n.canRender(t)) { return e.type === 'render.getShapePath' ? n.getShapePath(t) : n.getConnectionPath(t) }
      }
      )
    }
    function kt (e) {
      return e.flat().join(',').replace(/,?([A-z]),?/g, '$1')
    }
    function jt (e) {
      return ['M', e.x, e.y]
    }
    function Bt (e) {
      return ['L', e.x, e.y]
    }
    function Dt (e, t) {
      for (var n, r, o, i = e.length, a = [jt(e[0])], s = 1; s < i; s++) {
        const c = e[s - 1]
        const l = e[s]
        const p = e[s + 1]
        if (p && t) {
          const u = Math.min(t, Ot(l.x - c.x, l.y - c.y), Ot(p.x - l.x, p.y - l.y))
          if (u) {
            const d = Pt(l, c, u)
            const f = Pt(l, c, 0.5 * u)
            const h = Pt(l, p, u)
            const m = Pt(l, p, 0.5 * u)
            a.push(Bt(d)),
            a.push((r = m,
            o = h,
            ['C', (n = f).x, n.y, r.x, r.y, o.x, o.y]))
          } else { a.push(Bt(l)) }
        } else { a.push(Bt(l)) }
      }
      return a
    }
    function Pt (e, t, n) {
      const r = t.x - e.x
      const o = t.y - e.y
      const i = n / Ot(r, o)
      return {
        x: e.x + r * i,
        y: e.y + o * i
      }
    }
    function Ot (e, t) {
      return Math.sqrt(Math.pow(e, 2) + Math.pow(t, 2))
    }
    function Tt (e, t, n) {
      L(t) && (n = t,
      t = null),
      t || (t = {})
      const r = et('path', t)
      return L(n) && (r.dataset.cornerRadius = String(n)),
      Rt(r, e)
    }
    function Rt (e, t) {
      return We(e, {
        d: kt(Dt(t, parseInt(e.dataset.cornerRadius, 10) || 0))
      }),
      e
    }
    function Nt (e) {
      return W(e, function (t) {
        return !H(e, function (e) {
          return e !== t && Mt(t, e)
        }
        )
      }
      )
    }
    function Mt (e, t) {
      if (t) {
        if (e === t) { return t }
        if (e.parent) { return Mt(e.parent, t) }
      }
    }
    function It (e, t, n) {
      const r = !n || e.indexOf(t) === -1
      return r && e.push(t),
      r
    }
    function Lt (e, t, n) {
      n = n || 0,
      M(e) || (e = [e]),
      G(e, function (e, r) {
        const o = t(e, r, n)
        M(o) && o.length && Lt(o, t, n + 1)
      }
      )
    }
    function zt (e, t) {
      return (function (e, t, n) {
        const r = []
        const o = []
        return Lt(e, function (e, i, a) {
          It(r, e, t)
          const s = e.children
          if ((n === -1 || a < n) && s && It(o, s, t)) { return s }
        }
        ),
        r
      }(e, !t, -1))
    }
    function Ft (e, t) {
      let n, r, o, i
      return t = !!t,
      M(e) || (e = [e]),
      G(e, function (e) {
        let a = e
        e.waypoints && !t && (a = Ft(e.waypoints, !0))
        const s = a.x
        const c = a.y
        const l = a.height || 0
        const p = a.width || 0;
        (s < n || void 0 === n) && (n = s),
        (c < r || void 0 === r) && (r = c),
        (s + p > o || void 0 === o) && (o = s + p),
        (c + l > i || void 0 === i) && (i = c + l)
      }
      ),
      {
        x: n,
        y: r,
        height: i - r,
        width: o - n
      }
    }
    function $t (e) {
      return 'waypoints' in e ? 'connection' : 'x' in e ? 'shape' : 'root'
    }
    function Ht (e) {
      return !(!e || !e.isFrame)
    }
    function qt (e, t) {
      return le({}, e || {}, t || {})
    }
    function Wt (e, t) {
      St.call(this, e, 1),
      this.CONNECTION_STYLE = t.style(['no-fill'], {
        strokeWidth: 5,
        stroke: 'fuchsia'
      }),
      this.SHAPE_STYLE = t.style({
        fill: 'white',
        stroke: 'fuchsia',
        strokeWidth: 2
      }),
      this.FRAME_STYLE = t.style(['no-fill'], {
        stroke: 'fuchsia',
        strokeDasharray: 4,
        strokeWidth: 2
      })
    }
    St.prototype.canRender = function (e) {}
    ,
    St.prototype.drawShape = function (e, t) {}
    ,
    St.prototype.drawConnection = function (e, t) {}
    ,
    St.prototype.getShapePath = function (e) {}
    ,
    St.prototype.getConnectionPath = function (e) {}
    ,
    w(Wt, St),
    Wt.prototype.canRender = function () {
      return !0
    }
    ,
    Wt.prototype.drawShape = function (e, t, n) {
      const r = et('rect')
      return We(r, {
        x: 0,
        y: 0,
        width: t.width || 0,
        height: t.height || 0
      }),
      Ht(t) ? We(r, le({}, this.FRAME_STYLE, n || {})) : We(r, le({}, this.SHAPE_STYLE, n || {})),
      Fe(e, r),
      r
    }
    ,
    Wt.prototype.drawConnection = function (e, t, n) {
      const r = Tt(t.waypoints, le({}, this.CONNECTION_STYLE, n || {}))
      return Fe(e, r),
      r
    }
    ,
    Wt.prototype.getShapePath = function (e) {
      const t = e.x
      const n = e.y
      const r = e.width
      return kt([['M', t, n], ['l', r, 0], ['l', 0, e.height], ['l', -r, 0], ['z']])
    }
    ,
    Wt.prototype.getConnectionPath = function (e) {
      let t; let n; const r = e.waypoints; const o = []
      for (t = 0; n = r[t]; t++) {
        n = n.original || n,
        o.push([t === 0 ? 'M' : 'L', n.x, n.y])
      }
      return kt(o)
    }
    ,
    Wt.$inject = ['eventBus', 'styles']
    const Gt = {
      __init__: ['defaultRenderer'],
      defaultRenderer: ['type', Wt],
      styles: ['type', function () {
        const e = {
          'no-fill': {
            fill: 'none'
          },
          'no-border': {
            strokeOpacity: 0
          },
          'no-events': {
            pointerEvents: 'none'
          }
        }
        const t = this
        this.cls = function (e, t, n) {
          return le(this.style(t, n), {
            class: e
          })
        }
        ,
        this.style = function (t, n) {
          M(t) || n || (n = t,
          t = [])
          const r = U(t, function (t, n) {
            return le(t, e[n] || {})
          }
          , {})
          return n ? le(r, n) : r
        }
        ,
        this.computeStyle = function (e, n, r) {
          return M(n) || (r = n,
          n = []),
          t.style(n || [], le({}, r, e || {}))
        }
      }
      ]
    }
    function Ut (e, t) {
      return t.forEach(function (t) {
        t && typeof t !== 'string' && !Array.isArray(t) && Object.keys(t).forEach(function (n) {
          if (n !== 'default' && !(n in e)) {
            const r = Object.getOwnPropertyDescriptor(t, n)
            Object.defineProperty(e, n, r.get
              ? r
              : {
                  enumerable: !0,
                  get: function () {
                    return t[n]
                  }
                })
          }
        }
        )
      }
      ),
      Object.freeze(e)
    }
    const Vt = Object.prototype.toString
    const Qt = Object.prototype.hasOwnProperty
    function Yt (e, t) {
      return Qt.call(e, t)
    }
    function Kt (e, t) {
      let n, r
      if (void 0 !== e) {
        const o = (r = e,
        Vt.call(r) === '[object Array]' ? Xt : Jt)
        for (const i in e) {
          if (Yt(e, i) && !1 === t(n = e[i], o(i))) { return n }
        }
      }
    }
    function Jt (e) {
      return e
    }
    function Xt (e) {
      return Number(e)
    }
    function Zt (e) {
      for (var t = e.style, n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++) { r[o - 1] = arguments[o] }
      return Kt(r, function (e) {
        e && Kt(e, function (e, n) {
          t[n] = e
        }
        )
      }
      ),
      e
    }
    function en (e, t, n) {
      return arguments.length == 2
        ? e.getAttribute(t)
        : n === null
          ? e.removeAttribute(t)
          : (e.setAttribute(t, n),
            e)
    }
    const tn = Object.prototype.toString
    function nn (e) {
      return new rn(e)
    }
    function rn (e) {
      if (!e || !e.nodeType) { throw new Error('A DOM element reference is required') }
      this.el = e,
      this.list = e.classList
    }
    function on (e) {
      for (var t; e.childNodes.length;) {
        t = e.childNodes[0],
        e.removeChild(t)
      }
      return e
    }
    function an (e, t) {
      return e && typeof e.matches === 'function' && e.matches(t)
    }
    function sn (e, t, n) {
      for (var r = n ? e : e.parentNode; r && r.nodeType !== document.DOCUMENT_NODE && r.nodeType !== document.DOCUMENT_FRAGMENT_NODE;) {
        if (an(r, t)) { return r }
        r = r.parentNode
      }
      return an(r, t) ? r : null
    }
    rn.prototype.add = function (e) {
      return this.list.add(e),
      this
    }
    ,
    rn.prototype.remove = function (e) {
      return tn.call(e) == '[object RegExp]'
        ? this.removeMatching(e)
        : (this.list.remove(e),
          this)
    }
    ,
    rn.prototype.removeMatching = function (e) {
      for (let t = this.array(), n = 0; n < t.length; n++) { e.test(t[n]) && this.remove(t[n]) }
      return this
    }
    ,
    rn.prototype.toggle = function (e, t) {
      return void 0 !== t ? t !== this.list.toggle(e, t) && this.list.toggle(e) : this.list.toggle(e),
      this
    }
    ,
    rn.prototype.array = function () {
      return Array.from(this.list)
    }
    ,
    rn.prototype.has = rn.prototype.contains = function (e) {
      return this.list.contains(e)
    }

    let cn; let ln; let pn; const un = {}
    function dn () {
      cn = window.addEventListener ? 'addEventListener' : 'attachEvent',
      ln = window.removeEventListener ? 'removeEventListener' : 'detachEvent',
      pn = cn !== 'addEventListener' ? 'on' : ''
    }
    let fn; const hn = un.bind = function (e, t, n, r) {
      return cn || dn(),
      e[cn](pn + t, n, r || !1),
      n
    }
    const mn = un.unbind = function (e, t, n, r) {
      return ln || dn(),
      e[ln](pn + t, n, r || !1),
      n
    }
    const vn = Ut({
      __proto__: null,
      bind: hn,
      unbind: mn,
      default: un
    }, [un]); const gn = ['focus', 'blur']; const yn = function (e, t, n, r, o) {
      return gn.indexOf(n) !== -1 && (o = !0),
      vn.bind(e, n, function (n) {
        const o = n.target || n.srcElement
        n.delegateTarget = sn(o, t, !0),
        n.delegateTarget && r.call(e, n)
      }
      , o)
    }; const bn = function (e, t, n, r) {
      return gn.indexOf(t) !== -1 && (r = !0),
      vn.unbind(e, t, n, r)
    }; let An = !1
    typeof document !== 'undefined' && ((fn = document.createElement('div')).innerHTML = '  <link/><table></table><a href="/a">a</a><input type="checkbox"/>',
    An = !fn.getElementsByTagName('link').length,
    fn = void 0)
    const En = {
      legend: [1, '<fieldset>', '</fieldset>'],
      tr: [2, '<table><tbody>', '</tbody></table>'],
      col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
      _default: An ? [1, 'X<div>', '</div>'] : [0, '', '']
    }
    En.td = En.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'],
    En.option = En.optgroup = [1, '<select multiple="multiple">', '</select>'],
    En.thead = En.tbody = En.colgroup = En.caption = En.tfoot = [1, '<table>', '</table>'],
    En.polyline = En.ellipse = En.polygon = En.circle = En.text = En.line = En.path = En.rect = En.g = [1, '<svg xmlns="http://www.w3.org/2000/svg" version="1.1">', '</svg>']
    const xn = function (e, t) {
      if (typeof e !== 'string') { throw new TypeError('String expected') }
      t || (t = document)
      const n = /<([\w:]+)/.exec(e)
      if (!n) { return t.createTextNode(e) }
      e = e.replace(/^\s+|\s+$/g, '')
      const r = n[1]
      if (r == 'body') {
        return (o = t.createElement('html')).innerHTML = e,
        o.removeChild(o.lastChild)
      }
      let o; const i = Object.prototype.hasOwnProperty.call(En, r) ? En[r] : En._default; let a = i[0]; const s = i[1]; const c = i[2]
      for ((o = t.createElement('div')).innerHTML = s + e + c; a--;) { o = o.lastChild }
      if (o.firstChild == o.lastChild) { return o.removeChild(o.firstChild) }
      for (var l = t.createDocumentFragment(); o.firstChild;) { l.appendChild(o.removeChild(o.firstChild)) }
      return l
    }
    function wn (e, t) {
      return (t = t || document).querySelector(e)
    }
    function _n (e, t) {
      return (t = t || document).querySelectorAll(e)
    }
    function Cn (e) {
      e.parentNode && e.parentNode.removeChild(e)
    }
    function Sn (e, t) {
      if (!e || !t) { return -1 }
      const n = e.indexOf(t)
      return n !== -1 && e.splice(n, 1),
      n
    }
    function kn (e, t, n) {
      if (e && t) {
        typeof n !== 'number' && (n = -1)
        const r = e.indexOf(t)
        if (r !== -1) {
          if (r === n) { return }
          if (n === -1) { return }
          e.splice(r, 1)
        }
        n !== -1 ? e.splice(n, 0, t) : e.push(t)
      }
    }
    function jn (e, t) {
      return e && t ? e.indexOf(t) : -1
    }
    function Bn (e, t) {
      (t == null || t > e.length) && (t = e.length)
      for (var n = 0, r = new Array(t); n < t; n++) { r[n] = e[n] }
      return r
    }
    function Dn (e, t) {
      return e && t ? Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2)) : -1
    }
    function Pn (e, t, n, r) {
      if (void 0 === r && (r = 5),
      !e || !t || !n) { return !1 }
      const o = (t.x - e.x) * (n.y - e.y) - (t.y - e.y) * (n.x - e.x)
      const i = Dn(e, t)
      return Math.abs(o / i) <= r
    }
    const On = 2
    function Tn (e, t) {
      for (let n = Array.from(arguments).flat(), r = 0, o = Object.entries({
        x: 'v',
        y: 'h'
      }); r < o.length; r++) {
        const i = (c = o[r],
        l = 2,
        (function (e) {
          if (Array.isArray(e)) { return e }
        }(c)) || (function (e, t) {
          let n = e == null ? null : typeof Symbol !== 'undefined' && e[Symbol.iterator] || e['@@iterator']
          if (n != null) {
            let r; let o; let i; let a; const s = []; let c = !0; let l = !1
            try {
              if (i = (n = n.call(e)).next,
              t === 0) {
                if (Object(n) !== n) { return }
                c = !1
              } else {
                for (; !(c = (r = i.call(n)).done) && (s.push(r.value),
                s.length !== t); c = !0)
                  ;
              }
            } catch (e) {
              l = !0,
              o = e
            } finally {
              try {
                if (!c && n.return != null && (a = n.return(),
                Object(a) !== a)) { return }
              } finally {
                if (l) { throw o }
              }
            }
            return s
          }
        }(c, l)) || (function (e, t) {
          if (e) {
            if (typeof e === 'string') { return Bn(e, t) }
            let n = Object.prototype.toString.call(e).slice(8, -1)
            return n === 'Object' && e.constructor && (n = e.constructor.name),
            n === 'Map' || n === 'Set' ? Array.from(e) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Bn(e, t) : void 0
          }
        }(c, l)) || (function () {
          throw new TypeError('Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
        }()))
        const a = i[0]
        const s = i[1]
        if (Rn(a, n)) { return s }
      }
      let c, l
      return !1
    }
    function Rn (e, t) {
      const n = t[0]
      return V(t, function (t) {
        return Math.abs(n[e] - t[e]) <= On
      }
      )
    }
    function Nn (e, t, n) {
      return n = n || 0,
      e.x > t.x - n && e.y > t.y - n && e.x < t.x + t.width + n && e.y < t.y + t.height + n
    }
    function Mn (e, t) {
      return {
        x: Math.round(e.x + (t.x - e.x) / 2),
        y: Math.round(e.y + (t.y - e.y) / 2)
      }
    }
    function In (e) {
      return (function (e) {
        if (Array.isArray(e)) { return Ln(e) }
      }(e)) || (function (e) {
        if (typeof Symbol !== 'undefined' && e[Symbol.iterator] != null || e['@@iterator'] != null) { return Array.from(e) }
      }(e)) || (function (e, t) {
        if (e) {
          if (typeof e === 'string') { return Ln(e, t) }
          let n = Object.prototype.toString.call(e).slice(8, -1)
          return n === 'Object' && e.constructor && (n = e.constructor.name),
          n === 'Map' || n === 'Set' ? Array.from(e) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Ln(e, t) : void 0
        }
      }(e)) || (function () {
        throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
      }())
    }
    function Ln (e, t) {
      (t == null || t > e.length) && (t = e.length)
      for (var n = 0, r = new Array(t); n < t; n++) { r[n] = e[n] }
      return r
    }
    const zn = /,?([a-z]),?/gi
    const Fn = parseFloat
    const $n = Math
    const Hn = $n.PI
    const qn = $n.min
    const Wn = $n.max
    const Gn = $n.pow
    const Un = $n.abs
    const Vn = /([a-z])[\s,]*((-?\d*\.?\d*(?:e[-+]?\d+)?[\s]*,?[\s]*)+)/gi
    const Qn = /(-?\d*\.?\d*(?:e[-+]?\d+)?)[\s]*,?[\s]*/gi
    const Yn = Array.isArray || function (e) {
      return e instanceof Array
    }

    function Kn (e, t) {
      return Object.prototype.hasOwnProperty.call(e, t)
    }
    function Jn (e) {
      if (typeof e === 'function' || Object(e) !== e) { return e }
      const t = new e.constructor()
      for (const n in e) { Kn(e, n) && (t[n] = Jn(e[n])) }
      return t
    }
    function Xn (e) {
      const t = Xn.ps = Xn.ps || {}
      return t[e]
        ? t[e].sleep = 100
        : t[e] = {
          sleep: 100
        },
      setTimeout(function () {
        for (const n in t) {
          Kn(t, n) && n != e && (t[n].sleep--,
          !t[n].sleep && delete t[n])
        }
      }
      ),
      t[e]
    }
    function Zn (e, t, n, r) {
      return arguments.length === 1 && (t = e.y,
      n = e.width,
      r = e.height,
      e = e.x),
      {
        x: e,
        y: t,
        width: n,
        height: r,
        x2: e + n,
        y2: t + r
      }
    }
    function er () {
      return this.join(',').replace(zn, '$1')
    }
    function tr (e) {
      const t = Jn(e)
      return t.toString = er,
      t
    }
    function nr (e, t, n, r, o, i, a, s, c) {
      const l = 1 - c
      const p = Gn(l, 3)
      const u = Gn(l, 2)
      const d = c * c * c
      const f = p * t + 3 * u * c * r + 3 * l * c * c * i + d * s
      return {
        x: cr(p * e + 3 * u * c * n + 3 * l * c * c * o + d * a),
        y: cr(f)
      }
    }
    function rr (e) {
      const t = vr.apply(void 0, In(e))
      return Zn(t.x0, t.y0, t.x1 - t.x0, t.y1 - t.y0)
    }
    function or (e, t, n) {
      return t >= e.x && t <= e.x + e.width && n >= e.y && n <= e.y + e.height
    }
    function ir (e, t, n, r, o) {
      return e * (e * (-3 * t + 9 * n - 9 * r + 3 * o) + 6 * t - 12 * n + 6 * r) - 3 * t + 3 * n
    }
    function ar (e, t, n, r, o, i, a, s, c) {
      c == null && (c = 1)
      for (var l = (c = c > 1 ? 1 : c < 0 ? 0 : c) / 2, p = [-0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699, 0.7699, -0.9041, 0.9041, -0.9816, 0.9816], u = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472], d = 0, f = 0; f < 12; f++) {
        const h = l * p[f] + l
        const m = ir(h, e, n, o, a)
        const v = ir(h, t, r, i, s)
        const g = m * m + v * v
        d += u[f] * $n.sqrt(g)
      }
      return l * d
    }
    function sr (e, t, n, r, o, i, a, s) {
      if (!(Wn(e, n) < qn(o, a) || qn(e, n) > Wn(o, a) || Wn(t, r) < qn(i, s) || qn(t, r) > Wn(i, s))) {
        const c = (e * r - t * n) * (i - s) - (t - r) * (o * s - i * a)
        const l = (e - n) * (i - s) - (t - r) * (o - a)
        if (l) {
          const p = cr(((e * r - t * n) * (o - a) - (e - n) * (o * s - i * a)) / l)
          const u = cr(c / l)
          const d = +p.toFixed(2)
          const f = +u.toFixed(2)
          if (!(d < +qn(e, n).toFixed(2) || d > +Wn(e, n).toFixed(2) || d < +qn(o, a).toFixed(2) || d > +Wn(o, a).toFixed(2) || f < +qn(t, r).toFixed(2) || f > +Wn(t, r).toFixed(2) || f < +qn(i, s).toFixed(2) || f > +Wn(i, s).toFixed(2))) {
            return {
              x: p,
              y: u
            }
          }
        }
      }
    }
    function cr (e) {
      return Math.round(1e11 * e) / 1e11
    }
    function lr (e, t, n) {
      if (r = rr(e),
      o = rr(t),
      r = Zn(r),
      !(or(o = Zn(o), r.x, r.y) || or(o, r.x2, r.y) || or(o, r.x, r.y2) || or(o, r.x2, r.y2) || or(r, o.x, o.y) || or(r, o.x2, o.y) || or(r, o.x, o.y2) || or(r, o.x2, o.y2) || (r.x < o.x2 && r.x > o.x || o.x < r.x2 && o.x > r.x) && (r.y < o.y2 && r.y > o.y || o.y < r.y2 && o.y > r.y))) { return n ? 0 : [] }
      for (var r, o, i = ar.apply(void 0, In(e)), a = ar.apply(void 0, In(t)), s = dr(e) ? 1 : ~~(i / 5) || 1, c = dr(t) ? 1 : ~~(a / 5) || 1, l = [], p = [], u = {}, d = n ? 0 : [], f = 0; f < s + 1; f++) {
        var h = nr.apply(void 0, In(e).concat([f / s]))
        l.push({
          x: h.x,
          y: h.y,
          t: f / s
        })
      }
      for (f = 0; f < c + 1; f++) {
        h = nr.apply(void 0, In(t).concat([f / c])),
        p.push({
          x: h.x,
          y: h.y,
          t: f / c
        })
      }
      for (f = 0; f < s; f++) {
        for (let m = 0; m < c; m++) {
          var v; const g = l[f]; const y = l[f + 1]; const b = p[m]; const A = p[m + 1]; const E = Un(y.x - g.x) < 0.01 ? 'y' : 'x'; const x = Un(A.x - b.x) < 0.01 ? 'y' : 'x'; const w = sr(g.x, g.y, y.x, y.y, b.x, b.y, A.x, A.y)
          if (w) {
            if (u[v = w.x.toFixed(9) + '#' + w.y.toFixed(9)]) { continue }
            u[v] = !0
            const _ = g.t + Un((w[E] - g[E]) / (y[E] - g[E])) * (y.t - g.t)
            const C = b.t + Un((w[x] - b[x]) / (A[x] - b[x])) * (A.t - b.t)
            _ >= 0 && _ <= 1 && C >= 0 && C <= 1 && (n
              ? d++
              : d.push({
                x: w.x,
                y: w.y,
                t1: _,
                t2: C
              }))
          }
        }
      }
      return d
    }
    function pr (e, t, n) {
      e = gr(e),
      t = gr(t)
      for (var r, o, i, a, s, c, l, p, u, d, f = n ? 0 : [], h = 0, m = e.length; h < m; h++) {
        const v = e[h]
        if (v[0] == 'M') {
          r = s = v[1],
          o = c = v[2]
        } else {
          v[0] == 'C'
            ? (u = [r, o].concat(In(v.slice(1))),
              r = u[6],
              o = u[7])
            : (u = [r, o, r, o, s, c, s, c],
              r = s,
              o = c)
          for (let g = 0, y = t.length; g < y; g++) {
            const b = t[g]
            if (b[0] == 'M') {
              i = l = b[1],
              a = p = b[2]
            } else {
              b[0] == 'C'
                ? (d = [i, a].concat(In(b.slice(1))),
                  i = d[6],
                  a = d[7])
                : (d = [i, a, i, a, l, p, l, p],
                  i = l,
                  a = p)
              const A = lr(u, d, n)
              if (n) { f += A } else {
                for (let E = 0, x = A.length; E < x; E++) {
                  A[E].segment1 = h,
                  A[E].segment2 = g,
                  A[E].bez1 = u,
                  A[E].bez2 = d
                }
                f = f.concat(A)
              }
            }
          }
        }
      }
      return f
    }
    function ur (e) {
      const t = Xn(e)
      if (t.abs) { return tr(t.abs) }
      if (Yn(e) && Yn(e && e[0]) || (e = (function (e) {
        if (!e) { return null }
        const t = Xn(e)
        if (t.arr) { return Jn(t.arr) }
        const n = {
          a: 7,
          c: 6,
          h: 1,
          l: 2,
          m: 2,
          q: 4,
          s: 4,
          t: 2,
          v: 1,
          z: 0
        }
        let r = []
        return Yn(e) && Yn(e[0]) && (r = Jn(e)),
        r.length || String(e).replace(Vn, function (e, t, o) {
          const i = []
          let a = t.toLowerCase()
          for (o.replace(Qn, function (e, t) {
            t && i.push(+t)
          }
          ),
          a == 'm' && i.length > 2 && (r.push([t].concat(In(i.splice(0, 2)))),
          a = 'l',
          t = t == 'm' ? 'l' : 'L'); i.length >= n[a] && (r.push([t].concat(In(i.splice(0, n[a])))),
            n[a]);)
            ;
        }
        ),
        r.toString = Xn.toString,
        t.arr = Jn(r),
        r
      }(e))),
      !e || !e.length) { return [['M', 0, 0]] }
      let n; const r = []; let o = 0; let i = 0; let a = 0; let s = 0; let c = 0
      e[0][0] == 'M' && (a = o = +e[0][1],
      s = i = +e[0][2],
      c++,
      r[0] = ['M', o, i])
      for (var l, p, u = c, d = e.length; u < d; u++) {
        if (r.push(l = []),
        (n = (p = e[u])[0]) != n.toUpperCase()) {
          switch (l[0] = n.toUpperCase(),
          l[0]) {
            case 'A':
              l[1] = p[1],
              l[2] = p[2],
              l[3] = p[3],
              l[4] = p[4],
              l[5] = p[5],
              l[6] = +p[6] + o,
              l[7] = +p[7] + i
              break
            case 'V':
              l[1] = +p[1] + i
              break
            case 'H':
              l[1] = +p[1] + o
              break
            case 'M':
              a = +p[1] + o,
              s = +p[2] + i
            default:
              for (let f = 1, h = p.length; f < h; f++) { l[f] = +p[f] + (f % 2 ? o : i) }
          }
        } else {
          for (let m = 0, v = p.length; m < v; m++) { l[m] = p[m] }
        }
        switch (n = n.toUpperCase(),
        l[0]) {
          case 'Z':
            o = +a,
            i = +s
            break
          case 'H':
            o = l[1]
            break
          case 'V':
            i = l[1]
            break
          case 'M':
            a = l[l.length - 2],
            s = l[l.length - 1]
          default:
            o = l[l.length - 2],
            i = l[l.length - 1]
        }
      }
      return r.toString = er,
      t.abs = tr(r),
      r
    }
    function dr (e) {
      return e[0] === e[2] && e[1] === e[3] && e[4] === e[6] && e[5] === e[7]
    }
    function fr (e, t, n, r) {
      return [e, t, n, r, n, r]
    }
    function hr (e, t, n, r, o, i) {
      const a = 1 / 3
      const s = 2 / 3
      return [a * e + s * n, a * t + s * r, a * o + s * n, a * i + s * r, o, i]
    }
    function mr (e, t, n, r, o, i, a, s, c, l) {
      let p; const u = 120 * Hn / 180; const d = Hn / 180 * (+o || 0); let f = []; const h = (function (e) {
        return function t () {
          const n = Array.prototype.slice.call(arguments, 0).join('␀')
          const r = t.cache = t.cache || {}
          const o = t.count = t.count || []
          return Kn(r, n)
            ? ((function (e, t) {
                for (let n = 0, r = e.length; n < r; n++) {
                  if (e[n] === t) { return e.push(e.splice(n, 1)[0]) }
                }
              }(o, n)),
              r[n])
            : (o.length >= 1e3 && delete r[o.shift()],
              o.push(n),
              r[n] = e.apply(void 0, arguments),
              r[n])
        }
      }(function (e, t, n) {
        return {
          x: e * $n.cos(n) - t * $n.sin(n),
          y: e * $n.sin(n) + t * $n.cos(n)
        }
      }
      ))
      if (l) {
        w = l[0],
        _ = l[1],
        E = l[2],
        x = l[3]
      } else {
        e = (p = h(e, t, -d)).x,
        t = p.y
        const m = (e - (s = (p = h(s, c, -d)).x)) / 2
        const v = (t - (c = p.y)) / 2
        let g = m * m / (n * n) + v * v / (r * r)
        g > 1 && (n *= g = $n.sqrt(g),
        r *= g)
        const y = n * n
        const b = r * r
        const A = (i == a ? -1 : 1) * $n.sqrt(Un((y * b - y * v * v - b * m * m) / (y * v * v + b * m * m)))
        var E = A * n * v / r + (e + s) / 2
        var x = A * -r * m / n + (t + c) / 2
        var w = $n.asin(((t - x) / r).toFixed(9))
        var _ = $n.asin(((c - x) / r).toFixed(9));
        (w = e < E ? Hn - w : w) < 0 && (w = 2 * Hn + w),
        (_ = s < E ? Hn - _ : _) < 0 && (_ = 2 * Hn + _),
        a && w > _ && (w -= 2 * Hn),
        !a && _ > w && (_ -= 2 * Hn)
      }
      let C = _ - w
      if (Un(C) > u) {
        const S = _
        const k = s
        const j = c
        _ = w + u * (a && _ > w ? 1 : -1),
        f = mr(s = E + n * $n.cos(_), c = x + r * $n.sin(_), n, r, o, 0, a, k, j, [_, S, E, x])
      }
      C = _ - w
      const B = $n.cos(w)
      const D = $n.sin(w)
      const P = $n.cos(_)
      const O = $n.sin(_)
      const T = $n.tan(C / 4)
      const R = 4 / 3 * n * T
      const N = 4 / 3 * r * T
      const M = [e, t]
      const I = [e + R * D, t - N * B]
      const L = [s + R * O, c - N * P]
      const z = [s, c]
      if (I[0] = 2 * M[0] - I[0],
      I[1] = 2 * M[1] - I[1],
      l) { return [I, L, z].concat(f) }
      for (var F = [], $ = 0, H = (f = [I, L, z].concat(f).join().split(',')).length; $ < H; $++) { F[$] = $ % 2 ? h(f[$ - 1], f[$], d).y : h(f[$], f[$ + 1], d).x }
      return F
    }
    function vr (e, t, n, r, o, i, a, s) {
      for (var c, l, p, u, d, f, h, m, v = [], g = [[], []], y = 0; y < 2; ++y) {
        if (y == 0
          ? (l = 6 * e - 12 * n + 6 * o,
            c = -3 * e + 9 * n - 9 * o + 3 * a,
            p = 3 * n - 3 * e)
          : (l = 6 * t - 12 * r + 6 * i,
            c = -3 * t + 9 * r - 9 * i + 3 * s,
            p = 3 * r - 3 * t),
        Un(c) < 1e-12) {
          if (Un(l) < 1e-12) { continue }
          (u = -p / l) > 0 && u < 1 && v.push(u)
        } else {
          h = l * l - 4 * p * c,
          m = $n.sqrt(h),
          h < 0 || ((d = (-l + m) / (2 * c)) > 0 && d < 1 && v.push(d),
          (f = (-l - m) / (2 * c)) > 0 && f < 1 && v.push(f))
        }
      }
      for (var b, A = v.length, E = A; A--;) {
        b = 1 - (u = v[A]),
        g[0][A] = b * b * b * e + 3 * b * b * u * n + 3 * b * u * u * o + u * u * u * a,
        g[1][A] = b * b * b * t + 3 * b * b * u * r + 3 * b * u * u * i + u * u * u * s
      }
      return g[0][E] = e,
      g[1][E] = t,
      g[0][E + 1] = a,
      g[1][E + 1] = s,
      g[0].length = g[1].length = E + 2,
      {
        x0: qn.apply(void 0, In(g[0])),
        y0: qn.apply(void 0, In(g[1])),
        x1: Wn.apply(void 0, In(g[0])),
        y1: Wn.apply(void 0, In(g[1]))
      }
    }
    function gr (e) {
      const t = Xn(e)
      if (t.curve) { return tr(t.curve) }
      for (var n = ur(e), r = {
          x: 0,
          y: 0,
          bx: 0,
          by: 0,
          X: 0,
          Y: 0,
          qx: null,
          qy: null
        }, o = function (e, t, n) {
          let r, o
          if (!e) { return ['C', t.x, t.y, t.x, t.y, t.x, t.y] }
          switch (!(e[0] in {
            T: 1,
            Q: 1
          }) && (t.qx = t.qy = null),
          e[0]) {
            case 'M':
              t.X = e[1],
              t.Y = e[2]
              break
            case 'A':
              e = ['C'].concat(In(mr.apply(void 0, [t.x, t.y].concat(In(e.slice(1))))))
              break
            case 'S':
              n == 'C' || n == 'S'
                ? (r = 2 * t.x - t.bx,
                  o = 2 * t.y - t.by)
                : (r = t.x,
                  o = t.y),
              e = ['C', r, o].concat(In(e.slice(1)))
              break
            case 'T':
              n == 'Q' || n == 'T'
                ? (t.qx = 2 * t.x - t.qx,
                  t.qy = 2 * t.y - t.qy)
                : (t.qx = t.x,
                  t.qy = t.y),
              e = ['C'].concat(In(hr(t.x, t.y, t.qx, t.qy, e[1], e[2])))
              break
            case 'Q':
              t.qx = e[1],
              t.qy = e[2],
              e = ['C'].concat(In(hr(t.x, t.y, e[1], e[2], e[3], e[4])))
              break
            case 'L':
              e = ['C'].concat(In(fr(t.x, t.y, e[1], e[2])))
              break
            case 'H':
              e = ['C'].concat(In(fr(t.x, t.y, e[1], t.y)))
              break
            case 'V':
              e = ['C'].concat(In(fr(t.x, t.y, t.x, e[1])))
              break
            case 'Z':
              e = ['C'].concat(In(fr(t.x, t.y, t.X, t.Y)))
          }
          return e
        }, i = function (e, t) {
          if (e[t].length > 7) {
            e[t].shift()
            for (let r = e[t]; r.length;) {
              a[t] = 'A',
              e.splice(t++, 0, ['C'].concat(In(r.splice(0, 6))))
            }
            e.splice(t, 1),
            p = n.length
          }
        }, a = [], s = '', c = '', l = 0, p = n.length; l < p; l++) {
        n[l] && (s = n[l][0]),
        s != 'C' && (a[l] = s,
        l && (c = a[l - 1])),
        n[l] = o(n[l], r, c),
        a[l] != 'A' && s == 'C' && (a[l] = 'C'),
        i(n, l)
        const u = n[l]
        const d = u.length
        r.x = u[d - 2],
        r.y = u[d - 1],
        r.bx = Fn(u[d - 4]) || r.x,
        r.by = Fn(u[d - 3]) || r.y
      }
      return t.curve = tr(n),
      n
    }
    function yr (e) {
      return I(e) && $(e, 'waypoints')
    }
    function br (e) {
      return I(e) && $(e, 'labelTarget')
    }
    function Ar (e) {
      return {
        x: Math.round(e.x),
        y: Math.round(e.y),
        width: Math.round(e.width),
        height: Math.round(e.height)
      }
    }
    function Er (e) {
      return {
        x: Math.round(e.x),
        y: Math.round(e.y)
      }
    }
    function xr (e) {
      return {
        top: e.y,
        right: e.x + (e.width || 0),
        bottom: e.y + (e.height || 0),
        left: e.x
      }
    }
    function wr (e) {
      return {
        x: e.left,
        y: e.top,
        width: e.right - e.left,
        height: e.bottom - e.top
      }
    }
    function _r (e) {
      return yr(e)
        ? (function (e) {
            for (var t = e.waypoints, n = t.reduce(function (e, n, r) {
                const o = t[r - 1]
                if (o) {
                  const i = e[e.length - 1]
                  const a = i && i.endLength || 0
                  const s = (function (e, t) {
                    return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2))
                  }(o, n))
                  e.push({
                    start: o,
                    end: n,
                    startLength: a,
                    endLength: a + s,
                    length: s
                  })
                }
                return e
              }
              , []), r = n.reduce(function (e, t) {
                return e + t.length
              }
              , 0) / 2, o = 0, i = n[o]; i.endLength < r;) { i = n[++o] }
            const a = (r - i.startLength) / i.length
            return {
              x: i.start.x + (i.end.x - i.start.x) * a,
              y: i.start.y + (i.end.y - i.start.y) * a
            }
          }(e))
        : Er({
          x: (t = e).x + (t.width || 0) / 2,
          y: t.y + (t.height || 0) / 2
        })
      let t
    }
    function Cr (e, t, n) {
      I(n = n || 0) || (n = {
        x: n,
        y: n
      })
      const r = xr(e)
      const o = xr(t)
      const i = r.bottom + n.y <= o.top
      const a = r.left - n.x >= o.right
      const s = r.top - n.y >= o.bottom
      const c = i ? 'top' : s ? 'bottom' : null
      const l = r.right + n.x <= o.left ? 'left' : a ? 'right' : null
      return l && c ? c + '-' + l : l || c || 'intersect'
    }
    function Sr (e, t, n) {
      let r = (function (e, t) {
        return pr(e, t)
      }(e, t))
      return r.length === 1 || r.length === 2 && Dn(r[0], r[1]) < 1
        ? Er(r[0])
        : r.length > 1
          ? Er((r = te(r, function (e) {
            let t = Math.floor(100 * e.t2) || 1
            return t = ((t = 100 - t) < 10 ? '0' : '') + t,
            e.segment2 + '#' + t
          }
          ))[n ? 0 : r.length - 1])
          : null
    }
    function kr (e) {
      return kr = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      kr(e)
    }
    function jr (e, t) {
      return Math.round(e * t) / t
    }
    function Br (e) {
      return L(e) ? e + 'px' : e
    }
    function Dr (e, t, n) {
      const r = et('g')
      Ue(r).add(t)
      const o = void 0 !== n ? n : e.childNodes.length - 1
      return e.insertBefore(r, e.childNodes[o] || null),
      r
    }
    const Pr = {
      shape: ['x', 'y', 'width', 'height'],
      connection: ['waypoints']
    }
    function Or (e, t, n, r) {
      this._eventBus = t,
      this._elementRegistry = r,
      this._graphicsFactory = n,
      this._rootsIdx = 0,
      this._layers = {},
      this._planes = [],
      this._rootElement = null,
      this._init(e || {})
    }
    function Tr (e, t) {
      const n = 'matrix(' + t.a + ',' + t.b + ',' + t.c + ',' + t.d + ',' + t.e + ',' + t.f + ')'
      e.setAttribute('transform', n)
    }
    Or.$inject = ['config.canvas', 'eventBus', 'graphicsFactory', 'elementRegistry'],
    Or.prototype._init = function (e) {
      const t = this
      const n = this._eventBus
      const r = this._container = (function (e) {
        const t = (e = le({}, {
          width: '100%',
          height: '100%'
        }, e)).container || document.body
        const n = document.createElement('div')
        return n.setAttribute('class', 'djs-container djs-parent'),
        Zt(n, {
          position: 'relative',
          overflow: 'hidden',
          width: Br(e.width),
          height: Br(e.height)
        }),
        t.appendChild(n),
        n
      }(e))
      const o = this._svg = et('svg')
      We(o, {
        width: '100%',
        height: '100%'
      }),
      Fe(r, o)
      const i = this._viewport = Dr(o, 'viewport')
      e.deferUpdate && (this._viewboxChanged = se(ce(this._viewboxChanged, this), 300)),
      n.on('diagram.init', function () {
        n.fire('canvas.init', {
          svg: o,
          viewport: i
        })
      }
      ),
      n.on(['shape.added', 'connection.added', 'shape.removed', 'connection.removed', 'elements.changed', 'root.set'], function () {
        delete t._cachedViewbox
      }
      ),
      n.on('diagram.destroy', 500, this._destroy, this),
      n.on('diagram.clear', 500, this._clear, this)
    }
    ,
    Or.prototype._destroy = function () {
      this._eventBus.fire('canvas.destroy', {
        svg: this._svg,
        viewport: this._viewport
      })
      const e = this._container.parentNode
      e && e.removeChild(this._container),
      delete this._svg,
      delete this._container,
      delete this._layers,
      delete this._planes,
      delete this._rootElement,
      delete this._viewport
    }
    ,
    Or.prototype._clear = function () {
      const e = this
      this._elementRegistry.getAll().forEach(function (t) {
        const n = $t(t)
        n === 'root' ? e.removeRootElement(t) : e._removeElement(t, n)
      }
      ),
      this._planes = [],
      this._rootElement = null,
      delete this._cachedViewbox
    }
    ,
    Or.prototype.getDefaultLayer = function () {
      return this.getLayer('base', 0)
    }
    ,
    Or.prototype.getLayer = function (e, t) {
      if (!e) { throw new Error('must specify a name') }
      let n = this._layers[e]
      if (n || (n = this._layers[e] = this._createLayer(e, t)),
      void 0 !== t && n.index !== t) { throw new Error('layer <' + e + '> already created at index <' + t + '>') }
      return n.group
    }
    ,
    Or.prototype._getChildIndex = function (e) {
      return U(this._layers, function (t, n) {
        return n.visible && e >= n.index && t++,
        t
      }
      , 0)
    }
    ,
    Or.prototype._createLayer = function (e, t) {
      void 0 === t && (t = 1)
      const n = this._getChildIndex(t)
      return {
        group: Dr(this._viewport, 'layer-' + e, n),
        index: t,
        visible: !0
      }
    }
    ,
    Or.prototype.showLayer = function (e) {
      if (!e) { throw new Error('must specify a name') }
      const t = this._layers[e]
      if (!t) { throw new Error('layer <' + e + '> does not exist') }
      const n = this._viewport
      const r = t.group
      const o = t.index
      if (t.visible) { return r }
      const i = this._getChildIndex(o)
      return n.insertBefore(r, n.childNodes[i] || null),
      t.visible = !0,
      r
    }
    ,
    Or.prototype.hideLayer = function (e) {
      if (!e) { throw new Error('must specify a name') }
      const t = this._layers[e]
      if (!t) { throw new Error('layer <' + e + '> does not exist') }
      const n = t.group
      return t.visible
        ? (Qe(n),
          t.visible = !1,
          n)
        : n
    }
    ,
    Or.prototype._removeLayer = function (e) {
      const t = this._layers[e]
      t && (delete this._layers[e],
      Qe(t.group))
    }
    ,
    Or.prototype.getActiveLayer = function () {
      const e = this._findPlaneForRoot(this.getRootElement())
      return e ? e.layer : null
    }
    ,
    Or.prototype.findRoot = function (e) {
      if (typeof e === 'string' && (e = this._elementRegistry.get(e)),
      e) {
        const t = this._findPlaneForRoot(function (e) {
          for (; e.parent;) { e = e.parent }
          return e
        }(e)) || {}
        return t.rootElement
      }
    }
    ,
    Or.prototype.getRootElements = function () {
      return this._planes.map(function (e) {
        return e.rootElement
      }
      )
    }
    ,
    Or.prototype._findPlaneForRoot = function (e) {
      return H(this._planes, function (t) {
        return t.rootElement === e
      }
      )
    }
    ,
    Or.prototype.getContainer = function () {
      return this._container
    }
    ,
    Or.prototype._updateMarker = function (e, t, n) {
      let r
      e.id || (e = this._elementRegistry.get(e)),
      (r = this._elementRegistry._elements[e.id]) && (G([r.gfx, r.secondaryGfx], function (e) {
        e && (n ? Ue(e).add(t) : Ue(e).remove(t))
      }
      ),
      this._eventBus.fire('element.marker.update', {
        element: e,
        gfx: r.gfx,
        marker: t,
        add: !!n
      }))
    }
    ,
    Or.prototype.addMarker = function (e, t) {
      this._updateMarker(e, t, !0)
    }
    ,
    Or.prototype.removeMarker = function (e, t) {
      this._updateMarker(e, t, !1)
    }
    ,
    Or.prototype.hasMarker = function (e, t) {
      return e.id || (e = this._elementRegistry.get(e)),
      Ue(this.getGraphics(e)).has(t)
    }
    ,
    Or.prototype.toggleMarker = function (e, t) {
      this.hasMarker(e, t) ? this.removeMarker(e, t) : this.addMarker(e, t)
    }
    ,
    Or.prototype.getRootElement = function () {
      const e = this._rootElement
      return e || this._planes.length ? e : this.setRootElement(this.addRootElement(null))
    }
    ,
    Or.prototype.addRootElement = function (e) {
      const t = this._rootsIdx++
      e || (e = {
        id: '__implicitroot_' + t,
        children: [],
        isImplicit: !0
      })
      const n = e.layer = 'root-' + t
      this._ensureValid('root', e)
      const r = this.getLayer(n, 0)
      return this.hideLayer(n),
      this._addRoot(e, r),
      this._planes.push({
        rootElement: e,
        layer: r
      }),
      e
    }
    ,
    Or.prototype.removeRootElement = function (e) {
      if (typeof e === 'string' && (e = this._elementRegistry.get(e)),
      this._findPlaneForRoot(e)) {
        return this._removeRoot(e),
        this._removeLayer(e.layer),
        this._planes = this._planes.filter(function (t) {
          return t.rootElement !== e
        }
        ),
        this._rootElement === e && (this._rootElement = null),
        e
      }
    }
    ,
    Or.prototype.setRootElement = function (e) {
      if (e === this._rootElement) { return e }
      if (!e) { throw new Error('rootElement required') }
      return this._findPlaneForRoot(e) || (e = this.addRootElement(e)),
      this._setRoot(e),
      e
    }
    ,
    Or.prototype._removeRoot = function (e) {
      const t = this._elementRegistry
      const n = this._eventBus
      n.fire('root.remove', {
        element: e
      }),
      n.fire('root.removed', {
        element: e
      }),
      t.remove(e)
    }
    ,
    Or.prototype._addRoot = function (e, t) {
      const n = this._elementRegistry
      const r = this._eventBus
      r.fire('root.add', {
        element: e
      }),
      n.add(e, t),
      r.fire('root.added', {
        element: e,
        gfx: t
      })
    }
    ,
    Or.prototype._setRoot = function (e, t) {
      const n = this._rootElement
      n && (this._elementRegistry.updateGraphics(n, null, !0),
      this.hideLayer(n.layer)),
      e && (t || (t = this._findPlaneForRoot(e).layer),
      this._elementRegistry.updateGraphics(e, this._svg, !0),
      this.showLayer(e.layer)),
      this._rootElement = e,
      this._eventBus.fire('root.set', {
        element: e
      })
    }
    ,
    Or.prototype._ensureValid = function (e, t) {
      if (!t.id) { throw new Error('element must have an id') }
      if (this._elementRegistry.get(t.id)) { throw new Error('element <' + t.id + '> already exists') }
      const n = Pr[e]
      if (!V(n, function (e) {
        return void 0 !== t[e]
      }
      )) { throw new Error('must supply { ' + n.join(', ') + ' } with ' + e) }
    }
    ,
    Or.prototype._setParent = function (e, t, n) {
      kn(t.children, e, n),
      e.parent = t
    }
    ,
    Or.prototype._addElement = function (e, t, n, r) {
      n = n || this.getRootElement()
      const o = this._eventBus
      const i = this._graphicsFactory
      this._ensureValid(e, t),
      o.fire(e + '.add', {
        element: t,
        parent: n
      }),
      this._setParent(t, n, r)
      const a = i.create(e, t, r)
      return this._elementRegistry.add(t, a),
      i.update(e, t, a),
      o.fire(e + '.added', {
        element: t,
        gfx: a
      }),
      t
    }
    ,
    Or.prototype.addShape = function (e, t, n) {
      return this._addElement('shape', e, t, n)
    }
    ,
    Or.prototype.addConnection = function (e, t, n) {
      return this._addElement('connection', e, t, n)
    }
    ,
    Or.prototype._removeElement = function (e, t) {
      const n = this._elementRegistry
      const r = this._graphicsFactory
      const o = this._eventBus
      if (e = n.get(e.id || e)) {
        return o.fire(t + '.remove', {
          element: e
        }),
        r.remove(e),
        Sn(e.parent && e.parent.children, e),
        e.parent = null,
        o.fire(t + '.removed', {
          element: e
        }),
        n.remove(e),
        e
      }
    }
    ,
    Or.prototype.removeShape = function (e) {
      return this._removeElement(e, 'shape')
    }
    ,
    Or.prototype.removeConnection = function (e) {
      return this._removeElement(e, 'connection')
    }
    ,
    Or.prototype.getGraphics = function (e, t) {
      return this._elementRegistry.getGraphics(e, t)
    }
    ,
    Or.prototype._changeViewbox = function (e) {
      this._eventBus.fire('canvas.viewbox.changing'),
      e.apply(this),
      this._cachedViewbox = null,
      this._viewboxChanged()
    }
    ,
    Or.prototype._viewboxChanged = function () {
      this._eventBus.fire('canvas.viewbox.changed', {
        viewbox: this.viewbox()
      })
    }
    ,
    Or.prototype.viewbox = function (e) {
      if (void 0 === e && this._cachedViewbox) { return this._cachedViewbox }
      let t; let n; let r; let o; let i; let a; let s; const c = this._viewport; const l = this.getSize()
      return e
        ? (this._changeViewbox(function () {
            i = Math.min(l.width / e.width, l.height / e.height)
            const t = this._svg.createSVGMatrix().scale(i).translate(-e.x, -e.y)
            dt(c, t)
          }
          ),
          e)
        : (t = (r = this._rootElement ? this.getActiveLayer() : null) && r.getBBox() || {},
          n = (o = dt(c))
            ? o.matrix
            : (function (e, t, n, r, o, i) {
                const a = nt().createSVGMatrix()
                switch (arguments.length) {
                  case 0:
                    return a
                  case 1:
                    return rt(a, e)
                  case 6:
                    return rt(a, {
                      a: e,
                      b: t,
                      c: n,
                      d: r,
                      e: o,
                      f: i
                    })
                }
              }()),
          i = jr(n.a, 1e3),
          a = jr(-n.e || 0, 1e3),
          s = jr(-n.f || 0, 1e3),
          e = this._cachedViewbox = {
            x: a ? a / i : 0,
            y: s ? s / i : 0,
            width: l.width / i,
            height: l.height / i,
            scale: i,
            inner: {
              width: t.width || 0,
              height: t.height || 0,
              x: t.x || 0,
              y: t.y || 0
            },
            outer: l
          })
    }
    ,
    Or.prototype.scroll = function (e) {
      const t = this._viewport
      let n = t.getCTM()
      return e && this._changeViewbox(function () {
        e = le({
          dx: 0,
          dy: 0
        }, e || {}),
        n = this._svg.createSVGMatrix().translate(e.dx, e.dy).multiply(n),
        Tr(t, n)
      }
      ),
      {
        x: n.e,
        y: n.f
      }
    }
    ,
    Or.prototype.scrollToElement = function (e, t) {
      let n = 100
      typeof e === 'string' && (e = this._elementRegistry.get(e))
      const r = this.findRoot(e)
      if (r !== this.getRootElement() && this.setRootElement(r),
      r !== e) {
        t || (t = {}),
        typeof t === 'number' && (n = t),
        t = {
          top: t.top || n,
          right: t.right || n,
          bottom: t.bottom || n,
          left: t.left || n
        }
        let o; let i; const a = Ft(e); const s = xr(a); const c = this.viewbox(); const l = this.zoom()
        c.y += t.top / l,
        c.x += t.left / l,
        c.width -= (t.right + t.left) / l,
        c.height -= (t.bottom + t.top) / l
        const p = xr(c)
        if (a.width < c.width && a.height < c.height) {
          const u = Math.max(0, s.right - p.right)
          const d = Math.min(0, s.left - p.left)
          const f = Math.max(0, s.bottom - p.bottom)
          const h = Math.min(0, s.top - p.top)
          o = u || d,
          i = f || h
        } else {
          o = a.x - c.x,
          i = a.y - c.y
        }
        this.scroll({
          dx: -o * l,
          dy: -i * l
        })
      }
    }
    ,
    Or.prototype.zoom = function (e, t) {
      return e
        ? e === 'fit-viewport'
          ? this._fitViewport(t)
          : (this._changeViewbox(function () {
              kr(t) !== 'object' && (n = this.viewbox().outer,
              t = {
                x: n.width / 2,
                y: n.height / 2
              }),
              r = this._setZoom(e, t)
            }
            ),
            jr(r.a, 1e3))
        : this.viewbox(e).scale
      let n, r
    }
    ,
    Or.prototype._fitViewport = function (e) {
      let t; let n; const r = this.viewbox(); const o = r.outer; const i = r.inner
      return i.x >= 0 && i.y >= 0 && i.x + i.width <= o.width && i.y + i.height <= o.height && !e
        ? n = {
          x: 0,
          y: 0,
          width: Math.max(i.width + i.x, o.width),
          height: Math.max(i.height + i.y, o.height)
        }
        : (t = Math.min(1, o.width / i.width, o.height / i.height),
          n = {
            x: i.x + (e ? i.width / 2 - o.width / t / 2 : 0),
            y: i.y + (e ? i.height / 2 - o.height / t / 2 : 0),
            width: o.width / t,
            height: o.height / t
          }),
      this.viewbox(n),
      this.viewbox(!1).scale
    }
    ,
    Or.prototype._setZoom = function (e, t) {
      let n; let r; let o; let i; const a = this._svg; const s = this._viewport; const c = a.createSVGMatrix(); const l = a.createSVGPoint(); const p = (r = s.getCTM()).a
      return t
        ? (n = le(l, t).matrixTransform(r.inverse()),
          o = c.translate(n.x, n.y).scale(1 / p * e).translate(-n.x, -n.y),
          i = r.multiply(o))
        : i = c.scale(e),
      Tr(this._viewport, i),
      i
    }
    ,
    Or.prototype.getSize = function () {
      return {
        width: this._container.clientWidth,
        height: this._container.clientHeight
      }
    }
    ,
    Or.prototype.getAbsoluteBBox = function (e) {
      let t; const n = this.viewbox()
      return {
        x: (t = e.waypoints ? this.getGraphics(e).getBBox() : e).x * n.scale - n.x * n.scale,
        y: t.y * n.scale - n.y * n.scale,
        width: t.width * n.scale,
        height: t.height * n.scale
      }
    }
    ,
    Or.prototype.resized = function () {
      delete this._cachedViewbox,
      this._eventBus.fire('canvas.resized')
    }

    const Rr = 'data-element-id'
    function Nr (e) {
      this._elements = {},
      this._eventBus = e
    }
    function Mr (e, t, n) {
      const r = (function (e, t, n, r) {
        const o = n.inverse
        return Object.defineProperty(e, 'remove', {
          value: function (e) {
            const n = this.indexOf(e)
            return n !== -1 && (this.splice(n, 1),
            t.unset(e, o, r)),
            e
          }
        }),
        Object.defineProperty(e, 'contains', {
          value: function (e) {
            return this.indexOf(e) !== -1
          }
        }),
        Object.defineProperty(e, 'add', {
          value: function (e, n) {
            const i = this.indexOf(e)
            if (void 0 === n) {
              if (i !== -1) { return }
              n = this.length
            }
            i !== -1 && this.splice(i, 1),
            this.splice(n, 0, e),
            i === -1 && t.set(e, o, r)
          }
        }),
        Object.defineProperty(e, '__refs_collection', {
          value: !0
        }),
        e
      }(n[t.name] || [], e, t, n))
      Object.defineProperty(n, t.name, {
        enumerable: t.enumerable,
        value: r
      }),
      r.length && r.forEach(function (r) {
        e.set(r, t.inverse, n)
      }
      )
    }
    function Ir (e, t) {
      if (!(this instanceof Ir)) { return new Ir(e, t) }
      e.inverse = t,
      t.inverse = e,
      this.props = {},
      this.props[e.name] = e,
      this.props[t.name] = t
    }
    Nr.$inject = ['eventBus'],
    Nr.prototype.add = function (e, t, n) {
      const r = e.id
      this._validateId(r),
      We(t, Rr, r),
      n && We(n, Rr, r),
      this._elements[r] = {
        element: e,
        gfx: t,
        secondaryGfx: n
      }
    }
    ,
    Nr.prototype.remove = function (e) {
      const t = this._elements
      const n = e.id || e
      const r = n && t[n]
      r && (We(r.gfx, Rr, ''),
      r.secondaryGfx && We(r.secondaryGfx, Rr, ''),
      delete t[n])
    }
    ,
    Nr.prototype.updateId = function (e, t) {
      this._validateId(t),
      typeof e === 'string' && (e = this.get(e)),
      this._eventBus.fire('element.updateId', {
        element: e,
        newId: t
      })
      const n = this.getGraphics(e)
      const r = this.getGraphics(e, !0)
      this.remove(e),
      e.id = t,
      this.add(e, n, r)
    }
    ,
    Nr.prototype.updateGraphics = function (e, t, n) {
      const r = e.id || e
      const o = this._elements[r]
      return n ? o.secondaryGfx = t : o.gfx = t,
      t && We(t, Rr, r),
      t
    }
    ,
    Nr.prototype.get = function (e) {
      let t
      t = typeof e === 'string' ? e : e && We(e, Rr)
      const n = this._elements[t]
      return n && n.element
    }
    ,
    Nr.prototype.filter = function (e) {
      const t = []
      return this.forEach(function (n, r) {
        e(n, r) && t.push(n)
      }
      ),
      t
    }
    ,
    Nr.prototype.find = function (e) {
      for (let t = this._elements, n = Object.keys(t), r = 0; r < n.length; r++) {
        const o = t[n[r]]
        const i = o.element
        if (e(i, o.gfx)) { return i }
      }
    }
    ,
    Nr.prototype.getAll = function () {
      return this.filter(function (e) {
        return e
      }
      )
    }
    ,
    Nr.prototype.forEach = function (e) {
      const t = this._elements
      Object.keys(t).forEach(function (n) {
        const r = t[n]
        const o = r.element
        const i = r.gfx
        return e(o, i)
      }
      )
    }
    ,
    Nr.prototype.getGraphics = function (e, t) {
      const n = e.id || e
      const r = this._elements[n]
      return r && (t ? r.secondaryGfx : r.gfx)
    }
    ,
    Nr.prototype._validateId = function (e) {
      if (!e) { throw new Error('element must have an id') }
      if (this._elements[e]) { throw new Error('element with id ' + e + ' already added') }
    }
    ,
    Ir.prototype.bind = function (e, t) {
      if (typeof t === 'string') {
        if (!this.props[t]) { throw new Error('no property <' + t + '> in ref') }
        t = this.props[t]
      }
      t.collection
        ? Mr(this, t, e)
        : (function (e, t, n) {
            const r = t.inverse
            let o = n[t.name]
            Object.defineProperty(n, t.name, {
              configurable: t.configurable,
              enumerable: t.enumerable,
              get: function () {
                return o
              },
              set: function (t) {
                if (t !== o) {
                  const i = o
                  o = null,
                  i && e.unset(i, r, n),
                  o = t,
                  e.set(o, r, n)
                }
              }
            })
          }(this, t, e))
    }
    ,
    Ir.prototype.ensureRefsCollection = function (e, t) {
      const n = e[t.name]
      return (function (e) {
        return !0 === e.__refs_collection
      }(n)) || Mr(this, t, e),
      n
    }
    ,
    Ir.prototype.ensureBound = function (e, t) {
      (function (e, t) {
        return Object.prototype.hasOwnProperty.call(e, t.name || t)
      }
      )(e, t) || this.bind(e, t)
    }
    ,
    Ir.prototype.unset = function (e, t, n) {
      e && (this.ensureBound(e, t),
      t.collection ? this.ensureRefsCollection(e, t).remove(n) : e[t.name] = void 0)
    }
    ,
    Ir.prototype.set = function (e, t, n) {
      e && (this.ensureBound(e, t),
      t.collection ? this.ensureRefsCollection(e, t).add(n) : e[t.name] = n)
    }

    const Lr = new Ir({
      name: 'children',
      enumerable: !0,
      collection: !0
    }, {
      name: 'parent'
    })
    const zr = new Ir({
      name: 'labels',
      enumerable: !0,
      collection: !0
    }, {
      name: 'labelTarget'
    })
    const Fr = new Ir({
      name: 'attachers',
      collection: !0
    }, {
      name: 'host'
    })
    const $r = new Ir({
      name: 'outgoing',
      collection: !0
    }, {
      name: 'source'
    })
    const Hr = new Ir({
      name: 'incoming',
      collection: !0
    }, {
      name: 'target'
    })
    function qr () {
      Object.defineProperty(this, 'businessObject', {
        writable: !0
      }),
      Object.defineProperty(this, 'label', {
        get: function () {
          return this.labels[0]
        },
        set: function (e) {
          const t = this.label
          const n = this.labels
          !e && t ? n.remove(t) : n.add(e, 0)
        }
      }),
      Lr.bind(this, 'parent'),
      zr.bind(this, 'labels'),
      $r.bind(this, 'outgoing'),
      Hr.bind(this, 'incoming')
    }
    function Wr () {
      qr.call(this),
      Lr.bind(this, 'children'),
      Fr.bind(this, 'host'),
      Fr.bind(this, 'attachers')
    }
    function Gr () {
      qr.call(this),
      Lr.bind(this, 'children')
    }
    function Ur () {
      Wr.call(this),
      zr.bind(this, 'labelTarget')
    }
    function Vr () {
      qr.call(this),
      $r.bind(this, 'source'),
      Hr.bind(this, 'target')
    }
    w(Wr, qr),
    w(Gr, Wr),
    w(Ur, Wr),
    w(Vr, qr)
    const Qr = {
      connection: Vr,
      shape: Wr,
      label: Ur,
      root: Gr
    }
    function Yr () {
      this._uid = 12
    }
    function Kr (e) {
      return Kr = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      Kr(e)
    }
    Yr.prototype.createRoot = function (e) {
      return this.create('root', e)
    }
    ,
    Yr.prototype.createLabel = function (e) {
      return this.create('label', e)
    }
    ,
    Yr.prototype.createShape = function (e) {
      return this.create('shape', e)
    }
    ,
    Yr.prototype.createConnection = function (e) {
      return this.create('connection', e)
    }
    ,
    Yr.prototype.create = function (e, t) {
      return (t = le({}, t || {})).id || (t.id = e + '_' + this._uid++),
      (function (e, t) {
        const n = Qr[e]
        if (!n) { throw new Error('unknown type: <' + e + '>') }
        return le(new n(), t)
      }(e, t))
    }

    const Jr = '__fn'
    const Xr = Array.prototype.slice
    function Zr () {
      this._listeners = {},
      this.on('diagram.destroy', 1, this._destroy, this)
    }
    function eo () {}
    function to (e) {
      return e.childNodes[0]
    }
    function no (e, t, n, r, o) {
      const i = ot()
      i.setTranslate(t, n)
      const a = ot()
      a.setRotate(r || 0, 0, 0)
      const s = ot()
      s.setScale(o || 1, o || 1),
      dt(e, [i, a, s])
    }
    function ro (e, t, n) {
      const r = ot()
      r.setTranslate(t, n),
      dt(e, r)
    }
    function oo (e, t) {
      const n = ot()
      n.setRotate(t, 0, 0),
      dt(e, n)
    }
    function io (e, t) {
      this._eventBus = e,
      this._elementRegistry = t
    }
    function ao (e, t, n) {
      const r = n || t.firstChild
      e !== r && t.insertBefore(e, r)
    }
    Zr.prototype.on = function (e, t, n, r) {
      if (e = M(e) ? e : [e],
      z(t) && (r = n,
      n = t,
      t = 1e3),
      !L(t)) { throw new Error('priority must be a number') }
      let o = n
      r && ((o = ce(n, r))[Jr] = n[Jr] || n)
      const i = this
      e.forEach(function (e) {
        i._addListener(e, {
          priority: t,
          callback: o,
          next: null
        })
      }
      )
    }
    ,
    Zr.prototype.once = function (e, t, n, r) {
      const o = this
      if (z(t) && (r = n,
      n = t,
      t = 1e3),
      !L(t)) { throw new Error('priority must be a number') }
      function i () {
        i.__isTomb = !0
        const t = n.apply(r, arguments)
        return o.off(e, i),
        t
      }
      i[Jr] = n,
      this.on(e, t, i)
    }
    ,
    Zr.prototype.off = function (e, t) {
      e = M(e) ? e : [e]
      const n = this
      e.forEach(function (e) {
        n._removeListener(e, t)
      }
      )
    }
    ,
    Zr.prototype.createEvent = function (e) {
      const t = new eo()
      return t.init(e),
      t
    }
    ,
    Zr.prototype.fire = function (e, t) {
      let n, r, o, i
      if (i = Xr.call(arguments),
      Kr(e) === 'object' && (e = (t = e).type),
      !e) { throw new Error('no event type specified') }
      if (r = this._listeners[e]) {
        n = t instanceof eo ? t : this.createEvent(t),
        i[0] = n
        const a = n.type
        e !== a && (n.type = e)
        try {
          o = this._invokeListeners(n, i, r)
        } finally {
          e !== a && (n.type = a)
        }
        return void 0 === o && n.defaultPrevented && (o = !1),
        o
      }
    }
    ,
    Zr.prototype.handleError = function (e) {
      return !1 === this.fire('error', {
        error: e
      })
    }
    ,
    Zr.prototype._destroy = function () {
      this._listeners = {}
    }
    ,
    Zr.prototype._invokeListeners = function (e, t, n) {
      for (var r; n && !e.cancelBubble;) {
        r = this._invokeListener(e, t, n),
        n = n.next
      }
      return r
    }
    ,
    Zr.prototype._invokeListener = function (e, t, n) {
      let r
      if (n.callback.__isTomb) { return r }
      try {
        r = (function (e, t) {
          return e.apply(null, t)
        }(n.callback, t)),
        void 0 !== r && (e.returnValue = r,
        e.stopPropagation()),
        !1 === r && e.preventDefault()
      } catch (e) {
        if (!this.handleError(e)) {
          throw console.error('unhandled error in event listener', e),
          e
        }
      }
      return r
    }
    ,
    Zr.prototype._addListener = function (e, t) {
      let n; let r = this._getListeners(e)
      if (r) {
        for (; r;) {
          if (r.priority < t.priority) {
            return t.next = r,
            void (n ? n.next = t : this._setListeners(e, t))
          }
          n = r,
          r = r.next
        }
        n.next = t
      } else { this._setListeners(e, t) }
    }
    ,
    Zr.prototype._getListeners = function (e) {
      return this._listeners[e]
    }
    ,
    Zr.prototype._setListeners = function (e, t) {
      this._listeners[e] = t
    }
    ,
    Zr.prototype._removeListener = function (e, t) {
      let n; let r; let o; let i = this._getListeners(e)
      if (t) {
        for (; i;) {
          n = i.next,
          (o = i.callback) !== t && o[Jr] !== t || (r ? r.next = n : this._setListeners(e, n)),
          r = i,
          i = n
        }
      } else { this._setListeners(e, null) }
    }
    ,
    eo.prototype.stopPropagation = function () {
      this.cancelBubble = !0
    }
    ,
    eo.prototype.preventDefault = function () {
      this.defaultPrevented = !0
    }
    ,
    eo.prototype.init = function (e) {
      le(this, e || {})
    }
    ,
    io.$inject = ['eventBus', 'elementRegistry'],
    io.prototype._getChildrenContainer = function (e) {
      let t; const n = this._elementRegistry.getGraphics(e)
      return e.parent
        ? (t = (function (e) {
            return e.parentNode.childNodes[1]
          }(n)),
          t || (Ue(t = et('g')).add('djs-children'),
          Fe(n.parentNode, t)))
        : t = n,
      t
    }
    ,
    io.prototype._clear = function (e) {
      const t = to(e)
      return on(t),
      t
    }
    ,
    io.prototype._createContainer = function (e, t, n, r) {
      const o = et('g')
      Ue(o).add('djs-group'),
      void 0 !== n ? ao(o, t, t.childNodes[n]) : Fe(t, o)
      const i = et('g')
      Ue(i).add('djs-element'),
      Ue(i).add('djs-' + e),
      r && Ue(i).add('djs-frame'),
      Fe(o, i)
      const a = et('g')
      return Ue(a).add('djs-visual'),
      Fe(i, a),
      i
    }
    ,
    io.prototype.create = function (e, t, n) {
      const r = this._getChildrenContainer(t.parent)
      return this._createContainer(e, r, n, Ht(t))
    }
    ,
    io.prototype.updateContainments = function (e) {
      let t; const n = this; const r = this._elementRegistry
      t = U(e, function (e, t) {
        return t.parent && (e[t.parent.id] = t.parent),
        e
      }
      , {}),
      G(t, function (e) {
        const t = e.children
        if (t) {
          const o = n._getChildrenContainer(e)
          G(t.slice().reverse(), function (e) {
            ao(r.getGraphics(e).parentNode, o)
          }
          )
        }
      }
      )
    }
    ,
    io.prototype.drawShape = function (e, t) {
      const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
      return this._eventBus.fire('render.shape', {
        gfx: e,
        element: t,
        attrs: n
      })
    }
    ,
    io.prototype.getShapePath = function (e) {
      return this._eventBus.fire('render.getShapePath', e)
    }
    ,
    io.prototype.drawConnection = function (e, t) {
      const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
      return this._eventBus.fire('render.connection', {
        gfx: e,
        element: t,
        attrs: n
      })
    }
    ,
    io.prototype.getConnectionPath = function (e) {
      return this._eventBus.fire('render.getConnectionPath', e)
    }
    ,
    io.prototype.update = function (e, t, n) {
      if (t.parent) {
        const r = this._clear(n)
        if (e === 'shape') {
          this.drawShape(r, t),
          ro(n, t.x, t.y)
        } else {
          if (e !== 'connection') { throw new Error('unknown type: ' + e) }
          this.drawConnection(r, t)
        }
        t.hidden ? We(n, 'display', 'none') : We(n, 'display', 'block')
      }
    }
    ,
    io.prototype.remove = function (e) {
      Qe(this._elementRegistry.getGraphics(e).parentNode)
    }

    const so = {
      __depends__: [Gt],
      __init__: ['canvas'],
      canvas: ['type', Or],
      elementRegistry: ['type', Nr],
      elementFactory: ['type', Yr],
      eventBus: ['type', Zr],
      graphicsFactory: ['type', io]
    }
    function co (e, t) {
      this._injector = t || (function (e) {
        return t = [{
          config: ['value', e = e || {}]
        }, so].concat(e.modules || []),
        (n = new wt(t)).init(),
        n
        let t, n
      }(e)),
      this.get('eventBus').fire('diagram.init')
    }
    function lo () {}
    function po (e, t) {
      this.model = e,
      this.properties = t
    }
    co.prototype.get = function (e, t) {
      return this._injector.get(e, t)
    }
    ,
    co.prototype.invoke = function (e, t, n) {
      return this._injector.invoke(e, t, n)
    }
    ,
    co.prototype.destroy = function () {
      this.get('eventBus').fire('diagram.destroy')
    }
    ,
    co.prototype.clear = function () {
      this.get('eventBus').fire('diagram.clear')
    }
    ,
    lo.prototype.get = function (e) {
      return this.$model.properties.get(this, e)
    }
    ,
    lo.prototype.set = function (e, t) {
      this.$model.properties.set(this, e, t)
    }
    ,
    po.prototype.createType = function (e) {
      const t = this.model
      const n = this.properties
      const r = Object.create(lo.prototype)
      G(e.properties, function (e) {
        e.isMany || void 0 === e.default || (r[e.name] = e.default)
      }
      ),
      n.defineModel(r, t),
      n.defineDescriptor(r, e)
      const o = e.ns.name
      function i (e) {
        n.define(this, '$type', {
          value: o,
          enumerable: !0
        }),
        n.define(this, '$attrs', {
          value: {}
        }),
        n.define(this, '$parent', {
          writable: !0
        }),
        G(e, ce(function (e, t) {
          this.set(t, e)
        }
        , this))
      }
      return i.prototype = r,
      i.hasType = r.$instanceOf = this.model.hasType,
      n.defineModel(i, t),
      n.defineDescriptor(i, e),
      i
    }

    const uo = {
      String: !0,
      Boolean: !0,
      Integer: !0,
      Real: !0,
      Element: !0
    }
    const fo = {
      String: function (e) {
        return e
      },
      Boolean: function (e) {
        return e === 'true'
      },
      Integer: function (e) {
        return parseInt(e, 10)
      },
      Real: function (e) {
        return parseFloat(e)
      }
    }
    function ho (e, t) {
      const n = fo[e]
      return n ? n(t) : t
    }
    function mo (e) {
      return !!uo[e]
    }
    function vo (e) {
      return !!fo[e]
    }
    function go (e, t) {
      let n; let r; const o = e.split(/:/)
      if (o.length === 1) {
        n = e,
        r = t
      } else {
        if (o.length !== 2) { throw new Error('expected <prefix:localName> or <localName>, got ' + e) }
        n = o[1],
        r = o[0]
      }
      return {
        name: e = (r ? r + ':' : '') + n,
        prefix: r,
        localName: n
      }
    }
    function yo (e) {
      this.ns = e,
      this.name = e.name,
      this.allTypes = [],
      this.allTypesByName = {},
      this.properties = [],
      this.propertiesByName = {}
    }
    function bo (e, t) {
      this.packageMap = {},
      this.typeMap = {},
      this.packages = [],
      this.properties = t,
      G(e, ce(this.registerPackage, this))
    }
    function Ao (e, t, n) {
      const r = t[n]
      if (r in e) { throw new Error('package with ' + n + ' <' + r + '> already defined') }
    }
    function Eo (e) {
      this.model = e
    }
    function xo (e, t, n) {
      Object.defineProperty(e, t.name, {
        enumerable: !t.isReference,
        writable: !0,
        value: n,
        configurable: !0
      })
    }
    function wo (e) {
      return e.replace(/^:/, '')
    }
    function _o (e) {
      const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
      this.properties = new Eo(this),
      this.factory = new po(this, this.properties),
      this.registry = new bo(e, this.properties),
      this.typeCache = {},
      this.config = t
    }
    function Co (e) {
      return Co = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      Co(e)
    }
    yo.prototype.build = function () {
      return pe(this, ['ns', 'name', 'allTypes', 'allTypesByName', 'properties', 'propertiesByName', 'bodyProperty', 'idProperty'])
    }
    ,
    yo.prototype.addProperty = function (e, t, n) {
      typeof t === 'boolean' && (n = t,
      t = void 0),
      this.addNamedProperty(e, !1 !== n)
      const r = this.properties
      void 0 !== t ? r.splice(t, 0, e) : r.push(e)
    }
    ,
    yo.prototype.replaceProperty = function (e, t, n) {
      const r = e.ns
      const o = this.properties
      const i = this.propertiesByName
      const a = e.name !== t.name
      if (e.isId) {
        if (!t.isId) { throw new Error('property <' + t.ns.name + '> must be id property to refine <' + e.ns.name + '>') }
        this.setIdProperty(t, !1)
      }
      if (e.isBody) {
        if (!t.isBody) { throw new Error('property <' + t.ns.name + '> must be body property to refine <' + e.ns.name + '>') }
        this.setBodyProperty(t, !1)
      }
      const s = o.indexOf(e)
      if (s === -1) { throw new Error('property <' + r.name + '> not found in property list') }
      o.splice(s, 1),
      this.addProperty(t, n ? void 0 : s, a),
      i[r.name] = i[r.localName] = t
    }
    ,
    yo.prototype.redefineProperty = function (e, t, n) {
      const r = e.ns.prefix
      const o = t.split('#')
      const i = go(o[0], r)
      const a = go(o[1], i.prefix).name
      const s = this.propertiesByName[a]
      if (!s) { throw new Error('refined property <' + a + '> not found') }
      this.replaceProperty(s, e, n),
      delete e.redefines
    }
    ,
    yo.prototype.addNamedProperty = function (e, t) {
      const n = e.ns
      const r = this.propertiesByName
      t && (this.assertNotDefined(e, n.name),
      this.assertNotDefined(e, n.localName)),
      r[n.name] = r[n.localName] = e
    }
    ,
    yo.prototype.removeNamedProperty = function (e) {
      const t = e.ns
      const n = this.propertiesByName
      delete n[t.name],
      delete n[t.localName]
    }
    ,
    yo.prototype.setBodyProperty = function (e, t) {
      if (t && this.bodyProperty) { throw new Error('body property defined multiple times (<' + this.bodyProperty.ns.name + '>, <' + e.ns.name + '>)') }
      this.bodyProperty = e
    }
    ,
    yo.prototype.setIdProperty = function (e, t) {
      if (t && this.idProperty) { throw new Error('id property defined multiple times (<' + this.idProperty.ns.name + '>, <' + e.ns.name + '>)') }
      this.idProperty = e
    }
    ,
    yo.prototype.assertNotTrait = function (e) {
      if ((e.extends || []).length) { throw new Error('cannot create <'.concat(e.name, '> extending <').concat(e.extends, '>')) }
    }
    ,
    yo.prototype.assertNotDefined = function (e, t) {
      const n = e.name
      const r = this.propertiesByName[n]
      if (r) { throw new Error('property <' + n + '> already defined; override of <' + r.definedBy.ns.name + '#' + r.ns.name + '> by <' + e.definedBy.ns.name + '#' + e.ns.name + '> not allowed without redefines') }
    }
    ,
    yo.prototype.hasProperty = function (e) {
      return this.propertiesByName[e]
    }
    ,
    yo.prototype.addTrait = function (e, t) {
      t && this.assertNotTrait(e)
      const n = this.allTypesByName
      const r = this.allTypes
      const o = e.name
      o in n || (G(e.properties, ce(function (n) {
        n = le({}, n, {
          name: n.ns.localName,
          inherited: t
        }),
        Object.defineProperty(n, 'definedBy', {
          value: e
        })
        const r = n.replaces
        const o = n.redefines
        r || o
          ? this.redefineProperty(n, r || o, r)
          : (n.isBody && this.setBodyProperty(n),
            n.isId && this.setIdProperty(n),
            this.addProperty(n))
      }
      , this)),
      r.push(e),
      n[o] = e)
    }
    ,
    bo.prototype.getPackage = function (e) {
      return this.packageMap[e]
    }
    ,
    bo.prototype.getPackages = function () {
      return this.packages
    }
    ,
    bo.prototype.registerPackage = function (e) {
      e = le({}, e)
      const t = this.packageMap
      Ao(t, e, 'prefix'),
      Ao(t, e, 'uri'),
      G(e.types, ce(function (t) {
        this.registerType(t, e)
      }
      , this)),
      t[e.uri] = t[e.prefix] = e,
      this.packages.push(e)
    }
    ,
    bo.prototype.registerType = function (e, t) {
      const n = go((e = le({}, e, {
        superClass: (e.superClass || []).slice(),
        extends: (e.extends || []).slice(),
        properties: (e.properties || []).slice(),
        meta: le(e.meta || {})
      })).name, t.prefix)
      const r = n.name
      const o = {}
      G(e.properties, ce(function (e) {
        const t = go(e.name, n.prefix)
        const r = t.name
        mo(e.type) || (e.type = go(e.type, t.prefix).name),
        le(e, {
          ns: t,
          name: r
        }),
        o[r] = e
      }
      , this)),
      le(e, {
        ns: n,
        name: r,
        propertiesByName: o
      }),
      G(e.extends, ce(function (e) {
        const t = go(e, n.prefix)
        const o = this.typeMap[t.name]
        o.traits = o.traits || [],
        o.traits.push(r)
      }
      , this)),
      this.definePackage(e, t),
      this.typeMap[r] = e
    }
    ,
    bo.prototype.mapTypes = function (e, t, n) {
      const r = mo(e.name)
        ? {
            name: e.name
          }
        : this.typeMap[e.name]
      const o = this
      function i (n, r) {
        const i = go(n, mo(n) ? '' : e.prefix)
        o.mapTypes(i, t, r)
      }
      function a (e) {
        return i(e, !0)
      }
      if (!r) { throw new Error('unknown type <' + e.name + '>') }
      G(r.superClass, n
        ? a
        : function (e) {
          return i(e, !1)
        }
      ),
      t(r, !n),
      G(r.traits, a)
    }
    ,
    bo.prototype.getEffectiveDescriptor = function (e) {
      const t = go(e)
      const n = new yo(t)
      this.mapTypes(t, function (e, t) {
        n.addTrait(e, t)
      }
      )
      const r = n.build()
      return this.definePackage(r, r.allTypes[r.allTypes.length - 1].$pkg),
      r
    }
    ,
    bo.prototype.definePackage = function (e, t) {
      this.properties.define(e, '$pkg', {
        value: t
      })
    }
    ,
    Eo.prototype.set = function (e, t, n) {
      if (!F(t) || !t.length) { throw new TypeError('property name must be a non-empty string') }
      const r = this.getProperty(e, t)
      const o = r && r.name
      void 0 === n ? r ? delete e[o] : delete e.$attrs[wo(t)] : r ? o in e ? e[o] = n : xo(e, r, n) : e.$attrs[wo(t)] = n
    }
    ,
    Eo.prototype.get = function (e, t) {
      const n = this.getProperty(e, t)
      if (!n) { return e.$attrs[wo(t)] }
      const r = n.name
      return !e[r] && n.isMany && xo(e, n, []),
      e[r]
    }
    ,
    Eo.prototype.define = function (e, t, n) {
      if (!n.writable) {
        const r = n.value
        delete (n = le({}, n, {
          get: function () {
            return r
          }
        })).value
      }
      Object.defineProperty(e, t, n)
    }
    ,
    Eo.prototype.defineDescriptor = function (e, t) {
      this.define(e, '$descriptor', {
        value: t
      })
    }
    ,
    Eo.prototype.defineModel = function (e, t) {
      this.define(e, '$model', {
        value: t
      })
    }
    ,
    Eo.prototype.getProperty = function (e, t) {
      const n = this.model
      const r = n.getPropertyDescriptor(e, t)
      if (r) { return r }
      if (t.includes(':')) { return null }
      const o = n.config.strict
      if (void 0 !== o) {
        const i = new TypeError('unknown property <'.concat(t, '> on <').concat(e.$type, '>'))
        if (o) { throw i }
        typeof console !== 'undefined' && console.warn(i)
      }
      return null
    }
    ,
    _o.prototype.create = function (e, t) {
      const n = this.getType(e)
      if (!n) { throw new Error('unknown type <' + e + '>') }
      return new n(t)
    }
    ,
    _o.prototype.getType = function (e) {
      const t = this.typeCache
      const n = F(e) ? e : e.ns.name
      let r = t[n]
      return r || (e = this.registry.getEffectiveDescriptor(n),
      r = t[n] = this.factory.createType(e)),
      r
    }
    ,
    _o.prototype.createAny = function (e, t, n) {
      const r = go(e)
      const o = {
        $type: e,
        $instanceOf: function (e) {
          return e === this.$type
        },
        get: function (e) {
          return this[e]
        },
        set: function (e, t) {
          !(function (e, t, n) {
            let r = e
            G(t, function (e, o) {
              if (typeof e !== 'number' && typeof e !== 'string') { throw new Error('illegal key type: ' + B(e) + '. Key should be of type number or string.') }
              if (e === 'constructor') { throw new Error('illegal key: constructor') }
              if (e === '__proto__') { throw new Error('illegal key: __proto__') }
              const i = t[o + 1]
              let a = r[e]
              R(i) && N(a) && (a = r[e] = isNaN(+i) ? {} : []),
              T(i) ? T(n) ? delete r[e] : r[e] = n : r = a
            }
            )
          }(this, [e], t))
        }
      }
      const i = {
        name: e,
        isGeneric: !0,
        ns: {
          prefix: r.prefix,
          localName: r.localName,
          uri: t
        }
      }
      return this.properties.defineDescriptor(o, i),
      this.properties.defineModel(o, this),
      this.properties.define(o, 'get', {
        enumerable: !1,
        writable: !0
      }),
      this.properties.define(o, 'set', {
        enumerable: !1,
        writable: !0
      }),
      this.properties.define(o, '$parent', {
        enumerable: !1,
        writable: !0
      }),
      this.properties.define(o, '$instanceOf', {
        enumerable: !1,
        writable: !0
      }),
      G(n, function (e, t) {
        I(e) && void 0 !== e.value ? o[e.name] = e.value : o[t] = e
      }
      ),
      o
    }
    ,
    _o.prototype.getPackage = function (e) {
      return this.registry.getPackage(e)
    }
    ,
    _o.prototype.getPackages = function () {
      return this.registry.getPackages()
    }
    ,
    _o.prototype.getElementDescriptor = function (e) {
      return e.$descriptor
    }
    ,
    _o.prototype.hasType = function (e, t) {
      return void 0 === t && (t = e,
      e = this),
      t in e.$model.getElementDescriptor(e).allTypesByName
    }
    ,
    _o.prototype.getPropertyDescriptor = function (e, t) {
      return this.getElementDescriptor(e).propertiesByName[t]
    }
    ,
    _o.prototype.getTypeDescriptor = function (e) {
      return this.registry.typeMap[e]
    }

    const So = String.fromCharCode
    const ko = Object.prototype.hasOwnProperty
    const jo = /&#(\d+);|&#x([0-9a-f]+);|&(\w+);/gi
    const Bo = {
      amp: '&',
      apos: "'",
      gt: '>',
      lt: '<',
      quot: '"'
    }
    function Do (e, t, n, r) {
      return r ? ko.call(Bo, r) ? Bo[r] : '&' + r + ';' : So(t || parseInt(n, 16))
    }
    function Po (e) {
      return e.length > 3 && e.indexOf('&') !== -1 ? e.replace(jo, Do) : e
    }
    Object.keys(Bo).forEach(function (e) {
      Bo[e.toUpperCase()] = Bo[e]
    }
    )
    const Oo = 'xsi:type'
    const To = 'non-whitespace outside of root node'
    function Ro (e) {
      return new Error(e)
    }
    function No (e) {
      return 'missing namespace for prefix <' + e + '>'
    }
    function Mo (e) {
      return {
        get: e,
        enumerable: !0
      }
    }
    function Io (e) {
      let t; const n = {}
      for (t in e) { n[t] = e[t] }
      return n
    }
    function Lo (e) {
      return e + '$uri'
    }
    function zo () {
      return {
        line: 0,
        column: 0
      }
    }
    function Fo (e) {
      throw e
    }
    function $o (e) {
      if (!this) { return new $o(e) }
      let t; let n; let r; let o; let i; let a; let s; let c; let l; const p = e && e.proxy; let u = Fo; let d = zo; let f = !1; let h = !1; let m = null; let v = !1
      function g (e) {
        e instanceof Error || (e = Ro(e)),
        m = e,
        u(e, d)
      }
      function y (e) {
        i && (e instanceof Error || (e = Ro(e)),
        i(e, d))
      }
      this.on = function (e, l) {
        if (typeof l !== 'function') { throw Ro('required args <name, cb>') }
        switch (e) {
          case 'openTag':
            n = l
            break
          case 'text':
            t = l
            break
          case 'closeTag':
            r = l
            break
          case 'error':
            u = l
            break
          case 'warn':
            i = l
            break
          case 'cdata':
            o = l
            break
          case 'attention':
            c = l
            break
          case 'question':
            s = l
            break
          case 'comment':
            a = l
            break
          default:
            throw Ro('unsupported event: ' + e)
        }
        return this
      }
      ,
      this.ns = function (e) {
        if (void 0 === e && (e = {}),
        Co(e) !== 'object') { throw Ro('required args <nsMap={}>') }
        let t; const n = {}
        for (t in e) { n[t] = e[t] }
        return n['http://www.w3.org/2001/XMLSchema-instance'] = 'xsi',
        h = !0,
        l = n,
        this
      }
      ,
      this.parse = function (e) {
        if (typeof e !== 'string') { throw Ro('required args <xml=string>') }
        return m = null,
        (function (e) {
          let i; let u; let m; let b; let A; let E; let x; let w; let _; let C; let S; const k = h ? [] : null; let j = h
            ? (function (e) {
                let t; let n; const r = {}
                for (t in e) {
                  r[n = e[t]] = n,
                  r[Lo(n)] = t
                }
                return r
              }(l))
            : null; const B = []; let D = 0; let P = !1; let O = !1; let T = 0; let R = 0; let N = ''; let M = 0
          function I () {
            if (S !== null) { return S }
            let e; let t; let n; let r; let o; let i; let a; let s; let c; let p; let u; let d = h && j.xmlns; const m = h && f ? [] : null; let v = M; const g = N; let b = g.length; const A = {}; const E = {}
            e: for (; v < b; v++) {
              if (c = !1,
              !((p = g.charCodeAt(v)) === 32 || p < 14 && p > 8)) {
                for ((p < 65 || p > 122 || p > 90 && p < 97) && p !== 95 && p !== 58 && (y('illegal first char attribute name'),
                c = !0),
                u = v + 1; u < b; u++) {
                  if (!((p = g.charCodeAt(u)) > 96 && p < 123 || p > 64 && p < 91 || p > 47 && p < 59 || p === 46 || p === 45 || p === 95)) {
                    if (p === 32 || p < 14 && p > 8) {
                      y('missing attribute value'),
                      v = u
                      continue e
                    }
                    if (p === 61) { break }
                    y('illegal attribute name char'),
                    c = !0
                  }
                }
                if ((s = g.substring(v, u)) === 'xmlns:xmlns' && (y('illegal declaration of xmlns'),
                c = !0),
                (p = g.charCodeAt(u + 1)) === 34) {
                  (u = g.indexOf('"', v = u + 2)) === -1 && (u = g.indexOf("'", v)) !== -1 && (y('attribute value quote missmatch'),
                  c = !0)
                } else if (p === 39) {
                  (u = g.indexOf("'", v = u + 2)) === -1 && (u = g.indexOf('"', v)) !== -1 && (y('attribute value quote missmatch'),
                  c = !0)
                } else {
                  for (y('missing attribute value quotes'),
                  c = !0,
                  u += 1; u < b && !((p = g.charCodeAt(u + 1)) === 32 || p < 14 && p > 8); u++)
                    ;
                }
                for (u === -1 && (y('missing closing quotes'),
                u = b,
                c = !0),
                c || (i = g.substring(v, u)),
                v = u; u + 1 < b && !((p = g.charCodeAt(u + 1)) === 32 || p < 14 && p > 8); u++) {
                  v === u && (y('illegal character after attribute end'),
                  c = !0)
                }
                if (v = u + 1,
                !c) {
                  if (s in E) { y('attribute <' + s + '> already defined') } else if (E[s] = !0,
                  h) {
                    if (f) {
                      if ((o = s === 'xmlns' ? 'xmlns' : s.charCodeAt(0) === 120 && s.substr(0, 6) === 'xmlns:' ? s.substr(6) : null) !== null) {
                        if (e = Po(i),
                        t = Lo(o),
                        !(a = l[e])) {
                          if (o === 'xmlns' || t in j && j[t] !== e) {
                            do {
                              a = 'ns' + D++
                            } while (void 0 !== j[a])
                          } else { a = o }
                          l[e] = a
                        }
                        j[o] !== a && (r || (j = Io(j),
                        r = !0),
                        j[o] = a,
                        o === 'xmlns' && (j[Lo(a)] = e,
                        d = a),
                        j[t] = e),
                        A[s] = i
                        continue
                      }
                      m.push(s, i)
                    } else {
                      (p = s.indexOf(':')) !== -1
                        ? (n = j[s.substring(0, p)])
                            ? ((s = d === n ? s.substr(p + 1) : n + s.substr(p)) === Oo && ((p = i.indexOf(':')) !== -1
                                ? (n = i.substring(0, p),
                                  i = (n = j[n] || n) + i.substring(p))
                                : i = d + ':' + i),
                              A[s] = i)
                            : y(No(s.substring(0, p)))
                        : A[s] = i
                    }
                  } else { A[s] = i }
                }
              }
            }
            if (f) {
              for (v = 0,
              b = m.length; v < b; v++) {
                if (s = m[v++],
                i = m[v],
                (p = s.indexOf(':')) !== -1) {
                  if (!(n = j[s.substring(0, p)])) {
                    y(No(s.substring(0, p)))
                    continue
                  }
                  (s = d === n ? s.substr(p + 1) : n + s.substr(p)) === Oo && ((p = i.indexOf(':')) !== -1
                    ? (n = i.substring(0, p),
                      i = (n = j[n] || n) + i.substring(p))
                    : i = d + ':' + i)
                }
                A[s] = i
              }
            }
            return S = A
          }
          for (d = function () {
            for (var t, n, r = /(\r\n|\r|\n)/g, o = 0, i = 0, a = 0, s = R; T >= a && (t = r.exec(e)) && !((s = t[0].length + t.index) > T);) {
              o += 1,
              a = s
            }
            return T == -1
              ? (i = s,
                n = e.substring(R))
              : R === 0
                ? n = e.substring(R, T)
                : (i = T - a,
                  n = R == -1 ? e.substring(T) : e.substring(T, R + 1)),
            {
              data: n,
              line: o,
              column: i
            }
          }
          ,
          p && (C = Object.create({}, {
            name: Mo(function () {
              return w
            }
            ),
            originalName: Mo(function () {
              return _
            }
            ),
            attrs: Mo(I),
            ns: Mo(function () {
              return j
            }
            )
          })); R !== -1;) {
            if ((T = e.charCodeAt(R) === 60 ? R : e.indexOf('<', R)) === -1) { return B.length ? g('unexpected end of file') : R === 0 ? g('missing start tag') : void (R < e.length && e.substring(R).trim() && y(To)) }
            if (R !== T) {
              if (B.length) {
                if (t && (t(e.substring(R, T), Po, d),
                v)) { return }
              } else if (e.substring(R, T).trim() && (y(To),
              v)) { return }
            }
            if ((A = e.charCodeAt(T + 1)) === 33) {
              if ((b = e.charCodeAt(T + 2)) === 91 && e.substr(T + 3, 6) === 'CDATA[') {
                if ((R = e.indexOf(']]>', T)) === -1) { return g('unclosed cdata') }
                if (o && (o(e.substring(T + 9, R), d),
                v)) { return }
                R += 3
                continue
              }
              if (b === 45 && e.charCodeAt(T + 3) === 45) {
                if ((R = e.indexOf('--\x3e', T)) === -1) { return g('unclosed comment') }
                if (a && (a(e.substring(T + 4, R), Po, d),
                v)) { return }
                R += 3
                continue
              }
            }
            if (A !== 63) {
              for (u = T + 1; ; u++) {
                if (E = e.charCodeAt(u),
                isNaN(E)) {
                  return R = -1,
                  g('unclosed tag')
                }
                if (E === 34) { u = (b = e.indexOf('"', u + 1)) !== -1 ? b : u } else if (E === 39) { u = (b = e.indexOf("'", u + 1)) !== -1 ? b : u } else if (E === 62) {
                  R = u
                  break
                }
              }
              if (A !== 33) {
                if (S = {},
                A === 47) {
                  if (P = !1,
                  O = !0,
                  !B.length) { return g('missing open tag') }
                  if (u = w = B.pop(),
                  b = T + 2 + u.length,
                  e.substring(T + 2, b) !== u) { return g('closing tag mismatch') }
                  for (; b < R; b++) {
                    if (!((A = e.charCodeAt(b)) === 32 || A > 8 && A < 14)) { return g('close tag') }
                  }
                } else {
                  if (e.charCodeAt(R - 1) === 47
                    ? (u = w = e.substring(T + 1, R - 1),
                      P = !0,
                      O = !0)
                    : (u = w = e.substring(T + 1, R),
                      P = !0,
                      O = !1),
                  !(A > 96 && A < 123 || A > 64 && A < 91 || A === 95 || A === 58)) { return g('illegal first char nodeName') }
                  for (b = 1,
                  m = u.length; b < m; b++) {
                    if (!((A = u.charCodeAt(b)) > 96 && A < 123 || A > 64 && A < 91 || A > 47 && A < 59 || A === 45 || A === 95 || A == 46)) {
                      if (A === 32 || A < 14 && A > 8) {
                        w = u.substring(0, b),
                        S = null
                        break
                      }
                      return g('invalid nodeName')
                    }
                  }
                  O || B.push(w)
                }
                if (h) {
                  if (i = j,
                  P && (O || k.push(i),
                  S === null && (f = u.indexOf('xmlns', b) !== -1) && (M = b,
                  N = u,
                  I(),
                  f = !1)),
                  _ = w,
                  (A = w.indexOf(':')) !== -1) {
                    if (!(x = j[w.substring(0, A)])) { return g('missing namespace on <' + _ + '>') }
                    w = w.substr(A + 1)
                  } else { x = j.xmlns }
                  x && (w = x + ':' + w)
                }
                if (P && (M = b,
                N = u,
                n && (p ? n(C, Po, O, d) : n(w, I, Po, O, d),
                v))) { return }
                if (O) {
                  if (r && (r(p ? C : w, Po, P, d),
                  v)) { return }
                  h && (j = P ? i : k.pop())
                }
                R += 1
              } else {
                if (c && (c(e.substring(T, R + 1), Po, d),
                v)) { return }
                R += 1
              }
            } else {
              if ((R = e.indexOf('?>', T)) === -1) { return g('unclosed question') }
              if (s && (s(e.substring(T, R + 2), d),
              v)) { return }
              R += 2
            }
          }
        }(e)),
        d = zo,
        v = !1,
        m
      }
      ,
      this.stop = function () {
        v = !0
      }
    }
    function Ho (e) {
      return e.xml && e.xml.tagAlias === 'lowerCase'
    }
    const qo = {
      xsi: 'http://www.w3.org/2001/XMLSchema-instance',
      xml: 'http://www.w3.org/XML/1998/namespace'
    }
    const Wo = 'xsi:type'
    function Go (e) {
      return e.xml && e.xml.serialize
    }
    function Uo (e) {
      return Go(e) === Wo
    }
    function Vo (e, t) {
      return Ho(t) ? e.prefix + ':' + ((n = e.localName).charAt(0).toUpperCase() + n.slice(1)) : e.name
      let n
    }
    function Qo (e) {
      return new Error(e)
    }
    function Yo (e) {
      return e.$descriptor
    }
    function Ko (e) {
      le(this, e),
      this.elementsById = {},
      this.references = [],
      this.warnings = [],
      this.addReference = function (e) {
        this.references.push(e)
      }
      ,
      this.addElement = function (e) {
        if (!e) { throw Qo('expected element') }
        let t; const n = this.elementsById; const r = Yo(e).idProperty
        if (r && (t = e.get(r.name))) {
          if (!/^([a-z][\w-.]*:)?[a-z_][\w-.]*$/i.test(t)) { throw new Error('illegal ID <' + t + '>') }
          if (n[t]) { throw Qo('duplicate ID <' + t + '>') }
          n[t] = e
        }
      }
      ,
      this.addWarning = function (e) {
        this.warnings.push(e)
      }
    }
    function Jo () {}
    function Xo () {}
    function Zo () {}
    function ei (e, t) {
      this.property = e,
      this.context = t
    }
    function ti (e, t) {
      this.element = t,
      this.propertyDesc = e
    }
    function ni () {}
    function ri (e, t, n) {
      this.model = e,
      this.type = e.getType(t),
      this.context = n
    }
    function oi (e, t, n) {
      ri.call(this, e, t, n)
    }
    function ii (e, t, n) {
      this.model = e,
      this.context = n
    }
    function ai (e) {
      e instanceof _o && (e = {
        model: e
      }),
      le(this, {
        lax: !1
      }, e)
    }
    Jo.prototype.handleEnd = function () {}
    ,
    Jo.prototype.handleText = function () {}
    ,
    Jo.prototype.handleNode = function () {}
    ,
    Xo.prototype = Object.create(Jo.prototype),
    Xo.prototype.handleNode = function () {
      return this
    }
    ,
    Zo.prototype = Object.create(Jo.prototype),
    Zo.prototype.handleText = function (e) {
      this.body = (this.body || '') + e
    }
    ,
    ei.prototype = Object.create(Zo.prototype),
    ei.prototype.handleNode = function (e) {
      if (this.element) { throw Qo('expected no sub nodes') }
      return this.element = this.createReference(e),
      this
    }
    ,
    ei.prototype.handleEnd = function () {
      this.element.id = this.body
    }
    ,
    ei.prototype.createReference = function (e) {
      return {
        property: this.property.ns.name,
        id: ''
      }
    }
    ,
    ti.prototype = Object.create(Zo.prototype),
    ti.prototype.handleEnd = function () {
      let e = this.body || ''
      const t = this.element
      const n = this.propertyDesc
      e = ho(n.type, e),
      n.isMany ? t.get(n.name).push(e) : t.set(n.name, e)
    }
    ,
    ni.prototype = Object.create(Zo.prototype),
    ni.prototype.handleNode = function (e) {
      let t = this
      let n = this.element
      return n
        ? t = this.handleChild(e)
        : (n = this.element = this.createElement(e),
          this.context.addElement(n)),
      t
    }
    ,
    ri.prototype = Object.create(ni.prototype),
    ri.prototype.addReference = function (e) {
      this.context.addReference(e)
    }
    ,
    ri.prototype.handleText = function (e) {
      if (!Yo(this.element).bodyProperty) { throw Qo('unexpected body text <' + e + '>') }
      Zo.prototype.handleText.call(this, e)
    }
    ,
    ri.prototype.handleEnd = function () {
      let e = this.body
      const t = this.element
      const n = Yo(t).bodyProperty
      n && void 0 !== e && (e = ho(n.type, e),
      t.set(n.name, e))
    }
    ,
    ri.prototype.createElement = function (e) {
      let t; const n = e.attributes; const r = this.type; const o = Yo(r); const i = this.context; const a = new r({}); const s = this.model
      return G(n, function (e, n) {
        const r = o.propertiesByName[n]
        r && r.isReference
          ? r.isMany
            ? G(e.split(' '), function (e) {
              i.addReference({
                element: a,
                property: r.ns.name,
                id: e
              })
            }
            )
            : i.addReference({
              element: a,
              property: r.ns.name,
              id: e
            })
          : (r
              ? e = ho(r.type, e)
              : n !== 'xmlns' && (t = go(n, o.ns.prefix),
              s.getPackage(t.prefix) && i.addWarning({
                message: 'unknown attribute <' + n + '>',
                element: a,
                property: n,
                value: e
              })),
            a.set(n, e))
      }
      ),
      a
    }
    ,
    ri.prototype.getPropertyForNode = function (e) {
      let t; let n; const r = go(e.name); const o = this.type; const i = this.model; const a = Yo(o); const s = r.name; let c = a.propertiesByName[s]
      if (c && !c.isAttr) {
        return Uo(c) && (t = e.attributes[Wo])
          ? (t = (function (e, t) {
              const n = go(e)
              return (function (e, t) {
                const n = e.name
                const r = e.localName
                const o = t.xml && t.xml.typePrefix
                return o && r.indexOf(o) === 0 ? e.prefix + ':' + r.slice(o.length) : n
              }(n, t.getPackage(n.prefix)))
            }(t, i)),
            le({}, c, {
              effectiveType: Yo(n = i.getType(t)).name
            }))
          : c
      }
      const l = i.getPackage(r.prefix)
      if (l) {
        if (t = Vo(r, l),
        n = i.getType(t),
        c = H(a.properties, function (e) {
          return !e.isVirtual && !e.isReference && !e.isAttribute && n.hasType(e.type)
        }
        ),
        c) {
          return le({}, c, {
            effectiveType: Yo(n).name
          })
        }
      } else if (c = H(a.properties, function (e) {
        return !e.isReference && !e.isAttribute && e.type === 'Element'
      }
      ),
      c) { return c }
      throw Qo('unrecognized element <' + r.name + '>')
    }
    ,
    ri.prototype.toString = function () {
      return 'ElementDescriptor[' + Yo(this.type).name + ']'
    }
    ,
    ri.prototype.valueHandler = function (e, t) {
      return new ti(e, t)
    }
    ,
    ri.prototype.referenceHandler = function (e) {
      return new ei(e, this.context)
    }
    ,
    ri.prototype.handler = function (e) {
      return e === 'Element' ? new ii(this.model, e, this.context) : new ri(this.model, e, this.context)
    }
    ,
    ri.prototype.handleChild = function (e) {
      let t, n, r, o
      if (t = this.getPropertyForNode(e),
      r = this.element,
      vo(n = t.effectiveType || t.type)) { return this.valueHandler(t, r) }
      const i = (o = t.isReference ? this.referenceHandler(t).handleNode(e) : this.handler(n).handleNode(e)).element
      return void 0 !== i && (t.isMany ? r.get(t.name).push(i) : r.set(t.name, i),
      t.isReference
        ? (le(i, {
            element: r
          }),
          this.context.addReference(i))
        : i.$parent = r),
      o
    }
    ,
    oi.prototype = Object.create(ri.prototype),
    oi.prototype.createElement = function (e) {
      const t = e.name
      const n = go(t)
      const r = this.model
      const o = this.type
      const i = r.getPackage(n.prefix)
      const a = i && Vo(n, i) || t
      if (!o.hasType(a)) { throw Qo('unexpected element <' + e.originalName + '>') }
      return ri.prototype.createElement.call(this, e)
    }
    ,
    ii.prototype = Object.create(ni.prototype),
    ii.prototype.createElement = function (e) {
      const t = e.name
      const n = go(t).prefix
      const r = e.ns[n + '$uri']
      const o = e.attributes
      return this.model.createAny(t, r, o)
    }
    ,
    ii.prototype.handleChild = function (e) {
      const t = new ii(this.model, 'Element', this.context).handleNode(e)
      const n = this.element
      const r = t.element
      return void 0 !== r && ((n.$children = n.$children || []).push(r),
      r.$parent = n),
      t
    }
    ,
    ii.prototype.handleEnd = function () {
      this.body && (this.element.$body = this.body)
    }
    ,
    ai.prototype.fromXML = function (e, t, n) {
      let r = t.rootHandler
      t instanceof ri
        ? (r = t,
          t = {})
        : typeof t === 'string'
          ? (r = this.handler(t),
            t = {})
          : typeof r === 'string' && (r = this.handler(r))
      const o = this.model
      const i = this.lax
      const a = new Ko(le({}, t, {
        rootHandler: r
      }))
      const s = new $o({
        proxy: !0
      })
      const c = (function () {
        const e = []
        return Object.defineProperty(e, 'peek', {
          value: function () {
            return this[this.length - 1]
          }
        }),
        e
      }())
      function l (e, t, n) {
        const r = t()
        const o = r.line
        const i = r.column
        let s = r.data
        s.charAt(0) === '<' && s.indexOf(' ') !== -1 && (s = s.slice(0, s.indexOf(' ')) + '>')
        const c = 'unparsable content ' + (s ? s + ' ' : '') + 'detected\n\tline: ' + o + '\n\tcolumn: ' + i + '\n\tnested error: ' + e.message
        if (n) {
          return a.addWarning({
            message: c,
            error: e
          }),
          !0
        }
        throw Qo(c)
      }
      function p (e, t) {
        return l(e, t, !0)
      }
      r.context = a,
      c.push(r)
      const u = /^<\?xml /i
      const d = / encoding="([^"]+)"/i
      const f = /^utf-8$/i
      function h (e, t) {
        try {
          c.peek().handleText(e)
        } catch (e) {
          p(e, t)
        }
      }
      const m = o.getPackages().reduce(function (e, t) {
        return e[t.uri] = t.prefix,
        e
      }
      , {
        'http://www.w3.org/XML/1998/namespace': 'xml'
      })
      return s.ns(m).on('openTag', function (e, t, n, r) {
        const o = e.attrs || {}
        const a = Object.keys(o).reduce(function (e, n) {
          const r = t(o[n])
          return e[n] = r,
          e
        }
        , {})
        !(function (e, t) {
          const n = c.peek()
          try {
            c.push(n.handleNode(e))
          } catch (e) {
            l(e, t, i) && c.push(new Xo())
          }
        }({
          name: e.name,
          originalName: e.originalName,
          attributes: a,
          ns: e.ns
        }, r))
      }
      ).on('question', function (e) {
        if (u.test(e)) {
          const t = d.exec(e)
          const n = t && t[1]
          n && !f.test(n) && a.addWarning({
            message: 'unsupported document encoding <' + n + '>, falling back to UTF-8'
          })
        }
      }
      ).on('closeTag', function () {
        c.pop().handleEnd()
      }
      ).on('cdata', h).on('text', function (e, t, n) {
        !(function (e, t) {
          e.trim() && h(e, t)
        }(t(e), n))
      }
      ).on('error', l).on('warn', p),
      new Promise(function (t, n) {
        let o
        try {
          s.parse(e),
          (function () {
            let e; let t; const n = a.elementsById; const r = a.references
            for (e = 0; t = r[e]; e++) {
              const o = t.element
              const i = n[t.id]
              const s = Yo(o).propertiesByName[t.property]
              if (i || a.addWarning({
                message: 'unresolved reference <' + t.id + '>',
                element: t.element,
                property: t.property,
                value: t.id
              }),
              s.isMany) {
                const c = o.get(s.name)
                let l = c.indexOf(t)
                l === -1 && (l = c.length),
                i ? c[l] = i : c.splice(l, 1)
              } else { o.set(s.name, i) }
            }
          }())
        } catch (e) {
          o = e
        }
        const i = r.element
        o || i || (o = Qo('failed to parse document as <' + r.type.$descriptor.name + '>'))
        const c = a.warnings
        const l = a.references
        const p = a.elementsById
        return o
          ? (o.warnings = c,
            n(o))
          : t({
            rootElement: i,
            elementsById: p,
            references: l,
            warnings: c
          })
      }
      )
    }
    ,
    ai.prototype.handler = function (e) {
      return new oi(this.model, e)
    }

    const si = /<|>|'|"|&|\n\r|\n/g
    const ci = /<|>|&/g
    function li (e) {
      const t = {}
      const n = {}
      const r = {}
      const o = []
      const i = []
      this.byUri = function (t) {
        return n[t] || e && e.byUri(t)
      }
      ,
      this.add = function (e, t) {
        n[e.uri] = e,
        t ? o.push(e) : i.push(e),
        this.mapPrefix(e.prefix, e.uri)
      }
      ,
      this.uriByPrefix = function (e) {
        return t[e || 'xmlns']
      }
      ,
      this.mapPrefix = function (e, n) {
        t[e || 'xmlns'] = n
      }
      ,
      this.getNSKey = function (e) {
        return void 0 !== e.prefix ? e.uri + '|' + e.prefix : e.uri
      }
      ,
      this.logUsed = function (t) {
        const n = t.uri
        const o = this.getNSKey(t)
        r[o] = this.byUri(n),
        e && e.logUsed(t)
      }
      ,
      this.getUsed = function (e) {
        const t = this
        return [].concat(o, i).filter(function (e) {
          const n = t.getNSKey(e)
          return r[n]
        }
        )
      }
    }
    function pi (e, t) {
      e.super_ = t,
      e.prototype = Object.create(t.prototype, {
        constructor: {
          value: e,
          enumerable: !1,
          writable: !0,
          configurable: !0
        }
      })
    }
    function ui (e) {
      return F(e) ? e : (e.prefix ? e.prefix + ':' : '') + e.localName
    }
    const di = {
      '\n': '#10',
      '\n\r': '#10',
      '"': '#34',
      "'": '#39',
      '<': '#60',
      '>': '#62',
      '&': '#38'
    }
    const fi = {
      '<': 'lt',
      '>': 'gt',
      '&': 'amp'
    }
    function hi (e, t, n) {
      return (e = F(e) ? e : '' + e).replace(t, function (e) {
        return '&' + n[e] + ';'
      }
      )
    }
    function mi (e) {
      this.tagName = e
    }
    function vi () {}
    function gi (e) {
      this.tagName = e
    }
    function yi (e, t) {
      this.body = [],
      this.attrs = [],
      this.parent = e,
      this.propertyDescriptor = t
    }
    function bi (e, t) {
      yi.call(this, e, t)
    }
    function Ai () {
      this.value = '',
      this.write = function (e) {
        this.value += e
      }
    }
    function Ei (e, t) {
      const n = ['']
      this.append = function (t) {
        return e.write(t),
        this
      }
      ,
      this.appendNewLine = function () {
        return t && e.write('\n'),
        this
      }
      ,
      this.appendIndent = function () {
        return t && e.write(n.join('  ')),
        this
      }
      ,
      this.indent = function () {
        return n.push(''),
        this
      }
      ,
      this.unindent = function () {
        return n.pop(),
        this
      }
    }
    function xi (e) {
      return e = le({
        format: !1,
        preamble: !0
      }, e || {}),
      {
        toXML: function (t, n) {
          const r = n || new Ai()
          const o = new Ei(r, e.format)
          if (e.preamble && o.append('<?xml version="1.0" encoding="UTF-8"?>\n'),
          (new yi()).build(t).serializeTo(o),
          !n) { return r.value }
        }
      }
    }
    function wi (e, t) {
      _o.call(this, e, t)
    }
    mi.prototype.build = function (e) {
      return this.element = e,
      this
    }
    ,
    mi.prototype.serializeTo = function (e) {
      e.appendIndent().append('<' + this.tagName + '>' + this.element.id + '</' + this.tagName + '>').appendNewLine()
    }
    ,
    vi.prototype.serializeValue = vi.prototype.serializeTo = function (e) {
      e.append(this.escape ? hi(this.value, ci, fi) : this.value)
    }
    ,
    vi.prototype.build = function (e, t) {
      return this.value = t,
      e.type === 'String' && t.search(ci) !== -1 && (this.escape = !0),
      this
    }
    ,
    pi(gi, vi),
    gi.prototype.serializeTo = function (e) {
      e.appendIndent().append('<' + this.tagName + '>'),
      this.serializeValue(e),
      e.append('</' + this.tagName + '>').appendNewLine()
    }
    ,
    yi.prototype.build = function (e) {
      this.element = e
      let t; let n; const r = e.$descriptor; const o = this.propertyDescriptor; const i = r.isGeneric
      return t = i ? this.parseGeneric(e) : this.parseNsAttributes(e),
      this.ns = o ? this.nsPropertyTagName(o) : this.nsTagName(r),
      this.tagName = this.addTagName(this.ns),
      i || (n = (function (e) {
        return W(e.$descriptor.properties, function (t) {
          const n = t.name
          if (t.isVirtual) { return !1 }
          if (!$(e, n)) { return !1 }
          const r = e[n]
          return r !== t.default && r !== null && (!t.isMany || r.length)
        }
        )
      }(e)),
      this.parseAttributes(W(n, function (e) {
        return e.isAttr
      }
      )),
      this.parseContainments(W(n, function (e) {
        return !e.isAttr
      }
      ))),
      this.parseGenericAttributes(e, t),
      this
    }
    ,
    yi.prototype.nsTagName = function (e) {
      return (function (e, t) {
        return t.isGeneric
          ? le({
            localName: t.ns.localName
          }, e)
          : le({
            localName: (n = t.ns.localName,
            r = t.$pkg,
            Ho(r) ? (o = n).charAt(0).toLowerCase() + o.slice(1) : n)
          }, e)
        let n, r, o
      }(this.logNamespaceUsed(e.ns), e))
    }
    ,
    yi.prototype.nsPropertyTagName = function (e) {
      return (function (e, t) {
        return le({
          localName: t.ns.localName
        }, e)
      }(this.logNamespaceUsed(e.ns), e))
    }
    ,
    yi.prototype.isLocalNs = function (e) {
      return e.uri === this.ns.uri
    }
    ,
    yi.prototype.nsAttributeName = function (e) {
      let t
      if (t = F(e) ? go(e) : e.ns,
      e.inherited) {
        return {
          localName: t.localName
        }
      }
      const n = this.logNamespaceUsed(t)
      return this.getNamespaces().logUsed(n),
      this.isLocalNs(n)
        ? {
            localName: t.localName
          }
        : le({
          localName: t.localName
        }, n)
    }
    ,
    yi.prototype.parseGeneric = function (e) {
      const t = this
      const n = this.body
      const r = []
      return G(e, function (o, i) {
        i === '$body'
          ? n.push((new vi()).build({
            type: 'String'
          }, o))
          : i === '$children'
            ? G(o, function (e) {
              n.push(new yi(t).build(e))
            }
            )
            : i.indexOf('$') !== 0 && t.parseNsAttribute(e, i, o) && r.push({
              name: i,
              value: o
            })
      }
      ),
      r
    }
    ,
    yi.prototype.parseNsAttribute = function (e, t, n) {
      let r; const o = e.$model; const i = go(t)
      if (i.prefix === 'xmlns' && (r = {
        prefix: i.localName,
        uri: n
      }),
      i.prefix || i.localName !== 'xmlns' || (r = {
        uri: n
      }),
      !r) {
        return {
          name: t,
          value: n
        }
      }
      if (o && o.getPackage(n)) { this.logNamespace(r, !0, !0) } else {
        const a = this.logNamespaceUsed(r, !0)
        this.getNamespaces().logUsed(a)
      }
    }
    ,
    yi.prototype.parseNsAttributes = function (e, t) {
      const n = this
      const r = e.$attrs
      const o = []
      return G(r, function (t, r) {
        const i = n.parseNsAttribute(e, r, t)
        i && o.push(i)
      }
      ),
      o
    }
    ,
    yi.prototype.parseGenericAttributes = function (e, t) {
      const n = this
      G(t, function (t) {
        if (t.name !== Wo) {
          try {
            n.addAttribute(n.nsAttributeName(t.name), t.value)
          } catch (n) {
            console.warn('missing namespace information for ', t.name, '=', t.value, 'on', e, n)
          }
        }
      }
      )
    }
    ,
    yi.prototype.parseContainments = function (e) {
      const t = this
      const n = this.body
      const r = this.element
      G(e, function (e) {
        let o = r.get(e.name)
        const i = e.isReference
        if (e.isMany || (o = [o]),
        e.isBody) { n.push((new vi()).build(e, o[0])) } else if (vo(e.type)) {
          G(o, function (r) {
            n.push(new gi(t.addTagName(t.nsPropertyTagName(e))).build(e, r))
          }
          )
        } else if (i) {
          G(o, function (r) {
            n.push(new mi(t.addTagName(t.nsPropertyTagName(e))).build(r))
          }
          )
        } else {
          const a = Uo(e)
          const s = (function (e) {
            return Go(e) === 'property'
          }(e))
          G(o, function (r) {
            let o
            o = a ? new bi(t, e) : s ? new yi(t, e) : new yi(t),
            n.push(o.build(r))
          }
          )
        }
      }
      )
    }
    ,
    yi.prototype.getNamespaces = function (e) {
      let t; let n = this.namespaces; const r = this.parent
      return n || (t = r && r.getNamespaces(),
      e || !t ? this.namespaces = n = new li(t) : n = t),
      n
    }
    ,
    yi.prototype.logNamespace = function (e, t, n) {
      const r = this.getNamespaces(n)
      const o = e.uri
      const i = e.prefix
      return r.byUri(o) && !n || r.add(e, t),
      r.mapPrefix(i, o),
      e
    }
    ,
    yi.prototype.logNamespaceUsed = function (e, t) {
      let n; let r; let o; const i = this.element.$model; const a = this.getNamespaces(t); const s = e.prefix; let c = e.uri
      if (!s && !c) {
        return {
          localName: e.localName
        }
      }
      if (o = qo[s] || i && (i.getPackage(s) || {}).uri,
      !(c = c || o || a.uriByPrefix(s))) { throw new Error('no namespace uri given for prefix <' + s + '>') }
      if (!(e = a.byUri(c))) {
        for (n = s,
        r = 1; a.uriByPrefix(n);) { n = s + '_' + r++ }
        e = this.logNamespace({
          prefix: n,
          uri: c
        }, o === c)
      }
      return s && a.mapPrefix(s, c),
      e
    }
    ,
    yi.prototype.parseAttributes = function (e) {
      const t = this
      const n = this.element
      G(e, function (e) {
        let r = n.get(e.name)
        if (e.isReference) {
          if (e.isMany) {
            const o = []
            G(r, function (e) {
              o.push(e.id)
            }
            ),
            r = o.join(' ')
          } else { r = r.id }
        }
        t.addAttribute(t.nsAttributeName(e), r)
      }
      )
    }
    ,
    yi.prototype.addTagName = function (e) {
      const t = this.logNamespaceUsed(e)
      return this.getNamespaces().logUsed(t),
      ui(e)
    }
    ,
    yi.prototype.addAttribute = function (e, t) {
      const n = this.attrs
      F(t) && (t = hi(t, si, di))
      const r = q(n, function (t) {
        return t.name.localName === e.localName && t.name.uri === e.uri && t.name.prefix === e.prefix
      }
      )
      const o = {
        name: e,
        value: t
      }
      r !== -1 ? n.splice(r, 1, o) : n.push(o)
    }
    ,
    yi.prototype.serializeAttributes = function (e) {
      let t = this.attrs
      const n = this.namespaces
      n && (t = (function (e) {
        return e.getUsed().filter(function (e) {
          return e.prefix !== 'xml'
        }
        ).map(function (e) {
          return {
            name: 'xmlns' + (e.prefix ? ':' + e.prefix : ''),
            value: e.uri
          }
        }
        )
      }(n)).concat(t)),
      G(t, function (t) {
        e.append(' ').append(ui(t.name)).append('="').append(t.value).append('"')
      }
      )
    }
    ,
    yi.prototype.serializeTo = function (e) {
      const t = this.body[0]
      const n = t && t.constructor !== vi
      e.appendIndent().append('<' + this.tagName),
      this.serializeAttributes(e),
      e.append(t ? '>' : ' />'),
      t && (n && e.appendNewLine().indent(),
      G(this.body, function (t) {
        t.serializeTo(e)
      }
      ),
      n && e.unindent().appendIndent(),
      e.append('</' + this.tagName + '>')),
      e.appendNewLine()
    }
    ,
    pi(bi, yi),
    bi.prototype.parseNsAttributes = function (e) {
      const t = yi.prototype.parseNsAttributes.call(this, e)
      const n = e.$descriptor
      if (n.name === this.propertyDescriptor.type) { return t }
      const r = this.typeNs = this.nsTagName(n)
      this.getNamespaces().logUsed(this.typeNs)
      const o = e.$model.getPackage(r.uri)
      const i = o.xml && o.xml.typePrefix || ''
      return this.addAttribute(this.nsAttributeName(Wo), (r.prefix ? r.prefix + ':' : '') + i + n.ns.localName),
      t
    }
    ,
    bi.prototype.isLocalNs = function (e) {
      return e.uri === (this.typeNs || this.ns).uri
    }
    ,
    wi.prototype = Object.create(_o.prototype),
    wi.prototype.fromXML = function (e, t, n) {
      F(t) || (n = t,
      t = 'bpmn:Definitions')
      const r = new ai(le({
        model: this,
        lax: !0
      }, n))
      const o = r.handler(t)
      return r.fromXML(e, o)
    }
    ,
    wi.prototype.toXML = function (e, t) {
      const n = new xi(t)
      return new Promise(function (t, r) {
        try {
          return t({
            xml: n.toXML(e)
          })
        } catch (e) {
          return r(e)
        }
      }
      )
    }

    const _i = {
      bpmn: {
        name: 'BPMN20',
        uri: 'http://www.omg.org/spec/BPMN/20100524/MODEL',
        prefix: 'bpmn',
        associations: [],
        types: [{
          name: 'Interface',
          superClass: ['RootElement'],
          properties: [{
            name: 'name',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'operations',
            type: 'Operation',
            isMany: !0
          }, {
            name: 'implementationRef',
            isAttr: !0,
            type: 'String'
          }]
        }, {
          name: 'Operation',
          superClass: ['BaseElement'],
          properties: [{
            name: 'name',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'inMessageRef',
            type: 'Message',
            isReference: !0
          }, {
            name: 'outMessageRef',
            type: 'Message',
            isReference: !0
          }, {
            name: 'errorRef',
            type: 'Error',
            isMany: !0,
            isReference: !0
          }, {
            name: 'implementationRef',
            isAttr: !0,
            type: 'String'
          }]
        }, {
          name: 'EndPoint',
          superClass: ['RootElement']
        }, {
          name: 'Auditing',
          superClass: ['BaseElement']
        }, {
          name: 'GlobalTask',
          superClass: ['CallableElement'],
          properties: [{
            name: 'resources',
            type: 'ResourceRole',
            isMany: !0
          }]
        }, {
          name: 'Monitoring',
          superClass: ['BaseElement']
        }, {
          name: 'Performer',
          superClass: ['ResourceRole']
        }, {
          name: 'Process',
          superClass: ['FlowElementsContainer', 'CallableElement'],
          properties: [{
            name: 'processType',
            type: 'ProcessType',
            isAttr: !0
          }, {
            name: 'isClosed',
            isAttr: !0,
            type: 'Boolean'
          }, {
            name: 'auditing',
            type: 'Auditing'
          }, {
            name: 'monitoring',
            type: 'Monitoring'
          }, {
            name: 'properties',
            type: 'Property',
            isMany: !0
          }, {
            name: 'laneSets',
            isMany: !0,
            replaces: 'FlowElementsContainer#laneSets',
            type: 'LaneSet'
          }, {
            name: 'flowElements',
            isMany: !0,
            replaces: 'FlowElementsContainer#flowElements',
            type: 'FlowElement'
          }, {
            name: 'artifacts',
            type: 'Artifact',
            isMany: !0
          }, {
            name: 'resources',
            type: 'ResourceRole',
            isMany: !0
          }, {
            name: 'correlationSubscriptions',
            type: 'CorrelationSubscription',
            isMany: !0
          }, {
            name: 'supports',
            type: 'Process',
            isMany: !0,
            isReference: !0
          }, {
            name: 'definitionalCollaborationRef',
            type: 'Collaboration',
            isAttr: !0,
            isReference: !0
          }, {
            name: 'isExecutable',
            isAttr: !0,
            type: 'Boolean'
          }]
        }, {
          name: 'LaneSet',
          superClass: ['BaseElement'],
          properties: [{
            name: 'lanes',
            type: 'Lane',
            isMany: !0
          }, {
            name: 'name',
            isAttr: !0,
            type: 'String'
          }]
        }, {
          name: 'Lane',
          superClass: ['BaseElement'],
          properties: [{
            name: 'name',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'partitionElementRef',
            type: 'BaseElement',
            isAttr: !0,
            isReference: !0
          }, {
            name: 'partitionElement',
            type: 'BaseElement'
          }, {
            name: 'flowNodeRef',
            type: 'FlowNode',
            isMany: !0,
            isReference: !0
          }, {
            name: 'childLaneSet',
            type: 'LaneSet',
            xml: {
              serialize: 'xsi:type'
            }
          }]
        }, {
          name: 'GlobalManualTask',
          superClass: ['GlobalTask']
        }, {
          name: 'ManualTask',
          superClass: ['Task']
        }, {
          name: 'UserTask',
          superClass: ['Task'],
          properties: [{
            name: 'renderings',
            type: 'Rendering',
            isMany: !0
          }, {
            name: 'implementation',
            isAttr: !0,
            type: 'String'
          }]
        }, {
          name: 'Rendering',
          superClass: ['BaseElement']
        }, {
          name: 'HumanPerformer',
          superClass: ['Performer']
        }, {
          name: 'PotentialOwner',
          superClass: ['HumanPerformer']
        }, {
          name: 'GlobalUserTask',
          superClass: ['GlobalTask'],
          properties: [{
            name: 'implementation',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'renderings',
            type: 'Rendering',
            isMany: !0
          }]
        }, {
          name: 'Gateway',
          isAbstract: !0,
          superClass: ['FlowNode'],
          properties: [{
            name: 'gatewayDirection',
            type: 'GatewayDirection',
            default: 'Unspecified',
            isAttr: !0
          }]
        }, {
          name: 'EventBasedGateway',
          superClass: ['Gateway'],
          properties: [{
            name: 'instantiate',
            default: !1,
            isAttr: !0,
            type: 'Boolean'
          }, {
            name: 'eventGatewayType',
            type: 'EventBasedGatewayType',
            isAttr: !0,
            default: 'Exclusive'
          }]
        }, {
          name: 'ComplexGateway',
          superClass: ['Gateway'],
          properties: [{
            name: 'activationCondition',
            type: 'Expression',
            xml: {
              serialize: 'xsi:type'
            }
          }, {
            name: 'default',
            type: 'SequenceFlow',
            isAttr: !0,
            isReference: !0
          }]
        }, {
          name: 'ExclusiveGateway',
          superClass: ['Gateway'],
          properties: [{
            name: 'default',
            type: 'SequenceFlow',
            isAttr: !0,
            isReference: !0
          }]
        }, {
          name: 'InclusiveGateway',
          superClass: ['Gateway'],
          properties: [{
            name: 'default',
            type: 'SequenceFlow',
            isAttr: !0,
            isReference: !0
          }]
        }, {
          name: 'ParallelGateway',
          superClass: ['Gateway']
        }, {
          name: 'RootElement',
          isAbstract: !0,
          superClass: ['BaseElement']
        }, {
          name: 'Relationship',
          superClass: ['BaseElement'],
          properties: [{
            name: 'type',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'direction',
            type: 'RelationshipDirection',
            isAttr: !0
          }, {
            name: 'source',
            isMany: !0,
            isReference: !0,
            type: 'Element'
          }, {
            name: 'target',
            isMany: !0,
            isReference: !0,
            type: 'Element'
          }]
        }, {
          name: 'BaseElement',
          isAbstract: !0,
          properties: [{
            name: 'id',
            isAttr: !0,
            type: 'String',
            isId: !0
          }, {
            name: 'documentation',
            type: 'Documentation',
            isMany: !0
          }, {
            name: 'extensionDefinitions',
            type: 'ExtensionDefinition',
            isMany: !0,
            isReference: !0
          }, {
            name: 'extensionElements',
            type: 'ExtensionElements'
          }]
        }, {
          name: 'Extension',
          properties: [{
            name: 'mustUnderstand',
            default: !1,
            isAttr: !0,
            type: 'Boolean'
          }, {
            name: 'definition',
            type: 'ExtensionDefinition',
            isAttr: !0,
            isReference: !0
          }]
        }, {
          name: 'ExtensionDefinition',
          properties: [{
            name: 'name',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'extensionAttributeDefinitions',
            type: 'ExtensionAttributeDefinition',
            isMany: !0
          }]
        }, {
          name: 'ExtensionAttributeDefinition',
          properties: [{
            name: 'name',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'type',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'isReference',
            default: !1,
            isAttr: !0,
            type: 'Boolean'
          }, {
            name: 'extensionDefinition',
            type: 'ExtensionDefinition',
            isAttr: !0,
            isReference: !0
          }]
        }, {
          name: 'ExtensionElements',
          properties: [{
            name: 'valueRef',
            isAttr: !0,
            isReference: !0,
            type: 'Element'
          }, {
            name: 'values',
            type: 'Element',
            isMany: !0
          }, {
            name: 'extensionAttributeDefinition',
            type: 'ExtensionAttributeDefinition',
            isAttr: !0,
            isReference: !0
          }]
        }, {
          name: 'Documentation',
          superClass: ['BaseElement'],
          properties: [{
            name: 'text',
            type: 'String',
            isBody: !0
          }, {
            name: 'textFormat',
            default: 'text/plain',
            isAttr: !0,
            type: 'String'
          }]
        }, {
          name: 'Event',
          isAbstract: !0,
          superClass: ['FlowNode', 'InteractionNode'],
          properties: [{
            name: 'properties',
            type: 'Property',
            isMany: !0
          }]
        }, {
          name: 'IntermediateCatchEvent',
          superClass: ['CatchEvent']
        }, {
          name: 'IntermediateThrowEvent',
          superClass: ['ThrowEvent']
        }, {
          name: 'EndEvent',
          superClass: ['ThrowEvent']
        }, {
          name: 'StartEvent',
          superClass: ['CatchEvent'],
          properties: [{
            name: 'isInterrupting',
            default: !0,
            isAttr: !0,
            type: 'Boolean'
          }]
        }, {
          name: 'ThrowEvent',
          isAbstract: !0,
          superClass: ['Event'],
          properties: [{
            name: 'dataInputs',
            type: 'DataInput',
            isMany: !0
          }, {
            name: 'dataInputAssociations',
            type: 'DataInputAssociation',
            isMany: !0
          }, {
            name: 'inputSet',
            type: 'InputSet'
          }, {
            name: 'eventDefinitions',
            type: 'EventDefinition',
            isMany: !0
          }, {
            name: 'eventDefinitionRef',
            type: 'EventDefinition',
            isMany: !0,
            isReference: !0
          }]
        }, {
          name: 'CatchEvent',
          isAbstract: !0,
          superClass: ['Event'],
          properties: [{
            name: 'parallelMultiple',
            isAttr: !0,
            type: 'Boolean',
            default: !1
          }, {
            name: 'dataOutputs',
            type: 'DataOutput',
            isMany: !0
          }, {
            name: 'dataOutputAssociations',
            type: 'DataOutputAssociation',
            isMany: !0
          }, {
            name: 'outputSet',
            type: 'OutputSet'
          }, {
            name: 'eventDefinitions',
            type: 'EventDefinition',
            isMany: !0
          }, {
            name: 'eventDefinitionRef',
            type: 'EventDefinition',
            isMany: !0,
            isReference: !0
          }]
        }, {
          name: 'BoundaryEvent',
          superClass: ['CatchEvent'],
          properties: [{
            name: 'cancelActivity',
            default: !0,
            isAttr: !0,
            type: 'Boolean'
          }, {
            name: 'attachedToRef',
            type: 'Activity',
            isAttr: !0,
            isReference: !0
          }]
        }, {
          name: 'EventDefinition',
          isAbstract: !0,
          superClass: ['RootElement']
        }, {
          name: 'CancelEventDefinition',
          superClass: ['EventDefinition']
        }, {
          name: 'ErrorEventDefinition',
          superClass: ['EventDefinition'],
          properties: [{
            name: 'errorRef',
            type: 'Error',
            isAttr: !0,
            isReference: !0
          }]
        }, {
          name: 'TerminateEventDefinition',
          superClass: ['EventDefinition']
        }, {
          name: 'EscalationEventDefinition',
          superClass: ['EventDefinition'],
          properties: [{
            name: 'escalationRef',
            type: 'Escalation',
            isAttr: !0,
            isReference: !0
          }]
        }, {
          name: 'Escalation',
          properties: [{
            name: 'structureRef',
            type: 'ItemDefinition',
            isAttr: !0,
            isReference: !0
          }, {
            name: 'name',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'escalationCode',
            isAttr: !0,
            type: 'String'
          }],
          superClass: ['RootElement']
        }, {
          name: 'CompensateEventDefinition',
          superClass: ['EventDefinition'],
          properties: [{
            name: 'waitForCompletion',
            isAttr: !0,
            type: 'Boolean',
            default: !0
          }, {
            name: 'activityRef',
            type: 'Activity',
            isAttr: !0,
            isReference: !0
          }]
        }, {
          name: 'TimerEventDefinition',
          superClass: ['EventDefinition'],
          properties: [{
            name: 'timeDate',
            type: 'Expression',
            xml: {
              serialize: 'xsi:type'
            }
          }, {
            name: 'timeCycle',
            type: 'Expression',
            xml: {
              serialize: 'xsi:type'
            }
          }, {
            name: 'timeDuration',
            type: 'Expression',
            xml: {
              serialize: 'xsi:type'
            }
          }]
        }, {
          name: 'LinkEventDefinition',
          superClass: ['EventDefinition'],
          properties: [{
            name: 'name',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'target',
            type: 'LinkEventDefinition',
            isReference: !0
          }, {
            name: 'source',
            type: 'LinkEventDefinition',
            isMany: !0,
            isReference: !0
          }]
        }, {
          name: 'MessageEventDefinition',
          superClass: ['EventDefinition'],
          properties: [{
            name: 'messageRef',
            type: 'Message',
            isAttr: !0,
            isReference: !0
          }, {
            name: 'operationRef',
            type: 'Operation',
            isAttr: !0,
            isReference: !0
          }]
        }, {
          name: 'ConditionalEventDefinition',
          superClass: ['EventDefinition'],
          properties: [{
            name: 'condition',
            type: 'Expression',
            xml: {
              serialize: 'xsi:type'
            }
          }]
        }, {
          name: 'SignalEventDefinition',
          superClass: ['EventDefinition'],
          properties: [{
            name: 'signalRef',
            type: 'Signal',
            isAttr: !0,
            isReference: !0
          }]
        }, {
          name: 'Signal',
          superClass: ['RootElement'],
          properties: [{
            name: 'structureRef',
            type: 'ItemDefinition',
            isAttr: !0,
            isReference: !0
          }, {
            name: 'name',
            isAttr: !0,
            type: 'String'
          }]
        }, {
          name: 'ImplicitThrowEvent',
          superClass: ['ThrowEvent']
        }, {
          name: 'DataState',
          superClass: ['BaseElement'],
          properties: [{
            name: 'name',
            isAttr: !0,
            type: 'String'
          }]
        }, {
          name: 'ItemAwareElement',
          superClass: ['BaseElement'],
          properties: [{
            name: 'itemSubjectRef',
            type: 'ItemDefinition',
            isAttr: !0,
            isReference: !0
          }, {
            name: 'dataState',
            type: 'DataState'
          }]
        }, {
          name: 'DataAssociation',
          superClass: ['BaseElement'],
          properties: [{
            name: 'sourceRef',
            type: 'ItemAwareElement',
            isMany: !0,
            isReference: !0
          }, {
            name: 'targetRef',
            type: 'ItemAwareElement',
            isReference: !0
          }, {
            name: 'transformation',
            type: 'FormalExpression',
            xml: {
              serialize: 'property'
            }
          }, {
            name: 'assignment',
            type: 'Assignment',
            isMany: !0
          }]
        }, {
          name: 'DataInput',
          superClass: ['ItemAwareElement'],
          properties: [{
            name: 'name',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'isCollection',
            default: !1,
            isAttr: !0,
            type: 'Boolean'
          }, {
            name: 'inputSetRef',
            type: 'InputSet',
            isMany: !0,
            isVirtual: !0,
            isReference: !0
          }, {
            name: 'inputSetWithOptional',
            type: 'InputSet',
            isMany: !0,
            isVirtual: !0,
            isReference: !0
          }, {
            name: 'inputSetWithWhileExecuting',
            type: 'InputSet',
            isMany: !0,
            isVirtual: !0,
            isReference: !0
          }]
        }, {
          name: 'DataOutput',
          superClass: ['ItemAwareElement'],
          properties: [{
            name: 'name',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'isCollection',
            default: !1,
            isAttr: !0,
            type: 'Boolean'
          }, {
            name: 'outputSetRef',
            type: 'OutputSet',
            isMany: !0,
            isVirtual: !0,
            isReference: !0
          }, {
            name: 'outputSetWithOptional',
            type: 'OutputSet',
            isMany: !0,
            isVirtual: !0,
            isReference: !0
          }, {
            name: 'outputSetWithWhileExecuting',
            type: 'OutputSet',
            isMany: !0,
            isVirtual: !0,
            isReference: !0
          }]
        }, {
          name: 'InputSet',
          superClass: ['BaseElement'],
          properties: [{
            name: 'name',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'dataInputRefs',
            type: 'DataInput',
            isMany: !0,
            isReference: !0
          }, {
            name: 'optionalInputRefs',
            type: 'DataInput',
            isMany: !0,
            isReference: !0
          }, {
            name: 'whileExecutingInputRefs',
            type: 'DataInput',
            isMany: !0,
            isReference: !0
          }, {
            name: 'outputSetRefs',
            type: 'OutputSet',
            isMany: !0,
            isReference: !0
          }]
        }, {
          name: 'OutputSet',
          superClass: ['BaseElement'],
          properties: [{
            name: 'dataOutputRefs',
            type: 'DataOutput',
            isMany: !0,
            isReference: !0
          }, {
            name: 'name',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'inputSetRefs',
            type: 'InputSet',
            isMany: !0,
            isReference: !0
          }, {
            name: 'optionalOutputRefs',
            type: 'DataOutput',
            isMany: !0,
            isReference: !0
          }, {
            name: 'whileExecutingOutputRefs',
            type: 'DataOutput',
            isMany: !0,
            isReference: !0
          }]
        }, {
          name: 'Property',
          superClass: ['ItemAwareElement'],
          properties: [{
            name: 'name',
            isAttr: !0,
            type: 'String'
          }]
        }, {
          name: 'DataInputAssociation',
          superClass: ['DataAssociation']
        }, {
          name: 'DataOutputAssociation',
          superClass: ['DataAssociation']
        }, {
          name: 'InputOutputSpecification',
          superClass: ['BaseElement'],
          properties: [{
            name: 'dataInputs',
            type: 'DataInput',
            isMany: !0
          }, {
            name: 'dataOutputs',
            type: 'DataOutput',
            isMany: !0
          }, {
            name: 'inputSets',
            type: 'InputSet',
            isMany: !0
          }, {
            name: 'outputSets',
            type: 'OutputSet',
            isMany: !0
          }]
        }, {
          name: 'DataObject',
          superClass: ['FlowElement', 'ItemAwareElement'],
          properties: [{
            name: 'isCollection',
            default: !1,
            isAttr: !0,
            type: 'Boolean'
          }]
        }, {
          name: 'InputOutputBinding',
          properties: [{
            name: 'inputDataRef',
            type: 'InputSet',
            isAttr: !0,
            isReference: !0
          }, {
            name: 'outputDataRef',
            type: 'OutputSet',
            isAttr: !0,
            isReference: !0
          }, {
            name: 'operationRef',
            type: 'Operation',
            isAttr: !0,
            isReference: !0
          }]
        }, {
          name: 'Assignment',
          superClass: ['BaseElement'],
          properties: [{
            name: 'from',
            type: 'Expression',
            xml: {
              serialize: 'xsi:type'
            }
          }, {
            name: 'to',
            type: 'Expression',
            xml: {
              serialize: 'xsi:type'
            }
          }]
        }, {
          name: 'DataStore',
          superClass: ['RootElement', 'ItemAwareElement'],
          properties: [{
            name: 'name',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'capacity',
            isAttr: !0,
            type: 'Integer'
          }, {
            name: 'isUnlimited',
            default: !0,
            isAttr: !0,
            type: 'Boolean'
          }]
        }, {
          name: 'DataStoreReference',
          superClass: ['ItemAwareElement', 'FlowElement'],
          properties: [{
            name: 'dataStoreRef',
            type: 'DataStore',
            isAttr: !0,
            isReference: !0
          }]
        }, {
          name: 'DataObjectReference',
          superClass: ['ItemAwareElement', 'FlowElement'],
          properties: [{
            name: 'dataObjectRef',
            type: 'DataObject',
            isAttr: !0,
            isReference: !0
          }]
        }, {
          name: 'ConversationLink',
          superClass: ['BaseElement'],
          properties: [{
            name: 'sourceRef',
            type: 'InteractionNode',
            isAttr: !0,
            isReference: !0
          }, {
            name: 'targetRef',
            type: 'InteractionNode',
            isAttr: !0,
            isReference: !0
          }, {
            name: 'name',
            isAttr: !0,
            type: 'String'
          }]
        }, {
          name: 'ConversationAssociation',
          superClass: ['BaseElement'],
          properties: [{
            name: 'innerConversationNodeRef',
            type: 'ConversationNode',
            isAttr: !0,
            isReference: !0
          }, {
            name: 'outerConversationNodeRef',
            type: 'ConversationNode',
            isAttr: !0,
            isReference: !0
          }]
        }, {
          name: 'CallConversation',
          superClass: ['ConversationNode'],
          properties: [{
            name: 'calledCollaborationRef',
            type: 'Collaboration',
            isAttr: !0,
            isReference: !0
          }, {
            name: 'participantAssociations',
            type: 'ParticipantAssociation',
            isMany: !0
          }]
        }, {
          name: 'Conversation',
          superClass: ['ConversationNode']
        }, {
          name: 'SubConversation',
          superClass: ['ConversationNode'],
          properties: [{
            name: 'conversationNodes',
            type: 'ConversationNode',
            isMany: !0
          }]
        }, {
          name: 'ConversationNode',
          isAbstract: !0,
          superClass: ['InteractionNode', 'BaseElement'],
          properties: [{
            name: 'name',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'participantRef',
            type: 'Participant',
            isMany: !0,
            isReference: !0
          }, {
            name: 'messageFlowRefs',
            type: 'MessageFlow',
            isMany: !0,
            isReference: !0
          }, {
            name: 'correlationKeys',
            type: 'CorrelationKey',
            isMany: !0
          }]
        }, {
          name: 'GlobalConversation',
          superClass: ['Collaboration']
        }, {
          name: 'PartnerEntity',
          superClass: ['RootElement'],
          properties: [{
            name: 'name',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'participantRef',
            type: 'Participant',
            isMany: !0,
            isReference: !0
          }]
        }, {
          name: 'PartnerRole',
          superClass: ['RootElement'],
          properties: [{
            name: 'name',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'participantRef',
            type: 'Participant',
            isMany: !0,
            isReference: !0
          }]
        }, {
          name: 'CorrelationProperty',
          superClass: ['RootElement'],
          properties: [{
            name: 'correlationPropertyRetrievalExpression',
            type: 'CorrelationPropertyRetrievalExpression',
            isMany: !0
          }, {
            name: 'name',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'type',
            type: 'ItemDefinition',
            isAttr: !0,
            isReference: !0
          }]
        }, {
          name: 'Error',
          superClass: ['RootElement'],
          properties: [{
            name: 'structureRef',
            type: 'ItemDefinition',
            isAttr: !0,
            isReference: !0
          }, {
            name: 'name',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'errorCode',
            isAttr: !0,
            type: 'String'
          }]
        }, {
          name: 'CorrelationKey',
          superClass: ['BaseElement'],
          properties: [{
            name: 'correlationPropertyRef',
            type: 'CorrelationProperty',
            isMany: !0,
            isReference: !0
          }, {
            name: 'name',
            isAttr: !0,
            type: 'String'
          }]
        }, {
          name: 'Expression',
          superClass: ['BaseElement'],
          isAbstract: !1,
          properties: [{
            name: 'body',
            isBody: !0,
            type: 'String'
          }]
        }, {
          name: 'FormalExpression',
          superClass: ['Expression'],
          properties: [{
            name: 'language',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'evaluatesToTypeRef',
            type: 'ItemDefinition',
            isAttr: !0,
            isReference: !0
          }]
        }, {
          name: 'Message',
          superClass: ['RootElement'],
          properties: [{
            name: 'name',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'itemRef',
            type: 'ItemDefinition',
            isAttr: !0,
            isReference: !0
          }]
        }, {
          name: 'ItemDefinition',
          superClass: ['RootElement'],
          properties: [{
            name: 'itemKind',
            type: 'ItemKind',
            isAttr: !0
          }, {
            name: 'structureRef',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'isCollection',
            default: !1,
            isAttr: !0,
            type: 'Boolean'
          }, {
            name: 'import',
            type: 'Import',
            isAttr: !0,
            isReference: !0
          }]
        }, {
          name: 'FlowElement',
          isAbstract: !0,
          superClass: ['BaseElement'],
          properties: [{
            name: 'name',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'auditing',
            type: 'Auditing'
          }, {
            name: 'monitoring',
            type: 'Monitoring'
          }, {
            name: 'categoryValueRef',
            type: 'CategoryValue',
            isMany: !0,
            isReference: !0
          }]
        }, {
          name: 'SequenceFlow',
          superClass: ['FlowElement'],
          properties: [{
            name: 'isImmediate',
            isAttr: !0,
            type: 'Boolean'
          }, {
            name: 'conditionExpression',
            type: 'Expression',
            xml: {
              serialize: 'xsi:type'
            }
          }, {
            name: 'sourceRef',
            type: 'FlowNode',
            isAttr: !0,
            isReference: !0
          }, {
            name: 'targetRef',
            type: 'FlowNode',
            isAttr: !0,
            isReference: !0
          }]
        }, {
          name: 'FlowElementsContainer',
          isAbstract: !0,
          superClass: ['BaseElement'],
          properties: [{
            name: 'laneSets',
            type: 'LaneSet',
            isMany: !0
          }, {
            name: 'flowElements',
            type: 'FlowElement',
            isMany: !0
          }]
        }, {
          name: 'CallableElement',
          isAbstract: !0,
          superClass: ['RootElement'],
          properties: [{
            name: 'name',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'ioSpecification',
            type: 'InputOutputSpecification',
            xml: {
              serialize: 'property'
            }
          }, {
            name: 'supportedInterfaceRef',
            type: 'Interface',
            isMany: !0,
            isReference: !0
          }, {
            name: 'ioBinding',
            type: 'InputOutputBinding',
            isMany: !0,
            xml: {
              serialize: 'property'
            }
          }]
        }, {
          name: 'FlowNode',
          isAbstract: !0,
          superClass: ['FlowElement'],
          properties: [{
            name: 'incoming',
            type: 'SequenceFlow',
            isMany: !0,
            isReference: !0
          }, {
            name: 'outgoing',
            type: 'SequenceFlow',
            isMany: !0,
            isReference: !0
          }, {
            name: 'lanes',
            type: 'Lane',
            isMany: !0,
            isVirtual: !0,
            isReference: !0
          }]
        }, {
          name: 'CorrelationPropertyRetrievalExpression',
          superClass: ['BaseElement'],
          properties: [{
            name: 'messagePath',
            type: 'FormalExpression'
          }, {
            name: 'messageRef',
            type: 'Message',
            isAttr: !0,
            isReference: !0
          }]
        }, {
          name: 'CorrelationPropertyBinding',
          superClass: ['BaseElement'],
          properties: [{
            name: 'dataPath',
            type: 'FormalExpression'
          }, {
            name: 'correlationPropertyRef',
            type: 'CorrelationProperty',
            isAttr: !0,
            isReference: !0
          }]
        }, {
          name: 'Resource',
          superClass: ['RootElement'],
          properties: [{
            name: 'name',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'resourceParameters',
            type: 'ResourceParameter',
            isMany: !0
          }]
        }, {
          name: 'ResourceParameter',
          superClass: ['BaseElement'],
          properties: [{
            name: 'name',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'isRequired',
            isAttr: !0,
            type: 'Boolean'
          }, {
            name: 'type',
            type: 'ItemDefinition',
            isAttr: !0,
            isReference: !0
          }]
        }, {
          name: 'CorrelationSubscription',
          superClass: ['BaseElement'],
          properties: [{
            name: 'correlationKeyRef',
            type: 'CorrelationKey',
            isAttr: !0,
            isReference: !0
          }, {
            name: 'correlationPropertyBinding',
            type: 'CorrelationPropertyBinding',
            isMany: !0
          }]
        }, {
          name: 'MessageFlow',
          superClass: ['BaseElement'],
          properties: [{
            name: 'name',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'sourceRef',
            type: 'InteractionNode',
            isAttr: !0,
            isReference: !0
          }, {
            name: 'targetRef',
            type: 'InteractionNode',
            isAttr: !0,
            isReference: !0
          }, {
            name: 'messageRef',
            type: 'Message',
            isAttr: !0,
            isReference: !0
          }]
        }, {
          name: 'MessageFlowAssociation',
          superClass: ['BaseElement'],
          properties: [{
            name: 'innerMessageFlowRef',
            type: 'MessageFlow',
            isAttr: !0,
            isReference: !0
          }, {
            name: 'outerMessageFlowRef',
            type: 'MessageFlow',
            isAttr: !0,
            isReference: !0
          }]
        }, {
          name: 'InteractionNode',
          isAbstract: !0,
          properties: [{
            name: 'incomingConversationLinks',
            type: 'ConversationLink',
            isMany: !0,
            isVirtual: !0,
            isReference: !0
          }, {
            name: 'outgoingConversationLinks',
            type: 'ConversationLink',
            isMany: !0,
            isVirtual: !0,
            isReference: !0
          }]
        }, {
          name: 'Participant',
          superClass: ['InteractionNode', 'BaseElement'],
          properties: [{
            name: 'name',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'interfaceRef',
            type: 'Interface',
            isMany: !0,
            isReference: !0
          }, {
            name: 'participantMultiplicity',
            type: 'ParticipantMultiplicity'
          }, {
            name: 'endPointRefs',
            type: 'EndPoint',
            isMany: !0,
            isReference: !0
          }, {
            name: 'processRef',
            type: 'Process',
            isAttr: !0,
            isReference: !0
          }]
        }, {
          name: 'ParticipantAssociation',
          superClass: ['BaseElement'],
          properties: [{
            name: 'innerParticipantRef',
            type: 'Participant',
            isAttr: !0,
            isReference: !0
          }, {
            name: 'outerParticipantRef',
            type: 'Participant',
            isAttr: !0,
            isReference: !0
          }]
        }, {
          name: 'ParticipantMultiplicity',
          properties: [{
            name: 'minimum',
            default: 0,
            isAttr: !0,
            type: 'Integer'
          }, {
            name: 'maximum',
            default: 1,
            isAttr: !0,
            type: 'Integer'
          }],
          superClass: ['BaseElement']
        }, {
          name: 'Collaboration',
          superClass: ['RootElement'],
          properties: [{
            name: 'name',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'isClosed',
            isAttr: !0,
            type: 'Boolean'
          }, {
            name: 'participants',
            type: 'Participant',
            isMany: !0
          }, {
            name: 'messageFlows',
            type: 'MessageFlow',
            isMany: !0
          }, {
            name: 'artifacts',
            type: 'Artifact',
            isMany: !0
          }, {
            name: 'conversations',
            type: 'ConversationNode',
            isMany: !0
          }, {
            name: 'conversationAssociations',
            type: 'ConversationAssociation'
          }, {
            name: 'participantAssociations',
            type: 'ParticipantAssociation',
            isMany: !0
          }, {
            name: 'messageFlowAssociations',
            type: 'MessageFlowAssociation',
            isMany: !0
          }, {
            name: 'correlationKeys',
            type: 'CorrelationKey',
            isMany: !0
          }, {
            name: 'choreographyRef',
            type: 'Choreography',
            isMany: !0,
            isReference: !0
          }, {
            name: 'conversationLinks',
            type: 'ConversationLink',
            isMany: !0
          }]
        }, {
          name: 'ChoreographyActivity',
          isAbstract: !0,
          superClass: ['FlowNode'],
          properties: [{
            name: 'participantRef',
            type: 'Participant',
            isMany: !0,
            isReference: !0
          }, {
            name: 'initiatingParticipantRef',
            type: 'Participant',
            isAttr: !0,
            isReference: !0
          }, {
            name: 'correlationKeys',
            type: 'CorrelationKey',
            isMany: !0
          }, {
            name: 'loopType',
            type: 'ChoreographyLoopType',
            default: 'None',
            isAttr: !0
          }]
        }, {
          name: 'CallChoreography',
          superClass: ['ChoreographyActivity'],
          properties: [{
            name: 'calledChoreographyRef',
            type: 'Choreography',
            isAttr: !0,
            isReference: !0
          }, {
            name: 'participantAssociations',
            type: 'ParticipantAssociation',
            isMany: !0
          }]
        }, {
          name: 'SubChoreography',
          superClass: ['ChoreographyActivity', 'FlowElementsContainer'],
          properties: [{
            name: 'artifacts',
            type: 'Artifact',
            isMany: !0
          }]
        }, {
          name: 'ChoreographyTask',
          superClass: ['ChoreographyActivity'],
          properties: [{
            name: 'messageFlowRef',
            type: 'MessageFlow',
            isMany: !0,
            isReference: !0
          }]
        }, {
          name: 'Choreography',
          superClass: ['Collaboration', 'FlowElementsContainer']
        }, {
          name: 'GlobalChoreographyTask',
          superClass: ['Choreography'],
          properties: [{
            name: 'initiatingParticipantRef',
            type: 'Participant',
            isAttr: !0,
            isReference: !0
          }]
        }, {
          name: 'TextAnnotation',
          superClass: ['Artifact'],
          properties: [{
            name: 'text',
            type: 'String'
          }, {
            name: 'textFormat',
            default: 'text/plain',
            isAttr: !0,
            type: 'String'
          }]
        }, {
          name: 'Group',
          superClass: ['Artifact'],
          properties: [{
            name: 'categoryValueRef',
            type: 'CategoryValue',
            isAttr: !0,
            isReference: !0
          }]
        }, {
          name: 'Association',
          superClass: ['Artifact'],
          properties: [{
            name: 'associationDirection',
            type: 'AssociationDirection',
            isAttr: !0
          }, {
            name: 'sourceRef',
            type: 'BaseElement',
            isAttr: !0,
            isReference: !0
          }, {
            name: 'targetRef',
            type: 'BaseElement',
            isAttr: !0,
            isReference: !0
          }]
        }, {
          name: 'Category',
          superClass: ['RootElement'],
          properties: [{
            name: 'categoryValue',
            type: 'CategoryValue',
            isMany: !0
          }, {
            name: 'name',
            isAttr: !0,
            type: 'String'
          }]
        }, {
          name: 'Artifact',
          isAbstract: !0,
          superClass: ['BaseElement']
        }, {
          name: 'CategoryValue',
          superClass: ['BaseElement'],
          properties: [{
            name: 'categorizedFlowElements',
            type: 'FlowElement',
            isMany: !0,
            isVirtual: !0,
            isReference: !0
          }, {
            name: 'value',
            isAttr: !0,
            type: 'String'
          }]
        }, {
          name: 'Activity',
          isAbstract: !0,
          superClass: ['FlowNode'],
          properties: [{
            name: 'isForCompensation',
            default: !1,
            isAttr: !0,
            type: 'Boolean'
          }, {
            name: 'default',
            type: 'SequenceFlow',
            isAttr: !0,
            isReference: !0
          }, {
            name: 'ioSpecification',
            type: 'InputOutputSpecification',
            xml: {
              serialize: 'property'
            }
          }, {
            name: 'boundaryEventRefs',
            type: 'BoundaryEvent',
            isMany: !0,
            isReference: !0
          }, {
            name: 'properties',
            type: 'Property',
            isMany: !0
          }, {
            name: 'dataInputAssociations',
            type: 'DataInputAssociation',
            isMany: !0
          }, {
            name: 'dataOutputAssociations',
            type: 'DataOutputAssociation',
            isMany: !0
          }, {
            name: 'startQuantity',
            default: 1,
            isAttr: !0,
            type: 'Integer'
          }, {
            name: 'resources',
            type: 'ResourceRole',
            isMany: !0
          }, {
            name: 'completionQuantity',
            default: 1,
            isAttr: !0,
            type: 'Integer'
          }, {
            name: 'loopCharacteristics',
            type: 'LoopCharacteristics'
          }]
        }, {
          name: 'ServiceTask',
          superClass: ['Task'],
          properties: [{
            name: 'implementation',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'operationRef',
            type: 'Operation',
            isAttr: !0,
            isReference: !0
          }]
        }, {
          name: 'SubProcess',
          superClass: ['Activity', 'FlowElementsContainer', 'InteractionNode'],
          properties: [{
            name: 'triggeredByEvent',
            default: !1,
            isAttr: !0,
            type: 'Boolean'
          }, {
            name: 'artifacts',
            type: 'Artifact',
            isMany: !0
          }]
        }, {
          name: 'LoopCharacteristics',
          isAbstract: !0,
          superClass: ['BaseElement']
        }, {
          name: 'MultiInstanceLoopCharacteristics',
          superClass: ['LoopCharacteristics'],
          properties: [{
            name: 'isSequential',
            default: !1,
            isAttr: !0,
            type: 'Boolean'
          }, {
            name: 'behavior',
            type: 'MultiInstanceBehavior',
            default: 'All',
            isAttr: !0
          }, {
            name: 'loopCardinality',
            type: 'Expression',
            xml: {
              serialize: 'xsi:type'
            }
          }, {
            name: 'loopDataInputRef',
            type: 'ItemAwareElement',
            isReference: !0
          }, {
            name: 'loopDataOutputRef',
            type: 'ItemAwareElement',
            isReference: !0
          }, {
            name: 'inputDataItem',
            type: 'DataInput',
            xml: {
              serialize: 'property'
            }
          }, {
            name: 'outputDataItem',
            type: 'DataOutput',
            xml: {
              serialize: 'property'
            }
          }, {
            name: 'complexBehaviorDefinition',
            type: 'ComplexBehaviorDefinition',
            isMany: !0
          }, {
            name: 'completionCondition',
            type: 'Expression',
            xml: {
              serialize: 'xsi:type'
            }
          }, {
            name: 'oneBehaviorEventRef',
            type: 'EventDefinition',
            isAttr: !0,
            isReference: !0
          }, {
            name: 'noneBehaviorEventRef',
            type: 'EventDefinition',
            isAttr: !0,
            isReference: !0
          }]
        }, {
          name: 'StandardLoopCharacteristics',
          superClass: ['LoopCharacteristics'],
          properties: [{
            name: 'testBefore',
            default: !1,
            isAttr: !0,
            type: 'Boolean'
          }, {
            name: 'loopCondition',
            type: 'Expression',
            xml: {
              serialize: 'xsi:type'
            }
          }, {
            name: 'loopMaximum',
            type: 'Integer',
            isAttr: !0
          }]
        }, {
          name: 'CallActivity',
          superClass: ['Activity', 'InteractionNode'],
          properties: [{
            name: 'calledElement',
            type: 'String',
            isAttr: !0
          }]
        }, {
          name: 'Task',
          superClass: ['Activity', 'InteractionNode']
        }, {
          name: 'SendTask',
          superClass: ['Task'],
          properties: [{
            name: 'implementation',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'operationRef',
            type: 'Operation',
            isAttr: !0,
            isReference: !0
          }, {
            name: 'messageRef',
            type: 'Message',
            isAttr: !0,
            isReference: !0
          }]
        }, {
          name: 'ReceiveTask',
          superClass: ['Task'],
          properties: [{
            name: 'implementation',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'instantiate',
            default: !1,
            isAttr: !0,
            type: 'Boolean'
          }, {
            name: 'operationRef',
            type: 'Operation',
            isAttr: !0,
            isReference: !0
          }, {
            name: 'messageRef',
            type: 'Message',
            isAttr: !0,
            isReference: !0
          }]
        }, {
          name: 'ScriptTask',
          superClass: ['Task'],
          properties: [{
            name: 'scriptFormat',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'script',
            type: 'String'
          }]
        }, {
          name: 'BusinessRuleTask',
          superClass: ['Task'],
          properties: [{
            name: 'implementation',
            isAttr: !0,
            type: 'String'
          }]
        }, {
          name: 'AdHocSubProcess',
          superClass: ['SubProcess'],
          properties: [{
            name: 'completionCondition',
            type: 'Expression',
            xml: {
              serialize: 'xsi:type'
            }
          }, {
            name: 'ordering',
            type: 'AdHocOrdering',
            isAttr: !0
          }, {
            name: 'cancelRemainingInstances',
            default: !0,
            isAttr: !0,
            type: 'Boolean'
          }]
        }, {
          name: 'Transaction',
          superClass: ['SubProcess'],
          properties: [{
            name: 'protocol',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'method',
            isAttr: !0,
            type: 'String'
          }]
        }, {
          name: 'GlobalScriptTask',
          superClass: ['GlobalTask'],
          properties: [{
            name: 'scriptLanguage',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'script',
            isAttr: !0,
            type: 'String'
          }]
        }, {
          name: 'GlobalBusinessRuleTask',
          superClass: ['GlobalTask'],
          properties: [{
            name: 'implementation',
            isAttr: !0,
            type: 'String'
          }]
        }, {
          name: 'ComplexBehaviorDefinition',
          superClass: ['BaseElement'],
          properties: [{
            name: 'condition',
            type: 'FormalExpression'
          }, {
            name: 'event',
            type: 'ImplicitThrowEvent'
          }]
        }, {
          name: 'ResourceRole',
          superClass: ['BaseElement'],
          properties: [{
            name: 'resourceRef',
            type: 'Resource',
            isReference: !0
          }, {
            name: 'resourceParameterBindings',
            type: 'ResourceParameterBinding',
            isMany: !0
          }, {
            name: 'resourceAssignmentExpression',
            type: 'ResourceAssignmentExpression'
          }, {
            name: 'name',
            isAttr: !0,
            type: 'String'
          }]
        }, {
          name: 'ResourceParameterBinding',
          properties: [{
            name: 'expression',
            type: 'Expression',
            xml: {
              serialize: 'xsi:type'
            }
          }, {
            name: 'parameterRef',
            type: 'ResourceParameter',
            isAttr: !0,
            isReference: !0
          }],
          superClass: ['BaseElement']
        }, {
          name: 'ResourceAssignmentExpression',
          properties: [{
            name: 'expression',
            type: 'Expression',
            xml: {
              serialize: 'xsi:type'
            }
          }],
          superClass: ['BaseElement']
        }, {
          name: 'Import',
          properties: [{
            name: 'importType',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'location',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'namespace',
            isAttr: !0,
            type: 'String'
          }]
        }, {
          name: 'Definitions',
          superClass: ['BaseElement'],
          properties: [{
            name: 'name',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'targetNamespace',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'expressionLanguage',
            default: 'http://www.w3.org/1999/XPath',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'typeLanguage',
            default: 'http://www.w3.org/2001/XMLSchema',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'imports',
            type: 'Import',
            isMany: !0
          }, {
            name: 'extensions',
            type: 'Extension',
            isMany: !0
          }, {
            name: 'rootElements',
            type: 'RootElement',
            isMany: !0
          }, {
            name: 'diagrams',
            isMany: !0,
            type: 'bpmndi:BPMNDiagram'
          }, {
            name: 'exporter',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'relationships',
            type: 'Relationship',
            isMany: !0
          }, {
            name: 'exporterVersion',
            isAttr: !0,
            type: 'String'
          }]
        }],
        enumerations: [{
          name: 'ProcessType',
          literalValues: [{
            name: 'None'
          }, {
            name: 'Public'
          }, {
            name: 'Private'
          }]
        }, {
          name: 'GatewayDirection',
          literalValues: [{
            name: 'Unspecified'
          }, {
            name: 'Converging'
          }, {
            name: 'Diverging'
          }, {
            name: 'Mixed'
          }]
        }, {
          name: 'EventBasedGatewayType',
          literalValues: [{
            name: 'Parallel'
          }, {
            name: 'Exclusive'
          }]
        }, {
          name: 'RelationshipDirection',
          literalValues: [{
            name: 'None'
          }, {
            name: 'Forward'
          }, {
            name: 'Backward'
          }, {
            name: 'Both'
          }]
        }, {
          name: 'ItemKind',
          literalValues: [{
            name: 'Physical'
          }, {
            name: 'Information'
          }]
        }, {
          name: 'ChoreographyLoopType',
          literalValues: [{
            name: 'None'
          }, {
            name: 'Standard'
          }, {
            name: 'MultiInstanceSequential'
          }, {
            name: 'MultiInstanceParallel'
          }]
        }, {
          name: 'AssociationDirection',
          literalValues: [{
            name: 'None'
          }, {
            name: 'One'
          }, {
            name: 'Both'
          }]
        }, {
          name: 'MultiInstanceBehavior',
          literalValues: [{
            name: 'None'
          }, {
            name: 'One'
          }, {
            name: 'All'
          }, {
            name: 'Complex'
          }]
        }, {
          name: 'AdHocOrdering',
          literalValues: [{
            name: 'Parallel'
          }, {
            name: 'Sequential'
          }]
        }],
        xml: {
          tagAlias: 'lowerCase',
          typePrefix: 't'
        }
      },
      bpmndi: {
        name: 'BPMNDI',
        uri: 'http://www.omg.org/spec/BPMN/20100524/DI',
        prefix: 'bpmndi',
        types: [{
          name: 'BPMNDiagram',
          properties: [{
            name: 'plane',
            type: 'BPMNPlane',
            redefines: 'di:Diagram#rootElement'
          }, {
            name: 'labelStyle',
            type: 'BPMNLabelStyle',
            isMany: !0
          }],
          superClass: ['di:Diagram']
        }, {
          name: 'BPMNPlane',
          properties: [{
            name: 'bpmnElement',
            isAttr: !0,
            isReference: !0,
            type: 'bpmn:BaseElement',
            redefines: 'di:DiagramElement#modelElement'
          }],
          superClass: ['di:Plane']
        }, {
          name: 'BPMNShape',
          properties: [{
            name: 'bpmnElement',
            isAttr: !0,
            isReference: !0,
            type: 'bpmn:BaseElement',
            redefines: 'di:DiagramElement#modelElement'
          }, {
            name: 'isHorizontal',
            isAttr: !0,
            type: 'Boolean'
          }, {
            name: 'isExpanded',
            isAttr: !0,
            type: 'Boolean'
          }, {
            name: 'isMarkerVisible',
            isAttr: !0,
            type: 'Boolean'
          }, {
            name: 'label',
            type: 'BPMNLabel'
          }, {
            name: 'isMessageVisible',
            isAttr: !0,
            type: 'Boolean'
          }, {
            name: 'participantBandKind',
            type: 'ParticipantBandKind',
            isAttr: !0
          }, {
            name: 'choreographyActivityShape',
            type: 'BPMNShape',
            isAttr: !0,
            isReference: !0
          }],
          superClass: ['di:LabeledShape']
        }, {
          name: 'BPMNEdge',
          properties: [{
            name: 'label',
            type: 'BPMNLabel'
          }, {
            name: 'bpmnElement',
            isAttr: !0,
            isReference: !0,
            type: 'bpmn:BaseElement',
            redefines: 'di:DiagramElement#modelElement'
          }, {
            name: 'sourceElement',
            isAttr: !0,
            isReference: !0,
            type: 'di:DiagramElement',
            redefines: 'di:Edge#source'
          }, {
            name: 'targetElement',
            isAttr: !0,
            isReference: !0,
            type: 'di:DiagramElement',
            redefines: 'di:Edge#target'
          }, {
            name: 'messageVisibleKind',
            type: 'MessageVisibleKind',
            isAttr: !0,
            default: 'initiating'
          }],
          superClass: ['di:LabeledEdge']
        }, {
          name: 'BPMNLabel',
          properties: [{
            name: 'labelStyle',
            type: 'BPMNLabelStyle',
            isAttr: !0,
            isReference: !0,
            redefines: 'di:DiagramElement#style'
          }],
          superClass: ['di:Label']
        }, {
          name: 'BPMNLabelStyle',
          properties: [{
            name: 'font',
            type: 'dc:Font'
          }],
          superClass: ['di:Style']
        }],
        enumerations: [{
          name: 'ParticipantBandKind',
          literalValues: [{
            name: 'top_initiating'
          }, {
            name: 'middle_initiating'
          }, {
            name: 'bottom_initiating'
          }, {
            name: 'top_non_initiating'
          }, {
            name: 'middle_non_initiating'
          }, {
            name: 'bottom_non_initiating'
          }]
        }, {
          name: 'MessageVisibleKind',
          literalValues: [{
            name: 'initiating'
          }, {
            name: 'non_initiating'
          }]
        }],
        associations: []
      },
      dc: {
        name: 'DC',
        uri: 'http://www.omg.org/spec/DD/20100524/DC',
        prefix: 'dc',
        types: [{
          name: 'Boolean'
        }, {
          name: 'Integer'
        }, {
          name: 'Real'
        }, {
          name: 'String'
        }, {
          name: 'Font',
          properties: [{
            name: 'name',
            type: 'String',
            isAttr: !0
          }, {
            name: 'size',
            type: 'Real',
            isAttr: !0
          }, {
            name: 'isBold',
            type: 'Boolean',
            isAttr: !0
          }, {
            name: 'isItalic',
            type: 'Boolean',
            isAttr: !0
          }, {
            name: 'isUnderline',
            type: 'Boolean',
            isAttr: !0
          }, {
            name: 'isStrikeThrough',
            type: 'Boolean',
            isAttr: !0
          }]
        }, {
          name: 'Point',
          properties: [{
            name: 'x',
            type: 'Real',
            default: '0',
            isAttr: !0
          }, {
            name: 'y',
            type: 'Real',
            default: '0',
            isAttr: !0
          }]
        }, {
          name: 'Bounds',
          properties: [{
            name: 'x',
            type: 'Real',
            default: '0',
            isAttr: !0
          }, {
            name: 'y',
            type: 'Real',
            default: '0',
            isAttr: !0
          }, {
            name: 'width',
            type: 'Real',
            isAttr: !0
          }, {
            name: 'height',
            type: 'Real',
            isAttr: !0
          }]
        }],
        associations: []
      },
      di: {
        name: 'DI',
        uri: 'http://www.omg.org/spec/DD/20100524/DI',
        prefix: 'di',
        types: [{
          name: 'DiagramElement',
          isAbstract: !0,
          properties: [{
            name: 'id',
            isAttr: !0,
            isId: !0,
            type: 'String'
          }, {
            name: 'extension',
            type: 'Extension'
          }, {
            name: 'owningDiagram',
            type: 'Diagram',
            isReadOnly: !0,
            isVirtual: !0,
            isReference: !0
          }, {
            name: 'owningElement',
            type: 'DiagramElement',
            isReadOnly: !0,
            isVirtual: !0,
            isReference: !0
          }, {
            name: 'modelElement',
            isReadOnly: !0,
            isVirtual: !0,
            isReference: !0,
            type: 'Element'
          }, {
            name: 'style',
            type: 'Style',
            isReadOnly: !0,
            isVirtual: !0,
            isReference: !0
          }, {
            name: 'ownedElement',
            type: 'DiagramElement',
            isReadOnly: !0,
            isMany: !0,
            isVirtual: !0
          }]
        }, {
          name: 'Node',
          isAbstract: !0,
          superClass: ['DiagramElement']
        }, {
          name: 'Edge',
          isAbstract: !0,
          superClass: ['DiagramElement'],
          properties: [{
            name: 'source',
            type: 'DiagramElement',
            isReadOnly: !0,
            isVirtual: !0,
            isReference: !0
          }, {
            name: 'target',
            type: 'DiagramElement',
            isReadOnly: !0,
            isVirtual: !0,
            isReference: !0
          }, {
            name: 'waypoint',
            isUnique: !1,
            isMany: !0,
            type: 'dc:Point',
            xml: {
              serialize: 'xsi:type'
            }
          }]
        }, {
          name: 'Diagram',
          isAbstract: !0,
          properties: [{
            name: 'id',
            isAttr: !0,
            isId: !0,
            type: 'String'
          }, {
            name: 'rootElement',
            type: 'DiagramElement',
            isReadOnly: !0,
            isVirtual: !0
          }, {
            name: 'name',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'documentation',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'resolution',
            isAttr: !0,
            type: 'Real'
          }, {
            name: 'ownedStyle',
            type: 'Style',
            isReadOnly: !0,
            isMany: !0,
            isVirtual: !0
          }]
        }, {
          name: 'Shape',
          isAbstract: !0,
          superClass: ['Node'],
          properties: [{
            name: 'bounds',
            type: 'dc:Bounds'
          }]
        }, {
          name: 'Plane',
          isAbstract: !0,
          superClass: ['Node'],
          properties: [{
            name: 'planeElement',
            type: 'DiagramElement',
            subsettedProperty: 'DiagramElement-ownedElement',
            isMany: !0
          }]
        }, {
          name: 'LabeledEdge',
          isAbstract: !0,
          superClass: ['Edge'],
          properties: [{
            name: 'ownedLabel',
            type: 'Label',
            isReadOnly: !0,
            subsettedProperty: 'DiagramElement-ownedElement',
            isMany: !0,
            isVirtual: !0
          }]
        }, {
          name: 'LabeledShape',
          isAbstract: !0,
          superClass: ['Shape'],
          properties: [{
            name: 'ownedLabel',
            type: 'Label',
            isReadOnly: !0,
            subsettedProperty: 'DiagramElement-ownedElement',
            isMany: !0,
            isVirtual: !0
          }]
        }, {
          name: 'Label',
          isAbstract: !0,
          superClass: ['Node'],
          properties: [{
            name: 'bounds',
            type: 'dc:Bounds'
          }]
        }, {
          name: 'Style',
          isAbstract: !0,
          properties: [{
            name: 'id',
            isAttr: !0,
            isId: !0,
            type: 'String'
          }]
        }, {
          name: 'Extension',
          properties: [{
            name: 'values',
            isMany: !0,
            type: 'Element'
          }]
        }],
        associations: [],
        xml: {
          tagAlias: 'lowerCase'
        }
      },
      bioc: {
        name: 'bpmn.io colors for BPMN',
        uri: 'http://bpmn.io/schema/bpmn/biocolor/1.0',
        prefix: 'bioc',
        types: [{
          name: 'ColoredShape',
          extends: ['bpmndi:BPMNShape'],
          properties: [{
            name: 'stroke',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'fill',
            isAttr: !0,
            type: 'String'
          }]
        }, {
          name: 'ColoredEdge',
          extends: ['bpmndi:BPMNEdge'],
          properties: [{
            name: 'stroke',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'fill',
            isAttr: !0,
            type: 'String'
          }]
        }],
        enumerations: [],
        associations: []
      },
      color: {
        name: 'BPMN in Color',
        uri: 'http://www.omg.org/spec/BPMN/non-normative/color/1.0',
        prefix: 'color',
        types: [{
          name: 'ColoredLabel',
          extends: ['bpmndi:BPMNLabel'],
          properties: [{
            name: 'color',
            isAttr: !0,
            type: 'String'
          }]
        }, {
          name: 'ColoredShape',
          extends: ['bpmndi:BPMNShape'],
          properties: [{
            name: 'background-color',
            isAttr: !0,
            type: 'String'
          }, {
            name: 'border-color',
            isAttr: !0,
            type: 'String'
          }]
        }, {
          name: 'ColoredEdge',
          extends: ['bpmndi:BPMNEdge'],
          properties: [{
            name: 'border-color',
            isAttr: !0,
            type: 'String'
          }]
        }],
        enumerations: [],
        associations: []
      }
    }
    function Ci (e, t) {
      return new wi(le({}, _i, e), t)
    }
    function Si (e) {
      return e ? '<' + e.$type + (e.id ? ' id="' + e.id : '') + '" />' : '<null>'
    }
    const ki = 'Tried to access di from the businessObject. The di is available through the diagram element only. For more information, see https://github.com/bpmn-io/bpmn-js/issues/1472'
    function ji (e) {
      $(e, 'di') || Object.defineProperty(e, 'di', {
        enumerable: !1,
        get: function () {
          throw new Error(ki)
        }
      })
    }
    function Bi (e, t) {
      return e.$instanceOf(t)
    }
    function Di (e, t) {
      const n = {}
      const r = []
      let o = {}
      function i (e, t) {
        return function (n) {
          e(n, t)
        }
      }
      function a (e) {
        n[e.id] = e
      }
      function s (n, r) {
        try {
          const i = o[n.id] && (function (n, r) {
            if (n.gfx) {
              throw new Error(t('already rendered {element}', {
                element: Si(n)
              }))
            }
            return e.element(n, o[n.id], r)
          }(n, r))
          return a(n),
          i
        } catch (e) {
          c(e.message, {
            element: n,
            error: e
          }),
          console.error(t('failed to import {element}', {
            element: Si(n)
          })),
          console.error(e)
        }
      }
      function c (t, n) {
        e.error(t, n)
      }
      const l = this.registerDi = function (e) {
        const n = e.bpmnElement
        n
          ? o[n.id]
            ? c(t('multiple DI elements defined for {element}', {
              element: Si(n)
            }), {
              element: n
            })
            : (o[n.id] = e,
              ji(n))
          : c(t('no bpmnElement referenced in {element}', {
            element: Si(e)
          }), {
            element: e
          })
      }

      function p (e) {
        l(e)
      }
      this.handleDefinitions = function (a, s) {
        const h = a.diagrams
        if (s && h.indexOf(s) === -1) { throw new Error(t('diagram not part of bpmn:Definitions')) }
        if (!s && h && h.length && (s = h[0]),
        !s) { throw new Error(t('no diagram to display')) }
        o = {},
        (function (e) {
          let t
          t = e.plane,
          l(t),
          G(t.planeElement, p)
        }(s))
        const m = s.plane
        if (!m) {
          throw new Error(t('no plane for {element}', {
            element: Si(s)
          }))
        }
        let v = m.bpmnElement
        if (!v) {
          if (v = (function (e) {
            return H(e.rootElements, function (e) {
              return Bi(e, 'bpmn:Process') || Bi(e, 'bpmn:Collaboration')
            }
            )
          }(a)),
          !v) { throw new Error(t('no process or collaboration to display')) }
          c(t('correcting missing bpmnElement on {plane} to {rootElement}', {
            plane: Si(m),
            rootElement: Si(v)
          })),
          m.bpmnElement = v,
          l(m)
        }
        let g; let b; const A = (function (t, n) {
          return e.root(t, o[t.id], n)
        }(v, m))
        if (Bi(v, 'bpmn:Process') || Bi(v, 'bpmn:SubProcess')) { d(v, A) } else {
          if (!Bi(v, 'bpmn:Collaboration')) {
            throw new Error(t('unsupported bpmnElement for {plane}: {rootElement}', {
              plane: Si(m),
              rootElement: Si(v)
            }))
          }
          b = A,
          G((g = v).participants, i(C, b)),
          y(g.artifacts, b),
          r.push(function () {
            !(function (e, t) {
              G(e, i(f, t))
            }(g.messageFlows, b))
          }
          ),
          (function (e, t) {
            const r = W(e, function (e) {
              return !n[e.id] && Bi(e, 'bpmn:Process') && e.laneSets
            }
            )
            r.forEach(i(d, t))
          }(a.rootElements, A))
        }
        u(r)
      }

      var u = this.handleDeferred = function () {
        for (; r.length;) { r.shift()() }
      }

      function d (e, t) {
        _(e, t),
        b(e.ioSpecification, t),
        y(e.artifacts, t),
        a(e)
      }
      function f (e, t) {
        s(e, t)
      }
      function h (e, t) {
        s(e, t)
      }
      function m (e, t) {
        s(e, t)
      }
      function v (e, t) {
        s(e, t)
      }
      function g (e, t) {
        s(e, t)
      }
      function y (e, t) {
        G(e, function (e) {
          Bi(e, 'bpmn:Association')
            ? r.push(function () {
              g(e, t)
            }
            )
            : g(e, t)
        }
        )
      }
      function b (e, t) {
        e && (G(e.dataInputs, i(m, t)),
        G(e.dataOutputs, i(v, t)))
      }
      const A = this.handleSubProcess = function (e, t) {
        _(e, t),
        y(e.artifacts, t)
      }

      function E (e, t) {
        const n = s(e, t)
        Bi(e, 'bpmn:SubProcess') && A(e, n || t),
        Bi(e, 'bpmn:Activity') && b(e.ioSpecification, t),
        r.push(function () {
          G(e.dataInputAssociations, i(h, t)),
          G(e.dataOutputAssociations, i(h, t))
        }
        )
      }
      function x (e, t) {
        r.push(function () {
          const n = s(e, t)
          e.childLaneSet && w(e.childLaneSet, n || t),
          (function (e) {
            G(e.flowNodeRef, function (t) {
              const n = t.get('lanes')
              n && n.push(e)
            }
            )
          }(e))
        }
        )
      }
      function w (e, t) {
        G(e.lanes, i(x, t))
      }
      function _ (e, n) {
        !(function (e, n) {
          G(e, function (e) {
            Bi(e, 'bpmn:SequenceFlow')
              ? r.push(function () {
                !(function (e, t) {
                  s(e, t)
                }(e, n))
              }
              )
              : Bi(e, 'bpmn:BoundaryEvent')
                ? r.unshift(function () {
                  E(e, n)
                }
                )
                : Bi(e, 'bpmn:FlowNode')
                  ? E(e, n)
                  : Bi(e, 'bpmn:DataObject') || (Bi(e, 'bpmn:DataStoreReference') || Bi(e, 'bpmn:DataObjectReference')
                    ? (function (e, t) {
                        s(e, t)
                      }(e, n))
                    : c(t('unrecognized flowElement {element} in context {context}', {
                      element: Si(e),
                      context: n ? Si(n.businessObject) : 'null'
                    }), {
                      element: e,
                      context: n
                    }))
          }
          )
        }(e.flowElements, n)),
        e.laneSets && (function (e, t) {
          G(e, i(w, t))
        }(e.laneSets, n))
      }
      function C (e, t) {
        const n = s(e, t)
        const r = e.processRef
        r && d(r, n || t)
      }
    }
    function Pi (e, t) {
      const n = Ti(e)
      return n && typeof n.$instanceOf === 'function' && n.$instanceOf(t)
    }
    function Oi (e, t) {
      return Q(t, function (t) {
        return Pi(e, t)
      }
      )
    }
    function Ti (e) {
      return e && e.businessObject || e
    }
    function Ri (e) {
      return e && e.di
    }
    function Ni (e, t, n) {
      let r; let o; let i; let a; const s = []
      function c (e, t) {
        const n = new Di({
          root: function (e, t) {
            return r.add(e, t)
          },
          element: function (e, t, n) {
            return r.add(e, t, n)
          },
          error: function (e, t) {
            s.push({
              message: e,
              context: t
            })
          }
        }, i)
        t = t || e.diagrams && e.diagrams[0]
        const o = (function (e, t) {
          if (t) {
            let n; const r = t.plane.bpmnElement; let o = r
            Pi(r, 'bpmn:Process') || Pi(r, 'bpmn:Collaboration') || (o = (function (e) {
              for (let t = e; t;) {
                if (Pi(t, 'bpmn:Process')) { return t }
                t = t.$parent
              }
            }(r))),
            n = Pi(o, 'bpmn:Collaboration')
              ? o
              : H(e.rootElements, function (e) {
                if (Pi(e, 'bpmn:Collaboration')) {
                  return H(e.participants, function (e) {
                    return e.processRef === o
                  }
                  )
                }
              }
              )
            let i = [o]
            n && (i = Y(n.participants, function (e) {
              return e.processRef
            }
            )).push(n)
            const a = Mi(i)
            const s = [t]
            const c = [r]
            return G(e.diagrams, function (e) {
              const t = e.plane.bpmnElement
              a.indexOf(t) !== -1 && c.indexOf(t) === -1 && (s.push(e),
              c.push(t))
            }
            ),
            s
          }
        }(e, t))
        if (!o) { throw new Error(i('no diagram to display')) }
        G(o, function (t) {
          n.handleDefinitions(e, t)
        }
        )
        const c = t.plane.bpmnElement.id
        a.setRootElement(a.findRoot(c + '_plane') || a.findRoot(c))
      }
      return new Promise(function (l, p) {
        try {
          return r = e.get('bpmnImporter'),
          o = e.get('eventBus'),
          i = e.get('translate'),
          a = e.get('canvas'),
          o.fire('import.render.start', {
            definitions: t
          }),
          c(t, n),
          o.fire('import.render.complete', {
            error: void 0,
            warnings: s
          }),
          l({
            warnings: s
          })
        } catch (e) {
          return e.warnings = s,
          p(e)
        }
      }
      )
    }
    function Mi (e) {
      let t = []
      return G(e, function (e) {
        e && (t.push(e),
        t = t.concat(Mi(e.flowElements)))
      }
      ),
      t
    }
    let Ii; const Li = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 14.02 5.57" width="53" height="21"><path fill="currentColor" d="M1.88.92v.14c0 .41-.13.68-.4.8.33.14.46.44.46.86v.33c0 .61-.33.95-.95.95H0V0h.95c.65 0 .93.3.93.92zM.63.57v1.06h.24c.24 0 .38-.1.38-.43V.98c0-.28-.1-.4-.32-.4zm0 1.63v1.22h.36c.2 0 .32-.1.32-.39v-.35c0-.37-.12-.48-.4-.48H.63zM4.18.99v.52c0 .64-.31.98-.94.98h-.3V4h-.62V0h.92c.63 0 .94.35.94.99zM2.94.57v1.35h.3c.2 0 .3-.09.3-.37v-.6c0-.29-.1-.38-.3-.38h-.3zm2.89 2.27L6.25 0h.88v4h-.6V1.12L6.1 3.99h-.6l-.46-2.82v2.82h-.55V0h.87zM8.14 1.1V4h-.56V0h.79L9 2.4V0h.56v4h-.64zm2.49 2.29v.6h-.6v-.6zM12.12 1c0-.63.33-1 .95-1 .61 0 .95.37.95 1v2.04c0 .64-.34 1-.95 1-.62 0-.95-.37-.95-1zm.62 2.08c0 .28.13.39.33.39s.32-.1.32-.4V.98c0-.29-.12-.4-.32-.4s-.33.11-.33.4z"/><path fill="currentColor" d="M0 4.53h14.02v1.04H0zM11.08 0h.63v.62h-.63zm.63 4V1h-.63v2.98z"/></svg>'; const zi = {
      verticalAlign: 'middle'
    }; const Fi = {
      color: '#404040'
    }; const $i = {
      zIndex: '1001',
      position: 'fixed',
      top: '0',
      left: '0',
      right: '0',
      bottom: '0'
    }; const Hi = {
      width: '100%',
      height: '100%',
      background: 'rgba(40,40,40,0.2)'
    }; const qi = {
      position: 'absolute',
      left: '50%',
      top: '40%',
      transform: 'translate(-50%)',
      width: '260px',
      padding: '10px',
      background: 'white',
      boxShadow: '0 1px 4px rgba(0,0,0,0.3)',
      fontFamily: 'Helvetica, Arial, sans-serif',
      fontSize: '14px',
      display: 'flex',
      lineHeight: '1.3'
    }; const Wi = '<div class="bjs-powered-by-lightbox"><div class="backdrop"></div><div class="notice"><a href="https://bpmn.io" target="_blank" rel="noopener" class="link">' + Li + '</a><span>Web-based tooling for BPMN, DMN and forms powered by <a href="https://bpmn.io" target="_blank" rel="noopener">bpmn.io</a>.</span></div></div>'
    function Gi (e, t, n) {
      return n
        ? t ? t(e) : e
        : (e && e.then || (e = Promise.resolve(e)),
          t ? e.then(t) : e)
    }
    function Ui (e, t) {
      try {
        var n = e()
      } catch (e) {
        return t(e)
      }
      return n && n.then ? n.then(void 0, t) : n
    }
    function Vi (e, t) {
      return e && e.then ? e.then(t) : t(e)
    }
    function Qi (e) {
      e = le({}, Ki, e),
      this._moddle = this._createModdle(e),
      this._container = this._createContainer(e),
      (function (e) {
        const t = Ie('<a href="http://bpmn.io" target="_blank" class="bjs-powered-by" title="Powered by bpmn.io" >' + Li + '</a>')
        be(Le('svg', t), zi),
        be(t, Fi, {
          position: 'absolute',
          bottom: '15px',
          right: '15px',
          zIndex: '100'
        }),
        e.appendChild(t),
        Oe.bind(t, 'click', function (e) {
          Ii || (be(Ii = Ie(Wi), $i),
          be(Le('svg', Ii), zi),
          be(Le('.backdrop', Ii), Hi),
          be(Le('.notice', Ii), qi),
          be(Le('.link', Ii), Fi, {
            margin: '15px 20px 15px 10px',
            alignSelf: 'center'
          }),
          Re.bind(Ii, '.backdrop', 'click', function (e) {
            document.body.removeChild(Ii)
          }
          )),
          document.body.appendChild(Ii),
          e.preventDefault()
        }
        )
      }(this._container)),
      this._init(this._container, this._moddle, e)
    }
    function Yi (e, t) {
      return e.warnings = t,
      e
    }
    w(Qi, co),
    Qi.prototype.importXML = function (e, t) {
      try {
        const n = this
        const r = n
        let o = []
        return Gi(Ui(function () {
          let i
          return e = n._emit('import.parse.start', {
            xml: e
          }) || e,
          Vi(Ui(function () {
            return Gi(n._moddle.fromXML(e, 'bpmn:Definitions'), function (e) {
              i = e
            }
            )
          }
          , function (e) {
            throw n._emit('import.parse.complete', {
              error: e
            }),
            e
          }
          ), function (e) {
            let a; let s = i.rootElement; const c = i.references; const l = i.warnings; const p = i.elementsById
            return o = o.concat(l),
            s = n._emit('import.parse.complete', (a = {
              error: null,
              definitions: s,
              elementsById: p,
              references: c,
              warnings: o
            },
            r.get('eventBus').createEvent(a))) || s,
            Gi(n.importDefinitions(s, t), function (e) {
              return o = o.concat(e.warnings),
              n._emit('import.done', {
                error: null,
                warnings: o
              }),
              {
                warnings: o
              }
            }
            )
          }
          )
        }
        , function (e) {
          let t = e
          throw Yi(t, o = o.concat(t.warnings || [])),
          t = (function (e) {
            const t = /unparsable content <([^>]+)> detected([\s\S]*)$/.exec(e.message)
            return t && (e.message = 'unparsable content <' + t[1] + '> detected; this may indicate an invalid BPMN 2.0 diagram file' + t[2]),
            e
          }(t)),
          n._emit('import.done', {
            error: t,
            warnings: t.warnings
          }),
          t
        }
        ))
      } catch (e) {
        return Promise.reject(e)
      }
    }
    ,
    Qi.prototype.importDefinitions = function (e, t) {
      try {
        return this._setDefinitions(e),
        Gi(this.open(t), function (e) {
          return {
            warnings: e.warnings
          }
        }
        )
      } catch (e) {
        return Promise.reject(e)
      }
    }
    ,
    Qi.prototype.open = function (e) {
      try {
        const t = this
        const n = t._definitions
        let r = e
        if (!n) {
          const o = new Error('no XML imported')
          throw Yi(o, []),
          o
        }
        if (typeof e === 'string' && (r = (function (e, t) {
          return t && H(e.diagrams, function (e) {
            return e.id === t
          }
          ) || null
        }(n, e)),
        !r)) {
          const i = new Error('BPMNDiagram <' + e + '> not found')
          throw Yi(i, []),
          i
        }
        try {
          t.clear()
        } catch (o) {
          throw Yi(o, []),
          o
        }
        return Gi(Ni(t, n, r), function (e) {
          return {
            warnings: e.warnings
          }
        }
        )
      } catch (e) {
        return Promise.reject(e)
      }
    }
    ,
    Qi.prototype.saveXML = function (e) {
      try {
        const t = this
        e = e || {}
        let n; let r; let o = t._definitions
        return Gi(Vi(Ui(function () {
          if (!o) { throw new Error('no definitions loaded') }
          return o = t._emit('saveXML.start', {
            definitions: o
          }) || o,
          Gi(t._moddle.toXML(o, e), function (e) {
            r = e.xml,
            r = t._emit('saveXML.serialized', {
              xml: r
            }) || r
          }
          )
        }
        , function (e) {
          n = e
        }
        ), function (e) {
          const o = n
            ? {
                error: n
              }
            : {
                xml: r
              }
          if (t._emit('saveXML.done', o),
          n) { throw n }
          return o
        }
        ))
      } catch (e) {
        return Promise.reject(e)
      }
    }
    ,
    Qi.prototype.saveSVG = function () {
      try {
        let e; let t; const n = this
        n._emit('saveSVG.start')
        try {
          const r = n.get('canvas')
          const o = r.getActiveLayer()
          const i = Le('defs', r._svg)
          const a = pt(o)
          const s = i ? '<defs>' + pt(i) + '</defs>' : ''
          const c = o.getBBox()
          e = '<?xml version="1.0" encoding="utf-8"?>\n\x3c!-- created with bpmn-js / http://bpmn.io --\x3e\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="' + c.width + '" height="' + c.height + '" viewBox="' + c.x + ' ' + c.y + ' ' + c.width + ' ' + c.height + '" version="1.1">' + s + a + '</svg>'
        } catch (e) {
          t = e
        }
        if (n._emit('saveSVG.done', {
          error: t,
          svg: e
        }),
        t) { throw t }
        return Gi({
          svg: e
        })
      } catch (e) {
        return Promise.reject(e)
      }
    }
    ,
    Qi.prototype._setDefinitions = function (e) {
      this._definitions = e
    }
    ,
    Qi.prototype.getModules = function () {
      return this._modules
    }
    ,
    Qi.prototype.clear = function () {
      this.getDefinitions() && co.prototype.clear.call(this)
    }
    ,
    Qi.prototype.destroy = function () {
      let e
      co.prototype.destroy.call(this),
      (e = this._container).parentNode && e.parentNode.removeChild(e)
    }
    ,
    Qi.prototype.on = function (e, t, n, r) {
      return this.get('eventBus').on(e, t, n, r)
    }
    ,
    Qi.prototype.off = function (e, t) {
      this.get('eventBus').off(e, t)
    }
    ,
    Qi.prototype.attachTo = function (e) {
      if (!e) { throw new Error('parentNode required') }
      this.detach(),
      e.get && e.constructor.prototype.jquery && (e = e.get(0)),
      typeof e === 'string' && (e = Le(e)),
      e.appendChild(this._container),
      this._emit('attach', {}),
      this.get('canvas').resized()
    }
    ,
    Qi.prototype.getDefinitions = function () {
      return this._definitions
    }
    ,
    Qi.prototype.detach = function () {
      const e = this._container
      const t = e.parentNode
      t && (this._emit('detach', {}),
      t.removeChild(e))
    }
    ,
    Qi.prototype._init = function (e, t, n) {
      const r = n.modules || this.getModules(n)
      const o = n.additionalModules || []
      const i = [].concat([{
        bpmnjs: ['value', this],
        moddle: ['value', t]
      }], r, o)
      const a = le(ue(n, ['additionalModules']), {
        canvas: le({}, n.canvas, {
          container: e
        }),
        modules: i
      })
      co.call(this, a),
      n && n.container && this.attachTo(n.container)
    }
    ,
    Qi.prototype._emit = function (e, t) {
      return this.get('eventBus').fire(e, t)
    }
    ,
    Qi.prototype._createContainer = function (e) {
      const t = Ie('<div class="bjs-container"></div>')
      return be(t, {
        width: Ji(e.width),
        height: Ji(e.height),
        position: e.position
      }),
      t
    }
    ,
    Qi.prototype._createModdle = function (e) {
      return new Ci(le({}, this._moddleExtensions, e.moddleExtensions))
    }
    ,
    Qi.prototype._modules = []
    var Ki = {
      width: '100%',
      height: '100%',
      position: 'relative'
    }
    function Ji (e) {
      return e + (L(e) ? 'px' : '')
    }
    function Xi (e) {
      Qi.call(this, e),
      this.on('import.parse.complete', function (e) {
        e.error || this._collectIds(e.definitions, e.elementsById)
      }
      , this),
      this.on('diagram.destroy', function () {
        this.get('moddle').ids.clear()
      }
      , this)
    }
    function Zi (e, t) {
      return !Pi(e, 'bpmn:CallActivity') && (Pi(e, 'bpmn:SubProcess') ? !(!(t = t || Ri(e)) || !Pi(t, 'bpmndi:BPMNPlane')) || t && !!t.isExpanded : !Pi(e, 'bpmn:Participant') || !!Ti(e).processRef)
    }
    function ea (e) {
      if (Pi(e, 'bpmn:Participant') || Pi(e, 'bpmn:Lane')) {
        const t = Ri(e).isHorizontal
        return void 0 === t || t
      }
    }
    function ta (e) {
      return e && !!Ti(e).triggeredByEvent
    }
    function na (e, t) {
      return Q(Ti(e).eventDefinitions, function (e) {
        return Pi(e, t)
      }
      )
    }
    w(Xi, Qi),
    Xi.prototype._createModdle = function (e) {
      const t = Qi.prototype._createModdle.call(this, e)
      return t.ids = new j([32, 36, 1]),
      t
    }
    ,
    Xi.prototype._collectIds = function (e, t) {
      let n; const r = e.$model.ids
      for (n in r.clear(),
      t) { r.claim(n, t[n]) }
    }

    const ra = {
      width: 90,
      height: 20
    }
    const oa = 15
    function ia (e) {
      return Pi(e, 'bpmn:Event') || Pi(e, 'bpmn:Gateway') || Pi(e, 'bpmn:DataStoreReference') || Pi(e, 'bpmn:DataObjectReference') || Pi(e, 'bpmn:DataInput') || Pi(e, 'bpmn:DataOutput') || Pi(e, 'bpmn:SequenceFlow') || Pi(e, 'bpmn:MessageFlow') || Pi(e, 'bpmn:Group')
    }
    function aa (e) {
      return br(e.label)
    }
    function sa (e) {
      return e.waypoints
        ? (function (e) {
            const t = e.length / 2 - 1
            const n = e[Math.floor(t)]
            const r = e[Math.ceil(t + 0.01)]
            const o = (function (e) {
              const t = e.length / 2 - 1
              const n = e[Math.floor(t)]
              const r = e[Math.ceil(t + 0.01)]
              return {
                x: n.x + (r.x - n.x) / 2,
                y: n.y + (r.y - n.y) / 2
              }
            }(e))
            const i = Math.atan((r.y - n.y) / (r.x - n.x))
            let a = o.x
            let s = o.y
            return Math.abs(i) < Math.PI / 2 ? s -= oa : a += oa,
            {
              x: a,
              y: s
            }
          }(e.waypoints))
        : Pi(e, 'bpmn:Group')
          ? {
              x: e.x + e.width / 2,
              y: e.y + ra.height / 2
            }
          : {
              x: e.x + e.width / 2,
              y: e.y + e.height + ra.height / 2
            }
    }
    function ca (e) {
      return Pi(e, 'bpmn:FlowElement') || Pi(e, 'bpmn:Participant') || Pi(e, 'bpmn:Lane') || Pi(e, 'bpmn:SequenceFlow') || Pi(e, 'bpmn:MessageFlow') || Pi(e, 'bpmn:DataInput') || Pi(e, 'bpmn:DataOutput') ? 'name' : Pi(e, 'bpmn:TextAnnotation') ? 'text' : Pi(e, 'bpmn:Group') ? 'categoryValueRef' : void 0
    }
    function la (e) {
      const t = e.businessObject
      const n = ca(t)
      if (n) {
        return n === 'categoryValueRef'
          ? (function (e) {
              const t = e.categoryValueRef
              return t && t.value || ''
            }(t))
          : t[n] || ''
      }
    }
    const pa = 'hsl(225, 10%, 15%)'
    const ua = 'white'
    function da (e, t) {
      return Q(e.eventDefinitions, function (e) {
        return e.$type === t
      }
      )
    }
    function fa (e, t, n) {
      const r = Ri(e)
      return n || r.get('color:background-color') || r.get('bioc:fill') || t || ua
    }
    function ha (e, t, n) {
      const r = Ri(e)
      return n || r.get('color:border-color') || r.get('bioc:stroke') || t || pa
    }
    function ma (e, t, n, r) {
      const o = Ri(e).get('label')
      return r || o && o.get('color:color') || t || ha(e, n)
    }
    function va (e) {
      const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
      return {
        width: ga(e, t),
        height: ya(e, t)
      }
    }
    function ga (e) {
      const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
      return $(t, 'width') ? t.width : e.width
    }
    function ya (e) {
      const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
      return $(t, 'height') ? t.height : e.height
    }
    function ba (e) {
      return ba = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      ba(e)
    }
    function Aa (e, t) {
      const n = Object.keys(e)
      if (Object.getOwnPropertySymbols) {
        let r = Object.getOwnPropertySymbols(e)
        t && (r = r.filter(function (t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable
        }
        )),
        n.push.apply(n, r)
      }
      return n
    }
    function Ea (e) {
      for (let t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {}
        t % 2
          ? Aa(Object(n), !0).forEach(function (t) {
            let r, o, i
            r = e,
            o = t,
            i = n[t],
            o = (function (e) {
              const t = (function (e, t) {
                if (ba(e) != 'object' || !e) { return e }
                const n = e[Symbol.toPrimitive]
                if (void 0 !== n) {
                  const r = n.call(e, 'string')
                  if (ba(r) != 'object') { return r }
                  throw new TypeError('@@toPrimitive must return a primitive value.')
                }
                return String(e)
              }(e))
              return ba(t) == 'symbol' ? t : t + ''
            }(o)),
            o in r
              ? Object.defineProperty(r, o, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
              })
              : r[o] = i
          }
          )
          : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
            : Aa(Object(n)).forEach(function (t) {
              Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
            }
            )
      }
      return e
    }
    const xa = new j()
    const wa = 0.95
    function _a (e, t, n, r, o, i, a) {
      St.call(this, t, a)
      const s = e && e.defaultFillColor
      const c = e && e.defaultStrokeColor
      const l = e && e.defaultLabelColor
      const p = xa.next()
      const u = {}
      function d (e) {
        return n.computeStyle(e, {
          strokeLinecap: 'round',
          strokeLinejoin: 'round',
          stroke: pa,
          strokeWidth: 2,
          fill: 'white'
        })
      }
      function f (e) {
        return n.computeStyle(e, ['no-fill'], {
          strokeLinecap: 'round',
          strokeLinejoin: 'round',
          stroke: pa,
          strokeWidth: 2
        })
      }
      function h (e, t) {
        const n = t.ref
        const r = void 0 === n
          ? {
              x: 0,
              y: 0
            }
          : n
        const i = t.scale
        const a = void 0 === i ? 1 : i
        const s = t.element
        const c = et('marker', {
          id: e,
          viewBox: '0 0 20 20',
          refX: r.x,
          refY: r.y,
          markerWidth: 20 * a,
          markerHeight: 20 * a,
          orient: 'auto'
        })
        Fe(c, s)
        let l = Le('defs', o._svg)
        l || (l = et('defs'),
        Fe(o._svg, l)),
        Fe(l, c),
        u[e] = c
      }
      function m (e) {
        return e.replace(/[^0-9a-zA-Z]+/g, '_')
      }
      function v (e, t, n) {
        const r = e + '-' + m(t) + '-' + m(n) + '-' + p
        return u[r] || (function (e, t, n, r) {
          t === 'sequenceflow-end' && h(e, {
            element: et('path', Ea({
              d: 'M 1 5 L 11 10 L 1 15 Z'
            }, d({
              fill: r,
              stroke: r,
              strokeWidth: 1
            }))),
            ref: {
              x: 11,
              y: 10
            },
            scale: 0.5
          }),
          t === 'messageflow-start' && h(e, {
            element: et('circle', Ea({
              cx: 6,
              cy: 6,
              r: 3.5
            }, d({
              fill: n,
              stroke: r,
              strokeWidth: 1,
              strokeDasharray: [1e4, 1]
            }))),
            ref: {
              x: 6,
              y: 6
            }
          }),
          t === 'messageflow-end' && h(e, {
            element: et('path', Ea({
              d: 'm 1 5 l 0 -3 l 7 3 l -7 3 z'
            }, d({
              fill: n,
              stroke: r,
              strokeWidth: 1,
              strokeDasharray: [1e4, 1]
            }))),
            ref: {
              x: 8.5,
              y: 5
            }
          }),
          t === 'association-start' && h(e, {
            element: et('path', Ea({
              d: 'M 11 5 L 1 10 L 11 15'
            }, f({
              fill: 'none',
              stroke: r,
              strokeWidth: 1.5,
              strokeDasharray: [1e4, 1]
            }))),
            ref: {
              x: 1,
              y: 10
            },
            scale: 0.5
          }),
          t === 'association-end' && h(e, {
            element: et('path', Ea({
              d: 'M 1 5 L 11 10 L 1 15'
            }, f({
              fill: 'none',
              stroke: r,
              strokeWidth: 1.5,
              strokeDasharray: [1e4, 1]
            }))),
            ref: {
              x: 11,
              y: 10
            },
            scale: 0.5
          }),
          t === 'conditional-flow-marker' && h(e, {
            element: et('path', Ea({
              d: 'M 0 10 L 8 6 L 16 10 L 8 14 Z'
            }, d({
              fill: n,
              stroke: r
            }))),
            ref: {
              x: -1,
              y: 10
            },
            scale: 0.5
          }),
          t === 'conditional-default-flow-marker' && h(e, {
            element: et('path', Ea({
              d: 'M 6 4 L 10 16'
            }, d({
              stroke: r
            }))),
            ref: {
              x: 0,
              y: 10
            },
            scale: 0.5
          })
        }(r, e, t, n)),
        'url(#' + r + ')'
      }
      function g (e, t, n, r) {
        let o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {}
        I(r) && (o = r,
        r = 0),
        r = r || 0,
        o = d(o)
        const i = et('circle', Ea({
          cx: t / 2,
          cy: n / 2,
          r: Math.round((t + n) / 4 - r)
        }, o))
        return Fe(e, i),
        i
      }
      function y (e, t, n, r, o, i) {
        I(o) && (i = o,
        o = 0)
        const a = et('rect', Ea({
          x: o = o || 0,
          y: o,
          width: t - 2 * o,
          height: n - 2 * o,
          rx: r,
          ry: r
        }, i = d(i)))
        return Fe(e, a),
        a
      }
      function b (e, t, n, r) {
        const o = Tt(t, n = f(n), r)
        return Fe(e, o),
        o
      }
      function A (e, t, n) {
        return b(e, t, n, 5)
      }
      function E (e, t, n) {
        const r = et('path', Ea(Ea({}, n = f(n)), {}, {
          d: t
        }))
        return Fe(e, r),
        r
      }
      function x (e, t, n, r) {
        return E(t, n, le({
          'data-marker': e
        }, r))
      }
      function w (e) {
        return $[e]
      }
      function _ (e) {
        return function (t, n, r) {
          return w(e)(t, n, r)
        }
      }
      function C (e, t) {
        let n; const o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; const i = Ti(e); const a = (n = i).$type === 'bpmn:IntermediateThrowEvent' || n.$type === 'bpmn:EndEvent'
        return i.get('eventDefinitions') && i.get('eventDefinitions').length > 1
          ? i.get('parallelMultiple')
            ? (function (e, t) {
                const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
                return E(e, r.getScaledPath('EVENT_PARALLEL_MULTIPLE', {
                  xScaleFactor: 1.2,
                  yScaleFactor: 1.2,
                  containerWidth: t.width,
                  containerHeight: t.height,
                  position: {
                    mx: 0.458,
                    my: 0.194
                  }
                }), {
                  fill: fa(t, s, n.fill),
                  stroke: ha(t, c, n.stroke),
                  strokeWidth: 1
                })
              }(t, e, o, a))
            : (function (e, t) {
                const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
                const o = arguments.length > 3 ? arguments[3] : void 0
                return E(e, r.getScaledPath('EVENT_MULTIPLE', {
                  xScaleFactor: 1.1,
                  yScaleFactor: 1.1,
                  containerWidth: t.width,
                  containerHeight: t.height,
                  position: {
                    mx: 0.222,
                    my: 0.36
                  }
                }), {
                  fill: o ? ha(t, c, n.stroke) : fa(t, s, n.fill),
                  strokeWidth: 1
                })
              }(t, e, o, a))
          : da(i, 'bpmn:MessageEventDefinition')
            ? (function (e, t) {
                const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
                const o = arguments.length > 3 ? arguments[3] : void 0
                return E(e, r.getScaledPath('EVENT_MESSAGE', {
                  xScaleFactor: 0.9,
                  yScaleFactor: 0.9,
                  containerWidth: t.width,
                  containerHeight: t.height,
                  position: {
                    mx: 0.235,
                    my: 0.315
                  }
                }), {
                  fill: o ? ha(t, c, n.stroke) : fa(t, s, n.fill),
                  stroke: o ? fa(t, s, n.fill) : ha(t, c, n.stroke),
                  strokeWidth: 1
                })
              }(t, e, o, a))
            : da(i, 'bpmn:TimerEventDefinition')
              ? (function (e, t) {
                  const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
                  const o = g(e, t.width, t.height, 0.2 * t.height, {
                    fill: fa(t, s, n.fill),
                    stroke: ha(t, c, n.stroke),
                    strokeWidth: 2
                  })
                  E(e, r.getScaledPath('EVENT_TIMER_WH', {
                    xScaleFactor: 0.75,
                    yScaleFactor: 0.75,
                    containerWidth: t.width,
                    containerHeight: t.height,
                    position: {
                      mx: 0.5,
                      my: 0.5
                    }
                  }), {
                    stroke: ha(t, c, n.stroke),
                    strokeWidth: 2
                  })
                  for (let i = 0; i < 12; i++) {
                    const a = r.getScaledPath('EVENT_TIMER_LINE', {
                      xScaleFactor: 0.75,
                      yScaleFactor: 0.75,
                      containerWidth: t.width,
                      containerHeight: t.height,
                      position: {
                        mx: 0.5,
                        my: 0.5
                      }
                    })
                    const l = t.width / 2
                    const p = t.height / 2
                    E(e, a, {
                      strokeWidth: 1,
                      stroke: ha(t, c, n.stroke),
                      transform: 'rotate(' + 30 * i + ',' + p + ',' + l + ')'
                    })
                  }
                  return o
                }(t, e, o, a))
              : da(i, 'bpmn:ConditionalEventDefinition')
                ? (function (e, t) {
                    const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
                    return E(e, r.getScaledPath('EVENT_CONDITIONAL', {
                      xScaleFactor: 1,
                      yScaleFactor: 1,
                      containerWidth: t.width,
                      containerHeight: t.height,
                      position: {
                        mx: 0.5,
                        my: 0.222
                      }
                    }), {
                      fill: fa(t, s, n.fill),
                      stroke: ha(t, c, n.stroke),
                      strokeWidth: 1
                    })
                  }(t, e, o, a))
                : da(i, 'bpmn:SignalEventDefinition')
                  ? (function (e, t) {
                      const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
                      const o = arguments.length > 3 ? arguments[3] : void 0
                      return E(e, r.getScaledPath('EVENT_SIGNAL', {
                        xScaleFactor: 0.9,
                        yScaleFactor: 0.9,
                        containerWidth: t.width,
                        containerHeight: t.height,
                        position: {
                          mx: 0.5,
                          my: 0.2
                        }
                      }), {
                        strokeWidth: 1,
                        fill: o ? ha(t, c, n.stroke) : fa(t, s, n.fill),
                        stroke: ha(t, c, n.stroke)
                      })
                    }(t, e, o, a))
                  : da(i, 'bpmn:EscalationEventDefinition')
                    ? (function (e, t) {
                        const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
                        const o = arguments.length > 3 ? arguments[3] : void 0
                        return E(e, r.getScaledPath('EVENT_ESCALATION', {
                          xScaleFactor: 1,
                          yScaleFactor: 1,
                          containerWidth: t.width,
                          containerHeight: t.height,
                          position: {
                            mx: 0.5,
                            my: 0.2
                          }
                        }), {
                          fill: o ? ha(t, c, n.stroke) : fa(t, s, n.fill),
                          stroke: ha(t, c, n.stroke),
                          strokeWidth: 1
                        })
                      }(t, e, o, a))
                    : da(i, 'bpmn:LinkEventDefinition')
                      ? (function (e, t) {
                          const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
                          const o = arguments.length > 3 ? arguments[3] : void 0
                          return E(e, r.getScaledPath('EVENT_LINK', {
                            xScaleFactor: 1,
                            yScaleFactor: 1,
                            containerWidth: t.width,
                            containerHeight: t.height,
                            position: {
                              mx: 0.57,
                              my: 0.263
                            }
                          }), {
                            fill: o ? ha(t, c, n.stroke) : fa(t, s, n.fill),
                            stroke: ha(t, c, n.stroke),
                            strokeWidth: 1
                          })
                        }(t, e, o, a))
                      : da(i, 'bpmn:ErrorEventDefinition')
                        ? (function (e, t) {
                            const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
                            const o = arguments.length > 3 ? arguments[3] : void 0
                            return E(e, r.getScaledPath('EVENT_ERROR', {
                              xScaleFactor: 1.1,
                              yScaleFactor: 1.1,
                              containerWidth: t.width,
                              containerHeight: t.height,
                              position: {
                                mx: 0.2,
                                my: 0.722
                              }
                            }), {
                              fill: o ? ha(t, c, n.stroke) : fa(t, s, n.fill),
                              stroke: ha(t, c, n.stroke),
                              strokeWidth: 1
                            })
                          }(t, e, o, a))
                        : da(i, 'bpmn:CancelEventDefinition')
                          ? (function (e, t) {
                              const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
                              const o = arguments.length > 3 ? arguments[3] : void 0
                              const i = E(e, r.getScaledPath('EVENT_CANCEL_45', {
                                xScaleFactor: 1,
                                yScaleFactor: 1,
                                containerWidth: t.width,
                                containerHeight: t.height,
                                position: {
                                  mx: 0.638,
                                  my: -0.055
                                }
                              }), {
                                fill: o ? ha(t, c, n.stroke) : 'none',
                                stroke: ha(t, c, n.stroke),
                                strokeWidth: 1
                              })
                              return oo(i, 45),
                              i
                            }(t, e, o, a))
                          : da(i, 'bpmn:CompensateEventDefinition')
                            ? (function (e, t) {
                                const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
                                const o = arguments.length > 3 ? arguments[3] : void 0
                                return E(e, r.getScaledPath('EVENT_COMPENSATION', {
                                  xScaleFactor: 1,
                                  yScaleFactor: 1,
                                  containerWidth: t.width,
                                  containerHeight: t.height,
                                  position: {
                                    mx: 0.22,
                                    my: 0.5
                                  }
                                }), {
                                  fill: o ? ha(t, c, n.stroke) : fa(t, s, n.fill),
                                  stroke: ha(t, c, n.stroke),
                                  strokeWidth: 1
                                })
                              }(t, e, o, a))
                            : da(i, 'bpmn:TerminateEventDefinition')
                              ? (function (e, t) {
                                  const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
                                  return g(e, t.width, t.height, 8, {
                                    fill: ha(t, c, n.stroke),
                                    stroke: ha(t, c, n.stroke),
                                    strokeWidth: 4
                                  })
                                }(t, e, o, a))
                              : null
      }
      const S = {
        ParticipantMultiplicityMarker: function (e, t) {
          const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
          const o = ga(t, n)
          const i = ya(t, n)
          x('participant-multiplicity', e, r.getScaledPath('MARKER_PARALLEL', {
            xScaleFactor: 1,
            yScaleFactor: 1,
            containerWidth: o,
            containerHeight: i,
            position: {
              mx: (o / 2 - 6) / o,
              my: (i - 15) / i
            }
          }), {
            strokeWidth: 2,
            fill: fa(t, s, n.fill),
            stroke: ha(t, c, n.stroke)
          })
        },
        SubProcessMarker: function (e, t) {
          const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
          ro(y(e, 14, 14, 0, {
            strokeWidth: 1,
            fill: fa(t, s, n.fill),
            stroke: ha(t, c, n.stroke)
          }), t.width / 2 - 7.5, t.height - 20),
          x('sub-process', e, r.getScaledPath('MARKER_SUB_PROCESS', {
            xScaleFactor: 1.5,
            yScaleFactor: 1.5,
            containerWidth: t.width,
            containerHeight: t.height,
            position: {
              mx: (t.width / 2 - 7.5) / t.width,
              my: (t.height - 20) / t.height
            }
          }), {
            fill: fa(t, s, n.fill),
            stroke: ha(t, c, n.stroke)
          })
        },
        ParallelMarker: function (e, t, n) {
          const o = ga(t, n)
          const i = ya(t, n)
          x('parallel', e, r.getScaledPath('MARKER_PARALLEL', {
            xScaleFactor: 1,
            yScaleFactor: 1,
            containerWidth: o,
            containerHeight: i,
            position: {
              mx: (o / 2 + n.parallel) / o,
              my: (i - 20) / i
            }
          }), {
            fill: fa(t, s, n.fill),
            stroke: ha(t, c, n.stroke)
          })
        },
        SequentialMarker: function (e, t, n) {
          x('sequential', e, r.getScaledPath('MARKER_SEQUENTIAL', {
            xScaleFactor: 1,
            yScaleFactor: 1,
            containerWidth: t.width,
            containerHeight: t.height,
            position: {
              mx: (t.width / 2 + n.seq) / t.width,
              my: (t.height - 19) / t.height
            }
          }), {
            fill: fa(t, s, n.fill),
            stroke: ha(t, c, n.stroke)
          })
        },
        CompensationMarker: function (e, t, n) {
          x('compensation', e, r.getScaledPath('MARKER_COMPENSATION', {
            xScaleFactor: 1,
            yScaleFactor: 1,
            containerWidth: t.width,
            containerHeight: t.height,
            position: {
              mx: (t.width / 2 + n.compensation) / t.width,
              my: (t.height - 13) / t.height
            }
          }), {
            strokeWidth: 1,
            fill: fa(t, s, n.fill),
            stroke: ha(t, c, n.stroke)
          })
        },
        LoopMarker: function (e, t, n) {
          const o = ga(t, n)
          const i = ya(t, n)
          x('loop', e, r.getScaledPath('MARKER_LOOP', {
            xScaleFactor: 1,
            yScaleFactor: 1,
            containerWidth: o,
            containerHeight: i,
            position: {
              mx: (o / 2 + n.loop) / o,
              my: (i - 7) / i
            }
          }), {
            strokeWidth: 1.5,
            fill: 'none',
            stroke: ha(t, c, n.stroke),
            strokeMiterlimit: 0.5
          })
        },
        AdhocMarker: function (e, t, n) {
          const o = ga(t, n)
          const i = ya(t, n)
          x('adhoc', e, r.getScaledPath('MARKER_ADHOC', {
            xScaleFactor: 1,
            yScaleFactor: 1,
            containerWidth: o,
            containerHeight: i,
            position: {
              mx: (o / 2 + n.adhoc) / o,
              my: (i - 15) / i
            }
          }), {
            strokeWidth: 1,
            fill: ha(t, c, n.stroke),
            stroke: ha(t, c, n.stroke)
          })
        }
      }
      function k (e, t, n, r) {
        S[e](t, n, r)
      }
      function j (e, t, n) {
        let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}
        r = {
          fill: r.fill,
          stroke: r.stroke,
          width: ga(t, r),
          height: ya(t, r)
        }
        const o = Ti(t)
        const i = n && n.includes('SubProcessMarker')
        r = Ea(Ea({}, r), {}, i
          ? {
              seq: -21,
              parallel: -22,
              compensation: -42,
              loop: -18,
              adhoc: 10
            }
          : {
              seq: -5,
              parallel: -6,
              compensation: -27,
              loop: 0,
              adhoc: 10
            }),
        G(n, function (n) {
          k(n, e, t, r)
        }
        ),
        o.get('isForCompensation') && k('CompensationMarker', e, t, r),
        Pi(o, 'bpmn:AdHocSubProcess') && k('AdhocMarker', e, t, r)
        const a = o.get('loopCharacteristics')
        const s = a && a.get('isSequential')
        a && (void 0 === s && k('LoopMarker', e, t, r),
        !1 === s && k('ParallelMarker', e, t, r),
        !0 === s && k('SequentialMarker', e, t, r))
      }
      function B (e, t) {
        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
        n = le({
          size: {
            width: 100
          }
        }, n)
        const r = i.createText(t || '', n)
        return Ue(r).add('djs-label'),
        Fe(e, r),
        r
      }
      function D (e, t, n) {
        const r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}
        const o = Ti(t)
        const i = va({
          x: t.x,
          y: t.y,
          width: t.width,
          height: t.height
        }, r)
        return B(e, o.name, {
          align: n,
          box: i,
          padding: 7,
          style: {
            fill: ma(t, l, c, r.stroke)
          }
        })
      }
      function P (e, t, n) {
        const r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}
        const o = ea(n)
        const i = B(e, t, {
          box: {
            height: 30,
            width: o ? ya(n, r) : ga(n, r)
          },
          align: 'center-middle',
          style: {
            fill: ma(n, l, c, r.stroke)
          }
        })
        o && no(i, 0, 1 * ya(n, r), 270)
      }
      function O (e, t) {
        const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
        const r = va(t, n)
        return y(e, r.width, r.height, 10, Ea(Ea({}, n), {}, {
          fill: fa(t, s, n.fill),
          fillOpacity: wa,
          stroke: ha(t, c, n.stroke)
        }))
      }
      function T (e, t) {
        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
        const r = Ti(t)
        const o = fa(t, s, n.fill)
        const i = ha(t, c, n.stroke)
        return r.get('associationDirection') !== 'One' && r.get('associationDirection') !== 'Both' || (n.markerEnd = v('association-end', o, i)),
        r.get('associationDirection') === 'Both' && (n.markerStart = v('association-start', o, i)),
        n = Ca(n, ['markerStart', 'markerEnd']),
        A(e, t.waypoints, Ea(Ea({}, n), {}, {
          stroke: i,
          strokeDasharray: '0, 5'
        }))
      }
      function R (e, t) {
        const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
        const o = fa(t, s, n.fill)
        const i = ha(t, c, n.stroke)
        const a = E(e, r.getScaledPath('DATA_OBJECT_PATH', {
          xScaleFactor: 1,
          yScaleFactor: 1,
          containerWidth: t.width,
          containerHeight: t.height,
          position: {
            mx: 0.474,
            my: 0.296
          }
        }), {
          fill: o,
          fillOpacity: wa,
          stroke: i
        })
        return (function (e) {
          const t = e.dataObjectRef
          return e.isCollection || t && t.isCollection
        }(Ti(t))) && E(e, r.getScaledPath('DATA_OBJECT_COLLECTION_PATH', {
          xScaleFactor: 1,
          yScaleFactor: 1,
          containerWidth: t.width,
          containerHeight: t.height,
          position: {
            mx: 0.33,
            my: (t.height - 18) / t.height
          }
        }), {
          strokeWidth: 2,
          fill: o,
          stroke: i
        }),
        a
      }
      function N (e, t) {
        const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
        return g(e, t.width, t.height, Ea(Ea({
          fillOpacity: wa
        }, n), {}, {
          fill: fa(t, s, n.fill),
          stroke: ha(t, c, n.stroke)
        }))
      }
      function M (e, t) {
        const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
        return (function (e, t, n, r) {
          const o = t / 2
          const i = n / 2
          const a = [{
            x: o,
            y: 0
          }, {
            x: t,
            y: i
          }, {
            x: o,
            y: n
          }, {
            x: 0,
            y: i
          }].map(function (e) {
            return e.x + ',' + e.y
          }
          ).join(' ')
          const s = et('polygon', Ea(Ea({}, r = d(r)), {}, {
            points: a
          }))
          return Fe(e, s),
          s
        }(e, t.width, t.height, {
          fill: fa(t, s, n.fill),
          fillOpacity: wa,
          stroke: ha(t, c, n.stroke)
        }))
      }
      function L (e, t) {
        const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
        const r = y(e, ga(t, n), ya(t, n), 0, {
          fill: fa(t, s, n.fill),
          fillOpacity: n.fillOpacity || wa,
          stroke: ha(t, c, n.stroke),
          strokeWidth: 1.5
        })
        const o = Ti(t)
        return Pi(o, 'bpmn:Lane') && P(e, o.get('name'), t, n),
        r
      }
      function z (e, t) {
        const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
        const r = O(e, t, n)
        ta(t) && We(r, {
          strokeDasharray: '0, 5.5',
          strokeWidth: 2.5
        })
        const o = Zi(t)
        return D(e, t, o ? 'center-top' : 'center-middle', n),
        j(e, t, o ? void 0 : ['SubProcessMarker'], n),
        r
      }
      function F (e, t) {
        const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
        const r = O(e, t, n)
        return D(e, t, 'center-middle', n),
        j(e, t, void 0, n),
        r
      }
      var $ = this.handlers = {
        'bpmn:AdHocSubProcess': function (e, t) {
          let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
          return z(e, t, n = Zi(t) ? Ca(n, ['fill', 'stroke', 'width', 'height']) : Ca(n, ['fill', 'stroke']))
        },
        'bpmn:Association': function (e, t) {
          let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
          return T(e, t, n = Ca(n, ['fill', 'stroke']))
        },
        'bpmn:BoundaryEvent': function (e, t) {
          let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
          const r = n.renderIcon
          const o = void 0 === r || r
          n = Ca(n, ['fill', 'stroke'])
          const i = Ti(t).get('cancelActivity')
          n = {
            strokeWidth: 1.5,
            fill: fa(t, s, n.fill),
            fillOpacity: 1,
            stroke: ha(t, c, n.stroke)
          },
          i || (n.strokeDasharray = '6')
          const a = N(e, t, n)
          return g(e, t.width, t.height, 3, Ea(Ea({}, n), {}, {
            fill: 'none'
          })),
          o && C(t, e, n),
          a
        },
        'bpmn:BusinessRuleTask': function (e, t) {
          let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
          const o = F(e, t, n = Ca(n, ['fill', 'stroke']))
          return We(E(e, r.getScaledPath('TASK_TYPE_BUSINESS_RULE_MAIN', {
            abspos: {
              x: 8,
              y: 8
            }
          })), {
            fill: fa(t, s, n.fill),
            stroke: ha(t, c, n.stroke),
            strokeWidth: 1
          }),
          We(E(e, r.getScaledPath('TASK_TYPE_BUSINESS_RULE_HEADER', {
            abspos: {
              x: 8,
              y: 8
            }
          })), {
            fill: ha(t, c, n.stroke),
            stroke: ha(t, c, n.stroke),
            strokeWidth: 1
          }),
          o
        },
        'bpmn:CallActivity': function (e, t) {
          let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
          return z(e, t, Ea({
            strokeWidth: 5
          }, n = Ca(n, ['fill', 'stroke'])))
        },
        'bpmn:ComplexGateway': function (e, t) {
          let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
          const o = M(e, t, n = Ca(n, ['fill', 'stroke']))
          return E(e, r.getScaledPath('GATEWAY_COMPLEX', {
            xScaleFactor: 0.5,
            yScaleFactor: 0.5,
            containerWidth: t.width,
            containerHeight: t.height,
            position: {
              mx: 0.46,
              my: 0.26
            }
          }), {
            fill: ha(t, c, n.stroke),
            stroke: ha(t, c, n.stroke),
            strokeWidth: 1
          }),
          o
        },
        'bpmn:DataInput': function (e, t) {
          let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
          n = Ca(n, ['fill', 'stroke'])
          const o = r.getRawPath('DATA_ARROW')
          const i = R(e, t, n)
          return E(e, o, {
            fill: 'none',
            stroke: ha(t, c, n.stroke),
            strokeWidth: 1
          }),
          i
        },
        'bpmn:DataInputAssociation': function (e, t) {
          let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
          return T(e, t, Ea(Ea({}, n = Ca(n, ['fill', 'stroke'])), {}, {
            markerEnd: v('association-end', fa(t, s, n.fill), ha(t, c, n.stroke))
          }))
        },
        'bpmn:DataObject': function (e, t) {
          let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
          return R(e, t, n = Ca(n, ['fill', 'stroke']))
        },
        'bpmn:DataObjectReference': _('bpmn:DataObject'),
        'bpmn:DataOutput': function (e, t) {
          let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
          n = Ca(n, ['fill', 'stroke'])
          const o = r.getRawPath('DATA_ARROW')
          const i = R(e, t, n)
          return E(e, o, {
            strokeWidth: 1,
            fill: fa(t, s, n.fill),
            stroke: ha(t, c, n.stroke)
          }),
          i
        },
        'bpmn:DataOutputAssociation': function (e, t) {
          let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
          return T(e, t, Ea(Ea({}, n = Ca(n, ['fill', 'stroke'])), {}, {
            markerEnd: v('association-end', fa(t, s, n.fill), ha(t, c, n.stroke))
          }))
        },
        'bpmn:DataStoreReference': function (e, t) {
          let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
          return n = Ca(n, ['fill', 'stroke']),
          E(e, r.getScaledPath('DATA_STORE', {
            xScaleFactor: 1,
            yScaleFactor: 1,
            containerWidth: t.width,
            containerHeight: t.height,
            position: {
              mx: 0,
              my: 0.133
            }
          }), {
            fill: fa(t, s, n.fill),
            fillOpacity: wa,
            stroke: ha(t, c, n.stroke),
            strokeWidth: 2
          })
        },
        'bpmn:EndEvent': function (e, t) {
          let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
          const r = n.renderIcon
          const o = void 0 === r || r
          const i = N(e, t, Ea(Ea({}, n = Ca(n, ['fill', 'stroke'])), {}, {
            strokeWidth: 4
          }))
          return o && C(t, e, n),
          i
        },
        'bpmn:EventBasedGateway': function (e, t) {
          let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
          n = Ca(n, ['fill', 'stroke'])
          const o = Ti(t)
          const i = M(e, t, n)
          g(e, t.width, t.height, 0.2 * t.height, {
            fill: fa(t, 'none', n.fill),
            stroke: ha(t, c, n.stroke),
            strokeWidth: 1
          })
          const a = o.get('eventGatewayType')
          const s = !!o.get('instantiate')
          if (a === 'Parallel') {
            const l = r.getScaledPath('GATEWAY_PARALLEL', {
              xScaleFactor: 0.4,
              yScaleFactor: 0.4,
              containerWidth: t.width,
              containerHeight: t.height,
              position: {
                mx: 0.474,
                my: 0.296
              }
            })
            E(e, l, {
              fill: 'none',
              stroke: ha(t, c, n.stroke),
              strokeWidth: 1
            })
          } else {
            a === 'Exclusive' && (s || g(e, t.width, t.height, 0.26 * t.height, {
              fill: 'none',
              stroke: ha(t, c, n.stroke),
              strokeWidth: 1
            }),
            (function () {
              const o = r.getScaledPath('GATEWAY_EVENT_BASED', {
                xScaleFactor: 0.18,
                yScaleFactor: 0.18,
                containerWidth: t.width,
                containerHeight: t.height,
                position: {
                  mx: 0.36,
                  my: 0.44
                }
              })
              E(e, o, {
                fill: 'none',
                stroke: ha(t, c, n.stroke),
                strokeWidth: 2
              })
            }()))
          }
          return i
        },
        'bpmn:ExclusiveGateway': function (e, t) {
          let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
          const o = M(e, t, n = Ca(n, ['fill', 'stroke']))
          const i = r.getScaledPath('GATEWAY_EXCLUSIVE', {
            xScaleFactor: 0.4,
            yScaleFactor: 0.4,
            containerWidth: t.width,
            containerHeight: t.height,
            position: {
              mx: 0.32,
              my: 0.3
            }
          })
          return Ri(t).get('isMarkerVisible') && E(e, i, {
            fill: ha(t, c, n.stroke),
            stroke: ha(t, c, n.stroke),
            strokeWidth: 1
          }),
          o
        },
        'bpmn:Gateway': function (e, t) {
          let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
          return M(e, t, n = Ca(n, ['fill', 'stroke']))
        },
        'bpmn:Group': function (e, t) {
          let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
          return n = Ca(n, ['fill', 'stroke', 'width', 'height']),
          y(e, t.width, t.height, 10, {
            stroke: ha(t, c, n.stroke),
            strokeWidth: 1.5,
            strokeDasharray: '10, 6, 0, 6',
            fill: 'none',
            pointerEvents: 'none',
            width: ga(t, n),
            height: ya(t, n)
          })
        },
        'bpmn:InclusiveGateway': function (e, t) {
          let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
          const r = M(e, t, n = Ca(n, ['fill', 'stroke']))
          return g(e, t.width, t.height, 0.24 * t.height, {
            fill: fa(t, s, n.fill),
            stroke: ha(t, c, n.stroke),
            strokeWidth: 2.5
          }),
          r
        },
        'bpmn:IntermediateEvent': function (e, t) {
          let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
          const r = n.renderIcon
          const o = void 0 === r || r
          const i = N(e, t, Ea(Ea({}, n = Ca(n, ['fill', 'stroke'])), {}, {
            strokeWidth: 1.5
          }))
          return g(e, t.width, t.height, 3, {
            fill: 'none',
            stroke: ha(t, c, n.stroke),
            strokeWidth: 1.5
          }),
          o && C(t, e, n),
          i
        },
        'bpmn:IntermediateCatchEvent': _('bpmn:IntermediateEvent'),
        'bpmn:IntermediateThrowEvent': _('bpmn:IntermediateEvent'),
        'bpmn:Lane': function (e, t) {
          let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
          return L(e, t, Ea(Ea({}, n = Ca(n, ['fill', 'stroke', 'width', 'height'])), {}, {
            fillOpacity: 0.25
          }))
        },
        'bpmn:ManualTask': function (e, t) {
          let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
          const o = F(e, t, n = Ca(n, ['fill', 'stroke']))
          return E(e, r.getScaledPath('TASK_TYPE_MANUAL', {
            abspos: {
              x: 17,
              y: 15
            }
          }), {
            fill: fa(t, s, n.fill),
            stroke: ha(t, c, n.stroke),
            strokeWidth: 0.5
          }),
          o
        },
        'bpmn:MessageFlow': function (e, t) {
          let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
          n = Ca(n, ['fill', 'stroke'])
          const o = Ti(t)
          const i = Ri(t)
          const a = fa(t, s, n.fill)
          const l = ha(t, c, n.stroke)
          const p = A(e, t.waypoints, {
            markerEnd: v('messageflow-end', a, l),
            markerStart: v('messageflow-start', a, l),
            stroke: l,
            strokeDasharray: '10, 11',
            strokeWidth: 1.5
          })
          if (o.get('messageRef')) {
            const u = p.getPointAtLength(p.getTotalLength() / 2)
            const d = r.getScaledPath('MESSAGE_FLOW_MARKER', {
              abspos: {
                x: u.x,
                y: u.y
              }
            })
            const f = {
              strokeWidth: 1
            }
            i.get('messageVisibleKind') === 'initiating'
              ? (f.fill = a,
                f.stroke = l)
              : (f.fill = l,
                f.stroke = a)
            const h = E(e, d, f)
            const m = B(e, o.get('messageRef').get('name'), {
              align: 'center-top',
              fitBox: !0,
              style: {
                fill: l
              }
            })
            const g = h.getBBox()
            const y = m.getBBox()
            no(m, u.x - y.width / 2, u.y + g.height / 2 + 10, 0)
          }
          return p
        },
        'bpmn:ParallelGateway': function (e, t) {
          let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
          const o = M(e, t, n = Ca(n, ['fill', 'stroke']))
          return E(e, r.getScaledPath('GATEWAY_PARALLEL', {
            xScaleFactor: 0.6,
            yScaleFactor: 0.6,
            containerWidth: t.width,
            containerHeight: t.height,
            position: {
              mx: 0.46,
              my: 0.2
            }
          }), {
            fill: ha(t, c, n.stroke),
            stroke: ha(t, c, n.stroke),
            strokeWidth: 1
          }),
          o
        },
        'bpmn:Participant': function (e, t) {
          let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
          const r = L(e, t, n = Ca(n, ['fill', 'stroke', 'width', 'height']))
          const o = Zi(t)
          const i = ea(t)
          const a = Ti(t)
          const s = a.get('name')
          if (o) {
            b(e, i
              ? [{
                  x: 30,
                  y: 0
                }, {
                  x: 30,
                  y: ya(t, n)
                }]
              : [{
                  x: 0,
                  y: 30
                }, {
                  x: ga(t, n),
                  y: 30
                }], {
              stroke: ha(t, c, n.stroke),
              strokeWidth: 1.5
            }),
            P(e, s, t, n)
          } else {
            const p = va(t, n)
            i || (p.height = ga(t, n),
            p.width = ya(t, n))
            const u = B(e, s, {
              box: p,
              align: 'center-middle',
              style: {
                fill: ma(t, l, c, n.stroke)
              }
            })
            i || no(u, 0, 1 * ya(t, n), 270)
          }
          return a.get('participantMultiplicity') && k('ParticipantMultiplicityMarker', e, t, n),
          r
        },
        'bpmn:ReceiveTask': function (e, t) {
          let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
          n = Ca(n, ['fill', 'stroke'])
          let o; const i = Ti(t); const a = F(e, t, n)
          return i.get('instantiate')
            ? (g(e, 28, 28, 4.4, {
                fill: fa(t, s, n.fill),
                stroke: ha(t, c, n.stroke),
                strokeWidth: 1
              }),
              o = r.getScaledPath('TASK_TYPE_INSTANTIATING_SEND', {
                abspos: {
                  x: 7.77,
                  y: 9.52
                }
              }))
            : o = r.getScaledPath('TASK_TYPE_SEND', {
              xScaleFactor: 0.9,
              yScaleFactor: 0.9,
              containerWidth: 21,
              containerHeight: 14,
              position: {
                mx: 0.3,
                my: 0.4
              }
            }),
          E(e, o, {
            fill: fa(t, s, n.fill),
            stroke: ha(t, c, n.stroke),
            strokeWidth: 1
          }),
          a
        },
        'bpmn:ScriptTask': function (e, t) {
          let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
          const o = F(e, t, n = Ca(n, ['fill', 'stroke']))
          return E(e, r.getScaledPath('TASK_TYPE_SCRIPT', {
            abspos: {
              x: 15,
              y: 20
            }
          }), {
            fill: fa(t, s, n.fill),
            stroke: ha(t, c, n.stroke),
            strokeWidth: 1
          }),
          o
        },
        'bpmn:SendTask': function (e, t) {
          let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
          const o = F(e, t, n = Ca(n, ['fill', 'stroke']))
          return E(e, r.getScaledPath('TASK_TYPE_SEND', {
            xScaleFactor: 1,
            yScaleFactor: 1,
            containerWidth: 21,
            containerHeight: 14,
            position: {
              mx: 0.285,
              my: 0.357
            }
          }), {
            fill: ha(t, c, n.stroke),
            stroke: fa(t, s, n.fill),
            strokeWidth: 1
          }),
          o
        },
        'bpmn:SequenceFlow': function (e, t) {
          let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
          n = Ca(n, ['fill', 'stroke'])
          const r = fa(t, s, n.fill)
          const o = ha(t, c, n.stroke)
          const i = A(e, t.waypoints, {
            markerEnd: v('sequenceflow-end', r, o),
            stroke: o
          })
          const a = Ti(t)
          const l = t.source
          if (l) {
            const p = Ti(l)
            a.get('conditionExpression') && Pi(p, 'bpmn:Activity') && We(i, {
              markerStart: v('conditional-flow-marker', r, o)
            }),
            p.get('default') && (Pi(p, 'bpmn:Gateway') || Pi(p, 'bpmn:Activity')) && p.get('default') === a && We(i, {
              markerStart: v('conditional-default-flow-marker', r, o)
            })
          }
          return i
        },
        'bpmn:ServiceTask': function (e, t) {
          let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
          const o = F(e, t, n = Ca(n, ['fill', 'stroke']))
          return g(e, 10, 10, {
            fill: fa(t, s, n.fill),
            stroke: 'none',
            transform: 'translate(6, 6)'
          }),
          E(e, r.getScaledPath('TASK_TYPE_SERVICE', {
            abspos: {
              x: 12,
              y: 18
            }
          }), {
            fill: fa(t, s, n.fill),
            stroke: ha(t, c, n.stroke),
            strokeWidth: 1
          }),
          g(e, 10, 10, {
            fill: fa(t, s, n.fill),
            stroke: 'none',
            transform: 'translate(11, 10)'
          }),
          E(e, r.getScaledPath('TASK_TYPE_SERVICE', {
            abspos: {
              x: 17,
              y: 22
            }
          }), {
            fill: fa(t, s, n.fill),
            stroke: ha(t, c, n.stroke),
            strokeWidth: 1
          }),
          o
        },
        'bpmn:StartEvent': function (e, t) {
          let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
          const r = n.renderIcon
          const o = void 0 === r || r
          n = Ca(n, ['fill', 'stroke']),
          Ti(t).get('isInterrupting') || (n = Ea(Ea({}, n), {}, {
            strokeDasharray: '6'
          }))
          const i = N(e, t, n)
          return o && C(t, e, n),
          i
        },
        'bpmn:SubProcess': function (e, t) {
          let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
          return z(e, t, n = Zi(t) ? Ca(n, ['fill', 'stroke', 'width', 'height']) : Ca(n, ['fill', 'stroke']))
        },
        'bpmn:Task': function (e, t) {
          let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
          return F(e, t, n = Ca(n, ['fill', 'stroke']))
        },
        'bpmn:TextAnnotation': function (e, t) {
          let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
          const o = va(t, n = Ca(n, ['fill', 'stroke', 'width', 'height']))
          const i = o.width
          const a = o.height
          const s = y(e, i, a, 0, 0, {
            fill: 'none',
            stroke: 'none'
          })
          return E(e, r.getScaledPath('TEXT_ANNOTATION', {
            xScaleFactor: 1,
            yScaleFactor: 1,
            containerWidth: i,
            containerHeight: a,
            position: {
              mx: 0,
              my: 0
            }
          }), {
            stroke: ha(t, c, n.stroke)
          }),
          B(e, Ti(t).get('text') || '', {
            align: 'left-top',
            box: va(t, n),
            padding: 7,
            style: {
              fill: ma(t, l, c, n.stroke)
            }
          }),
          s
        },
        'bpmn:Transaction': function (e, t) {
          let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
          const o = z(e, t, Ea({
            strokeWidth: 1.5
          }, r = Zi(t) ? Ca(r, ['fill', 'stroke', 'width', 'height']) : Ca(r, ['fill', 'stroke'])))
          const i = n.style(['no-fill', 'no-events'], {
            stroke: ha(t, c, r.stroke),
            strokeWidth: 1.5
          })
          return Zi(t) || (r = {}),
          y(e, ga(t, r), ya(t, r), 7, 3, i),
          o
        },
        'bpmn:UserTask': function (e, t) {
          let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
          const o = F(e, t, n = Ca(n, ['fill', 'stroke']))
          return E(e, r.getScaledPath('TASK_TYPE_USER_1', {
            abspos: {
              x: 15,
              y: 12
            }
          }), {
            fill: fa(t, s, n.fill),
            stroke: ha(t, c, n.stroke),
            strokeWidth: 0.5
          }),
          E(e, r.getScaledPath('TASK_TYPE_USER_2', {
            abspos: {
              x: 15,
              y: 12
            }
          }), {
            fill: fa(t, s, n.fill),
            stroke: ha(t, c, n.stroke),
            strokeWidth: 0.5
          }),
          E(e, r.getScaledPath('TASK_TYPE_USER_3', {
            abspos: {
              x: 15,
              y: 12
            }
          }), {
            fill: ha(t, c, n.stroke),
            stroke: ha(t, c, n.stroke),
            strokeWidth: 0.5
          }),
          o
        },
        label: function (e, t) {
          return (function (e, t) {
            const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
            const r = {
              width: 90,
              height: 30,
              x: t.width / 2 + t.x,
              y: t.height / 2 + t.y
            }
            return B(e, la(t), {
              box: r,
              fitBox: !0,
              style: le({}, i.getExternalStyle(), {
                fill: ma(t, l, c, n.stroke)
              })
            })
          }(e, t, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}))
        }
      }
      this._drawPath = E,
      this._renderer = w
    }
    function Ca (e) {
      return (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : []).reduce(function (t, n) {
        return e[n] && (t[n] = e[n]),
        t
      }
      , {})
    }
    w(_a, St),
    _a.$inject = ['config.bpmnRenderer', 'eventBus', 'styles', 'pathMap', 'canvas', 'textRenderer'],
    _a.prototype.canRender = function (e) {
      return Pi(e, 'bpmn:BaseElement')
    }
    ,
    _a.prototype.drawShape = function (e, t) {
      const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
      const r = t.type
      return this._renderer(r)(e, t, n)
    }
    ,
    _a.prototype.drawConnection = function (e, t) {
      const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
      const r = t.type
      return this._renderer(r)(e, t, n)
    }
    ,
    _a.prototype.getShapePath = function (e) {
      return Pi(e, 'bpmn:Event')
        ? kt([['M', (t = e).x + t.width / 2, t.y + t.height / 2], ['m', 0, -(n = t.width / 2)], ['a', n, n, 0, 1, 1, 0, 2 * n], ['a', n, n, 0, 1, 1, 0, -2 * n], ['z']])
        : Pi(e, 'bpmn:Activity')
          ? (function (e, t) {
              const n = e.x
              const r = e.y
              const o = e.width
              const i = e.height
              return kt([['M', n + t, r], ['l', o - 20, 0], ['a', t, t, 0, 0, 1, t, t], ['l', 0, i - 20], ['a', t, t, 0, 0, 1, -10, t], ['l', 20 - o, 0], ['a', t, t, 0, 0, 1, -10, -10], ['l', 0, 20 - i], ['a', t, t, 0, 0, 1, t, -10], ['z']])
            }(e, 10))
          : Pi(e, 'bpmn:Gateway')
            ? (function (e) {
                const t = e.width / 2
                const n = e.height / 2
                return kt([['M', e.x + t, e.y], ['l', t, n], ['l', -t, n], ['l', -t, -n], ['z']])
              }(e))
            : (function (e) {
                const t = e.x
                const n = e.y
                const r = e.width
                return kt([['M', t, n], ['l', r, 0], ['l', 0, e.height], ['l', -r, 0], ['z']])
              }(e))
      let t, n
    }

    const Sa = 0
    const ka = {
      width: 150,
      height: 50
    }
    function ja (e, t) {
      let n
      t.textContent = e
      try {
        let r; const o = e === ''
        return t.textContent = o ? 'dummy' : e,
        r = {
          width: (n = t.getBBox()).width + 2 * n.x,
          height: n.height
        },
        o && (r.width = 0),
        r
      } catch (e) {
        return {
          width: 0,
          height: 0
        }
      }
    }
    function Ba (e, t, n) {
      for (var r, o = e.shift(), i = o; ;) {
        if ((r = ja(i, n)).width = i ? r.width : 0,
        i === ' ' || i === '' || r.width < Math.round(t) || i.length < 2) { return Da(e, i, o, r) }
        i = Oa(i, r.width, t)
      }
    }
    function Da (e, t, n, r) {
      if (t.length < n.length) {
        const o = n.slice(t.length).trim()
        e.unshift(o)
      }
      return {
        width: r.width,
        height: r.height,
        text: t
      }
    }
    const Pa = '­'
    function Oa (e, t, n) {
      const r = Math.max(e.length * (n / t), 1)
      let o = (function (e, t) {
        let n; const r = e.split(/(\s|-|\u00AD)/g); const o = []; let i = 0
        if (r.length > 1) {
          for (; n = r.shift();) {
            if (!(n.length + i < t)) {
              n !== '-' && n !== Pa || o.pop()
              break
            }
            o.push(n),
            i += n.length
          }
        }
        const a = o[o.length - 1]
        return a && a === Pa && (o[o.length - 1] = '-'),
        o.join('')
      }(e, r))
      return o || (o = e.slice(0, Math.max(Math.round(r - 1), 1))),
      o
    }
    function Ta (e) {
      this._config = le({}, {
        size: ka,
        padding: Sa,
        style: {},
        align: 'center-top'
      }, e || {})
    }
    function Ra (e) {
      const t = le({
        fontFamily: 'Arial, sans-serif',
        fontSize: 12,
        fontWeight: 'normal',
        lineHeight: 1.2
      }, e && e.defaultStyle || {})
      const n = parseInt(t.fontSize, 10) - 1
      const r = le({}, t, {
        fontSize: n
      }, e && e.externalStyle || {})
      const o = new Ta({
        style: t
      })
      this.getExternalLabelBounds = function (e, t) {
        const n = o.getDimensions(t, {
          box: {
            width: 90,
            height: 30
          },
          style: r
        })
        return {
          x: Math.round(e.x + e.width / 2 - n.width / 2),
          y: Math.round(e.y),
          width: Math.ceil(n.width),
          height: Math.ceil(n.height)
        }
      }
      ,
      this.getTextAnnotationBounds = function (e, n) {
        const r = o.getDimensions(n, {
          box: e,
          style: t,
          align: 'left-top',
          padding: 5
        })
        return {
          x: e.x,
          y: e.y,
          width: e.width,
          height: Math.max(30, Math.round(r.height))
        }
      }
      ,
      this.createText = function (e, t) {
        return o.createText(e, t || {})
      }
      ,
      this.getDefaultStyle = function () {
        return t
      }
      ,
      this.getExternalStyle = function () {
        return r
      }
    }
    Ta.prototype.createText = function (e, t) {
      return this.layoutText(e, t).element
    }
    ,
    Ta.prototype.getDimensions = function (e, t) {
      return this.layoutText(e, t).dimensions
    }
    ,
    Ta.prototype.layoutText = function (e, t) {
      let n; const r = le({}, this._config.size, t.box); const o = le({}, this._config.style, t.style); const i = (function (e) {
        const t = e.split('-')
        return {
          horizontal: t[0] || 'center',
          vertical: t[1] || 'top'
        }
      }(t.align || this._config.align)); const a = (function (e) {
        return I(e)
          ? le({
            top: 0,
            left: 0,
            right: 0,
            bottom: 0
          }, e)
          : {
              top: e,
              left: e,
              right: e,
              bottom: e
            }
      }(void 0 !== t.padding ? t.padding : this._config.padding)); const s = t.fitBox || !1; const c = (function (e) {
        if ('fontSize' in e && 'lineHeight' in e) { return e.lineHeight * parseInt(e.fontSize, 10) }
      }(o)); const l = e.split(/\u00AD?\r?\n/); const p = []; const u = r.width - a.left - a.right; const d = et('text')
      for (We(d, {
        x: 0,
        y: 0
      }),
      We(d, o),
      Fe((n = void 0,
      (n = document.getElementById('helper-svg')) || (We(n = et('svg'), {
        id: 'helper-svg'
      }),
      Zt(n, {
        visibility: 'hidden',
        position: 'fixed',
        width: 0,
        height: 0
      }),
      document.body.appendChild(n)),
      n), d); l.length;) { p.push(Ba(l, u, d)) }
      i.vertical === 'middle' && (a.top = a.bottom = 0)
      const f = U(p, function (e, t, n) {
        return e + (c || t.height)
      }
      , 0) + a.top + a.bottom
      const h = U(p, function (e, t, n) {
        return t.width > e ? t.width : e
      }
      , 0)
      let m = a.top
      i.vertical === 'middle' && (m += (r.height - f) / 2),
      m -= (c || p[0].height) / 4
      const v = et('text')
      return We(v, o),
      G(p, function (e) {
        let t
        switch (m += c || e.height,
        i.horizontal) {
          case 'left':
            t = a.left
            break
          case 'right':
            t = (s ? h : u) - a.right - e.width
            break
          default:
            t = Math.max(((s ? h : u) - e.width) / 2 + a.left, 0)
        }
        const n = et('tspan')
        We(n, {
          x: t,
          y: m
        }),
        n.textContent = e.text,
        Fe(v, n)
      }
      ),
      Qe(d),
      {
        dimensions: {
          width: h,
          height: f
        },
        element: v
      }
    }
    ,
    Ra.$inject = ['config.textRenderer']
    const Na = /\{([^{}]+)\}/g
    const Ma = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g
    const Ia = {
      __init__: ['bpmnRenderer'],
      bpmnRenderer: ['type', _a],
      textRenderer: ['type', Ra],
      pathMap: ['type', function () {
        this.pathMap = {
          EVENT_MESSAGE: {
            d: 'm {mx},{my} l 0,{e.y1} l {e.x1},0 l 0,-{e.y1} z l {e.x0},{e.y0} l {e.x0},-{e.y0}',
            height: 36,
            width: 36,
            heightElements: [6, 14],
            widthElements: [10.5, 21]
          },
          EVENT_SIGNAL: {
            d: 'M {mx},{my} l {e.x0},{e.y0} l -{e.x1},0 Z',
            height: 36,
            width: 36,
            heightElements: [18],
            widthElements: [10, 20]
          },
          EVENT_ESCALATION: {
            d: 'M {mx},{my} l {e.x0},{e.y0} l -{e.x0},-{e.y1} l -{e.x0},{e.y1} Z',
            height: 36,
            width: 36,
            heightElements: [20, 7],
            widthElements: [8]
          },
          EVENT_CONDITIONAL: {
            d: 'M {e.x0},{e.y0} l {e.x1},0 l 0,{e.y2} l -{e.x1},0 Z M {e.x2},{e.y3} l {e.x0},0 M {e.x2},{e.y4} l {e.x0},0 M {e.x2},{e.y5} l {e.x0},0 M {e.x2},{e.y6} l {e.x0},0 M {e.x2},{e.y7} l {e.x0},0 M {e.x2},{e.y8} l {e.x0},0 ',
            height: 36,
            width: 36,
            heightElements: [8.5, 14.5, 18, 11.5, 14.5, 17.5, 20.5, 23.5, 26.5],
            widthElements: [10.5, 14.5, 12.5]
          },
          EVENT_LINK: {
            d: 'm {mx},{my} 0,{e.y0} -{e.x1},0 0,{e.y1} {e.x1},0 0,{e.y0} {e.x0},-{e.y2} -{e.x0},-{e.y2} z',
            height: 36,
            width: 36,
            heightElements: [4.4375, 6.75, 7.8125],
            widthElements: [9.84375, 13.5]
          },
          EVENT_ERROR: {
            d: 'm {mx},{my} {e.x0},-{e.y0} {e.x1},-{e.y1} {e.x2},{e.y2} {e.x3},-{e.y3} -{e.x4},{e.y4} -{e.x5},-{e.y5} z',
            height: 36,
            width: 36,
            heightElements: [0.023, 8.737, 8.151, 16.564, 10.591, 8.714],
            widthElements: [0.085, 6.672, 6.97, 4.273, 5.337, 6.636]
          },
          EVENT_CANCEL_45: {
            d: 'm {mx},{my} -{e.x1},0 0,{e.x0} {e.x1},0 0,{e.y1} {e.x0},0 0,-{e.y1} {e.x1},0 0,-{e.y0} -{e.x1},0 0,-{e.y1} -{e.x0},0 z',
            height: 36,
            width: 36,
            heightElements: [4.75, 8.5],
            widthElements: [4.75, 8.5]
          },
          EVENT_COMPENSATION: {
            d: 'm {mx},{my} {e.x0},-{e.y0} 0,{e.y1} z m {e.x1},-{e.y2} {e.x2},-{e.y3} 0,{e.y1} -{e.x2},-{e.y3} z',
            height: 36,
            width: 36,
            heightElements: [6.5, 13, 0.4, 6.1],
            widthElements: [9, 9.3, 8.7]
          },
          EVENT_TIMER_WH: {
            d: 'M {mx},{my} l {e.x0},-{e.y0} m -{e.x0},{e.y0} l {e.x1},{e.y1} ',
            height: 36,
            width: 36,
            heightElements: [10, 2],
            widthElements: [3, 7]
          },
          EVENT_TIMER_LINE: {
            d: 'M {mx},{my} m {e.x0},{e.y0} l -{e.x1},{e.y1} ',
            height: 36,
            width: 36,
            heightElements: [10, 3],
            widthElements: [0, 0]
          },
          EVENT_MULTIPLE: {
            d: 'm {mx},{my} {e.x1},-{e.y0} {e.x1},{e.y0} -{e.x0},{e.y1} -{e.x2},0 z',
            height: 36,
            width: 36,
            heightElements: [6.28099, 12.56199],
            widthElements: [3.1405, 9.42149, 12.56198]
          },
          EVENT_PARALLEL_MULTIPLE: {
            d: 'm {mx},{my} {e.x0},0 0,{e.y1} {e.x1},0 0,{e.y0} -{e.x1},0 0,{e.y1} -{e.x0},0 0,-{e.y1} -{e.x1},0 0,-{e.y0} {e.x1},0 z',
            height: 36,
            width: 36,
            heightElements: [2.56228, 7.68683],
            widthElements: [2.56228, 7.68683]
          },
          GATEWAY_EXCLUSIVE: {
            d: 'm {mx},{my} {e.x0},{e.y0} {e.x1},{e.y0} {e.x2},0 {e.x4},{e.y2} {e.x4},{e.y1} {e.x2},0 {e.x1},{e.y3} {e.x0},{e.y3} {e.x3},0 {e.x5},{e.y1} {e.x5},{e.y2} {e.x3},0 z',
            height: 17.5,
            width: 17.5,
            heightElements: [8.5, 6.5312, -6.5312, -8.5],
            widthElements: [6.5, -6.5, 3, -3, 5, -5]
          },
          GATEWAY_PARALLEL: {
            d: 'm {mx},{my} 0,{e.y1} -{e.x1},0 0,{e.y0} {e.x1},0 0,{e.y1} {e.x0},0 0,-{e.y1} {e.x1},0 0,-{e.y0} -{e.x1},0 0,-{e.y1} -{e.x0},0 z',
            height: 30,
            width: 30,
            heightElements: [5, 12.5],
            widthElements: [5, 12.5]
          },
          GATEWAY_EVENT_BASED: {
            d: 'm {mx},{my} {e.x0},{e.y0} {e.x0},{e.y1} {e.x1},{e.y2} {e.x2},0 z',
            height: 11,
            width: 11,
            heightElements: [-6, 6, 12, -12],
            widthElements: [9, -3, -12]
          },
          GATEWAY_COMPLEX: {
            d: 'm {mx},{my} 0,{e.y0} -{e.x0},-{e.y1} -{e.x1},{e.y2} {e.x0},{e.y1} -{e.x2},0 0,{e.y3} {e.x2},0  -{e.x0},{e.y1} l {e.x1},{e.y2} {e.x0},-{e.y1} 0,{e.y0} {e.x3},0 0,-{e.y0} {e.x0},{e.y1} {e.x1},-{e.y2} -{e.x0},-{e.y1} {e.x2},0 0,-{e.y3} -{e.x2},0 {e.x0},-{e.y1} -{e.x1},-{e.y2} -{e.x0},{e.y1} 0,-{e.y0} -{e.x3},0 z',
            height: 17.125,
            width: 17.125,
            heightElements: [4.875, 3.4375, 2.125, 3],
            widthElements: [3.4375, 2.125, 4.875, 3]
          },
          DATA_OBJECT_PATH: {
            d: 'm 0,0 {e.x1},0 {e.x0},{e.y0} 0,{e.y1} -{e.x2},0 0,-{e.y2} {e.x1},0 0,{e.y0} {e.x0},0',
            height: 61,
            width: 51,
            heightElements: [10, 50, 60],
            widthElements: [10, 40, 50, 60]
          },
          DATA_OBJECT_COLLECTION_PATH: {
            d: 'm{mx},{my} m 3,2 l 0,10 m 3,-10 l 0,10 m 3,-10 l 0,10',
            height: 10,
            width: 10,
            heightElements: [],
            widthElements: []
          },
          DATA_ARROW: {
            d: 'm 5,9 9,0 0,-3 5,5 -5,5 0,-3 -9,0 z',
            height: 61,
            width: 51,
            heightElements: [],
            widthElements: []
          },
          DATA_STORE: {
            d: 'm  {mx},{my} l  0,{e.y2} c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0 l  0,-{e.y2} c -{e.x0},-{e.y1} -{e.x1},-{e.y1} -{e.x2},0c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0 m  -{e.x2},{e.y0}c  {e.x0},{e.y1} {e.x1},{e.y1} {e.x2},0m  -{e.x2},{e.y0}c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0',
            height: 61,
            width: 61,
            heightElements: [7, 10, 45],
            widthElements: [2, 58, 60]
          },
          TEXT_ANNOTATION: {
            d: 'm {mx}, {my} m 10,0 l -10,0 l 0,{e.y0} l 10,0',
            height: 30,
            width: 10,
            heightElements: [30],
            widthElements: [10]
          },
          MARKER_SUB_PROCESS: {
            d: 'm{mx},{my} m 7,2 l 0,10 m -5,-5 l 10,0',
            height: 10,
            width: 10,
            heightElements: [],
            widthElements: []
          },
          MARKER_PARALLEL: {
            d: 'm{mx},{my} m 3,2 l 0,10 m 3,-10 l 0,10 m 3,-10 l 0,10',
            height: 10,
            width: 10,
            heightElements: [],
            widthElements: []
          },
          MARKER_SEQUENTIAL: {
            d: 'm{mx},{my} m 0,3 l 10,0 m -10,3 l 10,0 m -10,3 l 10,0',
            height: 10,
            width: 10,
            heightElements: [],
            widthElements: []
          },
          MARKER_COMPENSATION: {
            d: 'm {mx},{my} 7,-5 0,10 z m 7.1,-0.3 6.9,-4.7 0,10 -6.9,-4.7 z',
            height: 10,
            width: 21,
            heightElements: [],
            widthElements: []
          },
          MARKER_LOOP: {
            d: 'm {mx},{my} c 3.526979,0 6.386161,-2.829858 6.386161,-6.320661 0,-3.490806 -2.859182,-6.320661 -6.386161,-6.320661 -3.526978,0 -6.38616,2.829855 -6.38616,6.320661 0,1.745402 0.714797,3.325567 1.870463,4.469381 0.577834,0.571908 1.265885,1.034728 2.029916,1.35457 l -0.718163,-3.909793 m 0.718163,3.909793 -3.885211,0.802902',
            height: 13.9,
            width: 13.7,
            heightElements: [],
            widthElements: []
          },
          MARKER_ADHOC: {
            d: 'm {mx},{my} m 0.84461,2.64411 c 1.05533,-1.23780996 2.64337,-2.07882 4.29653,-1.97997996 2.05163,0.0805 3.85579,1.15803 5.76082,1.79107 1.06385,0.34139996 2.24454,0.1438 3.18759,-0.43767 0.61743,-0.33642 1.2775,-0.64078 1.7542,-1.17511 0,0.56023 0,1.12046 0,1.6807 -0.98706,0.96237996 -2.29792,1.62393996 -3.6918,1.66181996 -1.24459,0.0927 -2.46671,-0.2491 -3.59505,-0.74812 -1.35789,-0.55965 -2.75133,-1.33436996 -4.27027,-1.18121996 -1.37741,0.14601 -2.41842,1.13685996 -3.44288,1.96782996 z',
            height: 4,
            width: 15,
            heightElements: [],
            widthElements: []
          },
          TASK_TYPE_SEND: {
            d: 'm {mx},{my} l 0,{e.y1} l {e.x1},0 l 0,-{e.y1} z l {e.x0},{e.y0} l {e.x0},-{e.y0}',
            height: 14,
            width: 21,
            heightElements: [6, 14],
            widthElements: [10.5, 21]
          },
          TASK_TYPE_SCRIPT: {
            d: 'm {mx},{my} c 9.966553,-6.27276 -8.000926,-7.91932 2.968968,-14.938 l -8.802728,0 c -10.969894,7.01868 6.997585,8.66524 -2.968967,14.938 z m -7,-12 l 5,0 m -4.5,3 l 4.5,0 m -3,3 l 5,0m -4,3 l 5,0',
            height: 15,
            width: 12.6,
            heightElements: [6, 14],
            widthElements: [10.5, 21]
          },
          TASK_TYPE_USER_1: {
            d: 'm {mx},{my} c 0.909,-0.845 1.594,-2.049 1.594,-3.385 0,-2.554 -1.805,-4.62199999 -4.357,-4.62199999 -2.55199998,0 -4.28799998,2.06799999 -4.28799998,4.62199999 0,1.348 0.974,2.562 1.89599998,3.405 -0.52899998,0.187 -5.669,2.097 -5.794,4.7560005 v 6.718 h 17 v -6.718 c 0,-2.2980005 -5.5279996,-4.5950005 -6.0509996,-4.7760005 zm -8,6 l 0,5.5 m 11,0 l 0,-5'
          },
          TASK_TYPE_USER_2: {
            d: 'm {mx},{my} m 2.162,1.009 c 0,2.4470005 -2.158,4.4310005 -4.821,4.4310005 -2.66499998,0 -4.822,-1.981 -4.822,-4.4310005 '
          },
          TASK_TYPE_USER_3: {
            d: 'm {mx},{my} m -6.9,-3.80 c 0,0 2.25099998,-2.358 4.27399998,-1.177 2.024,1.181 4.221,1.537 4.124,0.965 -0.098,-0.57 -0.117,-3.79099999 -4.191,-4.13599999 -3.57499998,0.001 -4.20799998,3.36699999 -4.20699998,4.34799999 z'
          },
          TASK_TYPE_MANUAL: {
            d: 'm {mx},{my} c 0.234,-0.01 5.604,0.008 8.029,0.004 0.808,0 1.271,-0.172 1.417,-0.752 0.227,-0.898 -0.334,-1.314 -1.338,-1.316 -2.467,-0.01 -7.886,-0.004 -8.108,-0.004 -0.014,-0.079 0.016,-0.533 0,-0.61 0.195,-0.042 8.507,0.006 9.616,0.002 0.877,-0.007 1.35,-0.438 1.353,-1.208 0.003,-0.768 -0.479,-1.09 -1.35,-1.091 -2.968,-0.002 -9.619,-0.013 -9.619,-0.013 v -0.591 c 0,0 5.052,-0.016 7.225,-0.016 0.888,-0.002 1.354,-0.416 1.351,-1.193 -0.006,-0.761 -0.492,-1.196 -1.361,-1.196 -3.473,-0.005 -10.86,-0.003 -11.0829995,-0.003 -0.022,-0.047 -0.045,-0.094 -0.069,-0.139 0.3939995,-0.319 2.0409995,-1.626 2.4149995,-2.017 0.469,-0.4870005 0.519,-1.1650005 0.162,-1.6040005 -0.414,-0.511 -0.973,-0.5 -1.48,-0.236 -1.4609995,0.764 -6.5999995,3.6430005 -7.7329995,4.2710005 -0.9,0.499 -1.516,1.253 -1.882,2.19 -0.37000002,0.95 -0.17,2.01 -0.166,2.979 0.004,0.718 -0.27300002,1.345 -0.055,2.063 0.629,2.087 2.425,3.312 4.859,3.318 4.6179995,0.014 9.2379995,-0.139 13.8569995,-0.158 0.755,-0.004 1.171,-0.301 1.182,-1.033 0.012,-0.754 -0.423,-0.969 -1.183,-0.973 -1.778,-0.01 -5.824,-0.004 -6.04,-0.004 10e-4,-0.084 0.003,-0.586 10e-4,-0.67 z'
          },
          TASK_TYPE_INSTANTIATING_SEND: {
            d: 'm {mx},{my} l 0,8.4 l 12.6,0 l 0,-8.4 z l 6.3,3.6 l 6.3,-3.6'
          },
          TASK_TYPE_SERVICE: {
            d: 'm {mx},{my} v -1.71335 c 0.352326,-0.0705 0.703932,-0.17838 1.047628,-0.32133 0.344416,-0.14465 0.665822,-0.32133 0.966377,-0.52145 l 1.19431,1.18005 1.567487,-1.57688 -1.195028,-1.18014 c 0.403376,-0.61394 0.683079,-1.29908 0.825447,-2.01824 l 1.622133,-0.01 v -2.2196 l -1.636514,0.01 c -0.07333,-0.35153 -0.178319,-0.70024 -0.323564,-1.04372 -0.145244,-0.34406 -0.321407,-0.6644 -0.522735,-0.96217 l 1.131035,-1.13631 -1.583305,-1.56293 -1.129598,1.13589 c -0.614052,-0.40108 -1.302883,-0.68093 -2.022633,-0.82247 l 0.0093,-1.61852 h -2.241173 l 0.0042,1.63124 c -0.353763,0.0736 -0.705369,0.17977 -1.049785,0.32371 -0.344415,0.14437 -0.665102,0.32092 -0.9635006,0.52046 l -1.1698628,-1.15823 -1.5667691,1.5792 1.1684265,1.15669 c -0.4026573,0.61283 -0.68308,1.29797 -0.8247287,2.01713 l -1.6588041,0.003 v 2.22174 l 1.6724648,-0.006 c 0.073327,0.35077 0.1797598,0.70243 0.3242851,1.04472 0.1452428,0.34448 0.3214064,0.6644 0.5227339,0.96066 l -1.1993431,1.19723 1.5840256,1.56011 1.1964668,-1.19348 c 0.6140517,0.40346 1.3028827,0.68232 2.0233517,0.82331 l 7.19e-4,1.69892 h 2.226848 z m 0.221462,-3.9957 c -1.788948,0.7502 -3.8576,-0.0928 -4.6097055,-1.87438 -0.7521065,-1.78321 0.090598,-3.84627 1.8802645,-4.59604 1.78823,-0.74936 3.856881,0.0929 4.608987,1.87437 0.752106,1.78165 -0.0906,3.84612 -1.879546,4.59605 z'
          },
          TASK_TYPE_SERVICE_FILL: {
            d: 'm {mx},{my} c -1.788948,0.7502 -3.8576,-0.0928 -4.6097055,-1.87438 -0.7521065,-1.78321 0.090598,-3.84627 1.8802645,-4.59604 1.78823,-0.74936 3.856881,0.0929 4.608987,1.87437 0.752106,1.78165 -0.0906,3.84612 -1.879546,4.59605 z'
          },
          TASK_TYPE_BUSINESS_RULE_HEADER: {
            d: 'm {mx},{my} 0,4 20,0 0,-4 z'
          },
          TASK_TYPE_BUSINESS_RULE_MAIN: {
            d: 'm {mx},{my} 0,12 20,0 0,-12 zm 0,8 l 20,0 m -13,-4 l 0,8'
          },
          MESSAGE_FLOW_MARKER: {
            d: 'm {mx},{my} m -10.5 ,-7 l 0,14 l 21,0 l 0,-14 z l 10.5,6 l 10.5,-6'
          }
        },
        this.getRawPath = function (e) {
          return this.pathMap[e].d
        }
        ,
        this.getScaledPath = function (e, t) {
          let n; let r; const o = this.pathMap[e]
          t.abspos
            ? (n = t.abspos.x,
              r = t.abspos.y)
            : (n = t.containerWidth * t.position.mx,
              r = t.containerHeight * t.position.my)
          let i; let a; const s = {}
          if (t.position) {
            for (var c = t.containerHeight / o.height * t.yScaleFactor, l = t.containerWidth / o.width * t.xScaleFactor, p = 0; p < o.heightElements.length; p++) { s['y' + p] = o.heightElements[p] * c }
            for (let u = 0; u < o.widthElements.length; u++) { s['x' + u] = o.widthElements[u] * l }
          }
          return i = o.d,
          a = {
            mx: n,
            my: r,
            e: s
          },
          String(i).replace(Na, function (e, t) {
            return (function (e, t, n) {
              let r = n
              return t.replace(Ma, function (e, t, n, o, i) {
                t = t || o,
                r && (t in r && (r = r[t]),
                typeof r === 'function' && i && (r = r()))
              }
              ),
              r = (r == null || r == n ? e : r) + ''
            }(e, t, a))
          }
          )
        }
      }
      ]
    }
    const La = {
      translate: ['value', function (e, t) {
        return t = t || {},
        e.replace(/{([^}]+)}/g, function (e, n) {
          return t[n] || '{' + n + '}'
        }
        )
      }
      ]
    }
    function za (e, t, n) {
      return le({
        id: e.id,
        type: e.$type,
        businessObject: e,
        di: t
      }, n)
    }
    function Fa (e, t, n) {
      const r = e.waypoint
      return !r || r.length < 2
        ? [_r(t), _r(n)]
        : r.map(function (e) {
          return {
            x: e.x,
            y: e.y
          }
        }
        )
    }
    function $a (e, t, n, r) {
      return new Error(e('element {element} referenced by {referenced}#{property} not yet drawn', {
        element: Si(n),
        referenced: Si(t),
        property: r
      }))
    }
    function Ha (e, t, n, r, o, i) {
      this._eventBus = e,
      this._canvas = t,
      this._elementFactory = n,
      this._elementRegistry = r,
      this._translate = o,
      this._textRenderer = i
    }
    Ha.$inject = ['eventBus', 'canvas', 'elementFactory', 'elementRegistry', 'translate', 'textRenderer'],
    Ha.prototype.add = function (e, t, n) {
      let r; let o; let i; const a = this._translate
      if (Pi(t, 'bpmndi:BPMNPlane')) {
        const s = Pi(e, 'bpmn:SubProcess')
          ? {
              id: e.id + '_plane'
            }
          : {}
        r = this._elementFactory.createRoot(za(e, t, s)),
        this._canvas.addRootElement(r)
      } else if (Pi(t, 'bpmndi:BPMNShape')) {
        const c = !Zi(e, t)
        const l = (function (e) {
          return Pi(e, 'bpmn:Group')
        }(e))
        o = n && (n.hidden || n.collapsed)
        const p = t.bounds
        r = this._elementFactory.createShape(za(e, t, {
          collapsed: c,
          hidden: o,
          x: Math.round(p.x),
          y: Math.round(p.y),
          width: Math.round(p.width),
          height: Math.round(p.height),
          isFrame: l
        })),
        Pi(e, 'bpmn:BoundaryEvent') && this._attachBoundary(e, r),
        Pi(e, 'bpmn:Lane') && (i = 0),
        Pi(e, 'bpmn:DataStoreReference') && ((function (e, t) {
          const n = t.x
          const r = t.y
          return n >= e.x && n <= e.x + e.width && r >= e.y && r <= e.y + e.height
        }(n, _r(p))) || (n = this._canvas.findRoot(n))),
        this._canvas.addShape(r, n, i)
      } else {
        if (!Pi(t, 'bpmndi:BPMNEdge')) {
          throw new Error(a('unknown di {di} for element {semantic}', {
            di: Si(t),
            semantic: Si(e)
          }))
        }
        const u = this._getSource(e)
        const d = this._getTarget(e)
        o = n && (n.hidden || n.collapsed),
        r = this._elementFactory.createConnection(za(e, t, {
          hidden: o,
          source: u,
          target: d,
          waypoints: Fa(t, u, d)
        })),
        Pi(e, 'bpmn:DataAssociation') && (n = this._canvas.findRoot(n)),
        this._canvas.addConnection(r, n, i)
      }
      return ia(e) && la(r) && this.addLabel(e, t, r),
      this._eventBus.fire('bpmnElement.added', {
        element: r
      }),
      r
    }
    ,
    Ha.prototype._attachBoundary = function (e, t) {
      const n = this._translate
      const r = e.attachedToRef
      if (!r) {
        throw new Error(n('missing {semantic}#attachedToRef', {
          semantic: Si(e)
        }))
      }
      const o = this._elementRegistry.get(r.id)
      let i = o && o.attachers
      if (!o) { throw $a(n, e, r, 'attachedToRef') }
      t.host = o,
      i || (o.attachers = i = []),
      i.indexOf(t) === -1 && i.push(t)
    }
    ,
    Ha.prototype.addLabel = function (e, t, n) {
      let r, o, i
      return r = (function (e, t) {
        let n; let r; let o; const i = e.label
        return i && i.bounds
          ? (o = i.bounds,
            r = {
              width: Math.max(ra.width, o.width),
              height: o.height
            },
            n = {
              x: o.x + o.width / 2,
              y: o.y + o.height / 2
            })
          : (n = sa(t),
            r = ra),
        le({
          x: n.x - r.width / 2,
          y: n.y - r.height / 2
        }, r)
      }(t, n)),
      (o = la(n)) && (r = this._textRenderer.getExternalLabelBounds(r, o)),
      i = this._elementFactory.createLabel(za(e, t, {
        id: e.id + '_label',
        labelTarget: n,
        type: 'label',
        hidden: n.hidden || !la(n),
        x: Math.round(r.x),
        y: Math.round(r.y),
        width: Math.round(r.width),
        height: Math.round(r.height)
      })),
      this._canvas.addShape(i, n.parent)
    }
    ,
    Ha.prototype._getConnectedElement = function (e, t) {
      let n; let r; const o = e.$type; const i = this._translate
      if (r = e[t + 'Ref'],
      t === 'source' && o === 'bpmn:DataInputAssociation' && (r = r && r[0]),
      (t === 'source' && o === 'bpmn:DataOutputAssociation' || t === 'target' && o === 'bpmn:DataInputAssociation') && (r = e.$parent),
      n = r && this._getElement(r)) { return n }
      throw r
        ? $a(i, e, r, t + 'Ref')
        : new Error(i('{semantic}#{side} Ref not specified', {
          semantic: Si(e),
          side: t
        }))
    }
    ,
    Ha.prototype._getSource = function (e) {
      return this._getConnectedElement(e, 'source')
    }
    ,
    Ha.prototype._getTarget = function (e) {
      return this._getConnectedElement(e, 'target')
    }
    ,
    Ha.prototype._getElement = function (e) {
      return this._elementRegistry.get(e.id)
    }

    const qa = {
      __depends__: [Ia, {
        __depends__: [La],
        bpmnImporter: ['type', Ha]
      }]
    }
    function Wa (e) {
      e && typeof e.stopPropagation === 'function' && e.stopPropagation()
    }
    function Ga (e) {
      return e.originalEvent || e.srcEvent
    }
    function Ua (e) {
      Wa(e),
      Wa(Ga(e))
    }
    function Va (e) {
      return e.pointers && e.pointers.length && (e = e.pointers[0]),
      e.touches && e.touches.length && (e = e.touches[0]),
      e
        ? {
            x: e.clientX,
            y: e.clientY
          }
        : null
    }
    function Qa () {
      return /mac/i.test(navigator.platform)
    }
    function Ya (e, t) {
      return (Ga(e) || e).button === t
    }
    function Ka (e) {
      return Ya(e, 0)
    }
    function Ja (e) {
      const t = Ga(e) || e
      return !!Ka(e) && (Qa() ? t.metaKey : t.ctrlKey)
    }
    function Xa (e) {
      const t = Ga(e) || e
      return Ka(e) && t.shiftKey
    }
    function Za (e) {
      return !0
    }
    function es (e) {
      return Ka(e) || (function (e) {
        return Ya(e, 1)
      }(e))
    }
    function ts (e, t, n) {
      const r = this
      function o (n, r, o) {
        let i, a;
        (function (e, t) {
          return !(c[e] || Ka)(t)
        }
        )(n, r) || (o
          ? a = t.getGraphics(o)
          : (i = r.delegateTarget || r.target) && (a = i,
            o = t.get(a)),
        a && o && !1 === e.fire(n, {
          element: o,
          gfx: a,
          originalEvent: r
        }) && (r.stopPropagation(),
        r.preventDefault()))
      }
      const i = {}
      function a (e) {
        return i[e]
      }
      const s = {
        click: 'element.click',
        contextmenu: 'element.contextmenu',
        dblclick: 'element.dblclick',
        mousedown: 'element.mousedown',
        mousemove: 'element.mousemove',
        mouseover: 'element.hover',
        mouseout: 'element.out',
        mouseup: 'element.mouseup'
      }
      var c = {
        'element.contextmenu': Za,
        'element.mousedown': es,
        'element.mouseup': es,
        'element.click': es,
        'element.dblclick': es
      }
      function l (e, t, n, r) {
        const a = i[n] = function (e) {
          o(n, e)
        }

        r && (c[n] = r),
        a.$delegate = yn(e, 'svg, .djs-element', t, a)
      }
      function p (e, t, n) {
        const r = a(n)
        r && bn(e, t, r.$delegate)
      }
      e.on('canvas.destroy', function (e) {
        let t
        t = e.svg,
        G(s, function (e, n) {
          p(t, n, e)
        }
        )
      }
      ),
      e.on('canvas.init', function (e) {
        let t
        t = e.svg,
        G(s, function (e, n) {
          l(t, n, e)
        }
        )
      }
      ),
      e.on(['shape.added', 'connection.added'], function (t) {
        const n = t.element
        const r = t.gfx
        e.fire('interactionEvents.createHit', {
          element: n,
          gfx: r
        })
      }
      ),
      e.on(['shape.changed', 'connection.changed'], 500, function (t) {
        const n = t.element
        const r = t.gfx
        e.fire('interactionEvents.updateHit', {
          element: n,
          gfx: r
        })
      }
      ),
      e.on('interactionEvents.createHit', 500, function (e) {
        const t = e.element
        const n = e.gfx
        r.createDefaultHit(t, n)
      }
      ),
      e.on('interactionEvents.updateHit', function (e) {
        const t = e.element
        const n = e.gfx
        r.updateDefaultHit(t, n)
      }
      )
      const u = h('djs-hit djs-hit-stroke')
      const d = h('djs-hit djs-hit-click-stroke')
      const f = {
        all: h('djs-hit djs-hit-all'),
        'click-stroke': d,
        stroke: u,
        'no-move': h('djs-hit djs-hit-no-move')
      }
      function h (e, t) {
        return t = le({
          stroke: 'white',
          strokeWidth: 15
        }, t || {}),
        n.cls(e, ['no-fill', 'no-border'], t)
      }
      function m (e, t) {
        const n = f[t]
        if (!n) { throw new Error('invalid hit type <' + t + '>') }
        return We(e, n),
        e
      }
      function v (e, t) {
        Fe(e, t)
      }
      this.removeHits = function (e) {
        G(_n('.djs-hit', e), Qe)
      }
      ,
      this.createDefaultHit = function (e, t) {
        let n; const r = e.waypoints; const o = e.isFrame
        return r
          ? this.createWaypointsHit(t, r)
          : (n = o ? 'stroke' : 'all',
            this.createBoxHit(t, n, {
              width: e.width,
              height: e.height
            }))
      }
      ,
      this.createWaypointsHit = function (e, t) {
        const n = Tt(t)
        return m(n, 'stroke'),
        v(e, n),
        n
      }
      ,
      this.createBoxHit = function (e, t, n) {
        n = le({
          x: 0,
          y: 0
        }, n)
        const r = et('rect')
        return m(r, t),
        We(r, n),
        v(e, r),
        r
      }
      ,
      this.updateDefaultHit = function (e, t) {
        const n = wn('.djs-hit', t)
        if (n) {
          return e.waypoints
            ? Rt(n, e.waypoints)
            : We(n, {
              width: e.width,
              height: e.height
            }),
          n
        }
      }
      ,
      this.fire = o,
      this.triggerMouseEvent = function (e, t, n) {
        const r = s[e]
        if (!r) { throw new Error('unmapped DOM event name <' + e + '>') }
        return o(r, t, n)
      }
      ,
      this.mouseHandler = a,
      this.registerEvent = l,
      this.unregisterEvent = p
    }
    ts.$inject = ['eventBus', 'elementRegistry', 'styles']
    const ns = {
      __init__: ['interactionEvents'],
      interactionEvents: ['type', ts]
    }
    function rs (e, t) {
      this._eventBus = e,
      this.offset = 5
      const n = t.cls('djs-outline', ['no-fill'])
      const r = this
      function o (e) {
        const t = et('rect')
        return We(t, le({
          x: 0,
          y: 0,
          rx: 4,
          width: 100,
          height: 100
        }, n)),
        t
      }
      e.on(['shape.added', 'shape.changed'], 500, function (e) {
        const t = e.element
        const n = e.gfx
        let i = wn('.djs-outline', n)
        i || Fe(n, i = r.getOutline(t) || o()),
        r.updateShapeOutline(i, t)
      }
      ),
      e.on(['connection.added', 'connection.changed'], function (e) {
        const t = e.element
        const n = e.gfx
        let i = wn('.djs-outline', n)
        i || Fe(n, i = o()),
        r.updateConnectionOutline(i, t)
      }
      )
    }
    rs.prototype.updateShapeOutline = function (e, t) {
      let n = !1
      const r = this._getProviders()
      r.length && G(r, function (r) {
        n = n || r.updateOutline(t, e)
      }
      ),
      n || We(e, {
        x: -this.offset,
        y: -this.offset,
        width: t.width + 2 * this.offset,
        height: t.height + 2 * this.offset
      })
    }
    ,
    rs.prototype.updateConnectionOutline = function (e, t) {
      const n = Ft(t)
      We(e, {
        x: n.x - this.offset,
        y: n.y - this.offset,
        width: n.width + 2 * this.offset,
        height: n.height + 2 * this.offset
      })
    }
    ,
    rs.prototype.registerProvider = function (e, t) {
      t || (t = e,
      e = 1e3),
      this._eventBus.on('outline.getProviders', e, function (e) {
        e.providers.push(t)
      }
      )
    }
    ,
    rs.prototype._getProviders = function () {
      const e = this._eventBus.createEvent({
        type: 'outline.getProviders',
        providers: []
      })
      return this._eventBus.fire(e),
      e.providers
    }
    ,
    rs.prototype.getOutline = function (e) {
      let t
      return G(this._getProviders(), function (n) {
        z(n.getOutline) && (t = t || n.getOutline(e))
      }
      ),
      t
    }
    ,
    rs.$inject = ['eventBus', 'styles', 'elementRegistry']
    const os = {
      __init__: ['outline'],
      outline: ['type', rs]
    }
    function is (e, t) {
      this._eventBus = e,
      this._canvas = t,
      this._selectedElements = []
      const n = this
      e.on(['shape.remove', 'connection.remove'], function (e) {
        const t = e.element
        n.deselect(t)
      }
      ),
      e.on(['diagram.clear', 'root.set'], function (e) {
        n.select(null)
      }
      )
    }
    is.$inject = ['eventBus', 'canvas'],
    is.prototype.deselect = function (e) {
      const t = this._selectedElements
      const n = t.indexOf(e)
      if (n !== -1) {
        const r = t.slice()
        t.splice(n, 1),
        this._eventBus.fire('selection.changed', {
          oldSelection: r,
          newSelection: t
        })
      }
    }
    ,
    is.prototype.get = function () {
      return this._selectedElements
    }
    ,
    is.prototype.isSelected = function (e) {
      return this._selectedElements.indexOf(e) !== -1
    }
    ,
    is.prototype.select = function (e, t) {
      let n = this._selectedElements
      const r = n.slice()
      M(e) || (e = e ? [e] : [])
      const o = this._canvas
      const i = o.getRootElement()
      e = e.filter(function (e) {
        const t = o.findRoot(e)
        return i === t
      }
      ),
      t
        ? G(e, function (e) {
          n.indexOf(e) === -1 && n.push(e)
        }
        )
        : this._selectedElements = n = e.slice(),
      this._eventBus.fire('selection.changed', {
        oldSelection: r,
        newSelection: n
      })
    }

    const as = 'hover'
    const ss = 'selected'
    function cs (e, t, n) {
      this._canvas = e
      const r = this
      function o (t, n) {
        e.addMarker(t, n)
      }
      function i (t, n) {
        e.removeMarker(t, n)
      }
      this._multiSelectionBox = null,
      t.on('element.hover', function (e) {
        o(e.element, as)
      }
      ),
      t.on('element.out', function (e) {
        i(e.element, as)
      }
      ),
      t.on('selection.changed', function (e) {
        const t = e.oldSelection
        const n = e.newSelection
        G(t, function (e) {
          n.indexOf(e) === -1 && (function (e) {
            i(e, ss)
          }(e))
        }
        ),
        G(n, function (e) {
          t.indexOf(e) === -1 && (function (e) {
            o(e, ss)
          }(e))
        }
        ),
        r._updateSelectionOutline(n)
      }
      ),
      t.on('element.changed', function (e) {
        n.isSelected(e.element) && r._updateSelectionOutline(n.get())
      }
      )
    }
    function ls (e, t, n, r) {
      e.on('create.end', 500, function (e) {
        const n = e.context
        const r = n.canExecute
        const o = n.elements
        const i = (n.hints || {}).autoSelect
        if (r) {
          if (!1 === i) { return }
          M(i) ? t.select(i) : t.select(o.filter(ps))
        }
      }
      ),
      e.on('connect.end', 500, function (e) {
        const n = e.context.connection
        n && t.select(n)
      }
      ),
      e.on('shape.move.end', 500, function (e) {
        const n = e.previousSelection || []
        const o = r.get(e.context.shape.id)
        H(n, function (e) {
          return o.id === e.id
        }
        ) || t.select(o)
      }
      ),
      e.on('element.click', function (e) {
        if (Ka(e)) {
          let r = e.element
          r === n.getRootElement() && (r = null)
          const o = t.isSelected(r)
          const i = t.get().length > 1
          const a = Xa(e)
          if (o && i) { return a ? t.deselect(r) : t.select(r) }
          o ? t.deselect(r) : t.select(r, a)
        }
      }
      )
    }
    function ps (e) {
      return !e.hidden
    }
    cs.$inject = ['canvas', 'eventBus', 'selection'],
    cs.prototype._updateSelectionOutline = function (e) {
      const t = this._canvas.getLayer('selectionOutline')
      Ye(t)
      const n = e.length > 1
      if (Ue(this._canvas.getContainer())[n ? 'add' : 'remove']('djs-multi-select'),
      n) {
        const r = (function (e) {
          return {
            x: e.x - 6,
            y: e.y - 6,
            width: e.width + 12,
            height: e.height + 12
          }
        }(Ft(e)))
        const o = et('rect')
        We(o, le({
          rx: 3
        }, r)),
        Ue(o).add('djs-selection-outline'),
        Fe(t, o)
      }
    }
    ,
    ls.$inject = ['eventBus', 'selection', 'canvas', 'elementRegistry']
    const us = {
      __init__: ['selectionVisuals', 'selectionBehavior'],
      __depends__: [ns, os],
      selection: ['type', is],
      selectionVisuals: ['type', cs],
      selectionBehavior: ['type', ls]
    }
    function ds (e) {
      this._counter = 0,
      this._prefix = (e ? e + '-' : '') + Math.floor(1e9 * Math.random()) + '-'
    }
    ds.prototype.next = function () {
      return this._prefix + ++this._counter
    }

    const fs = new ds('ov')
    function hs (e, t, n, r) {
      let o, i
      this._eventBus = t,
      this._canvas = n,
      this._elementRegistry = r,
      this._ids = fs,
      this._overlayDefaults = le({
        show: null,
        scale: !0
      }, e && e.defaults),
      this._overlays = {},
      this._overlayContainers = [],
      this._overlayRoot = (o = n.getContainer(),
      Zt(i = xn('<div class="djs-overlay-container" />'), {
        position: 'absolute',
        width: 0,
        height: 0
      }),
      o.insertBefore(i, o.firstChild),
      i),
      this._init()
    }
    function ms (e, t, n) {
      Zt(e, {
        left: t + 'px',
        top: n + 'px'
      })
    }
    function vs (e, t) {
      e.style.display = !1 === t ? 'none' : ''
    }
    function gs (e, t) {
      e.style['transform-origin'] = 'top left',
      ['', '-ms-', '-webkit-'].forEach(function (n) {
        e.style[n + 'transform'] = t
      }
      )
    }
    hs.$inject = ['config.overlays', 'eventBus', 'canvas', 'elementRegistry'],
    hs.prototype.get = function (e) {
      if (F(e) && (e = {
        id: e
      }),
      F(e.element) && (e.element = this._elementRegistry.get(e.element)),
      e.element) {
        const t = this._getOverlayContainer(e.element, !0)
        return t
          ? e.type
            ? W(t.overlays, ne({
              type: e.type
            }))
            : t.overlays.slice()
          : []
      }
      return e.type
        ? W(this._overlays, ne({
          type: e.type
        }))
        : e.id ? this._overlays[e.id] : null
    }
    ,
    hs.prototype.add = function (e, t, n) {
      if (I(t) && (n = t,
      t = null),
      e.id || (e = this._elementRegistry.get(e)),
      !n.position) { throw new Error('must specifiy overlay position') }
      if (!n.html) { throw new Error('must specifiy overlay html') }
      if (!e) { throw new Error('invalid element specified') }
      const r = this._ids.next()
      return n = le({}, this._overlayDefaults, n, {
        id: r,
        type: t,
        element: e,
        html: n.html
      }),
      this._addOverlay(n),
      r
    }
    ,
    hs.prototype.remove = function (e) {
      let t = this.get(e) || []
      M(t) || (t = [t])
      const n = this
      G(t, function (e) {
        const t = n._getOverlayContainer(e.element, !0)
        if (e && (Cn(e.html),
        Cn(e.htmlContainer),
        delete e.htmlContainer,
        delete e.element,
        delete n._overlays[e.id]),
        t) {
          const r = t.overlays.indexOf(e)
          r !== -1 && t.overlays.splice(r, 1)
        }
      }
      )
    }
    ,
    hs.prototype.isShown = function () {
      return this._overlayRoot.style.display !== 'none'
    }
    ,
    hs.prototype.show = function () {
      vs(this._overlayRoot)
    }
    ,
    hs.prototype.hide = function () {
      vs(this._overlayRoot, !1)
    }
    ,
    hs.prototype.clear = function () {
      this._overlays = {},
      this._overlayContainers = [],
      on(this._overlayRoot)
    }
    ,
    hs.prototype._updateOverlayContainer = function (e) {
      const t = e.element
      const n = e.html
      let r = t.x
      let o = t.y
      if (t.waypoints) {
        const i = Ft(t)
        r = i.x,
        o = i.y
      }
      ms(n, r, o),
      en(e.html, 'data-container-id', t.id)
    }
    ,
    hs.prototype._updateOverlay = function (e) {
      let t; let n; const r = e.position; const o = e.htmlContainer; const i = e.element; let a = r.left; let s = r.top
      void 0 !== r.right && (t = i.waypoints ? Ft(i).width : i.width,
      a = -1 * r.right + t),
      void 0 !== r.bottom && (n = i.waypoints ? Ft(i).height : i.height,
      s = -1 * r.bottom + n),
      ms(o, a || 0, s || 0),
      this._updateOverlayVisibilty(e, this._canvas.viewbox())
    }
    ,
    hs.prototype._createOverlayContainer = function (e) {
      const t = xn('<div class="djs-overlays" />')
      Zt(t, {
        position: 'absolute'
      }),
      this._overlayRoot.appendChild(t)
      const n = {
        html: t,
        element: e,
        overlays: []
      }
      return this._updateOverlayContainer(n),
      this._overlayContainers.push(n),
      n
    }
    ,
    hs.prototype._updateRoot = function (e) {
      const t = e.scale || 1
      const n = 'matrix(' + [t, 0, 0, t, -1 * e.x * t, -1 * e.y * t].join(',') + ')'
      gs(this._overlayRoot, n)
    }
    ,
    hs.prototype._getOverlayContainer = function (e, t) {
      const n = H(this._overlayContainers, function (t) {
        return t.element === e
      }
      )
      return n || t ? n : this._createOverlayContainer(e)
    }
    ,
    hs.prototype._addOverlay = function (e) {
      let t; let n; const r = e.id; const o = e.element; let i = e.html
      i.get && i.constructor.prototype.jquery && (i = i.get(0)),
      F(i) && (i = xn(i)),
      n = this._getOverlayContainer(o),
      Zt(t = xn('<div class="djs-overlay" data-overlay-id="' + r + '">'), {
        position: 'absolute'
      }),
      t.appendChild(i),
      e.type && nn(t).add('djs-overlay-' + e.type),
      vs(t, this._canvas.findRoot(o) === this._canvas.getRootElement()),
      e.htmlContainer = t,
      n.overlays.push(e),
      n.html.appendChild(t),
      this._overlays[r] = e,
      this._updateOverlay(e),
      this._updateOverlayVisibilty(e, this._canvas.viewbox())
    }
    ,
    hs.prototype._updateOverlayVisibilty = function (e, t) {
      const n = e.show
      const r = this._canvas.findRoot(e.element)
      const o = n && n.minZoom
      const i = n && n.maxZoom
      const a = e.htmlContainer
      let s = !0;
      (r !== this._canvas.getRootElement() || n && (R(o) && o > t.scale || R(i) && i < t.scale)) && (s = !1),
      vs(a, s),
      this._updateOverlayScale(e, t)
    }
    ,
    hs.prototype._updateOverlayScale = function (e, t) {
      let n; let r; let o; const i = e.scale; const a = e.htmlContainer; let s = ''
      !0 !== i && (!1 === i
        ? (n = 1,
          r = 1)
        : (n = i.min,
          r = i.max),
      R(n) && t.scale < n && (o = (1 / t.scale || 1) * n),
      R(r) && t.scale > r && (o = (1 / t.scale || 1) * r)),
      R(o) && (s = 'scale(' + o + ',' + o + ')'),
      gs(a, s)
    }
    ,
    hs.prototype._updateOverlaysVisibilty = function (e) {
      const t = this
      G(this._overlays, function (n) {
        t._updateOverlayVisibilty(n, e)
      }
      )
    }
    ,
    hs.prototype._init = function () {
      const e = this._eventBus
      const t = this
      e.on('canvas.viewbox.changing', function (e) {
        t.hide()
      }
      ),
      e.on('canvas.viewbox.changed', function (e) {
        let n
        n = e.viewbox,
        t._updateRoot(n),
        t._updateOverlaysVisibilty(n),
        t.show()
      }
      ),
      e.on(['shape.remove', 'connection.remove'], function (e) {
        const n = e.element
        G(t.get({
          element: n
        }), function (e) {
          t.remove(e.id)
        }
        )
        const r = t._getOverlayContainer(n)
        if (r) {
          Cn(r.html)
          const o = t._overlayContainers.indexOf(r)
          o !== -1 && t._overlayContainers.splice(o, 1)
        }
      }
      ),
      e.on('element.changed', 500, function (e) {
        const n = e.element
        const r = t._getOverlayContainer(n, !0)
        r && (G(r.overlays, function (e) {
          t._updateOverlay(e)
        }
        ),
        t._updateOverlayContainer(r))
      }
      ),
      e.on('element.marker.update', function (e) {
        const n = t._getOverlayContainer(e.element, !0)
        n && nn(n.html)[e.add ? 'add' : 'remove'](e.marker)
      }
      ),
      e.on('root.set', function () {
        t._updateOverlaysVisibilty(t._canvas.viewbox())
      }
      ),
      e.on('diagram.clear', this.clear, this)
    }

    const ys = {
      __init__: ['overlays'],
      overlays: ['type', hs]
    }
    function bs (e, t, n, r) {
      e.on('element.changed', function (r) {
        const o = r.element;
        (o.parent || o === t.getRootElement()) && (r.gfx = n.getGraphics(o)),
        r.gfx && e.fire($t(o) + '.changed', r)
      }
      ),
      e.on('elements.changed', function (t) {
        const n = t.elements
        n.forEach(function (t) {
          e.fire('element.changed', {
            element: t
          })
        }
        ),
        r.updateContainments(n)
      }
      ),
      e.on('shape.changed', function (e) {
        r.update('shape', e.element, e.gfx)
      }
      ),
      e.on('connection.changed', function (e) {
        r.update('connection', e.element, e.gfx)
      }
      )
    }
    bs.$inject = ['eventBus', 'canvas', 'elementRegistry', 'graphicsFactory']
    const As = {
      __init__: ['changeSupport'],
      changeSupport: ['type', bs]
    }
    function Es (e) {
      this._eventBus = e
    }
    function xs (e) {
      return function (t, n, r, o, i) {
        (z(t) || L(t)) && (i = o,
        o = r,
        r = n,
        n = t,
        t = null),
        this.on(t, e, n, r, o, i)
      }
    }
    function ws (e, t) {
      t.invoke(Es, this),
      this.executed(function (t) {
        const n = t.context
        n.rootElement ? e.setRootElement(n.rootElement) : n.rootElement = e.getRootElement()
      }
      ),
      this.revert(function (t) {
        const n = t.context
        n.rootElement && e.setRootElement(n.rootElement)
      }
      )
    }
    Es.$inject = ['eventBus'],
    Es.prototype.on = function (e, t, n, r, o, i) {
      if ((z(t) || L(t)) && (i = o,
      o = r,
      r = n,
      n = t,
      t = null),
      z(n) && (i = o,
      o = r,
      r = n,
      n = 1e3),
      I(o) && (i = o,
      o = !1),
      !z(r)) { throw new Error('handlerFn must be a function') }
      M(e) || (e = [e])
      const a = this._eventBus
      G(e, function (e) {
        const s = ['commandStack', e, t].filter(function (e) {
          return e
        }
        ).join('.')
        a.on(s, n, o
          ? (function (e, t) {
              return function (n) {
                return e.call(t || null, n.context, n.command, n)
              }
            }(r, i))
          : r, i)
      }
      )
    }
    ,
    Es.prototype.canExecute = xs('canExecute'),
    Es.prototype.preExecute = xs('preExecute'),
    Es.prototype.preExecuted = xs('preExecuted'),
    Es.prototype.execute = xs('execute'),
    Es.prototype.executed = xs('executed'),
    Es.prototype.postExecute = xs('postExecute'),
    Es.prototype.postExecuted = xs('postExecuted'),
    Es.prototype.revert = xs('revert'),
    Es.prototype.reverted = xs('reverted'),
    w(ws, Es),
    ws.$inject = ['canvas', 'injector']
    const _s = {
      __init__: ['rootElementsBehavior'],
      rootElementsBehavior: ['type', ws]
    }
    function Cs (e) {
      return CSS.escape(e)
    }
    const Ss = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    }
    function ks (e) {
      return (e = '' + e) && e.replace(/[&<>"']/g, function (e) {
        return Ss[e]
      }
      )
    }
    const js = '_plane'
    function Bs (e) {
      return e.id.replace(new RegExp(js + '$'), '')
    }
    function Ds (e) {
      const t = e.id
      return Pi(e, 'bpmn:SubProcess') ? Ts(t) : t
    }
    function Ps (e) {
      return Ts(e)
    }
    function Os (e) {
      return Pi(Ri(e), 'bpmndi:BPMNPlane')
    }
    function Ts (e) {
      return e + js
    }
    function Rs (e, t, n) {
      const r = Ie('<ul class="bjs-breadcrumbs"></ul>')
      const o = n.getContainer()
      const i = Ee(o)
      o.appendChild(r)
      let a = []
      function s (e) {
        e && (a = (function (e) {
          for (var t = [], n = Ti(e); n; n = n.$parent) { (Pi(n, 'bpmn:SubProcess') || Pi(n, 'bpmn:Process')) && t.push(n) }
          return t.reverse()
        }(e)))
        const o = a.map(function (e) {
          const r = ks(e.name || e.id)
          const o = Ie('<li><span class="bjs-crumb"><a title="' + r + '">' + r + '</a></span></li>')
          let i = n.findRoot(Ds(e)) || n.findRoot(e.id)
          if (!i && Pi(e, 'bpmn:Process')) {
            const a = t.find(function (t) {
              const n = Ti(t)
              return n && n.get('processRef') && n.get('processRef') === e
            }
            )
            i = n.findRoot(a.id)
          }
          return o.addEventListener('click', function () {
            n.setRootElement(i)
          }
          ),
          o
        }
        )
        r.innerHTML = ''
        const s = o.length > 1
        i.toggle('bjs-breadcrumbs-shown', s),
        o.forEach(function (e) {
          r.appendChild(e)
        }
        )
      }
      e.on('element.changed', function (e) {
        const t = Ti(e.element)
        H(a, function (e) {
          return e === t
        }
        ) && s()
      }
      ),
      e.on('root.set', function (e) {
        s(e.element)
      }
      )
    }
    function Ns (e, t) {
      let n = null
      const r = new Ms()
      e.on('root.set', function (e) {
        const o = e.element
        const i = t.viewbox()
        let a = r.get(o)
        if (r.set(n, {
          x: i.x,
          y: i.y,
          zoom: i.scale
        }),
        n = o,
        !Pi(o, 'bpmn:Collaboration') || a) {
          a = a || {
            x: 0,
            y: 0,
            zoom: 1
          }
          const s = (i.x - a.x) * i.scale
          const c = (i.y - a.y) * i.scale
          s === 0 && c === 0 || t.scroll({
            dx: s,
            dy: c
          }),
          a.zoom !== i.scale && t.zoom(a.zoom, {
            x: 0,
            y: 0
          })
        }
      }
      ),
      e.on('diagram.clear', function () {
        r.clear(),
        n = null
      }
      )
    }
    function Ms () {
      this._entries = [],
      this.set = function (e, t) {
        let n = !1
        for (const r in this._entries) {
          if (this._entries[r][0] === e) {
            this._entries[r][1] = t,
            n = !0
            break
          }
        }
        n || this._entries.push([e, t])
      }
      ,
      this.get = function (e) {
        for (const t in this._entries) {
          if (this._entries[t][0] === e) { return this._entries[t][1] }
        }
        return null
      }
      ,
      this.clear = function () {
        this._entries.length = 0
      }
      ,
      this.remove = function (e) {
        let t = -1
        for (const n in this._entries) {
          if (this._entries[n][0] === e) {
            t = n
            break
          }
        }
        t !== -1 && this._entries.splice(t, 1)
      }
    }
    Rs.$inject = ['eventBus', 'elementRegistry', 'canvas'],
    Ns.$inject = ['eventBus', 'canvas']
    function Is (e, t) {
      this._eventBus = e,
      this._moddle = t
      const n = this
      e.on('import.render.start', 1500, function (e, t) {
        n._handleImport(t.definitions)
      }
      )
    }
    function Ls (e) {
      return Pi(e, 'bpmndi:BPMNDiagram') ? e : Ls(e.$parent)
    }
    Is.prototype._handleImport = function (e) {
      if (e.diagrams) {
        const t = this
        this._definitions = e,
        this._processToDiagramMap = {},
        e.diagrams.forEach(function (e) {
          e.plane && e.plane.bpmnElement && (t._processToDiagramMap[e.plane.bpmnElement.id] = e)
        }
        )
        const n = []
        e.diagrams.forEach(function (e) {
          const r = t._createNewDiagrams(e.plane)
          Array.prototype.push.apply(n, r)
        }
        ),
        n.forEach(function (e) {
          t._movePlaneElementsToOrigin(e.plane)
        }
        )
      }
    }
    ,
    Is.prototype._createNewDiagrams = function (e) {
      const t = this
      const n = []
      const r = []
      e.get('planeElement').forEach(function (t) {
        const o = t.bpmnElement
        if (o) {
          const i = o.$parent
          Pi(o, 'bpmn:SubProcess') && !t.isExpanded && n.push(o),
          (function (e, t) {
            const n = e.$parent
            return !(!Pi(n, 'bpmn:SubProcess') || n === t.bpmnElement) && !Oi(e, ['bpmn:DataInputAssociation', 'bpmn:DataOutputAssociation'])
          }(o, e)) && r.push({
            diElement: t,
            parent: i
          })
        }
      }
      )
      const o = []
      return n.forEach(function (e) {
        if (!t._processToDiagramMap[e.id]) {
          const n = t._createDiagram(e)
          t._processToDiagramMap[e.id] = n,
          o.push(n)
        }
      }
      ),
      r.forEach(function (e) {
        for (var r = e.diElement, o = e.parent; o && n.indexOf(o) === -1;) { o = o.$parent }
        if (o) {
          const i = t._processToDiagramMap[o.id]
          t._moveToDiPlane(r, i.plane)
        }
      }
      ),
      o
    }
    ,
    Is.prototype._movePlaneElementsToOrigin = function (e) {
      const t = e.get('planeElement')
      const n = (function (e) {
        const t = {
          top: 1 / 0,
          right: -1 / 0,
          bottom: -1 / 0,
          left: 1 / 0
        }
        return e.planeElement.forEach(function (e) {
          if (e.bounds) {
            const n = xr(e.bounds)
            t.top = Math.min(n.top, t.top),
            t.left = Math.min(n.left, t.left)
          }
        }
        ),
        wr(t)
      }(e))
      const r = n.x - 180
      const o = n.y - 160
      t.forEach(function (e) {
        e.waypoint
          ? e.waypoint.forEach(function (e) {
            e.x = e.x - r,
            e.y = e.y - o
          }
          )
          : e.bounds && (e.bounds.x = e.bounds.x - r,
          e.bounds.y = e.bounds.y - o)
      }
      )
    }
    ,
    Is.prototype._moveToDiPlane = function (e, t) {
      const n = Ls(e).plane.get('planeElement')
      n.splice(n.indexOf(e), 1),
      t.get('planeElement').push(e)
    }
    ,
    Is.prototype._createDiagram = function (e) {
      const t = this._moddle.create('bpmndi:BPMNPlane', {
        bpmnElement: e
      })
      const n = this._moddle.create('bpmndi:BPMNDiagram', {
        plane: t
      })
      return t.$parent = n,
      t.bpmnElement = e,
      n.$parent = this._definitions,
      this._definitions.diagrams.push(n),
      n
    }
    ,
    Is.$inject = ['eventBus', 'moddle']
    const zs = 250
    function Fs (e, t, n, r) {
      Es.call(this, t),
      this._canvas = e,
      this._eventBus = t,
      this._elementRegistry = n,
      this._overlays = r
      const o = this
      this.executed('shape.toggleCollapse', zs, function (e) {
        const t = e.shape
        o._canDrillDown(t) ? o._addOverlay(t) : o._removeOverlay(t)
      }
      , !0),
      this.reverted('shape.toggleCollapse', zs, function (e) {
        const t = e.shape
        o._canDrillDown(t) ? o._addOverlay(t) : o._removeOverlay(t)
      }
      , !0),
      this.executed(['shape.create', 'shape.move', 'shape.delete'], zs, function (e) {
        const t = e.oldParent
        const n = e.newParent || e.parent
        const r = e.shape
        o._canDrillDown(r) && o._addOverlay(r),
        o._updateDrilldownOverlay(t),
        o._updateDrilldownOverlay(n),
        o._updateDrilldownOverlay(r)
      }
      , !0),
      this.reverted(['shape.create', 'shape.move', 'shape.delete'], zs, function (e) {
        const t = e.oldParent
        const n = e.newParent || e.parent
        const r = e.shape
        o._canDrillDown(r) && o._addOverlay(r),
        o._updateDrilldownOverlay(t),
        o._updateDrilldownOverlay(n),
        o._updateDrilldownOverlay(r)
      }
      , !0),
      t.on('import.render.complete', function () {
        n.filter(function (e) {
          return o._canDrillDown(e)
        }
        ).map(function (e) {
          o._addOverlay(e)
        }
        )
      }
      )
    }
    w(Fs, Es),
    Fs.prototype._updateDrilldownOverlay = function (e) {
      const t = this._canvas
      if (e) {
        const n = t.findRoot(e)
        n && this._updateOverlayVisibility(n)
      }
    }
    ,
    Fs.prototype._canDrillDown = function (e) {
      const t = this._canvas
      return Pi(e, 'bpmn:SubProcess') && t.findRoot(Ds(e))
    }
    ,
    Fs.prototype._updateOverlayVisibility = function (e) {
      const t = this._overlays
      const n = Ti(e)
      const r = t.get({
        element: n.id,
        type: 'drilldown'
      })[0]
      if (r) {
        const o = n && n.get('flowElements') && n.get('flowElements').length
        Ee(r.html).toggle('bjs-drilldown-empty', !o)
      }
    }
    ,
    Fs.prototype._addOverlay = function (e) {
      const t = this._canvas
      const n = this._overlays
      n.get({
        element: e,
        type: 'drilldown'
      }).length && this._removeOverlay(e)
      const r = Ie('<button class="bjs-drilldown"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4.81801948,3.50735931 L10.4996894,9.1896894 L10.5,4 L12,4 L12,12 L4,12 L4,10.5 L9.6896894,10.4996894 L3.75735931,4.56801948 C3.46446609,4.27512627 3.46446609,3.80025253 3.75735931,3.50735931 C4.05025253,3.21446609 4.52512627,3.21446609 4.81801948,3.50735931 Z"/></svg></button>')
      r.addEventListener('click', function () {
        t.setRootElement(t.findRoot(Ds(e)))
      }
      ),
      n.add(e, 'drilldown', {
        position: {
          bottom: -7,
          right: -8
        },
        html: r
      }),
      this._updateOverlayVisibility(e)
    }
    ,
    Fs.prototype._removeOverlay = function (e) {
      this._overlays.remove({
        element: e,
        type: 'drilldown'
      })
    }
    ,
    Fs.$inject = ['canvas', 'eventBus', 'elementRegistry', 'overlays']
    const $s = {
      __depends__: [ys, As, _s],
      __init__: ['drilldownBreadcrumbs', 'drilldownOverlayBehavior', 'drilldownCentering', 'subprocessCompatibility'],
      drilldownBreadcrumbs: ['type', Rs],
      drilldownCentering: ['type', Ns],
      drilldownOverlayBehavior: ['type', Fs],
      subprocessCompatibility: ['type', Is]
    }
    function Hs (e) {
      Qi.call(this, e)
    }
    w(Hs, Qi),
    Hs.prototype._modules = [qa, La, us, ys, $s],
    Hs.prototype._moddleExtensions = {}
    const qs = ['c', 'C']
    const Ws = ['v', 'V']
    const Gs = ['y', 'Y']
    const Us = ['z', 'Z']
    function Vs (e) {
      return !e.altKey && (e.ctrlKey || e.metaKey)
    }
    function Qs (e, t) {
      return (e = M(e) ? e : [e]).indexOf(t.key) !== -1 || e.indexOf(t.code) !== -1
    }
    function Ys (e) {
      return e.shiftKey
    }
    const Ks = 'keyboard.keydown'
    const Js = 'input-handle-modified-keys'
    function Xs (e, t) {
      const n = this
      this._config = e || {},
      this._eventBus = t,
      this._keydownHandler = this._keydownHandler.bind(this),
      this._keyupHandler = this._keyupHandler.bind(this),
      t.on('diagram.destroy', function () {
        n._fire('destroy'),
        n.unbind()
      }
      ),
      t.on('diagram.init', function () {
        n._fire('init')
      }
      ),
      t.on('attach', function () {
        e && e.bindTo && n.bind(e.bindTo)
      }
      ),
      t.on('detach', function () {
        n.unbind()
      }
      )
    }
    Xs.$inject = ['config.keyboard', 'eventBus'],
    Xs.prototype._keydownHandler = function (e) {
      this._keyHandler(e, Ks)
    }
    ,
    Xs.prototype._keyupHandler = function (e) {
      this._keyHandler(e, 'keyboard.keyup')
    }
    ,
    Xs.prototype._keyHandler = function (e, t) {
      if (!this._isEventIgnored(e)) {
        const n = {
          keyEvent: e
        }
        this._eventBus.fire(t || Ks, n) && e.preventDefault()
      }
    }
    ,
    Xs.prototype._isEventIgnored = function (e) {
      return !!e.defaultPrevented || ((t = e.target) && (an(t, 'input, textarea') || t.contentEditable === 'true') || (function (e) {
        return e && an(e, 'button, input[type=submit], input[type=button], a[href], [aria-role=button]')
      }(e.target)) && Qs([' ', 'Enter'], e)) && this._isModifiedKeyIgnored(e)
      let t
    }
    ,
    Xs.prototype._isModifiedKeyIgnored = function (e) {
      return !Vs(e) || this._getAllowedModifiers(e.target).indexOf(e.key) === -1
    }
    ,
    Xs.prototype._getAllowedModifiers = function (e) {
      const t = sn(e, '[' + Js + ']', !0)
      return !t || this._node && !this._node.contains(t) ? [] : t.getAttribute(Js).split(',')
    }
    ,
    Xs.prototype.bind = function (e) {
      this.unbind(),
      this._node = e,
      vn.bind(e, 'keydown', this._keydownHandler),
      vn.bind(e, 'keyup', this._keyupHandler),
      this._fire('bind')
    }
    ,
    Xs.prototype.getBinding = function () {
      return this._node
    }
    ,
    Xs.prototype.unbind = function () {
      const e = this._node
      e && (this._fire('unbind'),
      vn.unbind(e, 'keydown', this._keydownHandler),
      vn.unbind(e, 'keyup', this._keyupHandler)),
      this._node = null
    }
    ,
    Xs.prototype._fire = function (e) {
      this._eventBus.fire('keyboard.' + e, {
        node: this._node
      })
    }
    ,
    Xs.prototype.addListener = function (e, t, n) {
      z(e) && (n = t,
      t = e,
      e = 1e3),
      this._eventBus.on(n || Ks, e, t)
    }
    ,
    Xs.prototype.removeListener = function (e, t) {
      this._eventBus.off(t || Ks, e)
    }
    ,
    Xs.prototype.hasModifier = function (e) {
      return e.ctrlKey || e.metaKey || e.shiftKey || e.altKey
    }
    ,
    Xs.prototype.isCmd = Vs,
    Xs.prototype.isShift = Ys,
    Xs.prototype.isKey = Qs
    const Zs = 500
    function ec (e, t) {
      const n = this
      e.on('editorActions.init', Zs, function (e) {
        const r = e.editorActions
        n.registerBindings(t, r)
      }
      )
    }
    ec.$inject = ['eventBus', 'keyboard'],
    ec.prototype.registerBindings = function (e, t) {
      function n (n, r) {
        t.isRegistered(n) && e.addListener(r)
      }
      n('undo', function (e) {
        if (Vs(n = e.keyEvent) && !Ys(n) && Qs(Us, n)) {
          return t.trigger('undo'),
          !0
        }
        let n
      }
      ),
      n('redo', function (e) {
        if (Vs(n = e.keyEvent) && (Qs(Gs, n) || Qs(Us, n) && Ys(n))) {
          return t.trigger('redo'),
          !0
        }
        let n
      }
      ),
      n('copy', function (e) {
        if (Vs(n = e.keyEvent) && Qs(qs, n)) {
          return t.trigger('copy'),
          !0
        }
        let n
      }
      ),
      n('paste', function (e) {
        if (Vs(n = e.keyEvent) && Qs(Ws, n)) {
          return t.trigger('paste'),
          !0
        }
        let n
      }
      ),
      n('stepZoom', function (e) {
        const n = e.keyEvent
        if (Qs(['+', 'Add', '='], n) && Vs(n)) {
          return t.trigger('stepZoom', {
            value: 1
          }),
          !0
        }
      }
      ),
      n('stepZoom', function (e) {
        const n = e.keyEvent
        if (Qs(['-', 'Subtract'], n) && Vs(n)) {
          return t.trigger('stepZoom', {
            value: -1
          }),
          !0
        }
      }
      ),
      n('zoom', function (e) {
        const n = e.keyEvent
        if (Qs('0', n) && Vs(n)) {
          return t.trigger('zoom', {
            value: 1
          }),
          !0
        }
      }
      ),
      n('removeSelection', function (e) {
        if (Qs(['Backspace', 'Delete', 'Del'], e.keyEvent)) {
          return t.trigger('removeSelection'),
          !0
        }
      }
      )
    }

    const tc = {
      __init__: ['keyboard', 'keyboardBindings'],
      keyboard: ['type', Xs],
      keyboardBindings: ['type', ec]
    }
    const nc = {
      moveSpeed: 50,
      moveSpeedAccelerated: 200
    }
    function rc (e, t, n) {
      const r = this
      this._config = le({}, nc, e || {}),
      t.addListener(function (e) {
        const n = e.keyEvent
        const o = r._config
        if (t.isCmd(n) && t.isKey(['ArrowLeft', 'Left', 'ArrowUp', 'Up', 'ArrowDown', 'Down', 'ArrowRight', 'Right'], n)) {
          let i; const a = t.isShift(n) ? o.moveSpeedAccelerated : o.moveSpeed
          switch (n.key) {
            case 'ArrowLeft':
            case 'Left':
              i = 'left'
              break
            case 'ArrowUp':
            case 'Up':
              i = 'up'
              break
            case 'ArrowRight':
            case 'Right':
              i = 'right'
              break
            case 'ArrowDown':
            case 'Down':
              i = 'down'
          }
          return r.moveCanvas({
            speed: a,
            direction: i
          }),
          !0
        }
      }
      ),
      this.moveCanvas = function (e) {
        let t = 0
        let r = 0
        const o = e.speed / Math.min(Math.sqrt(n.viewbox().scale), 1)
        switch (e.direction) {
          case 'left':
            t = o
            break
          case 'up':
            r = o
            break
          case 'right':
            t = -o
            break
          case 'down':
            r = -o
        }
        n.scroll({
          dx: t,
          dy: r
        })
      }
    }
    rc.$inject = ['config.keyboardMove', 'keyboard', 'canvas']
    const oc = {
      __depends__: [tc],
      __init__: ['keyboardMove'],
      keyboardMove: ['type', rc]
    }
    const ic = /^djs-cursor-.*$/
    function ac (e) {
      const t = nn(document.body)
      t.removeMatching(ic),
      e && t.add('djs-cursor-' + e)
    }
    function sc () {
      ac(null)
    }
    const cc = 5e3
    function lc (e, t) {
      function n () {
        return !1
      }
      return t = t || 'element.click',
      e.once(t, cc, n),
      function () {
        e.off(t, n)
      }
    }
    function pc (e) {
      return {
        x: e.x + e.width / 2,
        y: e.y + e.height / 2
      }
    }
    function uc (e, t) {
      return {
        x: e.x - t.x,
        y: e.y - t.y
      }
    }
    function dc (e, t) {
      let n
      function r (r) {
        let o; const i = n.start; const a = n.button; const s = Va(r); let c = uc(s, i)
        !n.dragging && (o = c,
        Math.sqrt(Math.pow(o.x, 2) + Math.pow(o.y, 2)) > 15) && (n.dragging = !0,
        a === 0 && lc(e),
        ac('grab')),
        n.dragging && (c = uc(s, n.last || n.start),
        t.scroll({
          dx: c.x,
          dy: c.y
        }),
        n.last = s),
        r.preventDefault()
      }
      function o (e) {
        vn.unbind(document, 'mousemove', r),
        vn.unbind(document, 'mouseup', o),
        n = null,
        sc()
      }
      e.on('element.mousedown', 500, function (e) {
        return (function (e) {
          if (!sn(e.target, '.djs-draggable')) {
            const t = e.button
            if (!(t >= 2 || e.ctrlKey || e.shiftKey || e.altKey)) {
              return n = {
                button: t,
                start: Va(e)
              },
              vn.bind(document, 'mousemove', r),
              vn.bind(document, 'mouseup', o),
              !0
            }
          }
        }(e.originalEvent))
      }
      ),
      this.isActive = function () {
        return !!n
      }
    }
    dc.$inject = ['eventBus', 'canvas']
    const fc = {
      __init__: ['moveCanvas'],
      moveCanvas: ['type', dc]
    }
    function hc (e) {
      return Math.log(e) / Math.log(10)
    }
    function mc (e, t) {
      const n = hc(e.min)
      const r = hc(e.max)
      return (Math.abs(n) + Math.abs(r)) / t
    }
    const vc = Math.sign || function (e) {
      return e >= 0 ? 1 : -1
    }
    const gc = {
      min: 0.2,
      max: 4
    }
    function yc (e, t, n) {
      e = e || {},
      this._enabled = !1,
      this._canvas = n,
      this._container = n._container,
      this._handleWheel = ce(this._handleWheel, this),
      this._totalDelta = 0,
      this._scale = e.scale || 0.75
      const r = this
      t.on('canvas.init', function (t) {
        r._init(!1 !== e.enabled)
      }
      )
    }
    yc.$inject = ['config.zoomScroll', 'eventBus', 'canvas'],
    yc.prototype.scroll = function (e) {
      this._canvas.scroll(e)
    }
    ,
    yc.prototype.reset = function () {
      this._canvas.zoom('fit-viewport')
    }
    ,
    yc.prototype.zoom = function (e, t) {
      const n = mc(gc, 20)
      this._totalDelta += e,
      Math.abs(this._totalDelta) > 0.1 && (this._zoom(e, t, n),
      this._totalDelta = 0)
    }
    ,
    yc.prototype._handleWheel = function (e) {
      if (!sn(e.target, '.djs-scrollable', !0)) {
        const t = this._container
        e.preventDefault()
        let n; const r = e.ctrlKey || Qa() && e.metaKey; const o = e.shiftKey; let i = -1 * this._scale
        if (i *= r ? e.deltaMode === 0 ? 0.02 : 0.32 : e.deltaMode === 0 ? 1 : 16,
        r) {
          const a = t.getBoundingClientRect()
          const s = {
            x: e.clientX - a.left,
            y: e.clientY - a.top
          }
          n = Math.sqrt(Math.pow(e.deltaY, 2) + Math.pow(e.deltaX, 2)) * vc(e.deltaY) * i,
          this.zoom(n, s)
        } else {
          n = o
            ? {
                dx: i * e.deltaY,
                dy: 0
              }
            : {
                dx: i * e.deltaX,
                dy: i * e.deltaY
              },
          this.scroll(n)
        }
      }
    }
    ,
    yc.prototype.stepZoom = function (e, t) {
      const n = mc(gc, 10)
      this._zoom(e, t, n)
    }
    ,
    yc.prototype._zoom = function (e, t, n) {
      const r = this._canvas
      const o = e > 0 ? 1 : -1
      const i = hc(r.zoom())
      let a = Math.round(i / n) * n
      a += n * o
      let s; let c; const l = Math.pow(10, a)
      r.zoom((s = gc,
      c = l,
      Math.max(s.min, Math.min(s.max, c))), t)
    }
    ,
    yc.prototype.toggle = function (e) {
      const t = this._container
      const n = this._handleWheel
      const r = this._enabled
      return void 0 === e && (e = !r),
      r !== e && vn[e ? 'bind' : 'unbind'](t, 'wheel', n, !1),
      this._enabled = e,
      e
    }
    ,
    yc.prototype._init = function (e) {
      this.toggle(e)
    }

    const bc = {
      __init__: ['zoomScroll'],
      zoomScroll: ['type', yc]
    }
    function Ac (e) {
      Hs.call(this, e)
    }
    function Ec (e) {
      return e && e[e.length - 1]
    }
    function xc (e) {
      return e.y
    }
    function wc (e) {
      return e.x
    }
    w(Ac, Hs),
    Ac.prototype._navigationModules = [oc, fc, bc],
    Ac.prototype._modules = [].concat(Hs.prototype._modules, Ac.prototype._navigationModules)
    const _c = {
      left: wc,
      center: wc,
      right: function (e) {
        return e.x + e.width
      },
      top: xc,
      middle: xc,
      bottom: function (e) {
        return e.y + e.height
      }
    }
    function Cc (e, t) {
      this._modeling = e,
      this._rules = t
    }
    Cc.$inject = ['modeling', 'rules'],
    Cc.prototype._getOrientationDetails = function (e) {
      let t = 'x'
      let n = 'width'
      return ['top', 'bottom', 'middle'].indexOf(e) !== -1 && (t = 'y',
      n = 'height'),
      {
        axis: t,
        dimension: n
      }
    }
    ,
    Cc.prototype._isType = function (e, t) {
      return t.indexOf(e) !== -1
    }
    ,
    Cc.prototype._alignmentPosition = function (e, t) {
      let n; let r; let o; const i = this._getOrientationDetails(e); const a = i.axis; const s = i.dimension; const c = {}; const l = {}; let p = !1
      if (this._isType(e, ['left', 'top'])) { c[e] = t[0][a] } else if (this._isType(e, ['right', 'bottom'])) {
        o = Ec(t),
        c[e] = o[a] + o[s]
      } else if (this._isType(e, ['center', 'middle'])) {
        if (G(t, function (e) {
          const t = e[a] + Math.round(e[s] / 2)
          l[t]
            ? l[t].elements.push(e)
            : l[t] = {
              elements: [e],
              center: t
            }
        }
        ),
        n = te(l, function (e) {
          return e.elements.length > 1 && (p = !0),
          e.elements.length
        }
        ),
        p) {
          return c[e] = Ec(n).center,
          c
        }
        r = t[0],
        o = Ec(t = te(t, function (e) {
          return e[a] + e[s]
        }
        )),
        c[e] = (function (e, t) {
          return Math.round((e[a] + t[a] + t[s]) / 2)
        }(r, o))
      }
      return c
    }
    ,
    Cc.prototype.trigger = function (e, t) {
      let n; const r = this._modeling; let o = W(e, function (e) {
        return !(e.waypoints || e.host || e.labelTarget)
      }
      )
      if (M(n = this._rules.allowed('elements.align', {
        elements: o
      })) && (o = n),
      !(o.length < 2) && n) {
        const i = te(o, _c[t])
        const a = this._alignmentPosition(t, i)
        r.alignElements(i, a)
      }
    }

    const Sc = {
      __init__: ['alignElements'],
      alignElements: ['type', Cc]
    }
    const kc = '.entry'
    function jc (e, t, n, r) {
      this._canvas = e,
      this._eventBus = n,
      this._overlays = r
      const o = R(t && t.scale)
        ? t.scale
        : {
            min: 1,
            max: 1.5
          }
      this._overlaysConfig = {
        scale: o
      },
      this._current = null,
      this._init()
    }
    function Bc (e, t) {
      return e.indexOf(t) !== -1
    }
    jc.$inject = ['canvas', 'config.contextPad', 'eventBus', 'overlays'],
    jc.prototype._init = function () {
      const e = this
      this._eventBus.on('selection.changed', function (t) {
        const n = t.newSelection
        const r = n.length ? n.length === 1 ? n[0] : n : null
        r ? e.open(r, !0) : e.close()
      }
      ),
      this._eventBus.on('elements.changed', function (t) {
        const n = t.elements
        const r = e._current
        if (r) {
          const o = r.target
          Q(M(o) ? o : [o], function (e) {
            return Bc(n, e)
          }
          ) && e.open(o, !0)
        }
      }
      )
    }
    ,
    jc.prototype.registerProvider = function (e, t) {
      t || (t = e,
      e = 1e3),
      this._eventBus.on('contextPad.getProviders', e, function (e) {
        e.providers.push(t)
      }
      )
    }
    ,
    jc.prototype.getEntries = function (e) {
      const t = this._getProviders()
      const n = M(e) ? 'getMultiElementContextPadEntries' : 'getContextPadEntries'
      let r = {}
      return G(t, function (t) {
        if (z(t[n])) {
          const o = t[n](e)
          z(o)
            ? r = o(r)
            : G(o, function (e, t) {
              r[t] = e
            }
            )
        }
      }
      ),
      r
    }
    ,
    jc.prototype.trigger = function (e, t, n) {
      let r; let o; const i = this; const a = t.delegateTarget || t.target
      return a
        ? (r = en(a, 'data-action'),
          o = t.originalEvent || t,
          e === 'mouseover'
            ? this._timeout = setTimeout(function () {
              i._mouseout = i.triggerEntry(r, 'hover', o, n)
            }
            , 300)
            : e === 'mouseout' && (clearTimeout(this._timeout),
            this._mouseout && (this._mouseout(),
            this._mouseout = null)),
          this.triggerEntry(r, e, o, n))
        : t.preventDefault()
    }
    ,
    jc.prototype.triggerEntry = function (e, t, n, r) {
      if (this.isShown()) {
        const o = this._current.target
        const i = this._current.entries[e]
        if (i) {
          const a = i.action
          if (!1 !== this._eventBus.fire('contextPad.trigger', {
            entry: i,
            event: n
          })) {
            if (z(a)) {
              if (t === 'click') { return a(n, o, r) }
            } else if (a[t]) { return a[t](n, o, r) }
            n.preventDefault()
          }
        }
      }
    }
    ,
    jc.prototype.open = function (e, t) {
      !t && this.isOpen(e) || (this.close(),
      this._updateAndOpen(e))
    }
    ,
    jc.prototype._getProviders = function () {
      const e = this._eventBus.createEvent({
        type: 'contextPad.getProviders',
        providers: []
      })
      return this._eventBus.fire(e),
      e.providers
    }
    ,
    jc.prototype._updateAndOpen = function (e) {
      let t; const n = this.getEntries(e); const r = this.getPad(e); const o = r.html
      G(n, function (e, n) {
        let r; const i = e.group || 'default'; const a = xn(e.html || '<div class="entry" draggable="true"></div>')
        en(a, 'data-action', n),
        (r = wn('[data-group=' + Cs(i) + ']', o)) || (en(r = xn('<div class="group"></div>'), 'data-group', i),
        o.appendChild(r)),
        r.appendChild(a),
        e.className && (function (e, t) {
          const n = nn(e);
          (t = M(t) ? t : t.split(/\s+/g)).forEach(function (e) {
            n.add(e)
          }
          )
        }(a, e.className)),
        e.title && en(a, 'title', e.title),
        e.imageUrl && (en(t = xn('<img>'), 'src', e.imageUrl),
        t.style.width = '100%',
        t.style.height = '100%',
        a.appendChild(t))
      }
      ),
      nn(o).add('open'),
      this._current = {
        target: e,
        entries: n,
        pad: r
      },
      this._eventBus.fire('contextPad.open', {
        current: this._current
      })
    }
    ,
    jc.prototype.getPad = function (e) {
      if (this.isOpen()) { return this._current.pad }
      const t = this
      const n = this._overlays
      const r = xn('<div class="djs-context-pad"></div>')
      const o = this._getPosition(e)
      const i = le({
        html: r
      }, this._overlaysConfig, o)
      yn(r, kc, 'click', function (e) {
        t.trigger('click', e)
      }
      ),
      yn(r, kc, 'dragstart', function (e) {
        t.trigger('dragstart', e)
      }
      ),
      yn(r, kc, 'mouseover', function (e) {
        t.trigger('mouseover', e)
      }
      ),
      yn(r, kc, 'mouseout', function (e) {
        t.trigger('mouseout', e)
      }
      ),
      vn.bind(r, 'mousedown', function (e) {
        e.stopPropagation()
      }
      )
      const a = this._canvas.getRootElement()
      this._overlayId = n.add(a, 'context-pad', i)
      const s = n.get(this._overlayId)
      return this._eventBus.fire('contextPad.create', {
        target: e,
        pad: s
      }),
      s
    }
    ,
    jc.prototype.close = function () {
      this.isOpen() && (clearTimeout(this._timeout),
      this._overlays.remove(this._overlayId),
      this._overlayId = null,
      this._eventBus.fire('contextPad.close', {
        current: this._current
      }),
      this._current = null)
    }
    ,
    jc.prototype.isOpen = function (e) {
      const t = this._current
      if (!t) { return !1 }
      if (!e) { return !0 }
      const n = t.target
      return M(e) === M(n) && (M(e)
        ? e.length === n.length && V(e, function (e) {
          return Bc(n, e)
        }
        )
        : n === e)
    }
    ,
    jc.prototype.isShown = function () {
      return this.isOpen() && this._overlays.isShown()
    }
    ,
    jc.prototype._getPosition = function (e) {
      let t; const n = Ft(M(e = yr(e) ? (t = e).waypoints[t.waypoints.length - 1] : e) ? e : [e])
      return {
        position: {
          left: n.x + n.width + 12,
          top: n.y - 6
        }
      }
    }

    const Dc = {
      __depends__: [ns, ys],
      contextPad: ['type', jc]
    }
    let Pc; let Oc; let Tc; let Rc; let Nc; let Mc; let Ic; const Lc = {}; const zc = []; const Fc = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i
    function $c (e, t) {
      for (const n in t) { e[n] = t[n] }
      return e
    }
    function Hc (e) {
      const t = e.parentNode
      t && t.removeChild(e)
    }
    function qc (e, t, n) {
      let r; let o; let i; const a = {}
      for (i in t) { i == 'key' ? r = t[i] : i == 'ref' ? o = t[i] : a[i] = t[i] }
      if (arguments.length > 2 && (a.children = arguments.length > 3 ? Pc.call(arguments, 2) : n),
      typeof e === 'function' && e.defaultProps != null) {
        for (i in e.defaultProps) { void 0 === a[i] && (a[i] = e.defaultProps[i]) }
      }
      return Wc(e, a, r, o, null)
    }
    function Wc (e, t, n, r, o) {
      const i = {
        type: e,
        props: t,
        key: n,
        ref: r,
        __k: null,
        __: null,
        __b: 0,
        __e: null,
        __d: void 0,
        __c: null,
        __h: null,
        constructor: void 0,
        __v: o == null ? ++Tc : o
      }
      return o == null && Oc.vnode != null && Oc.vnode(i),
      i
    }
    function Gc (e) {
      return e.children
    }
    function Uc (e, t) {
      this.props = e,
      this.context = t
    }
    function Vc (e, t) {
      if (t == null) { return e.__ ? Vc(e.__, e.__.__k.indexOf(e) + 1) : null }
      for (var n; t < e.__k.length; t++) {
        if ((n = e.__k[t]) != null && n.__e != null) { return n.__e }
      }
      return typeof e.type === 'function' ? Vc(e) : null
    }
    function Qc (e) {
      let t, n
      if ((e = e.__) != null && e.__c != null) {
        for (e.__e = e.__c.base = null,
        t = 0; t < e.__k.length; t++) {
          if ((n = e.__k[t]) != null && n.__e != null) {
            e.__e = e.__c.base = n.__e
            break
          }
        }
        return Qc(e)
      }
    }
    function Yc (e) {
      (!e.__d && (e.__d = !0) && Rc.push(e) && !Kc.__r++ || Nc !== Oc.debounceRendering) && ((Nc = Oc.debounceRendering) || Mc)(Kc)
    }
    function Kc () {
      let e, t, n, r, o, i, a, s
      for (Rc.sort(Ic); e = Rc.shift();) {
        e.__d && (t = Rc.length,
        r = void 0,
        o = void 0,
        a = (i = (n = e).__v).__e,
        (s = n.__P) && (r = [],
        (o = $c({}, i)).__v = i.__v + 1,
        il(s, i, o, n.__n, void 0 !== s.ownerSVGElement, i.__h != null ? [a] : null, r, a == null ? Vc(i) : a, i.__h),
        al(r, i),
        i.__e != a && Qc(i)),
        Rc.length > t && Rc.sort(Ic))
      }
      Kc.__r = 0
    }
    function Jc (e, t, n, r, o, i, a, s, c, l) {
      let p; let u; let d; let f; let h; let m; let v; const g = r && r.__k || zc; const y = g.length
      for (n.__k = [],
      p = 0; p < t.length; p++) {
        if ((f = n.__k[p] = (f = t[p]) == null || typeof f === 'boolean' || typeof f === 'function'
          ? null
          : typeof f === 'string' || typeof f === 'number' || typeof f === 'bigint'
            ? Wc(null, f, null, null, f)
            : Array.isArray(f)
              ? Wc(Gc, {
                children: f
              }, null, null, null)
              : f.__b > 0 ? Wc(f.type, f.props, f.key, f.ref ? f.ref : null, f.__v) : f) != null) {
          if (f.__ = n,
          f.__b = n.__b + 1,
          (d = g[p]) === null || d && f.key == d.key && f.type === d.type) { g[p] = void 0 } else {
            for (u = 0; u < y; u++) {
              if ((d = g[u]) && f.key == d.key && f.type === d.type) {
                g[u] = void 0
                break
              }
              d = null
            }
          }
          il(e, f, d = d || Lc, o, i, a, s, c, l),
          h = f.__e,
          (u = f.ref) && d.ref != u && (v || (v = []),
          d.ref && v.push(d.ref, null, f),
          v.push(u, f.__c || h, f)),
          h != null
            ? (m == null && (m = h),
              typeof f.type === 'function' && f.__k === d.__k ? f.__d = c = Xc(f, c, e) : c = Zc(e, f, d, g, h, c),
              typeof n.type === 'function' && (n.__d = c))
            : c && d.__e == c && c.parentNode != e && (c = Vc(d))
        }
      }
      for (n.__e = m,
      p = y; p--;) {
        g[p] != null && (typeof n.type === 'function' && g[p].__e != null && g[p].__e == n.__d && (n.__d = el(r).nextSibling),
        ll(g[p], g[p]))
      }
      if (v) {
        for (p = 0; p < v.length; p++) { cl(v[p], v[++p], v[++p]) }
      }
    }
    function Xc (e, t, n) {
      for (var r, o = e.__k, i = 0; o && i < o.length; i++) {
        (r = o[i]) && (r.__ = e,
        t = typeof r.type === 'function' ? Xc(r, t, n) : Zc(n, r, r, o, r.__e, t))
      }
      return t
    }
    function Zc (e, t, n, r, o, i) {
      let a, s, c
      if (void 0 !== t.__d) {
        a = t.__d,
        t.__d = void 0
      } else if (n == null || o != i || o.parentNode == null) {
        e: if (i == null || i.parentNode !== e) {
          e.appendChild(o),
          a = null
        } else {
          for (s = i,
          c = 0; (s = s.nextSibling) && c < r.length; c += 1) {
            if (s == o) { break e }
          }
          e.insertBefore(o, i),
          a = i
        }
      }
      return void 0 !== a ? a : o.nextSibling
    }
    function el (e) {
      let t, n, r
      if (e.type == null || typeof e.type === 'string') { return e.__e }
      if (e.__k) {
        for (t = e.__k.length - 1; t >= 0; t--) {
          if ((n = e.__k[t]) && (r = el(n))) { return r }
        }
      }
      return null
    }
    function tl (e, t, n) {
      t[0] === '-' ? e.setProperty(t, n == null ? '' : n) : e[t] = n == null ? '' : typeof n !== 'number' || Fc.test(t) ? n : n + 'px'
    }
    function nl (e, t, n, r, o) {
      let i
      e: if (t === 'style') {
        if (typeof n === 'string') { e.style.cssText = n } else {
          if (typeof r === 'string' && (e.style.cssText = r = ''),
          r) {
            for (t in r) { n && t in n || tl(e.style, t, '') }
          }
          if (n) {
            for (t in n) { r && n[t] === r[t] || tl(e.style, t, n[t]) }
          }
        }
      } else if (t[0] === 'o' && t[1] === 'n') {
        i = t !== (t = t.replace(/Capture$/, '')),
        t = t.toLowerCase() in e ? t.toLowerCase().slice(2) : t.slice(2),
        e.l || (e.l = {}),
        e.l[t + i] = n,
        n ? r || e.addEventListener(t, i ? ol : rl, i) : e.removeEventListener(t, i ? ol : rl, i)
      } else if (t !== 'dangerouslySetInnerHTML') {
        if (o) { t = t.replace(/xlink(H|:h)/, 'h').replace(/sName$/, 's') } else if (t !== 'width' && t !== 'height' && t !== 'href' && t !== 'list' && t !== 'form' && t !== 'tabIndex' && t !== 'download' && t in e) {
          try {
            e[t] = n == null ? '' : n
            break e
          } catch (e) {}
        }
        typeof n === 'function' || (n == null || !1 === n && t[4] !== '-' ? e.removeAttribute(t) : e.setAttribute(t, n))
      }
    }
    function rl (e) {
      return this.l[e.type + !1](Oc.event ? Oc.event(e) : e)
    }
    function ol (e) {
      return this.l[e.type + !0](Oc.event ? Oc.event(e) : e)
    }
    function il (e, t, n, r, o, i, a, s, c) {
      let l; let p; let u; let d; let f; let h; let m; let v; let g; let y; let b; let A; let E; let x; let w; const _ = t.type
      if (void 0 !== t.constructor) { return null }
      n.__h != null && (c = n.__h,
      s = t.__e = n.__e,
      t.__h = null,
      i = [s]),
      (l = Oc.__b) && l(t)
      try {
        e: if (typeof _ === 'function') {
          if (v = t.props,
          g = (l = _.contextType) && r[l.__c],
          y = l ? g ? g.props.value : l.__ : r,
          n.__c
            ? m = (p = t.__c = n.__c).__ = p.__E
            : ('prototype' in _ && _.prototype.render
                ? t.__c = p = new _(v, y)
                : (t.__c = p = new Uc(v, y),
                  p.constructor = _,
                  p.render = pl),
              g && g.sub(p),
              p.props = v,
              p.state || (p.state = {}),
              p.context = y,
              p.__n = r,
              u = p.__d = !0,
              p.__h = [],
              p._sb = []),
          p.__s == null && (p.__s = p.state),
          _.getDerivedStateFromProps != null && (p.__s == p.state && (p.__s = $c({}, p.__s)),
          $c(p.__s, _.getDerivedStateFromProps(v, p.__s))),
          d = p.props,
          f = p.state,
          p.__v = t,
          u) {
            _.getDerivedStateFromProps == null && p.componentWillMount != null && p.componentWillMount(),
            p.componentDidMount != null && p.__h.push(p.componentDidMount)
          } else {
            if (_.getDerivedStateFromProps == null && v !== d && p.componentWillReceiveProps != null && p.componentWillReceiveProps(v, y),
            !p.__e && p.shouldComponentUpdate != null && !1 === p.shouldComponentUpdate(v, p.__s, y) || t.__v === n.__v) {
              for (t.__v !== n.__v && (p.props = v,
              p.state = p.__s,
              p.__d = !1),
              p.__e = !1,
              t.__e = n.__e,
              t.__k = n.__k,
              t.__k.forEach(function (e) {
                e && (e.__ = t)
              }
              ),
              b = 0; b < p._sb.length; b++) { p.__h.push(p._sb[b]) }
              p._sb = [],
              p.__h.length && a.push(p)
              break e
            }
            p.componentWillUpdate != null && p.componentWillUpdate(v, p.__s, y),
            p.componentDidUpdate != null && p.__h.push(function () {
              p.componentDidUpdate(d, f, h)
            }
            )
          }
          if (p.context = y,
          p.props = v,
          p.__P = e,
          A = Oc.__r,
          E = 0,
          'prototype' in _ && _.prototype.render) {
            for (p.state = p.__s,
            p.__d = !1,
            A && A(t),
            l = p.render(p.props, p.state, p.context),
            x = 0; x < p._sb.length; x++) { p.__h.push(p._sb[x]) }
            p._sb = []
          } else {
            do {
              p.__d = !1,
              A && A(t),
              l = p.render(p.props, p.state, p.context),
              p.state = p.__s
            } while (p.__d && ++E < 25)
          }
          p.state = p.__s,
          p.getChildContext != null && (r = $c($c({}, r), p.getChildContext())),
          u || p.getSnapshotBeforeUpdate == null || (h = p.getSnapshotBeforeUpdate(d, f)),
          w = l != null && l.type === Gc && l.key == null ? l.props.children : l,
          Jc(e, Array.isArray(w) ? w : [w], t, n, r, o, i, a, s, c),
          p.base = t.__e,
          t.__h = null,
          p.__h.length && a.push(p),
          m && (p.__E = p.__ = null),
          p.__e = !1
        } else {
          i == null && t.__v === n.__v
            ? (t.__k = n.__k,
              t.__e = n.__e)
            : t.__e = sl(n.__e, t, n, r, o, i, a, c)
        }
        (l = Oc.diffed) && l(t)
      } catch (e) {
        t.__v = null,
        (c || i != null) && (t.__e = s,
        t.__h = !!c,
        i[i.indexOf(s)] = null),
        Oc.__e(e, t, n)
      }
    }
    function al (e, t) {
      Oc.__c && Oc.__c(t, e),
      e.some(function (t) {
        try {
          e = t.__h,
          t.__h = [],
          e.some(function (e) {
            e.call(t)
          }
          )
        } catch (e) {
          Oc.__e(e, t.__v)
        }
      }
      )
    }
    function sl (e, t, n, r, o, i, a, s) {
      let c; let l; let p; let u = n.props; const d = t.props; const f = t.type; let h = 0
      if (f === 'svg' && (o = !0),
      i != null) {
        for (; h < i.length; h++) {
          if ((c = i[h]) && 'setAttribute' in c == !!f && (f ? c.localName === f : c.nodeType === 3)) {
            e = c,
            i[h] = null
            break
          }
        }
      }
      if (e == null) {
        if (f === null) { return document.createTextNode(d) }
        e = o ? document.createElementNS('http://www.w3.org/2000/svg', f) : document.createElement(f, d.is && d),
        i = null,
        s = !1
      }
      if (f === null) { u === d || s && e.data === d || (e.data = d) } else {
        if (i = i && Pc.call(e.childNodes),
        l = (u = n.props || Lc).dangerouslySetInnerHTML,
        p = d.dangerouslySetInnerHTML,
        !s) {
          if (i != null) {
            for (u = {},
            h = 0; h < e.attributes.length; h++) { u[e.attributes[h].name] = e.attributes[h].value }
          }
          (p || l) && (p && (l && p.__html == l.__html || p.__html === e.innerHTML) || (e.innerHTML = p && p.__html || ''))
        }
        if ((function (e, t, n, r, o) {
          let i
          for (i in n) { i === 'children' || i === 'key' || i in t || nl(e, i, null, n[i], r) }
          for (i in t) { o && typeof t[i] !== 'function' || i === 'children' || i === 'key' || i === 'value' || i === 'checked' || n[i] === t[i] || nl(e, i, t[i], n[i], r) }
        }(e, d, u, o, s)),
        p) { t.__k = [] } else if (h = t.props.children,
        Jc(e, Array.isArray(h) ? h : [h], t, n, r, o && f !== 'foreignObject', i, a, i ? i[0] : n.__k && Vc(n, 0), s),
        i != null) {
          for (h = i.length; h--;) { i[h] != null && Hc(i[h]) }
        }
        s || ('value' in d && void 0 !== (h = d.value) && (h !== e.value || f === 'progress' && !h || f === 'option' && h !== u.value) && nl(e, 'value', h, u.value, !1),
        'checked' in d && void 0 !== (h = d.checked) && h !== e.checked && nl(e, 'checked', h, u.checked, !1))
      }
      return e
    }
    function cl (e, t, n) {
      try {
        typeof e === 'function' ? e(t) : e.current = t
      } catch (e) {
        Oc.__e(e, n)
      }
    }
    function ll (e, t, n) {
      let r, o
      if (Oc.unmount && Oc.unmount(e),
      (r = e.ref) && (r.current && r.current !== e.__e || cl(r, null, t)),
      (r = e.__c) != null) {
        if (r.componentWillUnmount) {
          try {
            r.componentWillUnmount()
          } catch (e) {
            Oc.__e(e, t)
          }
        }
        r.base = r.__P = null,
        e.__c = void 0
      }
      if (r = e.__k) {
        for (o = 0; o < r.length; o++) { r[o] && ll(r[o], t, n || typeof e.type !== 'function') }
      }
      n || e.__e == null || Hc(e.__e),
      e.__ = e.__e = e.__d = void 0
    }
    function pl (e, t, n) {
      return this.constructor(e, n)
    }
    function ul (e, t, n) {
      let r, o, i
      Oc.__ && Oc.__(e, t),
      o = (r = typeof n === 'function') ? null : n && n.__k || t.__k,
      i = [],
      il(t, e = (!r && n || t).__k = qc(Gc, null, [e]), o || Lc, Lc, void 0 !== t.ownerSVGElement, !r && n ? [n] : o ? null : t.firstChild ? Pc.call(t.childNodes) : null, i, !r && n ? n : o ? o.__e : t.firstChild, r),
      al(i, e)
    }
    Pc = zc.slice,
    Oc = {
      __e: function (e, t, n, r) {
        for (var o, i, a; t = t.__;) {
          if ((o = t.__c) && !o.__) {
            try {
              if ((i = o.constructor) && i.getDerivedStateFromError != null && (o.setState(i.getDerivedStateFromError(e)),
              a = o.__d),
              o.componentDidCatch != null && (o.componentDidCatch(e, r || {}),
              a = o.__d),
              a) { return o.__E = o }
            } catch (t) {
              e = t
            }
          }
        }
        throw e
      }
    },
    Tc = 0,
    Uc.prototype.setState = function (e, t) {
      let n
      n = this.__s != null && this.__s !== this.state ? this.__s : this.__s = $c({}, this.state),
      typeof e === 'function' && (e = e($c({}, n), this.props)),
      e && $c(n, e),
      e != null && this.__v && (t && this._sb.push(t),
      Yc(this))
    }
    ,
    Uc.prototype.forceUpdate = function (e) {
      this.__v && (this.__e = !0,
      e && this.__h.push(e),
      Yc(this))
    }
    ,
    Uc.prototype.render = Gc,
    Rc = [],
    Mc = typeof Promise === 'function' ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout,
    Ic = function (e, t) {
      return e.__v.__b - t.__v.__b
    }
    ,
    Kc.__r = 0
    let dl; let fl; let hl; let ml; const vl = function e (t, n, r, o) {
      let i
      n[0] = 0
      for (let a = 1; a < n.length; a++) {
        const s = n[a++]
        const c = n[a]
          ? (n[0] |= s ? 1 : 2,
            r[n[a++]])
          : n[++a]
        s === 3
          ? o[0] = c
          : s === 4
            ? o[1] = Object.assign(o[1] || {}, c)
            : s === 5
              ? (o[1] = o[1] || {})[n[++a]] = c
              : s === 6
                ? o[1][n[++a]] += c + ''
                : s
                  ? (i = t.apply(c, e(t, c, r, ['', null])),
                    o.push(i),
                    c[0]
                      ? n[0] |= 2
                      : (n[a - 2] = 0,
                        n[a] = i))
                  : o.push(c)
      }
      return o
    }; const gl = new Map(); const yl = function (e) {
      let t = gl.get(this)
      return t || (t = new Map(),
      gl.set(this, t)),
      (t = vl(this, t.get(e) || (t.set(e, t = (function (e) {
        for (var t, n, r = 1, o = '', i = '', a = [0], s = function (e) {
            r === 1 && (e || (o = o.replace(/^\s*\n\s*|\s*\n\s*$/g, '')))
              ? a.push(0, e, o)
              : r === 3 && (e || o)
                ? (a.push(3, e, o),
                  r = 2)
                : r === 2 && o === '...' && e
                  ? a.push(4, e, 0)
                  : r === 2 && o && !e
                    ? a.push(5, 0, !0, o)
                    : r >= 5 && ((o || !e && r === 5) && (a.push(r, 0, o, n),
                    r = 6),
                    e && (a.push(r, e, 0, n),
                    r = 6)),
            o = ''
          }, c = 0; c < e.length; c++) {
          c && (r === 1 && s(),
          s(c))
          for (let l = 0; l < e[c].length; l++) {
            t = e[c][l],
            r === 1
              ? t === '<'
                ? (s(),
                  a = [a],
                  r = 3)
                : o += t
              : r === 4
                ? o === '--' && t === '>'
                  ? (r = 1,
                    o = '')
                  : o = t + o[0]
                : i
                  ? t === i ? i = '' : o += t
                  : t === '"' || t === "'"
                    ? i = t
                    : t === '>'
                      ? (s(),
                        r = 1)
                      : r && (t === '='
                        ? (r = 5,
                          n = o,
                          o = '')
                        : t === '/' && (r < 5 || e[c][l + 1] === '>')
                          ? (s(),
                            r === 3 && (a = a[0]),
                            r = a,
                            (a = a[0]).push(2, 0, r),
                            r = 0)
                          : t === ' ' || t === '\t' || t === '\n' || t === '\r'
                            ? (s(),
                              r = 2)
                            : o += t),
            r === 3 && o === '!--' && (r = 4,
            a = a[0])
          }
        }
        return s(),
        a
      }(e))),
      t), arguments, [])).length > 1
        ? t
        : t[0]
    }
      .bind(qc); let bl = 0; const Al = []; const El = []; const xl = Oc.__b; const wl = Oc.__r; const _l = Oc.diffed; const Cl = Oc.__c; const Sl = Oc.unmount
    function kl (e, t) {
      Oc.__h && Oc.__h(fl, e, bl || t),
      bl = 0
      const n = fl.__H || (fl.__H = {
        __: [],
        __h: []
      })
      return e >= n.__.length && n.__.push({
        __V: El
      }),
      n.__[e]
    }
    function jl (e) {
      return bl = 1,
      (function (e, t, n) {
        const r = kl(dl++, 2)
        if (r.t = e,
        !r.__c && (r.__ = [Fl(void 0, t), function (e) {
          const t = r.__N ? r.__N[0] : r.__[0]
          const n = r.t(t, e)
          t !== n && (r.__N = [n, r.__[1]],
          r.__c.setState({}))
        }
        ],
        r.__c = fl,
        !fl.u)) {
          const o = function (e, t, n) {
            if (!r.__c.__H) { return !0 }
            const o = r.__c.__H.__.filter(function (e) {
              return e.__c
            }
            )
            if (o.every(function (e) {
              return !e.__N
            }
            )) { return !i || i.call(this, e, t, n) }
            let a = !1
            return o.forEach(function (e) {
              if (e.__N) {
                const t = e.__[0]
                e.__ = e.__N,
                e.__N = void 0,
                t !== e.__[0] && (a = !0)
              }
            }
            ),
            !(!a && r.__c.props === e) && (!i || i.call(this, e, t, n))
          }
          fl.u = !0
          var i = fl.shouldComponentUpdate
          const a = fl.componentWillUpdate
          fl.componentWillUpdate = function (e, t, n) {
            if (this.__e) {
              const r = i
              i = void 0,
              o(e, t, n),
              i = r
            }
            a && a.call(this, e, t, n)
          }
          ,
          fl.shouldComponentUpdate = o
        }
        return r.__N || r.__
      }(Fl, e))
    }
    function Bl (e, t) {
      const n = kl(dl++, 3)
      !Oc.__s && zl(n.__H, t) && (n.__ = e,
      n.i = t,
      fl.__H.__h.push(n))
    }
    function Dl (e, t) {
      const n = kl(dl++, 4)
      !Oc.__s && zl(n.__H, t) && (n.__ = e,
      n.i = t,
      fl.__h.push(n))
    }
    function Pl (e) {
      return bl = 5,
      Ol(function () {
        return {
          current: e
        }
      }
      , [])
    }
    function Ol (e, t) {
      const n = kl(dl++, 7)
      return zl(n.__H, t)
        ? (n.__V = e(),
          n.i = t,
          n.__h = e,
          n.__V)
        : n.__
    }
    function Tl (e, t) {
      return bl = 8,
      Ol(function () {
        return e
      }
      , t)
    }
    function Rl () {
      for (var e; e = Al.shift();) {
        if (e.__P && e.__H) {
          try {
            e.__H.__h.forEach(Il),
            e.__H.__h.forEach(Ll),
            e.__H.__h = []
          } catch (t) {
            e.__H.__h = [],
            Oc.__e(t, e.__v)
          }
        }
      }
    }
    Oc.__b = function (e) {
      fl = null,
      xl && xl(e)
    }
    ,
    Oc.__r = function (e) {
      wl && wl(e),
      dl = 0
      const t = (fl = e.__c).__H
      t && (hl === fl
        ? (t.__h = [],
          fl.__h = [],
          t.__.forEach(function (e) {
            e.__N && (e.__ = e.__N),
            e.__V = El,
            e.__N = e.i = void 0
          }
          ))
        : (t.__h.forEach(Il),
          t.__h.forEach(Ll),
          t.__h = [])),
      hl = fl
    }
    ,
    Oc.diffed = function (e) {
      _l && _l(e)
      const t = e.__c
      t && t.__H && (t.__H.__h.length && (Al.push(t) !== 1 && ml === Oc.requestAnimationFrame || ((ml = Oc.requestAnimationFrame) || Ml)(Rl)),
      t.__H.__.forEach(function (e) {
        e.i && (e.__H = e.i),
        e.__V !== El && (e.__ = e.__V),
        e.i = void 0,
        e.__V = El
      }
      )),
      hl = fl = null
    }
    ,
    Oc.__c = function (e, t) {
      t.some(function (e) {
        try {
          e.__h.forEach(Il),
          e.__h = e.__h.filter(function (e) {
            return !e.__ || Ll(e)
          }
          )
        } catch (n) {
          t.some(function (e) {
            e.__h && (e.__h = [])
          }
          ),
          t = [],
          Oc.__e(n, e.__v)
        }
      }
      ),
      Cl && Cl(e, t)
    }
    ,
    Oc.unmount = function (e) {
      Sl && Sl(e)
      let t; const n = e.__c
      n && n.__H && (n.__H.__.forEach(function (e) {
        try {
          Il(e)
        } catch (e) {
          t = e
        }
      }
      ),
      n.__H = void 0,
      t && Oc.__e(t, n.__v))
    }

    const Nl = typeof requestAnimationFrame === 'function'
    function Ml (e) {
      let t; const n = function () {
        clearTimeout(r),
        Nl && cancelAnimationFrame(t),
        setTimeout(e)
      }; var r = setTimeout(n, 100)
      Nl && (t = requestAnimationFrame(n))
    }
    function Il (e) {
      const t = fl
      const n = e.__c
      typeof n === 'function' && (e.__c = void 0,
      n()),
      fl = t
    }
    function Ll (e) {
      const t = fl
      e.__c = e.__(),
      fl = t
    }
    function zl (e, t) {
      return !e || e.length !== t.length || t.some(function (t, n) {
        return t !== e[n]
      }
      )
    }
    function Fl (e, t) {
      return typeof t === 'function' ? t(e) : t
    }
    function $l (e) {
      let t; let n; let r = ''
      if (typeof e === 'string' || typeof e === 'number') { r += e } else if (typeof e === 'object') {
        if (Array.isArray(e)) {
          const o = e.length
          for (t = 0; t < o; t++) {
            e[t] && (n = $l(e[t])) && (r && (r += ' '),
            r += n)
          }
        } else {
          for (n in e) {
            e[n] && (r && (r += ' '),
            r += n)
          }
        }
      }
      return r
    }
    const Hl = function () {
      for (var e, t, n = 0, r = '', o = arguments.length; n < o; n++) {
        (e = arguments[n]) && (t = $l(e)) && (r && (r += ' '),
        r += t)
      }
      return r
    }
    let ql, Wl, Gl, Ul, Vl, Ql, Yl, Kl, Jl, Xl
    function Zl (e, t) {
      return t || (t = e.slice(0)),
      Object.freeze(Object.defineProperties(e, {
        raw: {
          value: Object.freeze(t)
        }
      }))
    }
    function ep (e) {
      const t = e.entry
      const n = e.selected
      const r = e.onMouseEnter
      const o = e.onMouseLeave
      const i = e.onAction
      return yl(ql || (ql = Zl(['\n    <li\n      class=', '\n      data-id=', '\n      title=', '\n      tabIndex="0"\n      onClick=', '\n      onFocus=', '\n      onBlur=', '\n      onMouseEnter=', '\n      onMouseLeave=', '\n      onDragStart=', '\n      aria-role="button"\n      draggable=', '\n    >\n      <div class="djs-popup-entry-content">\n        <span\n          class=', '\n        >\n          ', '\n\n          ', '\n        </span>\n        ', '\n      </div>\n      ', '\n    </li>\n  '])), Hl('entry', {
        selected: n
      }), t.id, t.title || t.label, i, r, o, r, o, function (e) {
        return i(e, t, 'dragstart')
      }
      , !0, Hl('djs-popup-entry-name', t.className), t.imageUrl && yl(Wl || (Wl = Zl(['<img class="djs-popup-entry-icon" src=', ' alt="" />'])), t.imageUrl) || t.imageHtml && yl(Gl || (Gl = Zl(['<div class="djs-popup-entry-icon" dangerouslySetInnerHTML=', ' />'])), {
        __html: t.imageHtml
      }), t.label ? yl(Ul || (Ul = Zl(['\n            <span class="djs-popup-label">\n              ', '\n            </span>\n          '])), t.label) : null, t.description && yl(Vl || (Vl = Zl(['\n          <span\n            class="djs-popup-entry-description"\n            title=', '\n          >\n            ', '\n          </span>\n        '])), t.description, t.description), t.documentationRef && yl(Ql || (Ql = Zl(['\n        <div class="djs-popup-entry-docs">\n          <a\n            href="', '"\n            onClick=', '\n            title="Open element documentation"\n            target="_blank"\n            rel="noopener"\n          >\n            <svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">\n              <path fill-rule="evenodd" clip-rule="evenodd" d="M10.6368 10.6375V5.91761H11.9995V10.6382C11.9995 10.9973 11.8623 11.3141 11.5878 11.5885C11.3134 11.863 10.9966 12.0002 10.6375 12.0002H1.36266C0.982345 12.0002 0.660159 11.8681 0.396102 11.6041C0.132044 11.34 1.52588e-05 11.0178 1.52588e-05 10.6375V1.36267C1.52588e-05 0.98236 0.132044 0.660173 0.396102 0.396116C0.660159 0.132058 0.982345 2.95639e-05 1.36266 2.95639e-05H5.91624V1.36267H1.36266V10.6375H10.6368ZM12 0H7.2794L7.27873 1.36197H9.68701L3.06507 7.98391L4.01541 8.93425L10.6373 2.31231V4.72059H12V0Z" fill="#818798"/>\n            </svg>\n          </a>\n        </div>\n      '])), t.documentationRef, function (e) {
        return e.stopPropagation()
      }
      ))
    }
    function tp (e) {
      return tp = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      tp(e)
    }
    let np; let rp; let op; let ip; let ap; let sp; let cp; let lp; let pp; let up; let dp; const fp = ['selectedEntry', 'setSelectedEntry', 'entries']
    function hp (e, t) {
      const n = Object.keys(e)
      if (Object.getOwnPropertySymbols) {
        let r = Object.getOwnPropertySymbols(e)
        t && (r = r.filter(function (t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable
        }
        )),
        n.push.apply(n, r)
      }
      return n
    }
    function mp (e) {
      for (let t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {}
        t % 2
          ? hp(Object(n), !0).forEach(function (t) {
            let r, o, i
            r = e,
            o = t,
            i = n[t],
            o = (function (e) {
              const t = (function (e, t) {
                if (tp(e) != 'object' || !e) { return e }
                const n = e[Symbol.toPrimitive]
                if (void 0 !== n) {
                  const r = n.call(e, 'string')
                  if (tp(r) != 'object') { return r }
                  throw new TypeError('@@toPrimitive must return a primitive value.')
                }
                return String(e)
              }(e))
              return tp(t) == 'symbol' ? t : t + ''
            }(o)),
            o in r
              ? Object.defineProperty(r, o, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
              })
              : r[o] = i
          }
          )
          : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
            : hp(Object(n)).forEach(function (t) {
              Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
            }
            )
      }
      return e
    }
    function vp (e, t) {
      return t || (t = e.slice(0)),
      Object.freeze(Object.defineProperties(e, {
        raw: {
          value: Object.freeze(t)
        }
      }))
    }
    function gp (e) {
      const t = e.selectedEntry
      const n = e.setSelectedEntry
      const r = e.entries
      const o = (function (e, t) {
        if (e == null) { return {} }
        let n; let r; const o = (function (e, t) {
          if (e == null) { return {} }
          let n; let r; const o = {}; const i = Object.keys(e)
          for (r = 0; r < i.length; r++) {
            n = i[r],
            t.indexOf(n) >= 0 || (o[n] = e[n])
          }
          return o
        }(e, t))
        if (Object.getOwnPropertySymbols) {
          const i = Object.getOwnPropertySymbols(e)
          for (r = 0; r < i.length; r++) {
            n = i[r],
            t.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(e, n) && (o[n] = e[n])
          }
        }
        return o
      }(e, fp))
      const i = Pl()
      const a = Ol(function () {
        return (function (e) {
          const t = []
          const n = function (e) {
            return t.find(function (t) {
              return e.id === t.id
            }
            )
          }
          return e.forEach(function (e) {
            const r = e.group
              ? (function (e) {
                  return typeof e === 'string'
                    ? {
                        id: e
                      }
                    : e
                }(e.group))
              : {
                  id: 'default'
                }
            !(function (e) {
              return !!n(e)
            }(r))
              ? t.push(mp(mp({}, r), {}, {
                entries: [e]
              }))
              : n(r).entries.push(e)
          }
          ),
          t
        }(r))
      }
      , [r])
      return Dl(function () {
        const e = i.current
        if (e) {
          let t; const n = e.querySelector('.selected')
          n && (typeof (t = n).scrollIntoViewIfNeeded === 'function'
            ? t.scrollIntoViewIfNeeded()
            : t.scrollIntoView({
              scrollMode: 'if-needed',
              block: 'nearest'
            }))
        }
      }
      , [t]),
      yl(Yl || (Yl = vp(['\n    <div class="djs-popup-results" ref=', '>\n      ', '\n    </div>\n  '])), i, a.map(function (e) {
        return yl(Kl || (Kl = vp(['\n        ', '\n        <ul class="djs-popup-group" data-group=', '>\n          ', '\n        </ul>\n      '])), e.name && yl(Jl || (Jl = vp(['\n          <div key=', ' class="entry-header" title=', '>\n            ', '\n          </div>\n        '])), e.id, e.name, e.name), e.id, e.entries.map(function (e) {
          return yl(Xl || (Xl = vp(['\n            <', '\n              key=', '\n              entry=', '\n              selected=', '\n              onMouseEnter=', '\n              onMouseLeave=', '\n              ...', '\n            />\n          '])), ep, e.id, e, e === t, function () {
            return n(e)
          }
          , function () {
            return n(null)
          }
          , o)
        }
        ))
      }
      ))
    }
    function yp (e, t) {
      return t || (t = e.slice(0)),
      Object.freeze(Object.defineProperties(e, {
        raw: {
          value: Object.freeze(t)
        }
      }))
    }
    function bp (e, t) {
      return (function (e) {
        if (Array.isArray(e)) { return e }
      }(e)) || (function (e, t) {
        let n = e == null ? null : typeof Symbol !== 'undefined' && e[Symbol.iterator] || e['@@iterator']
        if (n != null) {
          let r; let o; let i; let a; const s = []; let c = !0; let l = !1
          try {
            if (i = (n = n.call(e)).next,
            t === 0) {
              if (Object(n) !== n) { return }
              c = !1
            } else {
              for (; !(c = (r = i.call(n)).done) && (s.push(r.value),
              s.length !== t); c = !0)
                ;
            }
          } catch (e) {
            l = !0,
            o = e
          } finally {
            try {
              if (!c && n.return != null && (a = n.return(),
              Object(a) !== a)) { return }
            } finally {
              if (l) { throw o }
            }
          }
          return s
        }
      }(e, t)) || (function (e, t) {
        if (e) {
          if (typeof e === 'string') { return Ap(e, t) }
          let n = Object.prototype.toString.call(e).slice(8, -1)
          return n === 'Object' && e.constructor && (n = e.constructor.name),
          n === 'Map' || n === 'Set' ? Array.from(e) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Ap(e, t) : void 0
        }
      }(e, t)) || (function () {
        throw new TypeError('Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
      }())
    }
    function Ap (e, t) {
      (t == null || t > e.length) && (t = e.length)
      for (var n = 0, r = new Array(t); n < t; n++) { r[n] = e[n] }
      return r
    }
    function Ep (e) {
      const t = e.onClose
      const n = e.onSelect
      const r = e.className
      const o = e.headerEntries
      const i = e.position
      const a = e.title
      const s = e.width
      const c = e.scale
      const l = e.search
      const p = e.emptyPlaceholder
      const u = e.entries
      const d = e.onOpened
      const f = e.onClosed
      const h = Ol(function () {
        return !!R(l) && u.length > 5
      }
      , [l, u])
      const m = bp(jl(''), 2)
      const v = m[0]
      const g = m[1]
      const y = Tl(function (e, t) {
        return h
          ? e.filter(function (e) {
            if (!t) { return (e.rank || 0) >= 0 }
            if (!1 === e.searchable) { return !1 }
            const n = [e.description || '', e.label || '', e.search || ''].map(function (e) {
              return e.toLowerCase()
            }
            )
            return t.toLowerCase().split(/\s/g).every(function (e) {
              return n.some(function (t) {
                return t.includes(e)
              }
              )
            }
            )
          }
          )
          : e
      }
      , [h])
      const b = bp(jl(y(u, v)), 2)
      const A = b[0]
      const E = b[1]
      const x = bp(jl(A[0]), 2)
      const w = x[0]
      const _ = x[1]
      const C = Tl(function (e) {
        w && e.includes(w) || _(e[0]),
        E(e)
      }
      , [w, E, _])
      Bl(function () {
        C(y(u, v))
      }
      , [v, u])
      const S = Tl(function (e) {
        let t = A.indexOf(w) + e
        t < 0 && (t = A.length - 1),
        t >= A.length && (t = 0),
        _(A[t])
      }
      , [A, w, _])
      const k = Tl(function (e) {
        return e.key === 'Enter' && w
          ? n(e, w)
          : e.key === 'ArrowUp'
            ? (S(-1),
              e.preventDefault())
            : e.key === 'ArrowDown'
              ? (S(1),
                e.preventDefault())
              : void 0
      }
      , [n, w, S])
      const j = Tl(function (e) {
        an(e.target, 'input') && g(function () {
          return e.target.value
        }
        )
      }
      , [g])
      Bl(function () {
        return d(),
        function () {
          f()
        }
      }
      , [])
      const B = Ol(function () {
        return a || o.length > 0
      }
      , [a, o])
      return yl(np || (np = yp(['\n    <', '\n      onClose=', '\n      onKeyup=', '\n      onKeydown=', '\n      className=', '\n      position=', '\n      width=', '\n      scale=', '\n    >\n      ', '\n      ', '\n    ', '\n    </', '>\n  '])), xp, t, j, k, r, i, s, c, B && yl(rp || (rp = yp(['\n        <div class="djs-popup-header">\n          <h3 class="djs-popup-title" title=', '>', '</h3>\n          ', '\n        </div>\n      '])), a, a, o.map(function (e) {
        return yl(op || (op = yp(['\n            <', '\n              class=', '\n              onClick=', '\n              title=', '\n              data-id=', '\n              onMouseEnter=', '\n              onMouseLeave=', '\n              onFocus=', '\n              onBlur=', '\n            >\n            ', '\n\n              ', '\n            </', '>\n          '])), e.action ? 'button' : 'span', (function (e, t) {
          return Hl('entry', e.className, e.active ? 'active' : '', e.disabled ? 'disabled' : '', t ? 'selected' : '')
        }(e, e === w)), function (t) {
          return n(t, e)
        }
        , e.title || e.label, e.id, function () {
          return _(e)
        }
        , function () {
          return _(null)
        }
        , function () {
          return _(e)
        }
        , function () {
          return _(null)
        }
        , e.imageUrl && yl(ip || (ip = yp(['<img class="djs-popup-entry-icon" src=', ' alt="" />'])), e.imageUrl) || e.imageHtml && yl(ap || (ap = yp(['<div class="djs-popup-entry-icon" dangerouslySetInnerHTML=', ' />'])), {
          __html: e.imageHtml
        }), e.label ? yl(sp || (sp = yp(['\n                <span class="djs-popup-label">', '</span>\n              '])), e.label) : null, e.action ? 'button' : 'span')
      }
      )), u.length > 0 && yl(cp || (cp = yp(['\n        <div class="djs-popup-body">\n\n          ', '\n\n          <', '\n            entries=', '\n            selectedEntry=', '\n            setSelectedEntry=', '\n            onAction=', '\n          />\n        </div>\n      '])), h && yl(lp || (lp = yp(['\n          <div class="djs-popup-search">\n            <svg class="djs-popup-search-icon" width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg">\n              <path fill-rule="evenodd" clip-rule="evenodd" d="M9.0325 8.5H9.625L13.3675 12.25L12.25 13.3675L8.5 9.625V9.0325L8.2975 8.8225C7.4425 9.5575 6.3325 10 5.125 10C2.4325 10 0.25 7.8175 0.25 5.125C0.25 2.4325 2.4325 0.25 5.125 0.25C7.8175 0.25 10 2.4325 10 5.125C10 6.3325 9.5575 7.4425 8.8225 8.2975L9.0325 8.5ZM1.75 5.125C1.75 6.9925 3.2575 8.5 5.125 8.5C6.9925 8.5 8.5 6.9925 8.5 5.125C8.5 3.2575 6.9925 1.75 5.125 1.75C3.2575 1.75 1.75 3.2575 1.75 5.125Z" fill="#22242A"/>\n            </svg>\n            <input type="text" aria-label="', '" />\n          </div>\n          '])), a), gp, A, w, _, n), p && A.length === 0 && yl(pp || (pp = yp(['\n      <div class="djs-popup-no-results">', '</div>\n    '])), z(p) ? p(v) : p), xp)
    }
    function xp (e) {
      const t = e.onClose
      const n = e.onKeydown
      const r = e.onKeyup
      const o = e.className
      const i = e.children
      const a = e.position
      const s = Pl()
      return Dl(function () {
        if (typeof a === 'function') {
          const e = s.current
          const t = a(e)
          e.style.left = ''.concat(t.x, 'px'),
          e.style.top = ''.concat(t.y, 'px')
        }
      }
      , [s.current, a]),
      Dl(function () {
        const e = s.current
        e && (e.querySelector('input') || e).focus()
      }
      , []),
      Bl(function () {
        const e = function (e) {
          if (e.key === 'Escape') {
            return e.preventDefault(),
            t()
          }
        }
        const n = function (e) {
          if (!sn(e.target, '.djs-popup', !0)) { return t() }
        }
        return document.documentElement.addEventListener('keydown', e),
        document.body.addEventListener('click', n),
        function () {
          document.documentElement.removeEventListener('keydown', e),
          document.body.removeEventListener('click', n)
        }
      }
      , []),
      yl(up || (up = yp(['\n    <div\n      class=', '\n      style=', '\n      onKeydown=', '\n      onKeyup=', '\n      ref=', '\n      tabIndex="-1"\n    >\n      ', '\n    </div>\n  '])), Hl('djs-popup', o), (function (e) {
        return {
          transform: 'scale('.concat(e.scale, ')'),
          width: ''.concat(e.width, 'px'),
          'transform-origin': 'top left'
        }
      }(e)), n, r, s, i)
    }
    function wp (e) {
      return wp = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      wp(e)
    }
    function _p (e, t) {
      const n = Object.keys(e)
      if (Object.getOwnPropertySymbols) {
        let r = Object.getOwnPropertySymbols(e)
        t && (r = r.filter(function (t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable
        }
        )),
        n.push.apply(n, r)
      }
      return n
    }
    function Cp (e) {
      for (let t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {}
        t % 2
          ? _p(Object(n), !0).forEach(function (t) {
            let r, o, i
            r = e,
            o = t,
            i = n[t],
            o = (function (e) {
              const t = (function (e, t) {
                if (wp(e) != 'object' || !e) { return e }
                const n = e[Symbol.toPrimitive]
                if (void 0 !== n) {
                  const r = n.call(e, 'string')
                  if (wp(r) != 'object') { return r }
                  throw new TypeError('@@toPrimitive must return a primitive value.')
                }
                return String(e)
              }(e))
              return wp(t) == 'symbol' ? t : t + ''
            }(o)),
            o in r
              ? Object.defineProperty(r, o, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
              })
              : r[o] = i
          }
          )
          : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
            : _p(Object(n)).forEach(function (t) {
              Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
            }
            )
      }
      return e
    }
    function Sp (e, t) {
      return (function (e) {
        if (Array.isArray(e)) { return e }
      }(e)) || (function (e, t) {
        let n = e == null ? null : typeof Symbol !== 'undefined' && e[Symbol.iterator] || e['@@iterator']
        if (n != null) {
          let r; let o; let i; let a; const s = []; let c = !0; let l = !1
          try {
            if (i = (n = n.call(e)).next,
            t === 0) {
              if (Object(n) !== n) { return }
              c = !1
            } else {
              for (; !(c = (r = i.call(n)).done) && (s.push(r.value),
              s.length !== t); c = !0)
                ;
            }
          } catch (e) {
            l = !0,
            o = e
          } finally {
            try {
              if (!c && n.return != null && (a = n.return(),
              Object(a) !== a)) { return }
            } finally {
              if (l) { throw o }
            }
          }
          return s
        }
      }(e, t)) || (function (e, t) {
        if (e) {
          if (typeof e === 'string') { return kp(e, t) }
          let n = Object.prototype.toString.call(e).slice(8, -1)
          return n === 'Object' && e.constructor && (n = e.constructor.name),
          n === 'Map' || n === 'Set' ? Array.from(e) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? kp(e, t) : void 0
        }
      }(e, t)) || (function () {
        throw new TypeError('Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
      }())
    }
    function kp (e, t) {
      (t == null || t > e.length) && (t = e.length)
      for (var n = 0, r = new Array(t); n < t; n++) { r[n] = e[n] }
      return r
    }
    const jp = ['contextPad.close', 'canvas.viewbox.changing', 'commandStack.changed']
    function Bp (e, t, n) {
      const r = this
      this._eventBus = t,
      this._canvas = n,
      this._current = null
      const o = R(e && e.scale)
        ? e.scale
        : {
            min: 1,
            max: 1.5
          }
      this._config = {
        scale: o
      },
      t.on('diagram.destroy', function () {
        r.close()
      }
      ),
      t.on('element.changed', function (e) {
        const t = r.isOpen() && r._current.target
        e.element === t && r.refresh()
      }
      )
    }
    Bp.$inject = ['config.popupMenu', 'eventBus', 'canvas'],
    Bp.prototype._render = function () {
      let e; let t; const n = this; const r = this._current; const o = r.position; const i = r.providerId; const a = r.entries; const s = r.headerEntries; const c = r.emptyPlaceholder; const l = r.options; const p = Object.entries(a).map(function (e) {
        const t = Sp(e, 2)
        return Cp({
          id: t[0]
        }, t[1])
      }
      ); const u = Object.entries(s).map(function (e) {
        const t = Sp(e, 2)
        return Cp({
          id: t[0]
        }, t[1])
      }
      ); const d = o && function (e) {
        return n._ensureVisible(e, o)
      }
      const f = this._updateScale(this._current.container)
      ul(yl(dp || (e = ['\n      <', '\n        onClose=', '\n        onSelect=', '\n        position=', '\n        className=', '\n        entries=', '\n        headerEntries=', '\n        emptyPlaceholder=', '\n        scale=', '\n        onOpened=', '\n        onClosed=', '\n        ...', '\n      />\n    '],
      t || (t = e.slice(0)),
      dp = Object.freeze(Object.defineProperties(e, {
        raw: {
          value: Object.freeze(t)
        }
      }))), Ep, function (e) {
        return n.close(e)
      }
      , function (e, t, r) {
        return n.trigger(e, t, r)
      }
      , d, i, p, u, c, f, this._onOpened.bind(this), this._onClosed.bind(this), Cp({}, l)), this._current.container)
    }
    ,
    Bp.prototype.open = function (e, t, n, r) {
      if (!e) { throw new Error('target is missing') }
      if (!t) { throw new Error('providers for <' + t + '> not found') }
      if (!n) { throw new Error('position is missing') }
      this.isOpen() && this.close()
      const o = this._getContext(e, t)
      const i = o.entries
      const a = o.headerEntries
      const s = o.emptyPlaceholder
      this._current = {
        position: n,
        providerId: t,
        target: e,
        entries: i,
        headerEntries: a,
        emptyPlaceholder: s,
        container: this._createContainer({
          provider: t
        }),
        options: r
      },
      this._emit('open'),
      this._bindAutoClose(),
      this._render()
    }
    ,
    Bp.prototype.refresh = function () {
      if (this.isOpen()) {
        const e = this._current
        const t = e.target
        const n = e.providerId
        const r = this._getContext(t, n)
        const o = r.entries
        const i = r.headerEntries
        const a = r.emptyPlaceholder
        this._current = Cp(Cp({}, this._current), {}, {
          entries: o,
          headerEntries: i,
          emptyPlaceholder: a
        }),
        this._emit('refresh'),
        this._render()
      }
    }
    ,
    Bp.prototype._getContext = function (e, t) {
      const n = this._getProviders(t)
      if (!n || !n.length) { throw new Error('provider for <' + t + '> not found') }
      const r = this._getEntries(e, n)
      const o = this._getHeaderEntries(e, n)
      return {
        entries: r,
        headerEntries: o,
        emptyPlaceholder: this._getEmptyPlaceholder(n),
        empty: !(Object.keys(r).length || Object.keys(o).length)
      }
    }
    ,
    Bp.prototype.close = function () {
      this.isOpen() && (this._emit('close'),
      this.reset(),
      this._current = null)
    }
    ,
    Bp.prototype.reset = function () {
      const e = this._current.container
      ul(null, e),
      Cn(e)
    }
    ,
    Bp.prototype._emit = function (e, t) {
      this._eventBus.fire('popupMenu.'.concat(e), t)
    }
    ,
    Bp.prototype._onOpened = function () {
      this._emit('opened')
    }
    ,
    Bp.prototype._onClosed = function () {
      this._emit('closed')
    }
    ,
    Bp.prototype._createContainer = function (e) {
      const t = this._canvas.getContainer()
      const n = xn('<div class="djs-popup-parent djs-scrollable" data-popup='.concat(e.provider, '></div>'))
      return t.appendChild(n),
      n
    }
    ,
    Bp.prototype._bindAutoClose = function () {
      this._eventBus.once(jp, this.close, this)
    }
    ,
    Bp.prototype._unbindAutoClose = function () {
      this._eventBus.off(jp, this.close, this)
    }
    ,
    Bp.prototype._updateScale = function () {
      let e; let t; const n = this._canvas.zoom(); const r = this._config.scale; let o = n
      return !0 !== r && (!1 === r
        ? (e = 1,
          t = 1)
        : (e = r.min,
          t = r.max),
      R(e) && n < e && (o = e),
      R(t) && n > t && (o = t)),
      o
    }
    ,
    Bp.prototype._ensureVisible = function (e, t) {
      const n = document.documentElement.getBoundingClientRect()
      const r = e.getBoundingClientRect()
      const o = {}
      let i = t.x
      let a = t.y
      return t.x + r.width > n.width && (o.x = !0),
      t.y + r.height > n.height && (o.y = !0),
      o.x && o.y
        ? (i = t.x - r.width,
          a = t.y - r.height)
        : o.x
          ? (i = t.x - r.width,
            a = t.y)
          : o.y && t.y < r.height
            ? (i = t.x,
              a = 10)
            : o.y && (i = t.x,
            a = t.y - r.height),
      t.y < n.top && (a = t.y + r.height),
      {
        x: i,
        y: a
      }
    }
    ,
    Bp.prototype.isEmpty = function (e, t) {
      if (!e) { throw new Error('target is missing') }
      if (!t) { throw new Error('provider ID is missing') }
      const n = this._getProviders(t)
      return !n || !n.length || this._getContext(e, t).empty
    }
    ,
    Bp.prototype.registerProvider = function (e, t, n) {
      n || (n = t,
      t = 1e3),
      this._eventBus.on('popupMenu.getProviders.' + e, t, function (e) {
        e.providers.push(n)
      }
      )
    }
    ,
    Bp.prototype._getProviders = function (e) {
      const t = this._eventBus.createEvent({
        type: 'popupMenu.getProviders.' + e,
        providers: []
      })
      return this._eventBus.fire(t),
      t.providers
    }
    ,
    Bp.prototype._getEntries = function (e, t) {
      let n = {}
      return G(t, function (t) {
        if (t.getPopupMenuEntries) {
          const r = t.getPopupMenuEntries(e)
          z(r)
            ? n = r(n)
            : G(r, function (e, t) {
              n[t] = e
            }
            )
        } else {
          G(t.getEntries(e), function (e) {
            const t = e.id
            if (!t) { throw new Error('entry ID is missing') }
            n[t] = ue(e, ['id'])
          }
          )
        }
      }
      ),
      n
    }
    ,
    Bp.prototype._getHeaderEntries = function (e, t) {
      let n = {}
      return G(t, function (t) {
        if (t.getPopupMenuHeaderEntries) {
          const r = t.getPopupMenuHeaderEntries(e)
          z(r)
            ? n = r(n)
            : G(r, function (e, t) {
              n[t] = e
            }
            )
        } else {
          if (!t.getHeaderEntries) { return }
          G(t.getHeaderEntries(e), function (e) {
            const t = e.id
            if (!t) { throw new Error('entry ID is missing') }
            n[t] = ue(e, ['id'])
          }
          )
        }
      }
      ),
      n
    }
    ,
    Bp.prototype._getEmptyPlaceholder = function (e) {
      const t = e.find(function (e) {
        return z(e.getEmptyPlaceholder)
      }
      )
      return t && t.getEmptyPlaceholder()
    }
    ,
    Bp.prototype.isOpen = function () {
      return !!this._current
    }
    ,
    Bp.prototype.trigger = function (e, t) {
      const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 'click'
      if (e.preventDefault(),
      !t) {
        const r = en(sn(e.delegateTarget || e.target, '.entry', !0), 'data-id')
        t = Cp({
          id: r
        }, this._getEntry(r))
      }
      const o = t.action
      if (!1 !== this._emit('trigger', {
        entry: t,
        event: e
      })) {
        if (z(o)) {
          if (n === 'click') { return o(e, t) }
        } else if (o[n]) { return o[n](e, t) }
      }
    }
    ,
    Bp.prototype._getEntry = function (e) {
      const t = this._current.entries[e] || this._current.headerEntries[e]
      if (!t) { throw new Error('entry not found') }
      return t
    }

    const Dp = {
      __init__: ['popupMenu'],
      popupMenu: ['type', Bp]
    }
    const Pp = {
      align: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2000 2000">\n              <line x1="200" y1="150" x2="200" y2="1850" style="stroke:currentColor;stroke-width:100;stroke-linecap:round;"/>\n              <rect x="500" y="150" width="1300" height="700" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>\n              <rect x="500" y="1150" width="700" height="700" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>\n          </svg>',
      bottom: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1800 1800">\n            <line x1="150" y1="1650" x2="1650" y2="1650" style="stroke:currentColor;stroke-width:100;stroke-linecap:round;"/>\n            <rect x="150" y="350" width="600" height="1300" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>\n            <rect x="1050" y="850" width="600" height="800" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>\n          </svg>',
      center: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1800 1800">\n            <line x1="900" y1="150" x2="900" y2="1650" style="stroke:currentColor;stroke-width:100;stroke-linecap:round;"/>\n            <rect x="250" y="150" width="1300" height="600" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>\n            <rect x="500" y="1050" width="800" height="600" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>\n          </svg>',
      left: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1800 1800">\n            <line x1="100" y1="150" x2="100" y2="1650" style="stroke:currentColor;stroke-width:100;stroke-linecap:round;"/>\n            <rect x="100" y="150" width="1300" height="600" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>\n            <rect x="100" y="1050" width="800" height="600" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>\n          </svg>',
      right: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1800 1800">\n            <line x1="1650" y1="150" x2="1650" y2="1650" style="stroke:currentColor;stroke-width:100;stroke-linecap:round;"/>\n            <rect x="350" y="150" width="1300" height="600" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>\n            <rect x="850" y="1050" width="800" height="600" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>\n          </svg>',
      top: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1800 1800">\n            <line x1="150" y1="150" x2="1650" y2="150" style="stroke:currentColor;stroke-width:100;stroke-linecap:round;"/>\n            <rect x="150" y="150" width="600" height="1300" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>\n            <rect x="1050" y="150" width="600" height="800" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>\n          </svg>',
      middle: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1800 1800">\n            <line x1="150" y1="900" x2="1650" y2="900" style="stroke:currentColor;stroke-width:100;stroke-linecap:round;"/>\n            <rect x="150" y="250" width="600" height="1300" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>\n            <rect x="1050" y="500" width="600" height="800" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>\n          </svg>'
    }
    function Op (e, t, n, r) {
      e.registerProvider(900, this),
      this._contextPad = e,
      this._popupMenu = t,
      this._translate = n,
      this._canvas = r
    }
    Op.$inject = ['contextPad', 'popupMenu', 'translate', 'canvas'],
    Op.prototype.getMultiElementContextPadEntries = function (e) {
      const t = {}
      return this._isAllowed(e) && le(t, this._getEntries(e)),
      t
    }
    ,
    Op.prototype._isAllowed = function (e) {
      return !this._popupMenu.isEmpty(e, 'align-elements')
    }
    ,
    Op.prototype._getEntries = function () {
      const e = this
      return {
        'align-elements': {
          group: 'align-elements',
          title: e._translate('Align elements'),
          html: '<div class="entry">'.concat(Pp.align, '</div>'),
          action: {
            click: function (t, n) {
              const r = e._getMenuPosition(n)
              le(r, {
                cursor: {
                  x: t.x,
                  y: t.y
                }
              }),
              e._popupMenu.open(n, 'align-elements', r)
            }
          }
        }
      }
    }
    ,
    Op.prototype._getMenuPosition = function (e) {
      const t = this._contextPad.getPad(e).html.getBoundingClientRect()
      return {
        x: t.left,
        y: t.bottom + 5
      }
    }

    const Tp = ['left', 'center', 'right', 'top', 'middle', 'bottom']
    function Rp (e, t, n, r) {
      this._alignElements = t,
      this._translate = n,
      this._popupMenu = e,
      this._rules = r,
      e.registerProvider('align-elements', this)
    }
    function Np (e) {
      Es.call(this, e),
      this.init()
    }
    function Mp (e) {
      Np.call(this, e)
    }
    Rp.$inject = ['popupMenu', 'alignElements', 'translate', 'rules'],
    Rp.prototype.getPopupMenuEntries = function (e) {
      const t = {}
      return this._isAllowed(e) && le(t, this._getEntries(e)),
      t
    }
    ,
    Rp.prototype._isAllowed = function (e) {
      return this._rules.allowed('elements.align', {
        elements: e
      })
    }
    ,
    Rp.prototype._getEntries = function (e) {
      const t = this._alignElements
      const n = this._translate
      const r = this._popupMenu
      const o = {}
      return G(Tp, function (i) {
        o['align-elements-' + i] = {
          group: 'align',
          title: n('Align elements ' + i),
          className: 'bjs-align-elements-menu-entry',
          imageHtml: Pp[i],
          action: function () {
            t.trigger(e, i),
            r.close()
          }
        }
      }
      ),
      o
    }
    ,
    Np.$inject = ['eventBus'],
    w(Np, Es),
    Np.prototype.addRule = function (e, t, n) {
      const r = this
      typeof e === 'string' && (e = [e]),
      e.forEach(function (e) {
        r.canExecute(e, t, function (e, t, r) {
          return n(e)
        }
        , !0)
      }
      )
    }
    ,
    Np.prototype.init = function () {}
    ,
    Mp.$inject = ['eventBus'],
    w(Mp, Np),
    Mp.prototype.init = function () {
      this.addRule('elements.align', function (e) {
        let t = W(e.elements, function (e) {
          return !(e.waypoints || e.host || e.labelTarget)
        }
        )
        return !((t = Nt(t)).length < 2) && t
      }
      )
    }

    const Ip = {
      __depends__: [Sc, Dc, Dp],
      __init__: ['alignElementsContextPadProvider', 'alignElementsMenuProvider', 'bpmnAlignElements'],
      alignElementsContextPadProvider: ['type', Op],
      alignElementsMenuProvider: ['type', Rp],
      bpmnAlignElements: ['type', Mp]
    }
    const Lp = 10
    const zp = 50
    const Fp = 250
    function $p (e, t, n, r) {
      for (var o; o = qp(e, n, t);) { n = r(t, n, o) }
      return n
    }
    function Hp (e) {
      return function (t, n, r) {
        const o = {
          x: n.x,
          y: n.y
        }
        return ['x', 'y'].forEach(function (i) {
          const a = e[i]
          if (a) {
            const s = i === 'x' ? 'width' : 'height'
            const c = a.margin
            const l = a.minDistance
            o[i] = c < 0 ? Math.min(r[i] + c - t[s] / 2, n[i] - l + c) : Math.max(r[i] + r[s] + c + t[s] / 2, n[i] + l + c)
          }
        }
        ),
        o
      }
    }
    function qp (e, t, n) {
      const r = {
        x: t.x - n.width / 2,
        y: t.y - n.height / 2,
        width: n.width,
        height: n.height
      }
      const o = (function (e) {
        let t = Wp(e)
        return e.host && (t = t.concat(Wp(e.host))),
        e.attachers && (t = t.concat(e.attachers.reduce(function (e, t) {
          return e.concat(Wp(t))
        }
        , []))),
        t
      }(e))
      return H(o, function (e) {
        return e !== n && Cr(e, r, Lp) === 'intersect'
      }
      )
    }
    function Wp (e) {
      return (t = e,
      t.outgoing.map(function (e) {
        return e.target
      }
      )).concat(function (e) {
        return e.incoming.map(function (e) {
          return e.source
        }
        )
      }(e))
      let t
    }
    function Gp () {
      return !0
    }
    function Up (e, t, n) {
      e.on('autoPlace', 100, function (e) {
        const t = e.shape
        return (function (e, t, n) {
          n || (n = {})
          const r = n.defaultDistance || zp
          const o = _r(e)
          return {
            x: xr(e).right + r + t.width / 2,
            y: o.y
          }
        }(e.source, t))
      }
      ),
      e.on('autoPlace.end', function (e) {
        n.scrollToElement(e.shape)
      }
      ),
      this.append = function (n, r, o) {
        e.fire('autoPlace.start', {
          source: n,
          shape: r
        })
        const i = e.fire('autoPlace', {
          source: n,
          shape: r
        })
        const a = t.appendShape(n, r, i, n.parent, o)
        return e.fire('autoPlace.end', {
          source: n,
          shape: a
        }),
        a
      }
    }
    function Vp (e, t) {
      e.on('autoPlace.end', 500, function (e) {
        t.select(e.shape)
      }
      )
    }
    Up.$inject = ['eventBus', 'modeling', 'canvas'],
    Vp.$inject = ['eventBus', 'selection']
    const Qp = {
      __init__: ['autoPlaceSelectionBehavior'],
      autoPlace: ['type', Up],
      autoPlaceSelectionBehavior: ['type', Vp]
    }
    function Yp (e, t) {
      return Pi(t, 'bpmn:TextAnnotation')
        ? (function (e, t) {
            const n = xr(e)
            let r = {
              x: n.right + t.width / 2,
              y: n.top - 50 - t.height / 2
            }
            return yr(e) && ((r = _r(e)).x += 100,
            r.y -= 50),
            $p(e, t, r, Hp({
              y: {
                margin: -30,
                minDistance: 20
              }
            }))
          }(e, t))
        : Oi(t, ['bpmn:DataObjectReference', 'bpmn:DataStoreReference'])
          ? (function (e, t) {
              const n = xr(e)
              return $p(e, t, {
                x: n.right - 10 + t.width / 2,
                y: n.bottom + 40 + t.width / 2
              }, Hp({
                x: {
                  margin: 30,
                  minDistance: 30
                }
              }))
            }(e, t))
          : Pi(t, 'bpmn:FlowNode')
            ? (function (e, t) {
                const n = xr(e)
                const r = _r(e)
                const o = (function (e, t) {
                  t || (t = {})
                  const n = t.defaultDistance || zp
                  const r = t.direction || 'e'
                  let o = t.filter
                  const i = t.getWeight || function (t) {
                    return t.source === e ? 1 : -1
                  }
                  const a = t.maxDistance || Fp
                  const s = t.reference || 'start'
                  function c (e, t) {
                    return r === 'n' ? s === 'start' ? xr(e).top - xr(t).bottom : s === 'center' ? xr(e).top - _r(t).y : xr(e).top - xr(t).top : r === 'w' ? s === 'start' ? xr(e).left - xr(t).right : s === 'center' ? xr(e).left - _r(t).x : xr(e).left - xr(t).left : r === 's' ? s === 'start' ? xr(t).top - xr(e).bottom : s === 'center' ? _r(t).y - xr(e).bottom : xr(t).bottom - xr(e).bottom : s === 'start' ? xr(t).left - xr(e).right : s === 'center' ? _r(t).x - xr(e).right : xr(t).right - xr(e).right
                  }
                  o || (o = Gp)
                  const l = e.incoming.filter(o).map(function (t) {
                    const n = i(t)
                    const r = n < 0 ? c(t.source, e) : c(e, t.source)
                    return {
                      id: t.source.id,
                      distance: r,
                      weight: n
                    }
                  }
                  )
                  const p = e.outgoing.filter(o).map(function (t) {
                    const n = i(t)
                    const r = n > 0 ? c(e, t.target) : c(t.target, e)
                    return {
                      id: t.target.id,
                      distance: r,
                      weight: n
                    }
                  }
                  )
                  return U(l.concat(p).reduce(function (e, t) {
                    return e[t.id + '__weight_' + t.weight] = t,
                    e
                  }
                  , {}), function (e, t) {
                    const n = t.distance
                    const r = t.weight
                    return n < 0 || n > a || (e[String(n)] || (e[String(n)] = 0),
                    e[String(n)] += 1 * r,
                    (!e.distance || e[e.distance] < e[String(n)]) && (e.distance = n)),
                    e
                  }
                  , {}).distance || n
                }(e, {
                  filter: function (e) {
                    return Pi(e, 'bpmn:SequenceFlow')
                  }
                }))
                let i = 30
                let a = 'left'
                return Pi(e, 'bpmn:BoundaryEvent') && (a = Cr(e, e.host, -25)).indexOf('top') !== -1 && (i *= -1),
                $p(e, t, {
                  x: n.right + o + t.width / 2,
                  y: r.y + Kp(a, 80)
                }, Hp({
                  y: {
                    margin: i,
                    minDistance: 80
                  }
                }))
              }(e, t))
            : void 0
    }
    function Kp (e, t) {
      return e.includes('top') ? -1 * t : e.includes('bottom') ? t : 0
    }
    function Jp (e) {
      e.on('autoPlace', function (e) {
        const t = e.shape
        return Yp(e.source, t)
      }
      )
    }
    Jp.$inject = ['eventBus']
    const Xp = {
      __depends__: [Qp],
      __init__: ['bpmnAutoPlace'],
      bpmnAutoPlace: ['type', Jp]
    }
    function Zp (e, t, n, r) {
      Es.call(this, e),
      this._elementRegistry = t,
      this._modeling = n,
      this._rules = r
      const o = this
      this.postExecuted(['shape.create'], function (e) {
        const t = e.context
        const n = t.hints || {}
        const r = t.shape
        const i = t.parent || t.newParent
        !1 !== n.autoResize && o._expand([r], i)
      }
      ),
      this.postExecuted(['elements.move'], function (e) {
        const t = e.context
        const n = D(J(t.closure.topLevel))
        const r = t.hints
        const i = !r || r.autoResize
        !1 !== i && G(X(n, function (e) {
          return e.parent.id
        }
        ), function (e, t) {
          M(i) && (e = e.filter(function (e) {
            return H(i, ne({
              id: e.id
            }))
          }
          )),
          o._expand(e, t)
        }
        )
      }
      ),
      this.postExecuted(['shape.toggleCollapse'], function (e) {
        const t = e.context
        const n = t.hints
        const r = t.shape
        n && !1 === n.autoResize || r.collapsed || o._expand(r.children || [], r)
      }
      ),
      this.postExecuted(['shape.resize'], function (e) {
        const t = e.context
        const n = t.hints
        const r = t.shape
        const i = r.parent
        n && !1 === n.autoResize || i && o._expand([r], i)
      }
      )
    }
    function eu (e) {
      e.invoke(Zp, this)
    }
    function tu (e) {
      Np.call(this, e)
      const t = this
      this.addRule('element.autoResize', function (e) {
        return t.canResize(e.elements, e.target)
      }
      )
    }
    function nu (e, t) {
      tu.call(this, e),
      this._modeling = t
    }
    Zp.$inject = ['eventBus', 'elementRegistry', 'modeling', 'rules'],
    w(Zp, Es),
    Zp.prototype._getOptimalBounds = function (e, t) {
      const n = this.getOffset(t)
      const r = this.getPadding(t)
      const o = xr(Ft(e))
      const i = xr(t)
      const a = {}
      return o.top - i.top < r.top && (a.top = o.top - n.top),
      o.left - i.left < r.left && (a.left = o.left - n.left),
      i.right - o.right < r.right && (a.right = o.right + n.right),
      i.bottom - o.bottom < r.bottom && (a.bottom = o.bottom + n.bottom),
      wr(le({}, i, a))
    }
    ,
    Zp.prototype._expand = function (e, t) {
      if (typeof t === 'string' && (t = this._elementRegistry.get(t)),
      this._rules.allowed('element.autoResize', {
        elements: e,
        target: t
      })) {
        const n = this._getOptimalBounds(e, t)
        if (function (e, t) {
          return e.x !== t.x || e.y !== t.y || e.width !== t.width || e.height !== t.height
        }(n, t)) {
          const r = (function (e, t) {
            let n = ''
            return e = xr(e),
            t = xr(t),
            e.top > t.top && (n = n.concat('n')),
            e.right < t.right && (n = n.concat('w')),
            e.bottom < t.bottom && (n = n.concat('s')),
            e.left > t.left && (n = n.concat('e')),
            n
          }(pe(t, ['x', 'y', 'width', 'height']), n))
          this.resize(t, n, {
            autoResize: r
          })
          const o = t.parent
          o && this._expand([t], o)
        }
      }
    }
    ,
    Zp.prototype.getOffset = function (e) {
      return {
        top: 60,
        bottom: 60,
        left: 100,
        right: 100
      }
    }
    ,
    Zp.prototype.getPadding = function (e) {
      return {
        top: 2,
        bottom: 2,
        left: 15,
        right: 15
      }
    }
    ,
    Zp.prototype.resize = function (e, t, n) {
      this._modeling.resizeShape(e, t, null, n)
    }
    ,
    eu.$inject = ['injector'],
    w(eu, Zp),
    eu.prototype.resize = function (e, t, n) {
      Pi(e, 'bpmn:Participant') ? this._modeling.resizeLane(e, t, null, n) : this._modeling.resizeShape(e, t, null, n)
    }
    ,
    tu.$inject = ['eventBus'],
    w(tu, Np),
    tu.prototype.canResize = function (e, t) {
      return !1
    }
    ,
    w(nu, tu),
    nu.$inject = ['eventBus', 'modeling'],
    nu.prototype.canResize = function (e, t) {
      if (Pi(t.di, 'bpmndi:BPMNPlane')) { return !1 }
      if (!Pi(t, 'bpmn:Participant') && !Pi(t, 'bpmn:Lane') && !Pi(t, 'bpmn:SubProcess')) { return !1 }
      let n = !0
      return G(e, function (e) {
        (Pi(e, 'bpmn:Lane') || br(e)) && (n = !1)
      }
      ),
      n
    }

    const ru = {
      __init__: ['bpmnAutoResize', 'bpmnAutoResizeProvider'],
      bpmnAutoResize: ['type', eu],
      bpmnAutoResizeProvider: ['type', nu]
    }
    function ou (e, t, n) {
      let r; let o; const i = this; const a = n.get('dragging', !1)
      a && t.on('drag.start', function (n) {
        t.once('drag.move', 1500, function (t) {
          !(function (t) {
            if (!t.hover) {
              const n = t.originalEvent
              const r = i._findTargetGfx(n)
              const o = r && e.get(r)
              r && o && (t.stopPropagation(),
              a.hover({
                element: o,
                gfx: r
              }),
              a.move(n))
            }
          }(t))
        }
        )
      }
      ),
      t.on('element.hover', function (e) {
        r = e.gfx,
        o = e.element
      }
      ),
      t.on('element.hover', 1500, function (e) {
        o && t.fire('element.out', {
          element: o,
          gfx: r
        })
      }
      ),
      t.on('element.out', function () {
        r = null,
        o = null
      }
      ),
      this._findTargetGfx = function (e) {
        let t
        if (e instanceof MouseEvent) {
          return t = Va(e),
          sn(document.elementFromPoint(t.x, t.y), 'svg, .djs-element', !0)
        }
      }
    }
    ou.$inject = ['elementRegistry', 'eventBus', 'injector']
    const iu = {
      __init__: ['hoverFix'],
      hoverFix: ['type', ou]
    }
    const au = Math.round
    const su = 'djs-drag-active'
    function cu (e) {
      e.preventDefault()
    }
    function lu (e, t, n, r) {
      let o; const i = {
        threshold: 5,
        trapClick: !0
      }
      function a (e) {
        const n = t.viewbox()
        const r = t._container.getBoundingClientRect()
        return {
          x: n.x + (e.x - r.left) / n.scale,
          y: n.y + (e.y - r.top) / n.scale
        }
      }
      function s (t, n) {
        n = n || o
        const r = e.createEvent(le({}, n.payload, n.data, {
          isTouch: n.isTouch
        }))
        return !1 !== e.fire('drag.' + t, r) && e.fire(n.prefix + '.' + t, r)
      }
      function c (e, r) {
        let i; const c = o.payload; const l = o.displacement; const p = o.globalStart; const u = Va(e); const d = uc(u, p); const f = o.localStart; const h = a(u); const v = uc(h, f)
        if (!o.active && (r || (i = d,
        Math.sqrt(Math.pow(i.x, 2) + Math.pow(i.y, 2)) > o.threshold))) {
          if (le(c, {
            x: au(f.x + l.x),
            y: au(f.y + l.y),
            dx: 0,
            dy: 0
          }, {
            originalEvent: e
          }),
          !1 === s('start')) { return m() }
          o.active = !0,
          o.keepSelection || (c.previousSelection = n.get(),
          n.select(null)),
          o.cursor && ac(o.cursor),
          t.addMarker(t.getRootElement(), su)
        }
        Ua(e),
        o.active && (le(c, {
          x: au(h.x + l.x),
          y: au(h.y + l.y),
          dx: au(v.x),
          dy: au(v.y)
        }, {
          originalEvent: e
        }),
        s('move'))
      }
      function l (e) {
        let t = !0
        o.active && (e && (o.payload.originalEvent = e,
        Ua(e)),
        t = s('end')),
        !1 === t && s('rejected'),
        s('ended', v(!0 !== t))
      }
      function p (e) {
        Qs('Escape', e) && (cu(e),
        m())
      }
      function u (t) {
        let n
        o.active && (n = lc(e),
        setTimeout(n, 400),
        cu(t)),
        l(t)
      }
      function d (e) {
        c(e)
      }
      function f (e) {
        const t = o.payload
        t.hoverGfx = e.gfx,
        t.hover = e.element,
        s('hover')
      }
      function h (e) {
        s('out')
        const t = o.payload
        t.hoverGfx = null,
        t.hover = null
      }
      function m (e) {
        let t
        if (o) {
          const n = o.active
          n && s('cancel'),
          t = v(e),
          n && s('canceled', t)
        }
      }
      function v (i) {
        let a, v
        s('cleanup'),
        sc(),
        v = o.trapClick ? u : l,
        vn.unbind(document, 'mousemove', c),
        vn.unbind(document, 'dragstart', cu),
        vn.unbind(document, 'selectstart', cu),
        vn.unbind(document, 'mousedown', v, !0),
        vn.unbind(document, 'mouseup', v, !0),
        vn.unbind(document, 'keyup', p),
        vn.unbind(document, 'touchstart', d, !0),
        vn.unbind(document, 'touchcancel', m, !0),
        vn.unbind(document, 'touchmove', c, !0),
        vn.unbind(document, 'touchend', l, !0),
        e.off('element.hover', f),
        e.off('element.out', h),
        t.removeMarker(t.getRootElement(), su)
        const g = o.payload.previousSelection
        return !1 !== i && g && !n.get().length && (function (e) {
          const t = e.filter(function (e) {
            return r.get(e.id)
          }
          )
          t.length && n.select(t)
        }(g)),
        a = o,
        o = null,
        a
      }
      e.on('diagram.destroy', m),
      this.init = function (t, n, r, v) {
        o && m(!1),
        typeof n === 'string' && (v = r,
        r = n,
        n = null)
        let g; let y; let b; let A; let E; const x = (v = le({}, i, v || {})).data || {}
        A = v.trapClick ? u : l,
        t
          ? (g = Ga(t) || t,
            y = Va(t),
            Ua(t),
            g.type === 'dragstart' && cu(g))
          : (g = null,
            y = {
              x: 0,
              y: 0
            }),
        b = a(y),
        n || (n = b),
        E = (function (e) {
          return typeof TouchEvent !== 'undefined' && e instanceof TouchEvent
        }(g)),
        o = le({
          prefix: r,
          data: x,
          payload: {},
          globalStart: y,
          displacement: uc(n, b),
          localStart: b,
          isTouch: E
        }, v),
        v.manual || (E
          ? (vn.bind(document, 'touchstart', d, !0),
            vn.bind(document, 'touchcancel', m, !0),
            vn.bind(document, 'touchmove', c, !0),
            vn.bind(document, 'touchend', l, !0))
          : (vn.bind(document, 'mousemove', c),
            vn.bind(document, 'dragstart', cu),
            vn.bind(document, 'selectstart', cu),
            vn.bind(document, 'mousedown', A, !0),
            vn.bind(document, 'mouseup', A, !0)),
        vn.bind(document, 'keyup', p),
        e.on('element.hover', f),
        e.on('element.out', h)),
        s('init'),
        v.autoActivate && c(t, !0)
      }
      ,
      this.move = c,
      this.hover = f,
      this.out = h,
      this.end = l,
      this.cancel = m,
      this.context = function () {
        return o
      }
      ,
      this.setOptions = function (e) {
        le(i, e)
      }
    }
    lu.$inject = ['eventBus', 'canvas', 'selection', 'elementRegistry']
    const pu = {
      __depends__: [iu, us],
      dragging: ['type', lu]
    }
    function uu (e, t, n) {
      this._canvas = n,
      this._opts = le({
        scrollThresholdIn: [20, 20, 20, 20],
        scrollThresholdOut: [0, 0, 0, 0],
        scrollRepeatTimeout: 15,
        scrollStep: 10
      }, e)
      const r = this
      t.on('drag.move', function (e) {
        const t = r._toBorderPoint(e)
        r.startScroll(t)
      }
      ),
      t.on(['drag.cleanup'], function () {
        r.stopScroll()
      }
      )
    }
    uu.$inject = ['config.autoScroll', 'eventBus', 'canvas'],
    uu.prototype.startScroll = function (e) {
      let t; let n; let r; const o = this._canvas; const i = this._opts; const a = this; const s = o.getContainer().getBoundingClientRect(); const c = [e.x, e.y, s.width - e.x, s.height - e.y]
      this.stopScroll()
      for (var l = 0, p = 0, u = 0; u < 4; u++) {
        t = c[u],
        n = i.scrollThresholdOut[u],
        r = i.scrollThresholdIn[u],
        n < t && t < r && (u === 0 ? l = i.scrollStep : u == 1 ? p = i.scrollStep : u == 2 ? l = -i.scrollStep : u == 3 && (p = -i.scrollStep))
      }
      l === 0 && p === 0 || (o.scroll({
        dx: l,
        dy: p
      }),
      this._scrolling = setTimeout(function () {
        a.startScroll(e)
      }
      , i.scrollRepeatTimeout))
    }
    ,
    uu.prototype.stopScroll = function () {
      clearTimeout(this._scrolling)
    }
    ,
    uu.prototype.setOptions = function (e) {
      this._opts = le({}, this._opts, e)
    }
    ,
    uu.prototype._toBorderPoint = function (e) {
      const t = this._canvas._container.getBoundingClientRect()
      const n = Va(e.originalEvent)
      return {
        x: n.x - t.left,
        y: n.y - t.top
      }
    }

    const du = {
      __depends__: [pu],
      __init__: ['autoScroll'],
      autoScroll: ['type', uu]
    }
    function fu (e) {
      this._commandStack = e.get('commandStack', !1)
    }
    fu.$inject = ['injector'],
    fu.prototype.allowed = function (e, t) {
      let n = !0
      const r = this._commandStack
      return r && (n = r.canExecute(e, t)),
      void 0 === n || n
    }

    const hu = {
      __init__: ['rules'],
      rules: ['type', fu]
    }
    const mu = Math.round
    const vu = Math.max
    const gu = 10
    function yu (e, t) {
      return (function (e, t) {
        let n, r
        for (n = 0; r = e[n]; n++) {
          if (Dn(r, t) <= gu) {
            return {
              point: e[n],
              bendpoint: !0,
              index: n
            }
          }
        }
        return null
      }(e, t)) || (function (e, t) {
        let n; let r; const o = pr((function (e, t) {
          return [['M', e.x, e.y], ['m', 0, -t], ['a', t, t, 0, 1, 1, 0, 2 * t], ['a', t, t, 0, 1, 1, 0, -2 * t], ['z']]
        }(t, gu)), (n = [],
        e.forEach(function (e, t) {
          n.push([t === 0 ? 'M' : 'L', e.x, e.y])
        }
        ),
        n)); const i = o[0]; const a = o[o.length - 1]
        return i
          ? i !== a
            ? i.segment2 !== a.segment2
              ? {
                  point: e[r = vu(i.segment2, a.segment2) - 1],
                  bendpoint: !0,
                  index: r
                }
              : {
                  point: {
                    x: mu(i.x + a.x) / 2,
                    y: mu(i.y + a.y) / 2
                  },
                  index: i.segment2
                }
            : {
                point: {
                  x: mu(i.x),
                  y: mu(i.y)
                },
                index: i.segment2
              }
          : null
      }(e, t))
    }
    function bu (e) {
      return Math.sqrt(Math.pow(e.x, 2) + Math.pow(e.y, 2))
    }
    function Au (e) {
      return Math.atan((e[1].y - e[0].y) / (e[1].x - e[0].x))
    }
    function Eu (e, t) {
      const n = t[0]
      const r = t[1]
      const o = {
        x: r.x - n.x,
        y: r.y - n.y
      }
      const i = (function (e, t, n) {
        const r = [{
          n: e[0] - n[0],
          lambda: t[0]
        }, {
          n: e[1] - n[1],
          lambda: t[1]
        }]
        return -(r[0].n * t[0] + r[1].n * t[1]) / (r[0].lambda * t[0] + r[1].lambda * t[1])
      }([n.x, n.y], [o.x, o.y], [e.x, e.y]))
      return {
        x: n.x + i * o.x,
        y: n.y + i * o.y
      }
    }
    function xu (e, t) {
      const n = Eu(e, t)
      return bu({
        x: n.x - e.x,
        y: n.y - e.y
      })
    }
    function wu (e, t) {
      return bu({
        x: e.x - t.x,
        y: e.y - t.y
      })
    }
    const _u = 'djs-bendpoint'
    const Cu = 'djs-segment-dragger'
    function Su (e, t, n) {
      const r = (function (e, t) {
        let n; const r = Va(t); const o = e._container.getBoundingClientRect()
        n = {
          x: o.left,
          y: o.top
        }
        const i = e.viewbox()
        return {
          x: i.x + (r.x - n.x) / i.scale,
          y: i.y + (r.y - n.y) / i.scale
        }
      }(e, n))
      return yu(t, r)
    }
    function ku (e, t) {
      const n = et('g')
      Ue(n).add(_u),
      Fe(e, n)
      const r = et('circle')
      We(r, {
        cx: 0,
        cy: 0,
        r: 4
      }),
      Ue(r).add('djs-visual'),
      Fe(n, r)
      const o = et('circle')
      return We(o, {
        cx: 0,
        cy: 0,
        r: 10
      }),
      Ue(o).add('djs-hit'),
      Fe(n, o),
      t && Ue(n).add(t),
      n
    }
    function ju (e, t, n) {
      const r = et('g')
      const o = Mn(t, n)
      const i = Tn(t, n)
      return Fe(e, r),
      (function (e, t, n, r) {
        const o = et('g')
        Fe(e, o)
        const i = (function (e, t, n) {
          const r = t.x - e.x
          const o = t.y - e.y
          return Bu(n === 'h' ? r : o)
        }(t, n, r))
        const a = et('rect')
        We(a, {
          x: -9,
          y: -3,
          width: 18,
          height: 6
        }),
        Ue(a).add('djs-visual'),
        Fe(o, a)
        const s = et('rect')
        We(s, {
          x: -i / 2,
          y: -8.5,
          width: i,
          height: 17
        }),
        Ue(s).add('djs-hit'),
        Fe(o, s),
        oo(o, r === 'v' ? 90 : 0)
      }(r, t, n, i)),
      Ue(r).add(Cu),
      Ue(r).add(i === 'h' ? 'horizontal' : 'vertical'),
      ro(r, o.x, o.y),
      r
    }
    function Bu (e) {
      return Math.abs(Math.round(2 * e / 3))
    }
    function Du (e, t, n, r, o) {
      function i (e, t, r) {
        vn.bind(e, t, function (e) {
          n.triggerMouseEvent(t, e, r),
          e.stopPropagation()
        }
        )
      }
      function a (e, n) {
        const r = t.getLayer('overlays')
        let o = wn('.djs-bendpoints[data-element-id="' + Cs(e.id) + '"]', r)
        return !o && n && (We(o = et('g'), {
          'data-element-id': e.id
        }),
        Ue(o).add('djs-bendpoints'),
        Fe(r, o),
        i(o, 'mousedown', e),
        i(o, 'click', e),
        i(o, 'dblclick', e)),
        o
      }
      function s (e, t) {
        return wn('.djs-segment-dragger[data-segment-idx="' + e + '"]', t)
      }
      function c (e, t) {
        t.waypoints.forEach(function (t, n) {
          const r = ku(e)
          Fe(e, r),
          ro(r, t.x, t.y)
        }
        ),
        ku(e, 'floating')
      }
      function l (e, t) {
        for (var n, r, o, a = t.waypoints, s = 1; s < a.length; s++) {
          Tn(n = a[s - 1], r = a[s]) && (We(o = ju(e, n, r), {
            'data-segment-idx': s
          }),
          i(o, 'mousemove', t))
        }
      }
      function p (e) {
        let t = a(e)
        return t || (c(t = a(e, !0), e),
        l(t, e)),
        t
      }
      function u (e) {
        const t = a(e)
        t && ((function (e) {
          G(_n('.' + Cu, e), function (e) {
            Qe(e)
          }
          )
        }(t)),
        (function (e) {
          G(_n('.' + _u, e), function (e) {
            Qe(e)
          }
          )
        }(t)),
        l(t, e),
        c(t, e))
      }
      e.on('connection.changed', function (e) {
        u(e.element)
      }
      ),
      e.on('connection.remove', function (e) {
        const t = a(e.element)
        t && Qe(t)
      }
      ),
      e.on('element.marker.update', function (e) {
        let t; const n = e.element
        n.waypoints && (t = p(n),
        e.add ? Ue(t).add(e.marker) : Ue(t).remove(e.marker))
      }
      ),
      e.on('element.mousemove', function (e) {
        let n; let r; const o = e.element; const i = o.waypoints
        if (i) {
          if (n = a(o, !0),
          !(r = Su(t, i, e.originalEvent))) { return }
          !(function (e, t) {
            const n = wn('.floating', e)
            const r = t.point
            n && ro(n, r.x, r.y)
          }(n, r)),
          r.bendpoint || (function (e, t, n) {
            let r; let o; const i = s(t.index, e); const a = n[t.index - 1]; const c = n[t.index]; const l = t.point; const p = Mn(a, c); const u = Tn(a, c)
            i && (r = (function (e) {
              return wn('.djs-visual', e)
            }(i)),
            o = {
              x: l.x - p.x,
              y: l.y - p.y
            },
            u === 'v' && (o = {
              x: o.y,
              y: o.x
            }),
            ro(r, o.x, o.y))
          }(n, r, i))
        }
      }
      ),
      e.on('element.mousedown', function (e) {
        if (Ka(e)) {
          const n = e.originalEvent
          const i = e.element
          if (i.waypoints) {
            return (function (e, n) {
              let i; const a = n.waypoints; const s = Su(t, a, e)
              if (s) {
                return i = (function (e, t) {
                  let n; let r; const o = e.waypoints
                  return t.index <= 0 || t.bendpoint
                    ? null
                    : (r = Tn((n = {
                        start: o[t.index - 1],
                        end: o[t.index]
                      }).start, n.end))
                        ? Bu(r === 'h' ? n.end.x - n.start.x : n.end.y - n.start.y) / 2
                        : null
                }(n, s)),
                (function (e, t, n) {
                  let r; let o; let i; let a; let s; let c; const l = e.index; const p = e.point
                  return !(l <= 0 || e.bendpoint) && (i = Mn(r = t[l - 1], o = t[l]),
                  a = Tn(r, o),
                  s = Math.abs(p.x - i.x),
                  c = Math.abs(p.y - i.y),
                  a && s <= n && c <= n)
                }(s, a, i))
                  ? o.start(e, n, s.index)
                  : r.start(e, n, s.index, !s.bendpoint),
                !0
              }
            }(n, i))
          }
        }
      }
      ),
      e.on('selection.changed', function (e) {
        const t = e.newSelection[0]
        t && t.waypoints && p(t)
      }
      ),
      e.on('element.hover', function (e) {
        const t = e.element
        t.waypoints && (p(t),
        n.registerEvent(e.gfx, 'mousemove', 'element.mousemove'))
      }
      ),
      e.on('element.out', function (e) {
        n.unregisterEvent(e.gfx, 'mousemove', 'element.mousemove')
      }
      ),
      e.on('element.updateId', function (e) {
        const t = e.element
        const n = e.newId
        if (t.waypoints) {
          const r = a(t)
          r && We(r, {
            'data-element-id': n
          })
        }
      }
      ),
      this.addHandles = p,
      this.updateHandles = u,
      this.getBendpointsContainer = a,
      this.getSegmentDragger = s
    }
    Du.$inject = ['eventBus', 'canvas', 'interactionEvents', 'bendpointMove', 'connectionSegmentMove']
    const Pu = Math.round
    const Ou = 'reconnectStart'
    const Tu = 'reconnectEnd'
    const Ru = 'updateWaypoints'
    function Nu (e, t, n, r, o, i) {
      this._injector = e,
      this.start = function (e, t, i, a) {
        let s; const c = n.getGraphics(t); const l = t.source; const p = t.target; const u = t.waypoints; const d = (s = a || i !== 0 ? a || i !== u.length - 1 ? Ru : Tu : Ou) === Ru ? 'connection.updateWaypoints' : 'connection.reconnect'; let f = o.allowed(d, {
          connection: t,
          source: l,
          target: p
        })
        !1 === f && (f = o.allowed(d, {
          connection: t,
          source: p,
          target: l
        })),
        !1 !== f && r.init(e, 'bendpoint.move', {
          data: {
            connection: t,
            connectionGfx: c,
            context: {
              allowed: f,
              bendpointIndex: i,
              connection: t,
              source: l,
              target: p,
              insert: a,
              type: s
            }
          }
        })
      }
      ,
      t.on('bendpoint.move.hover', function (e) {
        let t; const n = e.context; const r = n.connection; const i = r.source; const a = r.target; const s = e.hover; const c = n.type
        if (n.hover = s,
        s) {
          const l = c === Ru ? 'connection.updateWaypoints' : 'connection.reconnect'
          if (t = n.allowed = o.allowed(l, {
            connection: r,
            source: c === Ou ? s : i,
            target: c === Tu ? s : a
          })) {
            return n.source = c === Ou ? s : i,
            void (n.target = c === Tu ? s : a)
          }
          !1 === t && (t = n.allowed = o.allowed(l, {
            connection: r,
            source: c === Tu ? s : a,
            target: c === Ou ? s : i
          })),
          t && (n.source = c === Tu ? s : a,
          n.target = c === Ou ? s : i)
        }
      }
      ),
      t.on(['bendpoint.move.out', 'bendpoint.move.cleanup'], function (e) {
        const t = e.context
        const n = t.type
        t.hover = null,
        t.source = null,
        t.target = null,
        n !== Ru && (t.allowed = !1)
      }
      ),
      t.on('bendpoint.move.end', function (e) {
        const t = e.context
        const n = t.allowed
        const r = t.bendpointIndex
        const o = t.connection
        const a = t.insert
        let s = o.waypoints.slice()
        const c = t.source
        const l = t.target
        const p = t.type
        const u = t.hints || {}
        const d = {
          x: Pu(e.x),
          y: Pu(e.y)
        }
        if (!n) { return !1 }
        p === Ru
          ? (a ? s.splice(r, 0, d) : s[r] = d,
            u.bendpointMove = {
              insert: a,
              bendpointIndex: r
            },
            s = this.cropWaypoints(o, s),
            i.updateWaypoints(o, (function (e) {
              e = e.slice()
              for (var t, n, r, o = 0; e[o];) {
                t = e[o],
                n = e[o - 1],
                Dn(t, r = e[o + 1]) === 0 || Pn(n, r, t) ? e.splice(o, 1) : o++
              }
              return e
            }(s)), u))
          : (p === Ou
              ? (u.docking = 'source',
                Mu(t) && (u.docking = 'target',
                u.newWaypoints = s.reverse()))
              : p === Tu && (u.docking = 'target',
              Mu(t) && (u.docking = 'source',
              u.newWaypoints = s.reverse())),
            i.reconnect(o, c, l, d, u))
      }
      , this)
    }
    function Mu (e) {
      const t = e.hover
      const n = e.source
      const r = e.target
      const o = e.type
      return o === Ou ? t && r && t === r && n !== r : o === Tu ? t && n && t === n && n !== r : void 0
    }
    Nu.$inject = ['injector', 'eventBus', 'canvas', 'dragging', 'rules', 'modeling'],
    Nu.prototype.cropWaypoints = function (e, t) {
      const n = this._injector.get('connectionDocking', !1)
      if (!n) { return t }
      const r = e.waypoints
      return e.waypoints = t,
      e.waypoints = n.getCroppedWaypoints(e),
      t = e.waypoints,
      e.waypoints = r,
      t
    }

    const Iu = 'updateWaypoints'
    const Lu = 'connect-ok'
    const zu = 'connect-not-ok'
    const Fu = 'connect-hover'
    const $u = 'djs-updating'
    const Hu = 'djs-dragging'
    function qu (e, t, n, r) {
      this._injector = t
      const o = t.get('connectionPreview', !1)
      n.on('bendpoint.move.start', function (e) {
        const t = e.context
        const n = t.bendpointIndex
        const o = t.connection
        const i = t.insert
        const a = o.waypoints
        const s = a.slice()
        t.waypoints = a,
        i && s.splice(n, 0, {
          x: e.x,
          y: e.y
        }),
        o.waypoints = s,
        Ue(t.draggerGfx = ku(r.getLayer('overlays'))).add('djs-dragging'),
        r.addMarker(o, Hu),
        r.addMarker(o, $u)
      }
      ),
      n.on('bendpoint.move.hover', function (e) {
        const t = e.context
        const n = t.allowed
        const o = t.hover
        const i = t.type
        if (o) {
          if (r.addMarker(o, Fu),
          i === Iu) { return }
          n
            ? (r.removeMarker(o, zu),
              r.addMarker(o, Lu))
            : !1 === n && (r.removeMarker(o, Lu),
              r.addMarker(o, zu))
        }
      }
      ),
      n.on(['bendpoint.move.out', 'bendpoint.move.cleanup'], 1100, function (e) {
        const t = e.context
        const n = t.hover
        const o = t.target
        n && (r.removeMarker(n, Fu),
        r.removeMarker(n, o ? Lu : zu))
      }
      ),
      n.on('bendpoint.move.move', function (t) {
        const n = t.context
        const r = n.allowed
        const i = n.bendpointIndex
        const a = n.draggerGfx
        const s = n.hover
        const c = n.type
        const l = n.connection
        const p = l.source
        const u = l.target
        let d = l.waypoints.slice()
        const f = {
          x: t.x,
          y: t.y
        }
        const h = n.hints || {}
        const m = {}
        o && (h.connectionStart && (m.connectionStart = h.connectionStart),
        h.connectionEnd && (m.connectionEnd = h.connectionEnd),
        c === 'reconnectStart'
          ? Mu(n)
            ? (m.connectionEnd = m.connectionEnd || f,
              m.source = u,
              m.target = s || p,
              d = d.reverse())
            : (m.connectionStart = m.connectionStart || f,
              m.source = s || p,
              m.target = u)
          : c === 'reconnectEnd'
            ? Mu(n)
              ? (m.connectionStart = m.connectionStart || f,
                m.source = s || u,
                m.target = p,
                d = d.reverse())
              : (m.connectionEnd = m.connectionEnd || f,
                m.source = p,
                m.target = s || u)
            : (m.noCropping = !0,
              m.noLayout = !0,
              d[i] = f),
        c === Iu && (d = e.cropWaypoints(l, d)),
        m.waypoints = d,
        o.drawPreview(n, r, m)),
        ro(a, t.x, t.y)
      }
      , this),
      n.on(['bendpoint.move.end', 'bendpoint.move.cancel'], 1100, function (e) {
        const t = e.context
        const n = t.connection
        const i = t.draggerGfx
        const a = t.hover
        const s = t.target
        const c = t.waypoints
        n.waypoints = c,
        Qe(i),
        r.removeMarker(n, $u),
        r.removeMarker(n, Hu),
        a && (r.removeMarker(a, Lu),
        r.removeMarker(a, s ? Lu : zu)),
        o && o.cleanUp(t)
      }
      )
    }
    qu.$inject = ['bendpointMove', 'injector', 'eventBus', 'canvas']
    const Wu = 'connect-hover'
    const Gu = 'djs-updating'
    function Uu (e, t, n) {
      return Vu(e, t, e[t] + n)
    }
    function Vu (e, t, n) {
      return {
        x: t === 'x' ? n : e.x,
        y: t === 'y' ? n : e.y
      }
    }
    function Qu (e) {
      return e === 'x' ? 'y' : 'x'
    }
    function Yu (e, t, n) {
      let r, o
      return e.original
        ? e.original
        : (r = _r(t),
          Vu(e, o = Qu(n), r[o]))
    }
    function Ku (e, t, n, r, o, i) {
      const a = e.get('connectionDocking', !1)
      function s (e, t) {
        if (!a) { return t }
        let n; const r = e.waypoints
        return e.waypoints = t,
        n = a.getCroppedWaypoints(e),
        e.waypoints = r,
        n
      }
      function c (e) {
        o.update('connection', e.connection, e.connectionGfx)
      }
      this.start = function (e, t, o) {
        let i; let a; let s; let c; const l = n.getGraphics(t); const p = o - 1; const u = o; const d = t.waypoints; let f = d[p]; let h = d[u]; const m = Su(n, d, e);
        (a = Tn(f, h)) && (s = a === 'v' ? 'x' : 'y',
        p === 0 && (f = Yu(f, t.source, s)),
        u === d.length - 1 && (h = Yu(h, t.target, s)),
        i = {
          connection: t,
          segmentStartIndex: p,
          segmentEndIndex: u,
          segmentStart: f,
          segmentEnd: h,
          axis: s,
          dragPosition: c = m
            ? m.point
            : {
                x: (f.x + h.x) / 2,
                y: (f.y + h.y) / 2
              }
        },
        r.init(e, c, 'connectionSegment.move', {
          cursor: s === 'x' ? 'resize-ew' : 'resize-ns',
          data: {
            connection: t,
            connectionGfx: l,
            context: i
          }
        }))
      }
      ,
      t.on('connectionSegment.move.start', function (e) {
        const t = e.context
        const r = e.connection
        const o = n.getLayer('overlays')
        t.originalWaypoints = r.waypoints.slice(),
        t.draggerGfx = ju(o, t.segmentStart, t.segmentEnd),
        Ue(t.draggerGfx).add('djs-dragging'),
        n.addMarker(r, Gu)
      }
      ),
      t.on('connectionSegment.move.move', function (e) {
        let t; let n; const r = e.context; const o = r.connection; const i = r.segmentStartIndex; const a = r.segmentEndIndex; const l = r.segmentStart; const p = r.segmentEnd; const u = r.axis; const d = r.originalWaypoints.slice(); const f = Uu(l, u, e['d' + u]); const h = Uu(p, u, e['d' + u]); const m = d.length; let v = 0
        d[i] = f,
        d[a] = h,
        i < 2 && (t = Cr(o.source, f),
        i === 1
          ? t === 'intersect' && (d.shift(),
          d[0] = f,
          v--)
          : t !== 'intersect' && (d.unshift(l),
          v++)),
        a > m - 3 && (n = Cr(o.target, h),
        a === m - 2
          ? n === 'intersect' && (d.pop(),
          d[d.length - 1] = h)
          : n !== 'intersect' && d.push(p)),
        r.newWaypoints = o.waypoints = s(o, d),
        (function (e, t, n) {
          let r; let o; let i; let a; let s; let c; const l = e.newWaypoints; const p = (r = n,
          o = l[e.segmentStartIndex + t],
          i = l[e.segmentEndIndex + t],
          a = Qu(e.axis),
          s = Math.max(o[a], i[a]),
          c = Math.min(o[a], i[a]),
          Vu(o, a, Math.min(Math.max(c + 20, r[a]), s - 20)))
          ro(e.draggerGfx, p.x, p.y)
        }(r, v, e)),
        r.newSegmentStartIndex = i + v,
        c(e)
      }
      ),
      t.on('connectionSegment.move.hover', function (e) {
        e.context.hover = e.hover,
        n.addMarker(e.hover, Wu)
      }
      ),
      t.on(['connectionSegment.move.out', 'connectionSegment.move.cleanup'], function (e) {
        const t = e.context.hover
        t && n.removeMarker(t, Wu)
      }
      ),
      t.on('connectionSegment.move.cleanup', function (e) {
        const t = e.context
        const r = t.connection
        t.draggerGfx && Qe(t.draggerGfx),
        n.removeMarker(r, Gu)
      }
      ),
      t.on(['connectionSegment.move.cancel', 'connectionSegment.move.end'], function (e) {
        const t = e.context
        t.connection.waypoints = t.originalWaypoints,
        c(e)
      }
      ),
      t.on('connectionSegment.move.end', function (e) {
        const t = e.context
        const n = t.connection
        let r = t.newWaypoints
        const o = t.newSegmentStartIndex
        r = r.map(function (e) {
          return {
            original: e.original,
            x: Math.round(e.x),
            y: Math.round(e.y)
          }
        }
        )
        const a = (function (e, t) {
          let n = 0
          const r = e.filter(function (r, o) {
            return !Pn(e[o - 1], e[o + 1], r) || (n = o <= t ? n - 1 : n,
            !1)
          }
          )
          return {
            waypoints: r,
            segmentOffset: n
          }
        }(r, o))
        const c = s(n, a.waypoints)
        const l = a.segmentOffset
        const p = {
          segmentMove: {
            segmentStartIndex: t.segmentStartIndex,
            newSegmentStartIndex: o + l
          }
        }
        i.updateWaypoints(n, c, p)
      }
      )
    }
    Ku.$inject = ['injector', 'eventBus', 'canvas', 'dragging', 'graphicsFactory', 'modeling']
    const Ju = Math.abs
    const Xu = Math.round
    function Zu (e) {
      return {
        x: e.x,
        y: e.y
      }
    }
    function ed (e) {
      return {
        x: e.x + e.width,
        y: e.y + e.height
      }
    }
    function td (e, t) {
      return !e || isNaN(e.x) || isNaN(e.y)
        ? t
        : {
            x: Xu(e.x + e.width / 2),
            y: Xu(e.y + e.height / 2)
          }
    }
    function nd (e, t) {
      const n = e.snapped
      return !!n && (typeof t === 'string' ? n[t] : n.x && n.y)
    }
    function rd (e, t, n) {
      if (typeof t !== 'string') { throw new Error('axis must be in [x, y]') }
      if (typeof n !== 'number' && !1 !== n) { throw new Error('value must be Number or false') }
      let r; const o = e[t]; const i = e.snapped = e.snapped || {}
      return !1 === n
        ? i[t] = !1
        : (i[t] = !0,
          r = n - o,
          e[t] += r,
          e['d' + t] += r),
      o
    }
    function od (e) {
      return e.children || []
    }
    const id = Math.abs
    const ad = Math.round
    function sd (e) {
      function t (e, t) {
        if (M(e)) {
          for (let n = e.length; n--;) {
            if (id(e[n] - t) <= 10) { return e[n] }
          }
        } else {
          const r = t % (e = +e)
          if (r < 10) { return t - r }
          if (r > e - 10) { return t - r + e }
        }
        return t
      }
      function n (e, t) {
        return e.waypoints
          ? (r = (function (e, t) {
              for (var n, r = t.waypoints, o = 1 / 0, i = 0; i < r.length - 1; i++) {
                const a = xu(e, [r[i], r[i + 1]])
                a < o && (o = a,
                n = i)
              }
              return [r[n], r[n + 1]]
            }(n = t, e)),
            Eu(n, r))
          : e.width
            ? {
                x: ad(e.width / 2 + e.x),
                y: ad(e.height / 2 + e.y)
              }
            : void 0
        let n, r
      }
      e.on('connectionSegment.move.move', 1500, function (e) {
        let r; let o; const i = (function (e) {
          const t = e.context
          let r = t.snapPoints
          const o = t.connection
          const i = o.waypoints
          const a = t.segmentStart
          const s = t.segmentStartIndex
          const c = t.segmentEnd
          const l = t.segmentEndIndex
          const p = t.axis
          if (r) { return r }
          const u = [i[s - 1], a, c, i[l + 1]]
          return s < 2 && u.unshift(n(o.source, e)),
          l > i.length - 3 && u.unshift(n(o.target, e)),
          t.snapPoints = r = {
            horizontal: [],
            vertical: []
          },
          G(u, function (e) {
            e && (e = e.original || e,
            p === 'y' && r.horizontal.push(e.y),
            p === 'x' && r.vertical.push(e.x))
          }
          ),
          r
        }(e)); const a = e.x; const s = e.y
        if (i) {
          const c = a - (r = t(i.vertical, a))
          const l = s - (o = t(i.horizontal, s))
          le(e, {
            dx: e.dx - c,
            dy: e.dy - l,
            x: r,
            y: o
          }),
          (c || i.vertical.indexOf(a) !== -1) && rd(e, 'x', r),
          (l || i.horizontal.indexOf(s) !== -1) && rd(e, 'y', o)
        }
      }
      ),
      e.on(['connect.hover', 'connect.move', 'connect.end'], 1500, function (e) {
        const t = e.context.hover
        const r = t && n(t, e)
        yr(t) && r && r.x && r.y && (rd(e, 'x', r.x),
        rd(e, 'y', r.y))
      }
      ),
      e.on(['bendpoint.move.move', 'bendpoint.move.end'], 1500, function (e) {
        let r; let o; const i = e.context; const a = (function (e) {
          let t = e.snapPoints
          const n = e.connection.waypoints
          const r = e.bendpointIndex
          if (t) { return t }
          const o = [n[r - 1], n[r + 1]]
          return e.snapPoints = t = {
            horizontal: [],
            vertical: []
          },
          G(o, function (e) {
            e && (e = e.original || e,
            t.horizontal.push(e.y),
            t.vertical.push(e.x))
          }
          ),
          t
        }(i)); const s = i.hover; const c = s && n(s, e); const l = e.x; const p = e.y
        if (a) {
          const u = l - (r = t(c ? a.vertical.concat([c.x]) : a.vertical, l))
          const d = p - (o = t(c ? a.horizontal.concat([c.y]) : a.horizontal, p))
          le(e, {
            dx: e.dx - u,
            dy: e.dy - d,
            x: e.x - u,
            y: e.y - d
          }),
          (u || a.vertical.indexOf(l) !== -1) && rd(e, 'x', r),
          (d || a.horizontal.indexOf(p) !== -1) && rd(e, 'y', o)
        }
      }
      )
    }
    sd.$inject = ['eventBus']
    const cd = {
      __depends__: [pu, hu],
      __init__: ['bendpoints', 'bendpointSnapping', 'bendpointMovePreview'],
      bendpoints: ['type', Du],
      bendpointMove: ['type', Nu],
      bendpointMovePreview: ['type', qu],
      connectionSegmentMove: ['type', Ku],
      bendpointSnapping: ['type', sd]
    }
    function ld (e, t, n, r) {
      function o (e, t) {
        return r.allowed('connection.create', {
          source: e,
          target: t
        })
      }
      e.on('connect.hover', function (e) {
        let t; const n = e.context; const r = n.start; const i = e.hover
        if (n.hover = i,
        !N(t = n.canExecute = o(r, i))) {
          if (!1 !== t) {
            return n.source = r,
            void (n.target = i)
          }
          N(t = n.canExecute = o(i, r)) || !1 !== t && (n.source = i,
          n.target = r)
        }
      }
      ),
      e.on(['connect.out', 'connect.cleanup'], function (e) {
        const t = e.context
        t.hover = null,
        t.source = null,
        t.target = null,
        t.canExecute = !1
      }
      ),
      e.on('connect.end', function (e) {
        const t = e.context
        const r = t.canExecute
        const o = t.connectionStart
        const i = {
          x: e.x,
          y: e.y
        }
        const a = t.source
        const s = t.target
        if (!r) { return !1 }
        let c = null
        const l = {
          connectionStart: pd(t) ? i : o,
          connectionEnd: pd(t) ? o : i
        }
        I(r) && (c = r),
        t.connection = n.connect(a, s, c, l)
      }
      ),
      this.start = function (e, n, r, o) {
        I(r) || (o = r,
        r = _r(n)),
        t.init(e, 'connect', {
          autoActivate: o,
          data: {
            shape: n,
            context: {
              start: n,
              connectionStart: r
            }
          }
        })
      }
    }
    function pd (e) {
      const t = e.hover
      const n = e.source
      const r = e.target
      return t && n && t === n && n !== r
    }
    ld.$inject = ['eventBus', 'dragging', 'modeling', 'rules']
    const ud = 'connect-ok'
    const dd = 'connect-not-ok'
    function fd (e, t, n) {
      const r = e.get('connectionPreview', !1)
      r && t.on('connect.move', function (e) {
        const t = e.context
        const n = t.canExecute
        const o = t.hover
        const i = t.source
        const a = t.start
        const s = t.startPosition
        const c = t.target
        const l = t.connectionStart || s
        const p = t.connectionEnd || {
          x: e.x,
          y: e.y
        }
        let u = l
        let d = p
        pd(t) && (u = p,
        d = l),
        r.drawPreview(t, n, {
          source: i || a,
          target: c || o,
          connectionStart: u,
          connectionEnd: d
        })
      }
      ),
      t.on('connect.hover', 900, function (e) {
        const t = e.context
        const r = e.hover
        const o = t.canExecute
        o !== null && n.addMarker(r, o ? ud : dd)
      }
      ),
      t.on(['connect.out', 'connect.cleanup'], 1100, function (e) {
        const t = e.hover
        t && (n.removeMarker(t, ud),
        n.removeMarker(t, dd))
      }
      ),
      r && t.on('connect.cleanup', function (e) {
        r.cleanUp(e.context)
      }
      )
    }
    fd.$inject = ['injector', 'eventBus', 'canvas']
    const hd = {
      __depends__: [us, hu, pu],
      __init__: ['connectPreview'],
      connect: ['type', ld],
      connectPreview: ['type', fd]
    }
    function md (e, t, n, r) {
      this._canvas = t,
      this._graphicsFactory = n,
      this._elementFactory = r,
      this._connectionDocking = e.get('connectionDocking', !1),
      this._layouter = e.get('layouter', !1)
    }
    md.$inject = ['injector', 'canvas', 'graphicsFactory', 'elementFactory'],
    md.prototype.drawPreview = function (e, t, n) {
      n = n || {}
      let r; let o = e.connectionPreviewGfx; let i = e.getConnection; const a = n.source; const s = n.target; const c = n.waypoints; const l = n.connectionStart; const p = n.connectionEnd; const u = n.noLayout; const d = n.noCropping; const f = n.noNoop; const h = this
      o || (o = e.connectionPreviewGfx = this.createConnectionPreviewGfx()),
      Ye(o),
      i || (i = e.getConnection = (function (e) {
        const t = {}
        return function (n) {
          const r = JSON.stringify(n)
          let o = t[r]
          return o || (o = t[r] = e.apply(null, arguments)),
          o
        }
      }(function (e, t, n) {
        return h.getConnection(e, t, n)
      }
      ))),
      t && (r = i(t, a, s)),
      r
        ? (r.waypoints = c || [],
          this._layouter && !u && (r.waypoints = this._layouter.layoutConnection(r, {
            source: a,
            target: s,
            connectionStart: l,
            connectionEnd: p,
            waypoints: n.waypoints || r.waypoints
          })),
          r.waypoints && r.waypoints.length || (r.waypoints = [a ? _r(a) : l, s ? _r(s) : p]),
          this._connectionDocking && (a || s) && !d && (r.waypoints = this._connectionDocking.getCroppedWaypoints(r, a, s)),
          this._graphicsFactory.drawConnection(o, r, {
            stroke: 'var(--element-dragger-color)'
          }))
        : !f && this.drawNoopPreview(o, n)
    }
    ,
    md.prototype.drawNoopPreview = function (e, t) {
      const n = t.source
      const r = t.target
      const o = t.connectionStart || _r(n)
      const i = t.connectionEnd || _r(r)
      const a = this.cropWaypoints(o, i, n, r)
      Fe(e, this.createNoopConnection(a[0], a[1]))
    }
    ,
    md.prototype.cropWaypoints = function (e, t, n, r) {
      const o = this._graphicsFactory
      const i = n && o.getShapePath(n)
      const a = r && o.getShapePath(r)
      const s = o.getConnectionPath({
        waypoints: [e, t]
      })
      return [e = n && Sr(i, s, !0) || e, t = r && Sr(a, s, !1) || t]
    }
    ,
    md.prototype.cleanUp = function (e) {
      e && e.connectionPreviewGfx && Qe(e.connectionPreviewGfx)
    }
    ,
    md.prototype.getConnection = function (e) {
      const t = (function (e) {
        return I(e) ? e : {}
      }(e))
      return this._elementFactory.createConnection(t)
    }
    ,
    md.prototype.createConnectionPreviewGfx = function () {
      const e = et('g')
      return We(e, {
        pointerEvents: 'none'
      }),
      Ue(e).add('djs-dragger'),
      Fe(this._canvas.getActiveLayer(), e),
      e
    }
    ,
    md.prototype.createNoopConnection = function (e, t) {
      return Tt([e, t], {
        stroke: '#333',
        strokeDasharray: [1],
        strokeWidth: 2,
        'pointer-events': 'none'
      })
    }

    const vd = {
      __init__: ['connectionPreview'],
      connectionPreview: ['type', md]
    }
    const gd = ['marker-start', 'marker-mid', 'marker-end']
    const yd = ['circle', 'ellipse', 'line', 'path', 'polygon', 'polyline', 'path', 'rect']
    function bd (e, t, n, r) {
      this._elementRegistry = e,
      this._canvas = n,
      this._styles = r,
      this._clonedMarkers = {}
      const o = this
      t.on('drag.cleanup', function () {
        o.cleanUp()
      }
      )
    }
    bd.$inject = ['elementRegistry', 'eventBus', 'canvas', 'styles'],
    bd.prototype.cleanUp = function () {
      G(this._clonedMarkers, function (e) {
        Qe(e)
      }
      ),
      this._clonedMarkers = {}
    }
    ,
    bd.prototype.getGfx = function (e) {
      return this._elementRegistry.getGraphics(e)
    }
    ,
    bd.prototype.addDragger = function (e, t, n) {
      const r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 'djs-dragger'
      const o = Ke(n = n || this.getGfx(e))
      const i = n.getBoundingClientRect()
      return this._cloneMarkers(to(o), r),
      We(o, this._styles.cls(r, [], {
        x: i.top,
        y: i.left
      })),
      Fe(t, o),
      We(o, 'data-preview-support-element-id', e.id),
      o
    }
    ,
    bd.prototype.addFrame = function (e, t) {
      const n = et('rect', {
        class: 'djs-resize-overlay',
        width: e.width,
        height: e.height,
        x: e.x,
        y: e.y
      })
      return Fe(t, n),
      We(n, 'data-preview-support-element-id', e.id),
      n
    }
    ,
    bd.prototype._cloneMarkers = function (e) {
      let t; const n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'djs-dragger'; const r = this
      if (e.childNodes) {
        for (let o = 0; o < e.childNodes.length; o++) { r._cloneMarkers(e.childNodes[o], n) }
      }
      t = e,
      yd.indexOf(t.nodeName) !== -1 && gd.forEach(function (t) {
        if (We(e, t)) {
          const o = (function (e, t, n) {
            return wn('marker#' + We(e, t).match(/url\(['"]?#([^'"]*)['"]?\)/)[1], n || document)
          }(e, t, r._canvas.getContainer()))
          r._cloneMarker(e, o, t, n)
        }
      }
      )
    }
    ,
    bd.prototype._cloneMarker = function (e, t, n) {
      const r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 'djs-dragger'
      const o = t.id + '-' + r
      let i = this._clonedMarkers[o]
      if (!i) {
        const a = o + '-clone';
        (i = Ke(t)).id = a,
        Ue(i).add(r),
        this._clonedMarkers[o] = i
        let s = wn('defs', this._canvas._svg)
        s || (s = et('defs'),
        Fe(this._canvas._svg, s)),
        Fe(s, i)
      }
      We(e, n, 'url(#' + this._clonedMarkers[o].id + ')')
    }

    const Ad = {
      __init__: ['previewSupport'],
      previewSupport: ['type', bd]
    }
    function Ed (e) {
      return Ed = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      Ed(e)
    }
    function xd (e, t) {
      (t == null || t > e.length) && (t = e.length)
      for (var n = 0, r = new Array(t); n < t; n++) { r[n] = e[n] }
      return r
    }
    function wd (e, t) {
      for (let n = 0; n < t.length; n++) {
        const r = t[n]
        r.enumerable = r.enumerable || !1,
        r.configurable = !0,
        'value' in r && (r.writable = !0),
        Object.defineProperty(e, _d(r.key), r)
      }
    }
    function _d (e) {
      const t = (function (e, t) {
        if (Ed(e) != 'object' || !e) { return e }
        const n = e[Symbol.toPrimitive]
        if (void 0 !== n) {
          const r = n.call(e, 'string')
          if (Ed(r) != 'object') { return r }
          throw new TypeError('@@toPrimitive must return a primitive value.')
        }
        return String(e)
      }(e))
      return Ed(t) == 'symbol' ? t : t + ''
    }
    const Cd = 'complex-preview'
    const Sd = (function () {
      return e = function e (t, n, r) {
        !(function (e, t) {
          if (!(e instanceof t)) { throw new TypeError('Cannot call a class as a function') }
        }(this, e)),
        this._canvas = t,
        this._graphicsFactory = n,
        this._previewSupport = r,
        this._markers = []
      }
      ,
      t = [{
        key: 'create',
        value: function (e) {
          const t = this
          this.cleanUp()
          const n = e.created
          const r = void 0 === n ? [] : n
          const o = e.moved
          const i = void 0 === o ? [] : o
          const a = e.removed
          const s = void 0 === a ? [] : a
          const c = e.resized
          const l = void 0 === c ? [] : c
          const p = this._canvas.getLayer(Cd)
          r.filter(function (e) {
            return !(function (e) {
              return e.hidden
            }(e))
          }
          ).forEach(function (e) {
            let n
            yr(e)
              ? (n = t._graphicsFactory._createContainer('connection', et('g')),
                t._graphicsFactory.drawConnection(to(n), e))
              : (n = t._graphicsFactory._createContainer('shape', et('g')),
                t._graphicsFactory.drawShape(to(n), e),
                ro(n, e.x, e.y)),
            t._previewSupport.addDragger(e, p, n)
          }
          ),
          i.forEach(function (e) {
            const n = e.element
            const r = e.delta
            t._previewSupport.addDragger(n, p, void 0, 'djs-dragging'),
            t._canvas.addMarker(n, 'djs-element-hidden'),
            t._markers.push([n, 'djs-element-hidden'])
            const o = t._previewSupport.addDragger(n, p)
            yr(n) ? ro(o, r.x, r.y) : ro(o, n.x + r.x, n.y + r.y)
          }
          ),
          s.forEach(function (e) {
            t._previewSupport.addDragger(e, p, void 0, 'djs-dragging'),
            t._canvas.addMarker(e, 'djs-element-hidden'),
            t._markers.push([e, 'djs-element-hidden'])
          }
          ),
          l.forEach(function (e) {
            const n = e.shape
            const r = e.bounds
            t._canvas.addMarker(n, 'djs-hidden'),
            t._markers.push([n, 'djs-hidden']),
            t._previewSupport.addDragger(n, p, void 0, 'djs-dragging')
            const o = t._graphicsFactory._createContainer('shape', et('g'))
            t._graphicsFactory.drawShape(to(o), n, {
              width: r.width,
              height: r.height
            }),
            ro(o, r.x, r.y),
            t._previewSupport.addDragger(n, p, o)
          }
          )
        }
      }, {
        key: 'cleanUp',
        value: function () {
          const e = this
          Ye(this._canvas.getLayer(Cd)),
          this._markers.forEach(function (t) {
            let n; let r; const o = (r = 2,
            (function (e) {
              if (Array.isArray(e)) { return e }
            }(n = t)) || (function (e, t) {
              let n = e == null ? null : typeof Symbol !== 'undefined' && e[Symbol.iterator] || e['@@iterator']
              if (n != null) {
                let r; let o; let i; let a; const s = []; let c = !0; let l = !1
                try {
                  if (i = (n = n.call(e)).next,
                  t === 0) {
                    if (Object(n) !== n) { return }
                    c = !1
                  } else {
                    for (; !(c = (r = i.call(n)).done) && (s.push(r.value),
                    s.length !== t); c = !0)
                      ;
                  }
                } catch (e) {
                  l = !0,
                  o = e
                } finally {
                  try {
                    if (!c && n.return != null && (a = n.return(),
                    Object(a) !== a)) { return }
                  } finally {
                    if (l) { throw o }
                  }
                }
                return s
              }
            }(n, r)) || (function (e, t) {
              if (e) {
                if (typeof e === 'string') { return xd(e, t) }
                let n = Object.prototype.toString.call(e).slice(8, -1)
                return n === 'Object' && e.constructor && (n = e.constructor.name),
                n === 'Map' || n === 'Set' ? Array.from(e) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? xd(e, t) : void 0
              }
            }(n, r)) || (function () {
              throw new TypeError('Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
            }())); const i = o[0]; const a = o[1]
            return e._canvas.removeMarker(i, a)
          }
          ),
          this._markers = [],
          this._previewSupport.cleanUp()
        }
      }, {
        key: 'show',
        value: function () {
          this._canvas.showLayer(Cd)
        }
      }, {
        key: 'hide',
        value: function () {
          this._canvas.hideLayer(Cd)
        }
      }],
      t && wd(e.prototype, t),
      Object.defineProperty(e, 'prototype', {
        writable: !1
      }),
      e
      let e, t
    }())
    Sd.$inject = ['canvas', 'graphicsFactory', 'previewSupport']
    const kd = {
      __depends__: [Ad],
      __init__: ['complexPreview'],
      complexPreview: ['type', Sd]
    }
    const jd = ['top', 'bottom', 'left', 'right']
    function Bd (e, t) {
      function n (e) {
        if (aa(e)) {
          const n = (function (e) {
            const t = _r(e.label)
            const n = Dd(_r(e), t)
            if (r = n,
            jd.indexOf(r) !== -1) {
              var r; let o = (function (e) {
                const t = _r(e)
                const n = [].concat(e.incoming.map(function (e) {
                  return e.waypoints[e.waypoints.length - 2]
                }
                ), e.outgoing.map(function (e) {
                  return e.waypoints[1]
                }
                )).map(function (e) {
                  return Dd(t, e)
                }
                )
                return n
              }(e))
              if (e.host) {
                const i = (function (e) {
                  let t; const n = e.host; const r = Cr(_r(e), n)
                  return t = r.indexOf('-') >= 0 ? r.split('-') : [r],
                  jd.filter(function (e) {
                    return t.indexOf(e) === -1
                  }
                  )
                }(e))
                o = o.concat(i)
              }
              const a = jd.filter(function (e) {
                return o.indexOf(e) === -1
              }
              )
              if (a.indexOf(n) === -1) { return a[0] }
            }
          }(e))
          n && (function (e, n) {
            const r = _r(e)
            const o = e.label
            const i = _r(o)
            if (o.parent) {
              let a; const s = xr(e)
              switch (n) {
                case 'top':
                  a = {
                    x: r.x,
                    y: s.top - 10 - o.height / 2
                  }
                  break
                case 'left':
                  a = {
                    x: s.left - 10 - o.width / 2,
                    y: r.y
                  }
                  break
                case 'bottom':
                  a = {
                    x: r.x,
                    y: s.bottom + 10 + o.height / 2
                  }
                  break
                case 'right':
                  a = {
                    x: s.right + 10 + o.width / 2,
                    y: r.y
                  }
              }
              const c = uc(a, i)
              t.moveShape(o, c)
            }
          }(e, n))
        }
      }
      Es.call(this, e),
      this.postExecuted(['connection.create', 'connection.layout', 'connection.updateWaypoints'], function (e) {
        const t = e.context
        const r = t.connection
        const o = r.source
        const i = r.target
        !1 !== (t.hints || {}).createElementsBehavior && (n(o),
        n(i))
      }
      ),
      this.postExecuted(['label.create'], function (e) {
        const t = e.context
        const r = t.shape
        !1 !== (t.hints || {}).createElementsBehavior && n(r.labelTarget)
      }
      ),
      this.postExecuted(['elements.create'], function (e) {
        const t = e.context
        const r = t.elements
        !1 !== (t.hints || {}).createElementsBehavior && r.forEach(function (e) {
          n(e)
        }
        )
      }
      )
    }
    function Dd (e, t) {
      return Cr(t, e, 5)
    }
    function Pd (e) {
      Es.call(this, e),
      this.preExecute('shape.append', function (e) {
        const t = e.source
        const n = e.shape
        e.position || (Pi(n, 'bpmn:TextAnnotation')
          ? e.position = {
            x: t.x + t.width / 2 + 75,
            y: t.y - 50 - n.height / 2
          }
          : e.position = {
            x: t.x + t.width + 80 + n.width / 2,
            y: t.y + t.height / 2
          })
      }
      , !0)
    }
    function Od (e, t) {
      e.invoke(Es, this),
      this.postExecute('shape.move', function (e) {
        const n = e.newParent
        const r = e.shape
        G(W(r.incoming.concat(r.outgoing), function (e) {
          return Pi(e, 'bpmn:Association')
        }
        ), function (e) {
          t.moveConnection(e, {
            x: 0,
            y: 0
          }, n)
        }
        )
      }
      , !0)
    }
    function Td (e, t) {
      t.invoke(Es, this),
      this._bpmnReplace = e
      const n = this
      this.postExecuted('elements.create', 500, function (e) {
        let t = e.elements
        (t = t.filter(function (e) {
          return Rd(e, e.host)
        }
        )).length === 1 && t.map(function (e) {
          return t.indexOf(e)
        }
        ).forEach(function (r) {
          const o = t[r]
          e.elements[r] = n._replaceShape(t[r], o)
        }
        )
      }
      , !0),
      this.preExecute('elements.move', 500, function (e) {
        const t = e.shapes
        const r = e.newHost
        if (t.length === 1) {
          const o = t[0]
          Rd(o, r) && (e.shapes = [n._replaceShape(o, r)])
        }
      }
      , !0)
    }
    function Rd (e, t) {
      return !br(e) && Oi(e, ['bpmn:IntermediateThrowEvent', 'bpmn:IntermediateCatchEvent']) && !!t
    }
    function Nd (e, t) {
      function n (e) {
        return W(e.attachers, function (e) {
          return Pi(e, 'bpmn:BoundaryEvent')
        }
        )
      }
      Es.call(this, e),
      this.postExecute('connection.create', function (e) {
        const r = e.context.source
        const o = e.context.target
        const i = n(o)
        Pi(r, 'bpmn:EventBasedGateway') && Pi(o, 'bpmn:ReceiveTask') && i.length > 0 && t.removeElements(i)
      }
      ),
      this.postExecute('connection.reconnect', function (e) {
        const r = e.context.oldSource
        const o = e.context.newSource
        Pi(r, 'bpmn:Gateway') && Pi(o, 'bpmn:EventBasedGateway') && G(o.outgoing, function (e) {
          const r = e.target
          const o = n(r)
          Pi(r, 'bpmn:ReceiveTask') && o.length > 0 && t.removeElements(o)
        }
        )
      }
      )
    }
    function Md (e, t) {
      let n = typeof Symbol !== 'undefined' && e[Symbol.iterator] || e['@@iterator']
      if (!n) {
        if (Array.isArray(e) || (n = (function (e, t) {
          if (e) {
            if (typeof e === 'string') { return Id(e, t) }
            let n = Object.prototype.toString.call(e).slice(8, -1)
            return n === 'Object' && e.constructor && (n = e.constructor.name),
            n === 'Map' || n === 'Set' ? Array.from(e) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Id(e, t) : void 0
          }
        }(e))) || t && e && typeof e.length === 'number') {
          n && (e = n)
          let r = 0
          const o = function () {}
          return {
            s: o,
            n: function () {
              return r >= e.length
                ? {
                    done: !0
                  }
                : {
                    done: !1,
                    value: e[r++]
                  }
            },
            e: function (e) {
              throw e
            },
            f: o
          }
        }
        throw new TypeError('Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
      }
      let i; let a = !0; let s = !1
      return {
        s: function () {
          n = n.call(e)
        },
        n: function () {
          const e = n.next()
          return a = e.done,
          e
        },
        e: function (e) {
          s = !0,
          i = e
        },
        f: function () {
          try {
            a || n.return == null || n.return()
          } finally {
            if (s) { throw i }
          }
        }
      }
    }
    function Id (e, t) {
      (t == null || t > e.length) && (t = e.length)
      for (var n = 0, r = new Array(t); n < t; n++) { r[n] = e[n] }
      return r
    }
    function Ld (e, t, n) {
      function r (e) {
        t.updateProperties(e, {
          isForCompensation: !0
        })
      }
      function o (e) {
        t.updateProperties(e, {
          isForCompensation: void 0
        })
      }
      Es.call(this, e),
      this.preExecute('shape.replace', function (e) {
        let n; const r = e.newData; const o = e.oldShape
        if (Fd(e.oldShape) && r.eventDefinitionType !== 'bpmn:CompensateEventDefinition' || r.type !== 'bpmn:BoundaryEvent') {
          const i = o.outgoing.find(function (e) {
            return zd(e.target)
          }
          )
          i && i.target && (e._connectionTarget = i.target)
        } else if (!Fd(e.oldShape) && r.eventDefinitionType === 'bpmn:CompensateEventDefinition' && r.type === 'bpmn:BoundaryEvent') {
          const a = o.outgoing.find(function (e) {
            return $d(e.target)
          }
          )
          a && a.target && (e._connectionTarget = a.target),
          n = o.outgoing.filter(function (e) {
            return Pi(e, 'bpmn:SequenceFlow')
          }
          ),
          t.removeElements(n)
        }
      }
      , !0),
      this.postExecuted('shape.replace', function (e) {
        const n = e._connectionTarget
        const r = e.newShape
        n && t.connect(r, n)
      }
      , !0),
      this.preExecute('connection.create', function (e) {
        let n; let o; const i = e.connection; const a = e.source; const s = e.target
        Fd(a) && $d(s) && (r(s),
        n = [i],
        o = a.outgoing.filter(function (e) {
          return Pi(e, 'bpmn:Association')
        }
        ),
        o.filter(function (e) {
          return zd(e.target) && !n.includes(e)
        }
        ).forEach(function (e) {
          return t.removeConnection(e)
        }
        ))
      }
      , !0),
      this.postExecuted('connection.delete', function (e) {
        const t = e.source
        const n = e.target
        Fd(t) && zd(n) && o(n)
      }
      , !0),
      this.postExecuted('connection.reconnect', function (e) {
        const t = e.newTarget
        const n = e.oldSource
        const i = e.oldTarget
        if (i !== t) {
          const a = n
          zd(i) && o(i),
          Fd(a) && $d(t) && r(t)
        }
      }
      , !0),
      this.postExecuted('element.updateProperties', function (e) {
        const r = e.element
        zd(r)
          ? ((function (e) {
              let r; const o = Md(e.incoming)
              try {
                for (o.s(); !(r = o.n()).done;) {
                  const i = r.value
                  n.canConnect(i.source, e) || t.removeConnection(i)
                }
              } catch (e) {
                o.e(e)
              } finally {
                o.f()
              }
              let a; const s = Md(e.outgoing)
              try {
                for (s.s(); !(a = s.n()).done;) {
                  const c = a.value
                  n.canConnect(e, c.target) || t.removeConnection(c)
                }
              } catch (e) {
                s.e(e)
              } finally {
                s.f()
              }
            }(r)),
            (function (e) {
              const n = e.attachers.slice()
              n.length && t.removeElements(n)
            }(r)))
          : $d(r) && (function (e) {
            const n = e.incoming.filter(function (e) {
              return Fd(e.source)
            }
            )
            t.removeElements(n)
          }(r))
      }
      , !0)
    }
    function zd (e) {
      const t = Ti(e)
      return t && t.get('isForCompensation')
    }
    function Fd (e) {
      return e && Pi(e, 'bpmn:BoundaryEvent') && na(e, 'bpmn:CompensateEventDefinition')
    }
    function $d (e) {
      return e && Pi(e, 'bpmn:Activity') && !ta(e)
    }
    function Hd (e, t) {
      for (F(t) && (t = [t]); e = e.parent;) {
        if (Oi(e, t)) { return e }
      }
      return null
    }
    function qd (e) {
      e.invoke(Es, this),
      this.preExecute('shape.create', 1500, function (e) {
        const t = e.context
        const n = t.parent
        const r = t.shape
        Pi(n, 'bpmn:Lane') && !Pi(r, 'bpmn:Lane') && (t.parent = Hd(n, 'bpmn:Participant'))
      }
      )
    }
    function Wd (e, t) {
      Es.call(this, e),
      this.preExecute('shape.create', function (e) {
        const n = e.context.shape
        if (Pi(n, 'bpmn:DataObjectReference') && n.type !== 'label') {
          const r = t.create('bpmn:DataObject')
          n.businessObject.dataObjectRef = r
        }
      }
      )
    }
    w(Bd, Es),
    Bd.$inject = ['eventBus', 'modeling'],
    w(Pd, Es),
    Pd.$inject = ['eventBus'],
    w(Od, Es),
    Od.$inject = ['injector', 'modeling'],
    Td.$inject = ['bpmnReplace', 'injector'],
    w(Td, Es),
    Td.prototype._replaceShape = function (e, t) {
      let n; const r = (n = Ti(e).eventDefinitions) && n[0]; const o = {
        type: 'bpmn:BoundaryEvent',
        host: t
      }
      return r && (o.eventDefinitionType = r.$type),
      this._bpmnReplace.replaceElement(e, o, {
        layoutConnection: !1
      })
    }
    ,
    Nd.$inject = ['eventBus', 'modeling'],
    w(Nd, Es),
    w(Ld, Es),
    Ld.$inject = ['eventBus', 'modeling', 'bpmnRules'],
    qd.$inject = ['injector'],
    w(qd, Es),
    Wd.$inject = ['eventBus', 'bpmnFactory'],
    w(Wd, Es)
    const Gd = 2e3
    function Ud (e, t, n) {
      function r () {
        const t = e.getRootElement()
        return Pi(t, 'bpmn:Collaboration') ? t : n.makeCollaboration()
      }
      Es.call(this, t),
      t.on(['create.start', 'shape.move.start'], Gd, function (t) {
        const n = t.context
        const r = n.shape
        const o = e.getRootElement()
        if (Pi(r, 'bpmn:Participant') && Pi(o, 'bpmn:Process') && o.children.length) {
          const i = o.children.filter(function (e) {
            return !Pi(e, 'bpmn:Group') && !br(e) && !yr(e)
          }
          )
          if (i.length) {
            const a = Ft(i)
            const s = (function (e, t) {
              t = {
                width: t.width + 40 + 30,
                height: t.height + 40
              }
              const n = Math.max(e.width, t.width)
              const r = Math.max(e.height, t.height)
              return {
                x: -n / 2,
                y: -r / 2,
                width: n,
                height: r
              }
            }(r, a))
            le(r, s),
            n.createConstraints = (function (e, t) {
              return {
                bottom: (t = xr(t)).top + e.height / 2 - 20,
                left: t.right - e.width / 2 + 20,
                top: t.bottom - e.height / 2 + 20,
                right: t.left + e.width / 2 - 20 - 30
              }
            }(r, a))
          }
        }
      }
      ),
      t.on('create.start', Gd, function (n) {
        const r = n.context.shape
        const o = e.getRootElement()
        const i = e.getGraphics(o)
        function a (e) {
          e.element = o,
          e.gfx = i
        }
        Pi(r, 'bpmn:Participant') && Pi(o, 'bpmn:Process') && (t.on('element.hover', Gd, a),
        t.once('create.cleanup', function () {
          t.off('element.hover', a)
        }
        ))
      }
      ),
      this.preExecute('elements.create', Gd, function (e) {
        let t; const n = e.elements; const o = e.parent; const i = (function (e) {
          return H(e, function (e) {
            return Pi(e, 'bpmn:Participant')
          }
          )
        }(n))
        i && Pi(o, 'bpmn:Process') && (e.parent = r(),
        (t = e.hints = e.hints || {}).participant = i,
        t.process = o,
        t.processRef = Ti(i).get('processRef'))
      }
      , !0),
      this.preExecute('shape.create', function (e) {
        const t = e.parent
        const n = e.shape
        Pi(n, 'bpmn:Participant') && Pi(t, 'bpmn:Process') && (e.parent = r(),
        e.process = t,
        e.processRef = Ti(n).get('processRef'))
      }
      , !0),
      this.execute('shape.create', function (e) {
        const t = e.hints || {}
        const n = e.process || t.process
        const r = e.shape
        const o = t.participant
        !n || o && r !== o || Ti(r).set('processRef', Ti(n))
      }
      , !0),
      this.revert('shape.create', function (e) {
        const t = e.hints || {}
        const n = e.process || t.process
        const r = e.processRef || t.processRef
        const o = e.shape
        const i = t.participant
        !n || i && o !== i || Ti(o).set('processRef', r)
      }
      , !0),
      this.postExecute('shape.create', function (e) {
        const t = e.hints || {}
        const r = e.process || e.hints.process
        const o = e.shape
        const i = t.participant
        if (r) {
          const a = r.children.slice()
          i
            ? o === i && n.moveElements(a, {
              x: 0,
              y: 0
            }, i)
            : n.moveElements(a, {
              x: 0,
              y: 0
            }, o)
        }
      }
      , !0)
    }
    Ud.$inject = ['canvas', 'eventBus', 'modeling'],
    w(Ud, Es)
    const Vd = '__targetRef_placeholder'
    function Qd (e, t) {
      function n (e, n) {
        const r = e.get('properties')
        let o = H(r, function (e) {
          return e.name === Vd
        }
        )
        return !o && n && kn(r, o = t.create('bpmn:Property', {
          name: Vd
        })),
        o
      }
      function r (e, t) {
        const r = n(e)
        r && ((function (e, t, n) {
          return H(e.get('dataInputAssociations'), function (e) {
            return e !== n && e.targetRef === t
          }
          )
        }(e, r, t)) || Sn(e.get('properties'), r))
      }
      function o (e) {
        let t; const o = e.context; const i = o.connection; const a = i.businessObject; const s = i.target; const c = s && s.businessObject; const l = o.newTarget; const p = l && l.businessObject; const u = o.oldTarget || o.target; const d = u && u.businessObject; const f = i.businessObject
        d && d !== c && r(d, a),
        p && p !== c && r(p, a),
        c
          ? (t = n(c, !0),
            f.targetRef = t)
          : f.targetRef = null
      }
      Es.call(this, e),
      this.executed(['connection.create', 'connection.delete', 'connection.move', 'connection.reconnect'], Yd(o)),
      this.reverted(['connection.create', 'connection.delete', 'connection.move', 'connection.reconnect'], Yd(o))
    }
    function Yd (e) {
      return function (t) {
        if (Pi(t.context.connection, 'bpmn:DataInputAssociation')) { return e(t) }
      }
    }
    function Kd (e) {
      this._bpmnUpdater = e
    }
    function Jd (e, t, n, r) {
      function o (e) {
        return e.children.filter(function (e) {
          return Pi(e, 'bpmn:DataStoreReference') && !e.labelTarget
        }
        )
      }
      function i (e, r) {
        const o = e.businessObject || e
        if (r = r || n.filter(function (e) {
          return Pi(e, 'bpmn:Participant') && Ti(e).processRef
        }
        )[0]) {
          const i = r.businessObject || r
          t.execute('dataStore.updateContainment', {
            dataStoreBo: o,
            dataStoreDi: Ri(e),
            newSemanticParent: i.processRef || i,
            newDiParent: Ri(r)
          })
        }
      }
      Es.call(this, r),
      t.registerHandler('dataStore.updateContainment', Kd),
      this.preExecute('shape.create', function (e) {
        const t = e.context
        const n = t.shape
        Pi(n, 'bpmn:DataStoreReference') && n.type !== 'label' && (t.hints || (t.hints = {}),
        t.hints.autoResize = !1)
      }
      ),
      this.preExecute('elements.move', function (e) {
        const t = e.context
        const n = t.shapes
        n.filter(function (e) {
          return Pi(e, 'bpmn:DataStoreReference')
        }
        ).length && (t.hints || (t.hints = {}),
        t.hints.autoResize = n.filter(function (e) {
          return !Pi(e, 'bpmn:DataStoreReference')
        }
        ))
      }
      ),
      this.postExecute('shape.create', function (e) {
        const t = e.context.shape
        const n = t.parent
        Pi(t, 'bpmn:DataStoreReference') && t.type !== 'label' && Pi(n, 'bpmn:Collaboration') && i(t)
      }
      ),
      this.postExecute('shape.move', function (e) {
        const t = e.context
        const n = t.shape
        const r = t.oldParent
        const o = n.parent
        Pi(r, 'bpmn:Collaboration') || Pi(n, 'bpmn:DataStoreReference') && n.type !== 'label' && Pi(o, 'bpmn:Collaboration') && i(n, Pi(r, 'bpmn:Participant')
          ? r
          : (function (e, t) {
              for (; e.parent;) {
                if (Pi(e.parent, 'bpmn:Participant')) { return e.parent }
                e = e.parent
              }
            }(r)))
      }
      ),
      this.postExecute('shape.delete', function (t) {
        const n = t.context.shape
        const r = e.getRootElement()
        Oi(n, ['bpmn:Participant', 'bpmn:SubProcess']) && Pi(r, 'bpmn:Collaboration') && o(r).filter(function (e) {
          return (function (e, t) {
            for (let n = e.businessObject || e, r = t.businessObject || t; n.$parent;) {
              if (n.$parent === r.processRef || r) { return !0 }
              n = n.$parent
            }
            return !1
          }(e, n))
        }
        ).forEach(function (e) {
          i(e)
        }
        )
      }
      ),
      this.postExecute('canvas.updateRoot', function (e) {
        const t = e.context
        const n = t.oldRoot
        const r = t.newRoot
        o(n).forEach(function (e) {
          Pi(r, 'bpmn:Process') && i(e, r)
        }
        )
      }
      )
    }
    function Xd (e) {
      return Xd = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      Xd(e)
    }
    Qd.$inject = ['eventBus', 'bpmnFactory'],
    w(Qd, Es),
    Kd.$inject = ['bpmnUpdater'],
    Kd.prototype.execute = function (e) {
      const t = e.dataStoreBo
      const n = e.dataStoreDi
      const r = e.newSemanticParent
      const o = e.newDiParent
      return e.oldSemanticParent = t.$parent,
      e.oldDiParent = n.$parent,
      this._bpmnUpdater.updateSemanticParent(t, r),
      this._bpmnUpdater.updateDiParent(n, o),
      []
    }
    ,
    Kd.prototype.revert = function (e) {
      const t = e.dataStoreBo
      const n = e.dataStoreDi
      const r = e.oldSemanticParent
      const o = e.oldDiParent
      return this._bpmnUpdater.updateSemanticParent(t, r),
      this._bpmnUpdater.updateDiParent(n, o),
      []
    }
    ,
    Jd.$inject = ['canvas', 'commandStack', 'elementRegistry', 'eventBus'],
    w(Jd, Es)
    const Zd = Math.max
    const ef = Math.min
    const tf = 20
    function nf (e, t) {
      return {
        top: e.top - t.top,
        right: e.right - t.right,
        bottom: e.bottom - t.bottom,
        left: e.left - t.left
      }
    }
    function rf (e, t) {
      return {
        x: e.x + (t.left || 0),
        y: e.y + (t.top || 0),
        width: e.width - (t.left || 0) + (t.right || 0),
        height: e.height - (t.top || 0) + (t.bottom || 0)
      }
    }
    function of (e, t, n) {
      let r = t[e]
      const o = n.min && n.min[e]
      const i = n.max && n.max[e]
      return L(o) && (r = (/top|left/.test(e) ? ef : Zd)(r, o)),
      L(i) && (r = (/top|left/.test(e) ? Zd : ef)(r, i)),
      r
    }
    function af (e, t) {
      return void 0 !== e ? e : tf
    }
    function sf (e) {
      return !e.waypoints && e.type !== 'label'
    }
    function cf (e, t) {
      let n
      if ((n = void 0 === e.length ? W(e.children, sf) : e).length) {
        return (function (e, t) {
          let n, r, o, i
          return Xd(t) === 'object'
            ? (n = af(t.left),
              r = af(t.right),
              o = af(t.top),
              i = af(t.bottom))
            : n = r = o = i = af(t),
          {
            x: e.x - n,
            y: e.y - o,
            width: e.width + n + r,
            height: e.height + o + i
          }
        }(Ft(n), t))
      }
    }
    const lf = Math.abs
    const pf = ['bpmn:Participant', 'bpmn:Process', 'bpmn:SubProcess']
    const uf = 30
    function df (e, t) {
      return t = t || [],
      e.children.filter(function (e) {
        Pi(e, 'bpmn:Lane') && (df(e, t),
        t.push(e))
      }
      ),
      t
    }
    function ff (e) {
      return e.children.filter(function (e) {
        return Pi(e, 'bpmn:Lane')
      }
      )
    }
    function hf (e) {
      return Hd(e, pf) || e
    }
    function mf (e, t) {
      Es.call(this, e),
      this.postExecuted('shape.delete', 500, function (e) {
        const n = e.context
        const r = n.hints
        const o = n.shape
        const i = n.oldParent
        Pi(o, 'bpmn:Lane') && (r && r.nested || (function (e, n) {
          let r; let o; let i; let a; let s; const c = ea(e); const l = ff(n); const p = []; const u = []; const d = []; const f = []
          Lt(l, function (t) {
            return c ? t.y > e.y ? u.push(t) : p.push(t) : t.x > e.x ? f.push(t) : d.push(t),
            t.children
          }
          ),
          l.length && (r = c ? u.length && p.length ? e.height / 2 : e.height : f.length && d.length ? e.width / 2 : e.width,
          p.length && (o = t.calculateAdjustments(p, 'y', r, e.y - 10),
          t.makeSpace(o.movingShapes, o.resizingShapes, {
            x: 0,
            y: r
          }, 's')),
          u.length && (i = t.calculateAdjustments(u, 'y', -r, e.y + e.height + 10),
          t.makeSpace(i.movingShapes, i.resizingShapes, {
            x: 0,
            y: -r
          }, 'n')),
          d.length && (a = t.calculateAdjustments(d, 'x', r, e.x - 10),
          t.makeSpace(a.movingShapes, a.resizingShapes, {
            x: r,
            y: 0
          }, 'e')),
          f.length && (s = t.calculateAdjustments(f, 'x', -r, e.x + e.width + 10),
          t.makeSpace(s.movingShapes, s.resizingShapes, {
            x: -r,
            y: 0
          }, 'w')))
        }(o, i)))
      }
      )
    }
    function vf (e, t) {
      t.invoke(Es, this),
      this._bpmnReplace = e
      const n = this
      this.postExecuted('elements.create', 500, function (e) {
        const t = e.elements
        t.filter(function (e) {
          return gf(e, e.host)
        }
        ).map(function (e) {
          return t.indexOf(e)
        }
        ).forEach(function (r) {
          e.elements[r] = n._replaceShape(t[r])
        }
        )
      }
      , !0),
      this.preExecute('elements.move', 500, function (e) {
        const t = e.shapes
        const r = e.newHost
        t.forEach(function (e, o) {
          let i; const a = e.host
          gf(e, (i = a,
          t.indexOf(i) !== -1 ? a : r)) && (t[o] = n._replaceShape(e))
        }
        )
      }
      , !0)
    }
    function gf (e, t) {
      return !br(e) && Pi(e, 'bpmn:BoundaryEvent') && !t
    }
    function yf (e, t, n) {
      function r (e, r, o) {
        let i; let a; let s; let c; let l; let p; let u; let d; const f = r.waypoints; const h = e.outgoing.slice(); const m = e.incoming.slice(); const v = yu(f, d = L(o.width) ? _r(o) : o)
        if (v) {
          if (i = f.slice(0, v.index),
          a = f.slice(v.index + (v.bendpoint ? 1 : 0)),
          !i.length || !a.length) { return }
          s = v.bendpoint ? f[v.index] : d,
          i.length !== 1 && bf(e, i[i.length - 1]) || i.push(Af(s)),
          a.length !== 1 && bf(e, a[0]) || a.unshift(Af(s))
        }
        c = r.source,
        l = r.target,
        t.canConnect(c, e, r) && (n.reconnectEnd(r, e, i || d),
        p = r),
        t.canConnect(e, l, r) && (p
          ? u = n.connect(e, l, {
            type: r.type,
            waypoints: a
          })
          : (n.reconnectStart(r, e, a || d),
            u = r))
        const g = [].concat(p && W(m, function (e) {
          return e.source === p.source
        }
        ) || [], u && W(h, function (e) {
          return e.target === u.target
        }
        ) || [])
        g.length && n.removeElements(g)
      }
      Es.call(this, e),
      this.preExecute('elements.move', function (e) {
        let n = e.newParent
        const r = e.shapes
        const o = e.delta
        const i = r[0]
        if (i && n) {
          n && n.waypoints && (e.newParent = n = n.parent)
          const a = _r(i)
          const s = {
            x: a.x + o.x,
            y: a.y + o.y
          }
          const c = H(n.children, function (e) {
            return t.canInsert(r, e) && yu(e.waypoints, s)
          }
          )
          c && (e.targetFlow = c,
          e.position = s)
        }
      }
      , !0),
      this.postExecuted('elements.move', function (e) {
        const t = e.shapes
        const n = e.targetFlow
        const o = e.position
        n && r(t[0], n, o)
      }
      , !0),
      this.preExecute('shape.create', function (e) {
        const n = e.parent
        const r = e.shape
        t.canInsert(r, n) && (e.targetFlow = n,
        e.parent = n.parent)
      }
      , !0),
      this.postExecuted('shape.create', function (e) {
        const t = e.shape
        const n = e.targetFlow
        const o = e.position
        n && r(t, n, o)
      }
      , !0)
    }
    function bf (e, t) {
      const n = t.x
      const r = t.y
      return n >= e.x && n <= e.x + e.width && r >= e.y && r <= e.y + e.height
    }
    function Af (e) {
      return le({}, e)
    }
    function Ef (e, t) {
      Es.call(this, e),
      this.preExecuted('connection.create', function (e) {
        const n = e.context
        const r = n.connection
        const o = n.source
        const i = n.target
        const a = n.hints
        a && !1 === a.createElementsBehavior || !xf(r) || (Pi(o, 'bpmn:EventBasedGateway')
          ? i.incoming.filter(function (e) {
            return e !== r && xf(e)
          }
          )
          : i.incoming.filter(function (e) {
            return e !== r && xf(e) && Pi(e.source, 'bpmn:EventBasedGateway')
          }
          )).forEach(function (e) {
          t.removeConnection(e)
        }
        )
      }
      ),
      this.preExecuted('shape.replace', function (e) {
        const n = e.context.newShape
        Pi(n, 'bpmn:EventBasedGateway') && n.outgoing.filter(xf).reduce(function (e, t) {
          return e.includes(t.target) ? e : e.concat(t.target)
        }
        , []).forEach(function (e) {
          e.incoming.filter(xf).forEach(function (r) {
            const o = e.incoming.filter(xf).filter(function (e) {
              return e.source === n
            }
            );
            (r.source !== n || o.length > 1) && t.removeConnection(r)
          }
          )
        }
        )
      }
      )
    }
    function xf (e) {
      return Pi(e, 'bpmn:SequenceFlow')
    }
    mf.$inject = ['eventBus', 'spaceTool'],
    w(mf, Es),
    vf.$inject = ['bpmnReplace', 'injector'],
    w(vf, Es),
    vf.prototype._replaceShape = function (e) {
      let t; let n; const r = (n = Ti(e).eventDefinitions) && n[0]
      return t = r
        ? {
            type: 'bpmn:IntermediateCatchEvent',
            eventDefinitionType: r.$type
          }
        : {
            type: 'bpmn:IntermediateThrowEvent'
          },
      this._bpmnReplace.replaceElement(e, t, {
        layoutConnection: !1
      })
    }
    ,
    w(yf, Es),
    yf.$inject = ['eventBus', 'bpmnRules', 'modeling'],
    Ef.$inject = ['eventBus', 'modeling'],
    w(Ef, Es)
    const wf = 1500
    function _f (e, t, n) {
      t.on(['create.hover', 'create.move', 'create.out', 'create.end', 'shape.move.hover', 'shape.move.move', 'shape.move.out', 'shape.move.end'], wf, function (t) {
        const r = t.context.shape || t.shape
        const o = t.hover
        Pi(o, 'bpmn:Lane') && !Oi(r, ['bpmn:Lane', 'bpmn:Participant']) && (t.hover = hf(o),
        t.hoverGfx = e.getGraphics(t.hover))
        const i = n.getRootElement()
        o !== i && (r.labelTarget || Oi(r, ['bpmn:Group', 'bpmn:TextAnnotation'])) && (t.hover = i,
        t.hoverGfx = e.getGraphics(t.hover))
      }
      ),
      t.on(['connect.hover', 'connect.out', 'connect.end', 'connect.cleanup', 'global-connect.hover', 'global-connect.out', 'global-connect.end', 'global-connect.cleanup'], wf, function (t) {
        const n = t.hover
        Pi(n, 'bpmn:Lane') && (t.hover = hf(n) || n,
        t.hoverGfx = e.getGraphics(t.hover))
      }
      ),
      t.on(['bendpoint.move.hover'], wf, function (t) {
        const n = t.context
        const r = t.hover
        const o = n.type
        Pi(r, 'bpmn:Lane') && /reconnect/.test(o) && (t.hover = hf(r) || r,
        t.hoverGfx = e.getGraphics(t.hover))
      }
      ),
      t.on(['connect.start'], wf, function (e) {
        const t = e.context
        const n = t.start
        Pi(n, 'bpmn:Lane') && (t.start = hf(n) || n)
      }
      ),
      t.on('shape.move.start', 2e3, function (e) {
        const t = e.shape
        Pi(t, 'bpmn:Lane') && (e.shape = hf(t) || t)
      }
      ),
      t.on('spaceTool.move', 2e3, function (e) {
        const t = e.hover
        t && Pi(t, 'bpmn:Lane') && (e.hover = hf(t))
      }
      )
    }
    function Cf (e, t, n, r, o, i) {
      function a (e, t, r) {
        const o = n.filter(function (e) {
          return Pi(e, 'bpmn:Group')
        }
        ).filter(function (e) {
          return e.businessObject !== r
        }
        )
        t && !(function (e, t) {
          return e.some(function (e) {
            const n = Ti(e)
            return (n.categoryValueRef && n.categoryValueRef.$parent) === t
          }
          )
        }(o, t)) && (function (e) {
          const t = e.$parent
          t && (Sn(t.get('rootElements'), e),
          e.$parent = null)
        }(t)),
        e && !(function (e, t) {
          return e.some(function (e) {
            return Ti(e).categoryValueRef === t
          }
          )
        }(o, e)) && (function (e) {
          const t = e.$parent
          t && (Sn(t.get('categoryValue'), e),
          e.$parent = null)
        }(e))
      }
      function s (e, n) {
        return (function (e, t, n) {
          return kn(t.get('categoryValue'), e),
          e.$parent = t,
          kn(n.get('rootElements'), t),
          t.$parent = n,
          e
        }(e, n, t.getDefinitions()))
      }
      function c (n, r) {
        const o = Ti(n)
        let i = o.categoryValueRef
        i || (i = o.categoryValueRef = r.categoryValue = r.categoryValue || (function (e) {
          return e.create('bpmn:CategoryValue')
        }(e)))
        let a = i.$parent
        a || (a = i.$parent = r.category = r.category || (function (e) {
          return e.create('bpmn:Category')
        }(e))),
        s(i, a, t.getDefinitions())
      }
      function l (e, t) {
        const n = t.category
        const r = t.categoryValue
        const o = Ti(e)
        r
          ? (o.categoryValueRef = null,
            a(r, n, o))
          : a(null, o.categoryValueRef.$parent, o)
      }
      function p (t, n) {
        const r = e.create(t.$type)
        return i.copyElement(t, r, null, n)
      }
      o.invoke(Es, this),
      this.execute('label.create', function (e) {
        const t = e.context
        const n = t.labelTarget
        Pi(n, 'bpmn:Group') && c(n, t)
      }
      ),
      this.revert('label.create', function (e) {
        const t = e.context
        const n = t.labelTarget
        Pi(n, 'bpmn:Group') && l(n, t)
      }
      ),
      this.execute('shape.delete', function (e) {
        const t = e.context
        const n = t.shape
        const r = Ti(n)
        if (Pi(n, 'bpmn:Group') && !n.labelTarget) {
          const o = t.categoryValue = r.categoryValueRef
          o && (a(o, t.category = o.$parent, r),
          r.categoryValueRef = null)
        }
      }
      ),
      this.reverted('shape.delete', function (e) {
        const t = e.context
        const n = t.shape
        if (Pi(n, 'bpmn:Group') && !n.labelTarget) {
          const r = t.category
          const o = t.categoryValue
          const i = Ti(n)
          o && (i.categoryValueRef = o,
          s(o, r))
        }
      }
      ),
      this.execute('shape.create', function (e) {
        const t = e.context
        const n = t.shape
        Pi(n, 'bpmn:Group') && !n.labelTarget && Ti(n).categoryValueRef && c(n, t)
      }
      ),
      this.reverted('shape.create', function (e) {
        const t = e.context
        const n = t.shape
        Pi(n, 'bpmn:Group') && !n.labelTarget && Ti(n).categoryValueRef && l(n, t)
      }
      ),
      r.on('copyPaste.copyElement', 770, function (e) {
        const t = e.descriptor
        const n = e.element
        if (Pi(n, 'bpmn:Group') && !n.labelTarget) {
          const r = Ti(n)
          if (r.categoryValueRef) {
            const o = r.categoryValueRef
            t.categoryValue = p(o, !0),
            o.$parent && (t.category = p(o.$parent, !0))
          }
        }
      }
      ),
      r.on('copyPaste.pasteElement', 770, function (e) {
        const t = e.descriptor
        const n = t.businessObject
        let r = t.categoryValue
        const o = t.category
        r && (r = n.categoryValueRef = p(r)),
        o && (r.$parent = p(o)),
        delete t.category,
        delete t.categoryValue
      }
      )
    }
    function Sf (e, t, n, r) {
      let o, i, a, s
      return (o = (r.y - n.y) * (t.x - e.x) - (r.x - n.x) * (t.y - e.y)) == 0
        ? null
        : (i = e.y - n.y,
          a = e.x - n.x,
          s = ((r.x - n.x) * i - (r.y - n.y) * a) / o,
          {
            x: Math.round(e.x + s * (t.x - e.x)),
            y: Math.round(e.y + s * (t.y - e.y))
          })
    }
    function kf (e) {
      function t (e, t, n) {
        let r; const o = {
          x: n.x,
          y: n.y - 50
        }; const i = {
          x: n.x - 50,
          y: n.y
        }; const a = Sf(e, t, n, o); const s = Sf(e, t, n, i)
        r = a && s ? jf(a, n) > jf(s, n) ? s : a : a || s,
        e.original = r
      }
      e.on('bpmnElement.added', function (e) {
        let n; let r; const o = e.element
        o.waypoints && (t((r = (n = o).waypoints)[0], r[1], _r(n.source)),
        t(r[r.length - 1], r[r.length - 2], _r(n.target)))
      }
      )
    }
    function jf (e, t) {
      return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2))
    }
    function Bf (e) {
      Es.call(this, e)
      const t = ['bpmn:Participant', 'bpmn:Lane']
      this.executed(['shape.move', 'shape.create', 'shape.resize'], function (e) {
        const n = e.context.shape
        const r = Ti(n)
        const o = Ri(n)
        if (Oi(r, t)) {
          let i = o.get('isHorizontal')
          void 0 === i && (i = !0),
          o.set('isHorizontal', i)
        }
      }
      )
    }
    _f.$inject = ['elementRegistry', 'eventBus', 'canvas'],
    Cf.$inject = ['bpmnFactory', 'bpmnjs', 'elementRegistry', 'eventBus', 'injector', 'moddleCopy'],
    w(Cf, Es),
    kf.$inject = ['eventBus'],
    Bf.$inject = ['eventBus'],
    w(Bf, Es)
    const Df = Math.sqrt
    const Pf = Math.min
    const Of = Math.max
    const Tf = Math.abs
    function Rf (e) {
      return Math.pow(e, 2)
    }
    function Nf (e, t) {
      return Df(Rf(e.x - t.x) + Rf(e.y - t.y))
    }
    function Mf (e, t, n, r) {
      const o = t.x - e.x
      const i = t.y - e.y
      const a = n.x - e.x
      const s = n.y - e.y
      const c = o * o + i * i
      const l = (o * a + i * s) / c
      let p = l * l - (a * a + s * s - r * r) / c
      if (p < 0 && p > -1e-6 && (p = 0),
      p < 0) { return [] }
      const u = Df(p)
      const d = -l + u
      const f = -l - u
      const h = {
        x: e.x - o * d,
        y: e.y - i * d
      }
      return p === 0
        ? [h]
        : [h, {
            x: e.x - o * f,
            y: e.y - i * f
          }].filter(function (n) {
            return (function (e, t, n) {
              return If(e.x, t.x, n.x) && If(e.y, t.y, n.y)
            }(n, e, t))
          }
          )
    }
    function If (e, t, n) {
      return e >= Pf(t, n) - Lf && e <= Of(t, n) + Lf
    }
    var Lf = 0.1
    function zf (e, t) {
      return Tf(e.x - t.x) <= Lf && Tf(e.y - t.y) <= Lf
    }
    function Ff (e, t, n, r) {
      let o = 0
      let i = 0
      const a = {
        point: e,
        delta: {
          x: 0,
          y: 0
        }
      }
      const s = (function (e, t) {
        let n; let r; let o; let i; let a; let s; let c; let l; let p; let u; let d; let f; let h = 0
        for (h = 0; h < t.length - 1; h++) {
          if (zf(n = t[h], r = t[h + 1])
            ? s = [n]
            : (o = Nf(e, n),
              i = Nf(e, r),
              s = Mf(n, r, e, Pf(o, i))),
          s.length < 1) { throw new Error('expected between [1, 2] circle -> line intersections') }
          s.length === 1 && (c = {
            type: 'bendpoint',
            position: s[0],
            segmentIndex: h,
            bendpointIndex: zf(n, s[0]) ? h : h + 1
          }),
          s.length === 2 && (d = s[0],
          f = s[1],
          c = {
            type: 'segment',
            position: a = {
              x: (d.x + f.x) / 2,
              y: (d.y + f.y) / 2
            },
            segmentIndex: h,
            relativeLocation: Nf(n, a) / Nf(n, r)
          }),
          l = Nf(c.position, e),
          (!u || p > l) && (u = c,
          p = l)
        }
        return u
      }(e, n))
      const c = s.segmentIndex
      const l = (function (e, t, n, r) {
        const o = n.segmentIndex
        const i = t.length - e.length
        if (r.segmentMove) {
          const a = r.segmentMove.segmentStartIndex
          const s = r.segmentMove.newSegmentStartIndex
          return o === a ? s : o >= s ? o + i < s ? s : o + i : o
        }
        if (r.bendpointMove) {
          let c; const l = r.bendpointMove.insert; const p = r.bendpointMove.bendpointIndex
          return i === 0
            ? o
            : (o >= p && (c = l ? o + 1 : o - 1),
              o < p && (c = o,
              l && n.type !== 'bendpoint' && p - 1 === o && $f(t, p) < n.relativeLocation && c++),
              c)
        }
        return i === 0 ? o : r.connectionStart && o === 0 ? 0 : r.connectionEnd && o === e.length - 2 ? t.length - 2 : Math.floor((t.length - 2) / 2)
      }(n, t, s, r))
      if (l < 0 || l > t.length - 2 || l === null) { return a }
      let p; let u; let d; let f; let h; let m; const v = Hf(n, c); const g = Hf(t, l); const y = s.position; let b = (f = y,
      h = wu((d = v)[0], d[1]),
      m = wu(d[0], f),
      h === 0 ? 0 : m / h); const A = (p = g,
      u = Au(v),
      Au(p) - u)
      if (s.type === 'bendpoint') {
        const E = t.length - n.length
        const x = s.bendpointIndex
        const w = n[x]
        if (t.indexOf(w) !== -1) { return a }
        if (E === 0) {
          const _ = t[x]
          return {
            delta: {
              x: o = _.x - s.position.x,
              y: i = _.y - s.position.y
            },
            point: {
              x: e.x + o,
              y: e.y + i
            }
          }
        }
        E < 0 && x !== 0 && x < n.length - 1 && (b = $f(n, x))
      }
      let C; let S; const k = {
        x: (g[1].x - g[0].x) * b + g[0].x,
        y: (g[1].y - g[0].y) * b + g[0].y
      }; const j = (C = {
        x: e.x - y.x,
        y: e.y - y.y
      },
      (S = A)
        ? {
            x: Math.cos(S) * C.x - Math.sin(S) * C.y,
            y: Math.sin(S) * C.x + Math.cos(S) * C.y
          }
        : C)
      return o = k.x + j.x - e.x,
      i = k.y + j.y - e.y,
      {
        point: Er(k),
        delta: Er({
          x: o,
          y: i
        })
      }
    }
    function $f (e, t) {
      const n = wu(e[t - 1], e[t])
      return n / (n + wu(e[t], e[t + 1]))
    }
    function Hf (e, t) {
      return [e[t], e[t + 1]]
    }
    function qf (e, t, n) {
      const r = pc(t)
      const o = pc(n)
      const i = uc(e, r)
      const a = i.x * (n.width / t.width)
      const s = i.y * (n.height / t.height)
      return Er({
        x: o.x + a,
        y: o.y + s
      })
    }
    function Wf (e, t, n) {
      const r = pc(e)
      const o = pc(t)
      const i = pc(n)
      const a = uc(e, r)
      const s = uc(r, o)
      const c = (function (e, t, n) {
        const r = xr(t)
        const o = xr(n)
        if (function (e, t) {
          return (function (e, t) {
            return e.right !== t.right && e.left !== t.left
          }(e, t)) || (function (e, t) {
            return e.top !== t.top && e.bottom !== t.bottom
          }(e, t))
        }(r, o)) { return null }
        let i; const a = Cr(t, e)
        if (a === 'top') {
          i = {
            x: 0,
            y: o.bottom - r.bottom
          }
        } else if (a === 'bottom') {
          i = {
            x: 0,
            y: o.top - r.top
          }
        } else if (a === 'right') {
          i = {
            x: o.left - r.left,
            y: 0
          }
        } else {
          if (a !== 'left') { return null }
          i = {
            x: o.right - r.right,
            y: 0
          }
        }
        return Cr(n, {
          x: e.x + i.x,
          y: e.y + i.y
        }) !== a
          ? null
          : i
      }(r, t, n))
      if (c) { return c }
      const l = s.x * (n.width / t.width)
      const p = s.y * (n.height / t.height)
      const u = i.x + l
      const d = i.y + p
      return Er({
        x: u + a.x - e.x,
        y: d + a.y - e.y
      })
    }
    const Gf = 'name'
    const Uf = 'text'
    function Vf (e, t, n, r) {
      function o (e) {
        const n = e.context
        const o = n.element
        const i = n.properties
        if (Gf in i && t.updateLabel(o, i[Gf]),
        Uf in i && Pi(o, 'bpmn:TextAnnotation')) {
          const a = r.getTextAnnotationBounds({
            x: o.x,
            y: o.y,
            width: o.width,
            height: o.height
          }, i[Uf] || '')
          t.updateLabel(o, i.text, a)
        }
      }
      Es.call(this, e),
      this.postExecute('element.updateProperties', o),
      this.postExecute('element.updateModdleProperties', function (e) {
        Ti(e.context.element) === e.context.moddleElement && o(e)
      }
      ),
      this.postExecute(['shape.create', 'connection.create'], function (e) {
        const n = e.context
        if (!1 !== (n.hints || {}).createElementsBehavior) {
          const r = n.shape || n.connection
          !br(r) && ia(r) && la(r) && t.updateLabel(r, la(r))
        }
      }
      ),
      this.postExecute('shape.delete', function (e) {
        const n = e.context
        const r = n.labelTarget
        const o = n.hints || {}
        r && !1 !== o.unsetLabel && t.updateLabel(r, null, null, {
          removeShape: !1
        })
      }
      ),
      this.postExecute(['connection.layout', 'connection.updateWaypoints'], function (e) {
        const n = e.context
        if (!1 !== (n.hints || {}).labelBehavior) {
          let r; const o = n.connection.label
          o && o.parent && (r = (function (e) {
            const t = e.context
            const n = t.connection
            const r = n.label
            const o = le({}, t.hints)
            const i = t.newWaypoints || n.waypoints
            const a = t.oldWaypoints
            return void 0 === o.startChanged && (o.startChanged = !!o.connectionStart),
            void 0 === o.endChanged && (o.endChanged = !!o.connectionEnd),
            (function (e, t, n, r) {
              return Ff(_r(e), t, n, r).delta
            }(r, i, a, o))
          }(e)),
          t.moveShape(o, r))
        }
      }
      ),
      this.postExecute(['shape.replace'], function (e) {
        const t = e.context
        const n = t.newShape
        const r = t.oldShape
        const o = Ti(n)
        o && ia(o) && r.label && n.label && (n.label.x = r.label.x,
        n.label.y = r.label.y)
      }
      ),
      this.postExecute('shape.resize', function (e) {
        let n; const r = e.context; const o = r.shape; const i = r.newBounds; const a = r.oldBounds
        if (aa(o)) {
          const s = o.label
          const c = (function (e, t) {
            if (t.length) {
              const n = (function (e, t) {
                const n = t.map(function (t) {
                  return {
                    line: t,
                    distance: xu(e, t)
                  }
                }
                )
                return te(n, 'distance')[0].line
              }(e, t))
              return Eu(e, n)
            }
          }(_r(s), [[{
            x: (n = a).x,
            y: n.y
          }, {
            x: n.x + (n.width || 0),
            y: n.y
          }], [{
            x: n.x + (n.width || 0),
            y: n.y
          }, {
            x: n.x + (n.width || 0),
            y: n.y + (n.height || 0)
          }], [{
            x: n.x,
            y: n.y + (n.height || 0)
          }, {
            x: n.x + (n.width || 0),
            y: n.y + (n.height || 0)
          }], [{
            x: n.x,
            y: n.y
          }, {
            x: n.x,
            y: n.y + (n.height || 0)
          }]]))
          const l = (function (e, t, n) {
            return Er(uc(qf(e, t, n), e))
          }(c, a, i))
          t.moveShape(s, l)
        }
      }
      )
    }
    function Qf (e, t) {
      function n (e, t) {
        const n = e.context
        const r = n.connection
        const o = le({}, n.hints)
        const i = n.newWaypoints || r.waypoints
        const a = n.oldWaypoints
        return void 0 === o.startChanged && (o.startChanged = !!o.connectionStart),
        void 0 === o.endChanged && (o.endChanged = !!o.connectionEnd),
        (function (e, t, n, r) {
          return Ff(e, t, n, r).point
        }(t, i, a, o))
      }
      Es.call(this, e),
      this.postExecute(['connection.layout', 'connection.updateWaypoints'], function (e) {
        const r = e.context.connection
        const o = r.outgoing
        r.incoming.forEach(function (r) {
          const o = r.waypoints[r.waypoints.length - 1]
          const i = n(e, o)
          const a = [].concat(r.waypoints.slice(0, -1), [i])
          t.updateWaypoints(r, a)
        }
        ),
        o.forEach(function (r) {
          const o = r.waypoints[0]
          const i = n(e, o)
          const a = [].concat([i], r.waypoints.slice(1))
          t.updateWaypoints(r, a)
        }
        )
      }
      ),
      this.postExecute(['connection.move'], function (e) {
        const n = e.context
        const r = n.connection
        const o = r.outgoing
        const i = r.incoming
        const a = n.delta
        i.forEach(function (e) {
          const n = e.waypoints[e.waypoints.length - 1]
          const r = {
            x: n.x + a.x,
            y: n.y + a.y
          }
          const o = [].concat(e.waypoints.slice(0, -1), [r])
          t.updateWaypoints(e, o)
        }
        ),
        o.forEach(function (e) {
          const n = e.waypoints[0]
          const r = {
            x: n.x + a.x,
            y: n.y + a.y
          }
          const o = [].concat([r], e.waypoints.slice(1))
          t.updateWaypoints(e, o)
        }
        )
      }
      )
    }
    function Yf (e, t, n) {
      const r = eh(e)
      const o = th(r, t)
      const i = r[0]
      return o.length ? o[o.length - 1] : qf(i.original || i, n, t)
    }
    function Kf (e, t, n) {
      const r = eh(e)
      const o = th(r, t)
      const i = r[r.length - 1]
      return o.length ? o[0] : qf(i.original || i, n, t)
    }
    function Jf (e, t, n) {
      const r = eh(e)
      const o = Zf(t, n)
      const i = r[0]
      return qf(i.original || i, o, t)
    }
    function Xf (e, t, n) {
      const r = eh(e)
      const o = Zf(t, n)
      const i = r[r.length - 1]
      return qf(i.original || i, o, t)
    }
    function Zf (e, t) {
      return {
        x: e.x - t.x,
        y: e.y - t.y,
        width: e.width,
        height: e.height
      }
    }
    function eh (e) {
      const t = e.waypoints
      if (!t.length) { throw new Error('connection#' + e.id + ': no waypoints') }
      return t
    }
    function th (e, t) {
      return W(Y(e, nh), function (e) {
        return (function (e, t) {
          return Cr(t, e, 1) === 'intersect'
        }(e, t))
      }
      )
    }
    function nh (e) {
      return e.original || e
    }
    function rh (e, t) {
      Es.call(this, e),
      this.postExecute('shape.replace', function (e) {
        const n = e.oldShape
        const r = e.newShape
        if (function (e, t) {
          return Pi(e, 'bpmn:Participant') && Zi(e) && Pi(t, 'bpmn:Participant') && !Zi(t)
        }(n, r)) {
          let o; let i; let a; let s; const c = (i = zt([o = n], !1),
          a = [],
          s = [],
          i.forEach(function (e) {
            e !== o && (e.incoming.forEach(function (e) {
              Pi(e, 'bpmn:MessageFlow') && a.push(e)
            }
            ),
            e.outgoing.forEach(function (e) {
              Pi(e, 'bpmn:MessageFlow') && s.push(e)
            }
            ))
          }
          , []),
          {
            incoming: a,
            outgoing: s
          })
          c.incoming.forEach(function (e) {
            const o = Kf(e, r, n)
            t.reconnectEnd(e, r, o)
          }
          ),
          c.outgoing.forEach(function (e) {
            const o = Yf(e, r, n)
            t.reconnectStart(e, r, o)
          }
          )
        }
      }
      , !0)
    }
    w(Vf, Es),
    Vf.$inject = ['eventBus', 'modeling', 'bpmnFactory', 'textRenderer'],
    w(Qf, Es),
    Qf.$inject = ['eventBus', 'modeling'],
    rh.$inject = ['eventBus', 'modeling'],
    w(rh, Es)
    const oh = ['bpmn:MessageEventDefinition', 'bpmn:TimerEventDefinition', 'bpmn:EscalationEventDefinition', 'bpmn:ConditionalEventDefinition', 'bpmn:SignalEventDefinition']
    function ih (e) {
      const t = Ti(e)
      if (!(Pi(t, 'bpmn:BoundaryEvent') || Pi(t, 'bpmn:StartEvent') && ta(t.$parent))) { return !1 }
      const n = t.get('eventDefinitions')
      return !(!n || !n.length) && oh.some(function (e) {
        return Pi(n[0], e)
      }
      )
    }
    function ah (e) {
      return Pi(e, 'bpmn:BoundaryEvent') ? 'cancelActivity' : 'isInterrupting'
    }
    function sh (e) {
      return sh = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      sh(e)
    }
    function ch (e, t) {
      e.invoke(Es, this),
      this.postExecuted('shape.replace', function (e) {
        let n; let r; let o; const i = e.context.oldShape; const a = e.context.newShape; const s = e.context.hints
        if (ih(a)) {
          const c = ah(a)
          if (!s.targetElement || void 0 === s.targetElement[c]) {
            const l = Ti(i).get(c)
            l !== Ti(a).get(c) && t.updateProperties(a, (n = {},
            o = l,
            r = (function (e) {
              const t = (function (e, t) {
                if (sh(e) != 'object' || !e) { return e }
                const n = e[Symbol.toPrimitive]
                if (void 0 !== n) {
                  const r = n.call(e, 'string')
                  if (sh(r) != 'object') { return r }
                  throw new TypeError('@@toPrimitive must return a primitive value.')
                }
                return String(e)
              }(e))
              return sh(t) == 'symbol' ? t : t + ''
            }(r = c)),
            r in n
              ? Object.defineProperty(n, r, {
                value: o,
                enumerable: !0,
                configurable: !0,
                writable: !0
              })
              : n[r] = o,
            n))
          }
        }
      }
      )
    }
    function lh (e, t) {
      Es.call(this, e),
      this.preExecute('shape.resize', function (e) {
        const n = e.shape
        const r = Ri(n)
        const o = r && r.get('label')
        o && o.get('bounds') && t.updateModdleProperties(n, o, {
          bounds: void 0
        })
      }
      , !0)
    }
    function ph (e, t, n) {
      Es.call(this, e),
      this.preExecute('shape.delete', function (e) {
        let r; let o; let i; const a = e.context.shape
        if (a.incoming.length === 1 && a.outgoing.length === 1) {
          const s = a.incoming[0]
          const c = a.outgoing[0]
          if (Pi(s, 'bpmn:SequenceFlow') && Pi(c, 'bpmn:SequenceFlow') && t.canConnect(s.source, c.target, s)) {
            const l = (r = s.waypoints,
            o = c.waypoints,
            (i = Sf(uh(r[r.length - 2]), uh(r[r.length - 1]), uh(o[1]), uh(o[0]))) ? [].concat(r.slice(0, r.length - 1), [i], o.slice(1)) : [uh(r[0]), uh(o[o.length - 1])])
            n.reconnectEnd(s, c.target, l)
          }
        }
      }
      )
    }
    function uh (e) {
      return e.original || e
    }
    function dh (e, t) {
      Es.call(this, e),
      this.preExecute('shape.delete', function (e) {
        const t = e.shape
        const n = t.parent
        Pi(t, 'bpmn:Participant') && (e.collaborationRoot = n)
      }
      , !0),
      this.postExecute('shape.delete', function (e) {
        const n = e.collaborationRoot
        n && !n.businessObject.participants.length && t.makeProcess()
      }
      , !0)
    }
    function fh (e, t, n, r) {
      Es.call(this, e)
      const o = r.get('dragging', !1)
      function i (e) {
        let r; let o; const i = e.source; const a = e.target
        e.parent && (Pi(e, 'bpmn:SequenceFlow') && (n.canConnectSequenceFlow(i, a) || (o = !0),
        n.canConnectMessageFlow(i, a) && (r = 'bpmn:MessageFlow')),
        Pi(e, 'bpmn:MessageFlow') && (n.canConnectMessageFlow(i, a) || (o = !0),
        n.canConnectSequenceFlow(i, a) && (r = 'bpmn:SequenceFlow')),
        o && t.removeConnection(e),
        r && t.connect(i, a, {
          type: r,
          waypoints: e.waypoints.slice()
        }))
      }
      this.postExecuted('elements.move', function (e) {
        G(e.closure.allConnections, i)
      }
      , !0),
      this.preExecute('connection.reconnect', function (e) {
        let r; let i; const a = e.context; const s = a.connection; const c = a.newSource || s.source; const l = a.newTarget || s.target;
        (r = n.canConnect(c, l)) && r.type !== s.type && (i = t.connect(c, l, {
          type: r.type,
          associationDirection: r.associationDirection,
          waypoints: s.waypoints.slice()
        }),
        s.parent && t.removeConnection(s),
        a.connection = i,
        o && (function (e, t) {
          let n; const r = o.context(); const i = r && r.payload.previousSelection
          i && i.length && (n = i.indexOf(e)) !== -1 && i.splice(n, 1, t)
        }(s, i)))
      }
      ),
      this.postExecuted('element.updateProperties', function (e) {
        let n; const r = e.context; const o = r.properties; const i = r.element; const a = i.businessObject
        o.default && (n = H(i.outgoing, ne({
          id: i.businessObject.default.id
        }))) && t.updateProperties(n, {
          conditionExpression: void 0
        }),
        o.conditionExpression && a.sourceRef.default === a && t.updateProperties(i.source, {
          default: void 0
        })
      }
      )
    }
    function hh (e, t, n, r, o, i) {
      r.invoke(Es, this),
      this._bpmnReplace = e,
      this._elementRegistry = n,
      this._selection = i,
      this.postExecuted(['elements.create'], 500, function (e) {
        const n = e.context
        const r = n.parent
        const o = n.elements
        const i = U(o, function (e, n) {
          const o = t.canReplace([n], n.host || n.parent || r)
          return o ? e.concat(o.replacements) : e
        }
        , [])
        i.length && this._replaceElements(o, i)
      }
      , this),
      this.postExecuted(['elements.move'], 500, function (e) {
        const n = e.context
        let r = n.newParent
        const o = n.newHost
        let i = []
        G(n.closure.topLevel, function (e) {
          i = ta(e) ? i.concat(e.children) : i.concat(e)
        }
        ),
        i.length === 1 && o && (r = o)
        const a = t.canReplace(i, r)
        a && this._replaceElements(i, a.replacements, o)
      }
      , this),
      this.postExecute(['shape.replace'], 1500, function (e) {
        let n; const r = e.context; const o = r.oldShape; const i = r.newShape; const a = o.attachers
        a && a.length && (n = t.canReplace(a, i),
        this._replaceElements(a, n.replacements))
      }
      , this),
      this.postExecuted(['shape.replace'], 1500, function (e) {
        const t = e.context
        const n = t.oldShape
        const r = t.newShape
        o.unclaimId(n.businessObject.id, n.businessObject),
        o.updateProperties(r, {
          id: n.id
        })
      }
      )
    }
    ch.$inject = ['injector', 'modeling'],
    w(ch, Es),
    w(lh, Es),
    lh.$inject = ['eventBus', 'modeling'],
    w(ph, Es),
    ph.$inject = ['eventBus', 'bpmnRules', 'modeling'],
    dh.$inject = ['eventBus', 'modeling'],
    w(dh, Es),
    w(fh, Es),
    fh.$inject = ['eventBus', 'modeling', 'bpmnRules', 'injector'],
    w(hh, Es),
    hh.prototype._replaceElements = function (e, t) {
      const n = this._elementRegistry
      const r = this._bpmnReplace
      const o = this._selection
      G(t, function (t) {
        const o = {
          type: t.newElementType
        }
        const i = n.get(t.oldElementId)
        const a = e.indexOf(i)
        e[a] = r.replaceElement(i, o, {
          select: !1
        })
      }
      ),
      t && o.select(e)
    }
    ,
    hh.$inject = ['bpmnReplace', 'bpmnRules', 'elementRegistry', 'injector', 'modeling', 'selection']
    const mh = {
      width: 140,
      height: 120
    }
    const vh = {
      width: 300,
      height: 60
    }
    const gh = {
      width: 60,
      height: 300
    }
    const yh = {
      width: 300,
      height: 150
    }
    const bh = {
      width: 150,
      height: 300
    }
    const Ah = {
      width: 140,
      height: 120
    }
    const Eh = {
      width: 50,
      height: 30
    }
    function xh (e) {
      e.on('resize.start', 1500, function (e) {
        const t = e.context
        const n = t.shape
        const r = t.direction
        const o = t.balanced;
        (Pi(n, 'bpmn:Lane') || Pi(n, 'bpmn:Participant')) && (t.resizeConstraints = (function (e, t, n) {
          const r = hf(e)
          let o = !0
          let i = !0
          const a = df(r, [r])
          const s = xr(e)
          const c = {}
          const l = {}
          const p = ea(e)
          const u = p ? vh : gh;
          /n/.test(t) ? l.top = s.bottom - u.height : /e/.test(t) ? l.right = s.left + u.width : /s/.test(t) ? l.bottom = s.top + u.height : /w/.test(t) && (l.left = s.right - u.width),
          a.forEach(function (e) {
            const r = xr(e);
            /n/.test(t) && (p && r.top < s.top - 10 && (o = !1),
            n && wh(s.top - r.bottom) < 10 && jh(c, 'top', r.top + u.height),
            wh(s.top - r.top) < 5 && kh(l, 'top', r.bottom - u.height)),
            /e/.test(t) && (!p && r.right > s.right + 10 && (i = !1),
            n && wh(s.right - r.left) < 10 && kh(c, 'right', r.right - u.width),
            wh(s.right - r.right) < 5 && jh(l, 'right', r.left + u.width)),
            /s/.test(t) && (p && r.bottom > s.bottom + 10 && (i = !1),
            n && wh(s.bottom - r.top) < 10 && kh(c, 'bottom', r.bottom - u.height),
            wh(s.bottom - r.bottom) < 5 && jh(l, 'bottom', r.top + u.height)),
            /w/.test(t) && (!p && r.left < s.left - 10 && (o = !1),
            n && wh(s.left - r.right) < 10 && jh(c, 'left', r.left + u.width),
            wh(s.left - r.left) < 5 && kh(l, 'left', r.right - u.width))
          }
          )
          const d = r.children.filter(function (e) {
            return !e.hidden && !e.waypoints && (Pi(e, 'bpmn:FlowElement') || Pi(e, 'bpmn:Artifact'))
          }
          )
          const f = p ? Bh : Dh
          return d.forEach(function (e) {
            const n = xr(e)
            o && /n/.test(t) && kh(l, 'top', n.top - f.top),
            i && /e/.test(t) && jh(l, 'right', n.right + f.right),
            i && /s/.test(t) && jh(l, 'bottom', n.bottom + f.bottom),
            o && /w/.test(t) && kh(l, 'left', n.left - f.left)
          }
          ),
          {
            min: l,
            max: c
          }
        }(n, r, o))),
        Pi(n, 'bpmn:SubProcess') && Zi(n) && (t.minDimensions = Ah),
        Pi(n, 'bpmn:TextAnnotation') && (t.minDimensions = Eh)
      }
      )
    }
    xh.$inject = ['eventBus']
    var wh = Math.abs
    const _h = Math.min
    const Ch = Math.max
    function Sh (e, t, n, r) {
      const o = e[t]
      e[t] = void 0 === o ? n : r(n, o)
    }
    function kh (e, t, n) {
      return Sh(e, t, n, _h)
    }
    function jh (e, t, n) {
      return Sh(e, t, n, Ch)
    }
    var Bh = {
      top: 20,
      left: 50,
      right: 20,
      bottom: 20
    }
    var Dh = {
      top: 50,
      left: 20,
      right: 20,
      bottom: 20
    }
    function Ph (e, t) {
      e.on('resize.start', 1501, function (e) {
        const t = e.context
        const n = t.shape;
        (Pi(n, 'bpmn:Lane') || Pi(n, 'bpmn:Participant')) && (t.balanced = !Ja(e))
      }
      ),
      e.on('resize.end', 1001, function (e) {
        const n = e.context
        const r = n.shape
        const o = n.canExecute
        let i = n.newBounds
        if (Pi(r, 'bpmn:Lane') || Pi(r, 'bpmn:Participant')) {
          return o && (i = Ar(i),
          t.resizeLane(r, i, n.balanced)),
          !1
        }
      }
      )
    }
    function Oh (e, t, n, r, o) {
      function i (e) {
        return Oi(e, ['bpmn:ReceiveTask', 'bpmn:SendTask']) || (function (e, t) {
          return M(t) || (t = [t]),
          Q(t, function (t) {
            return na(e, t)
          }
          )
        }(e, ['bpmn:ErrorEventDefinition', 'bpmn:EscalationEventDefinition', 'bpmn:MessageEventDefinition', 'bpmn:SignalEventDefinition']))
      }
      function a (t) {
        return !!H(e.getDefinitions().get('rootElements'), ne({
          id: t.id
        }))
      }
      function s (e) {
        return Pi(e, 'bpmn:ErrorEventDefinition') ? 'errorRef' : Pi(e, 'bpmn:EscalationEventDefinition') ? 'escalationRef' : Pi(e, 'bpmn:MessageEventDefinition') ? 'messageRef' : Pi(e, 'bpmn:SignalEventDefinition') ? 'signalRef' : void 0
      }
      function c (e) {
        if (Oi(e, ['bpmn:ReceiveTask', 'bpmn:SendTask'])) { return e.get('messageRef') }
        const t = e.get('eventDefinitions')[0]
        return t.get(s(t))
      }
      n.invoke(Es, this),
      this.executed(['shape.create', 'element.updateProperties', 'element.updateModdleProperties'], function (t) {
        const n = t.shape || t.element
        if (i(n)) {
          const r = c(Ti(n))
          r && !a(r) && (kn(e.getDefinitions().get('rootElements'), r),
          t.addedRootElement = r)
        }
      }
      , !0),
      this.reverted(['shape.create', 'element.updateProperties', 'element.updateModdleProperties'], function (t) {
        const n = t.addedRootElement
        n && Sn(e.getDefinitions().get('rootElements'), n)
      }
      , !0),
      t.on('copyPaste.copyElement', function (e) {
        const t = e.descriptor
        const n = e.element
        if (!n.labelTarget && i(n)) {
          const r = c(Ti(n))
          r && (t.referencedRootElement = r)
        }
      }
      ),
      t.on('copyPaste.pasteElement', 500, function (e) {
        const t = e.descriptor
        const n = t.businessObject
        let i = t.referencedRootElement
        i && (a(i) || (i = r.copyElement(i, o.create(i.$type))),
        (function (e, t) {
          if (Oi(e, ['bpmn:ReceiveTask', 'bpmn:SendTask'])) { return e.set('messageRef', t) }
          const n = e.get('eventDefinitions')[0]
          n.set(s(n), t)
        }(n, i)),
        delete t.referencedRootElement)
      }
      )
    }
    Ph.$inject = ['eventBus', 'modeling'],
    Oh.$inject = ['bpmnjs', 'eventBus', 'injector', 'moddleCopy', 'bpmnFactory'],
    w(Oh, Es)
    const Th = Math.max
    function Rh (e) {
      e.on('spaceTool.getMinDimensions', function (e) {
        const t = e.shapes
        const n = e.axis
        const r = e.start
        const o = {}
        return G(t, function (e) {
          const t = e.id
          Pi(e, 'bpmn:Participant') && (o[t] = (function (e, t, n) {
            const r = ea(e)
            if (!ff(e).length) { return r ? yh : bh }
            const o = (function (e) {
              return e === 'x'
            }(t))
            return o
              ? r
                ? yh
                : {
                    width: Mh(e, n, o),
                    height: bh.height
                  }
              : r
                ? {
                    width: yh.width,
                    height: Nh(e, n, o)
                  }
                : bh
          }(e, n, r))),
          Pi(e, 'bpmn:Lane') && (o[t] = ea(e) ? vh : gh),
          Pi(e, 'bpmn:SubProcess') && Zi(e) && (o[t] = Ah),
          Pi(e, 'bpmn:TextAnnotation') && (o[t] = Eh),
          Pi(e, 'bpmn:Group') && (o[t] = mh)
        }
        ),
        o
      }
      )
    }
    function Nh (e, t, n) {
      let r
      return r = (function (e, t, n) {
        let r
        return r = Ih(ff(e), t, n),
        e.height - r.height + vh.height
      }(e, t, n)),
      Th(yh.height, r)
    }
    function Mh (e, t, n) {
      let r
      return r = (function (e, t, n) {
        let r
        return r = Ih(ff(e), t, n),
        e.width - r.width + gh.width
      }(e, t, n)),
      Th(bh.width, r)
    }
    function Ih (e, t, n) {
      let r, o, i
      for (r = 0; r < e.length; r++) {
        if (o = e[r],
        !n && t >= o.y && t <= o.y + o.height || n && t >= o.x && t <= o.x + o.width) { return (i = ff(o)).length ? Ih(i, t, n) : o }
      }
    }
    Rh.$inject = ['eventBus']
    function Lh (e, t, n, r, o, i, a) {
      Es.call(this, t),
      this._canvas = e,
      this._eventBus = t,
      this._modeling = n,
      this._elementFactory = r,
      this._bpmnFactory = o,
      this._bpmnjs = i,
      this._elementRegistry = a
      const s = this
      function c (e) {
        return Pi(e, 'bpmn:SubProcess') && !Zi(e)
      }
      function l (t) {
        const n = t.shape
        let r = t.newRootElement
        const o = Ti(n)
        r = s._addDiagram(r || o),
        t.newRootElement = e.addRootElement(r)
      }
      function p (t) {
        const n = Ti(t.shape)
        s._removeDiagram(n)
        const r = t.newRootElement = a.get(Ds(n))
        e.removeRootElement(r)
      }
      this.executed('shape.create', function (e) {
        c(e.shape) && l(e)
      }
      , !0),
      this.postExecuted('shape.create', function (e) {
        const t = e.shape
        const n = e.newRootElement
        n && t.children && (s._showRecursively(t.children),
        s._moveChildrenToShape(t, n))
      }
      , !0),
      this.reverted('shape.create', function (e) {
        c(e.shape) && p(e)
      }
      , !0),
      this.preExecuted('shape.delete', function (e) {
        const t = e.shape
        if (c(t)) {
          const r = a.get(Ds(t))
          r && n.removeElements(r.children.slice())
        }
      }
      , !0),
      this.executed('shape.delete', function (e) {
        c(e.shape) && p(e)
      }
      , !0),
      this.reverted('shape.delete', function (e) {
        c(e.shape) && l(e)
      }
      , !0),
      this.preExecuted('shape.replace', function (t) {
        const n = t.oldShape
        const r = t.newShape
        c(n) && c(r) && (t.oldRoot = e.removeRootElement(Ds(n)))
      }
      , !0),
      this.postExecuted('shape.replace', function (t) {
        const r = t.newShape
        const o = t.oldRoot
        const i = e.findRoot(Ds(r))
        if (o && i) {
          const a = o.children
          n.moveElements(a, {
            x: 0,
            y: 0
          }, i)
        }
      }
      , !0),
      this.executed('element.updateProperties', function (e) {
        const t = e.element
        if (Pi(t, 'bpmn:SubProcess')) {
          const n = e.properties
          const r = e.oldProperties.id
          const o = n.id
          if (r !== o) {
            if (Os(t)) {
              return a.updateId(t, Ps(o)),
              void a.updateId(r, o)
            }
            a.get(Ps(r)) && a.updateId(Ps(r), Ps(o))
          }
        }
      }
      , !0),
      this.reverted('element.updateProperties', function (e) {
        const t = e.element
        if (Pi(t, 'bpmn:SubProcess')) {
          const n = e.properties
          const r = e.oldProperties.id
          const o = n.id
          if (r !== o) {
            if (Os(t)) {
              return a.updateId(t, Ps(r)),
              void a.updateId(o, r)
            }
            const i = a.get(Ps(o))
            i && a.updateId(i, Ps(r))
          }
        }
      }
      , !0),
      t.on('element.changed', function (e) {
        const n = e.element
        if (Os(n)) {
          const r = n
          const o = a.get(Bs(r))
          o && o !== r && t.fire('element.changed', {
            element: o
          })
        }
      }
      ),
      this.executed('shape.toggleCollapse', 400, function (e) {
        const t = e.shape
        Pi(t, 'bpmn:SubProcess') && (Zi(t)
          ? p(e)
          : (l(e),
            s._showRecursively(t.children)))
      }
      , !0),
      this.reverted('shape.toggleCollapse', 400, function (e) {
        const t = e.shape
        Pi(t, 'bpmn:SubProcess') && (Zi(t)
          ? p(e)
          : (l(e),
            s._showRecursively(t.children)))
      }
      , !0),
      this.postExecuted('shape.toggleCollapse', 600, function (e) {
        const t = e.shape
        if (Pi(t, 'bpmn:SubProcess')) {
          const n = e.newRootElement
          n && (Zi(t) ? s._moveChildrenToShape(n, t) : s._moveChildrenToShape(t, n))
        }
      }
      , !0),
      t.on('copyPaste.createTree', function (e) {
        const t = e.element
        const n = e.children
        if (c(t)) {
          const r = Ds(t)
          const o = a.get(r)
          o && n.push.apply(n, o.children)
        }
      }
      ),
      t.on('copyPaste.copyElement', function (e) {
        const t = e.descriptor
        const n = e.element
        const r = e.elements
        const o = n.parent
        if (Pi(Ri(o), 'bpmndi:BPMNPlane')) {
          const i = Bs(o)
          const a = H(r, function (e) {
            return e.id === i
          }
          )
          a && (t.parent = a.id)
        }
      }
      ),
      t.on('copyPaste.pasteElement', function (e) {
        const t = e.descriptor
        t.parent && (c(t.parent) || t.parent.hidden) && (t.hidden = !0)
      }
      )
    }
    function zh (e, t) {
      e.invoke(Es, this),
      this.postExecuted('shape.replace', function (e) {
        const n = e.context.oldShape
        const r = e.context.newShape
        if (Pi(r, 'bpmn:SubProcess') && (Pi(n, 'bpmn:Task') || Pi(n, 'bpmn:CallActivity')) && Zi(r)) {
          let o; const i = {
            x: (o = r).x + o.width / 6,
            y: o.y + o.height / 2
          }
          t.createShape({
            type: 'bpmn:StartEvent'
          }, i, r)
        }
      }
      )
    }
    function Fh (e) {
      Es.call(this, e),
      this.preExecute('connection.create', function (e) {
        const t = e.target
        Pi(t, 'bpmn:TextAnnotation') && (e.parent = t.parent)
      }
      , !0),
      this.preExecute(['shape.create', 'shape.resize', 'elements.move'], function (e) {
        const t = e.shapes || [e.shape]
        t.length === 1 && Pi(t[0], 'bpmn:TextAnnotation') && (e.hints = e.hints || {},
        e.hints.autoResize = !1)
      }
      , !0)
    }
    function $h (e, t) {
      Es.call(this, e),
      this.postExecuted('shape.toggleCollapse', 1500, function (e) {
        const n = e.shape
        if (!Zi(n)) {
          var r = zt(n)
          r.forEach(function (e) {
            const t = e.incoming.slice()
            const n = e.outgoing.slice()
            G(t, function (e) {
              o(e, !0)
            }
            ),
            G(n, function (e) {
              o(e, !1)
            }
            )
          }
          )
        }
        function o (e, o) {
          r.indexOf(e.source) !== -1 && r.indexOf(e.target) !== -1 || (o ? t.reconnectEnd(e, n, _r(n)) : t.reconnectStart(e, n, _r(n)))
        }
      }
      , !0)
    }
    function Hh (e, t, n) {
      Es.call(this, e),
      this.executed(['shape.toggleCollapse'], 500, function (e) {
        let t; const n = e.context.shape
        Pi(n, 'bpmn:SubProcess') && (n.collapsed
          ? Ri(n).isExpanded = !1
          : ((t = n.children).length && t.forEach(function (e) {
              e.type !== 'label' || e.businessObject.name || (e.hidden = !0)
            }
            ),
            Ri(n).isExpanded = !0))
      }
      ),
      this.reverted(['shape.toggleCollapse'], 500, function (e) {
        const t = e.context.shape
        t.collapsed ? Ri(t).isExpanded = !1 : Ri(t).isExpanded = !0
      }
      ),
      this.postExecuted(['shape.toggleCollapse'], 500, function (e) {
        let r; const o = e.context.shape; const i = t.getDefaultSize(o)
        r = o.collapsed
          ? (function (e, t) {
              return {
                x: e.x + (e.width - t.width) / 2,
                y: e.y + (e.height - t.height) / 2,
                width: t.width,
                height: t.height
              }
            }(o, i))
          : (function (e, t) {
              let n; let r; let o; const i = t
              return n = (o = e.children,
              o.filter(function (e) {
                return !e.hidden
              }
              )).concat([e]),
              (r = cf(n))
                ? (i.width = Math.max(r.width, i.width),
                  i.height = Math.max(r.height, i.height),
                  i.x = r.x + (r.width - i.width) / 2,
                  i.y = r.y + (r.height - i.height) / 2)
                : (i.x = e.x + (e.width - i.width) / 2,
                  i.y = e.y + (e.height - i.height) / 2),
              i
            }(o, i)),
        n.resizeShape(o, r, null, {
          autoResize: !o.collapsed && 'nwse'
        })
      }
      )
    }
    function qh (e, t, n, r) {
      t.invoke(Es, this),
      this.preExecute('shape.delete', function (e) {
        const t = e.context.shape
        const o = t.businessObject
        br(t) || (Pi(t, 'bpmn:Participant') && Zi(t) && n.ids.unclaim(o.processRef.id),
        r.unclaimId(o.id, o))
      }
      ),
      this.preExecute('connection.delete', function (e) {
        const t = e.context.connection.businessObject
        r.unclaimId(t.id, t)
      }
      ),
      this.preExecute('canvas.updateRoot', function () {
        const t = e.getRootElement()
        const r = t.businessObject
        Pi(t, 'bpmn:Collaboration') && n.ids.unclaim(r.id)
      }
      )
    }
    function Wh (e, t) {
      Es.call(this, e),
      this.preExecute('connection.delete', function (e) {
        const n = e.context.connection
        const r = n.source;
        (function (e, t) {
          if (!Pi(e, 'bpmn:SequenceFlow')) { return !1 }
          const n = Ti(t)
          const r = Ti(e)
          return n.get('default') === r
        }
        )(n, r) && t.updateProperties(r, {
          default: null
        })
      }
      )
    }
    function Gh (e, t, n) {
      let r
      Es.call(this, e)
      const o = ['spaceTool', 'lane.add', 'lane.resize', 'lane.split', 'elements.create', 'elements.delete', 'elements.move', 'shape.create', 'shape.delete', 'shape.move', 'shape.resize']
      this.preExecute(o, 5e3, function (e) {
        (r = r || new Uh()).enter()
      }
      ),
      this.postExecuted(o, 500, function (e) {
        !(function () {
          if (!r) { throw new Error(n('out of bounds release')) }
          r.leave() && (t.updateLaneRefs(r.flowNodes, r.lanes),
          r = null)
        }())
      }
      ),
      this.preExecute(['shape.create', 'shape.move', 'shape.delete', 'shape.resize'], function (e) {
        const t = e.context.shape
        const o = (function () {
          if (!r) { throw new Error(n('out of bounds release')) }
          return r
        }())
        t.labelTarget || (Pi(t, 'bpmn:Lane') && o.addLane(t),
        Pi(t, 'bpmn:FlowNode') && o.addFlowNode(t))
      }
      )
    }
    function Uh () {
      this.flowNodes = [],
      this.lanes = [],
      this.counter = 0,
      this.addLane = function (e) {
        this.lanes.push(e)
      }
      ,
      this.addFlowNode = function (e) {
        this.flowNodes.push(e)
      }
      ,
      this.enter = function () {
        this.counter++
      }
      ,
      this.leave = function () {
        return this.counter--,
        !this.counter
      }
    }
    w(Lh, Es),
    Lh.prototype._moveChildrenToShape = function (e, t) {
      let n; const r = this._modeling; let o = e.children
      if (o) {
        const i = (o = o.concat(o.reduce(function (t, n) {
          return n.label && n.label.parent !== e ? t.concat(n.label) : t
        }
        , []))).filter(function (e) {
          return !e.hidden
        }
        )
        if (i.length) {
          const a = Ft(i)
          if (t.x) {
            const s = _r(t)
            const c = _r(a)
            n = {
              x: s.x - c.x,
              y: s.y - c.y
            }
          } else {
            n = {
              x: 180 - a.x,
              y: 160 - a.y
            }
          }
          r.moveElements(o, n, t, {
            autoResize: !1
          })
        } else {
          r.moveElements(o, {
            x: 0,
            y: 0
          }, t, {
            autoResize: !1
          })
        }
      }
    }
    ,
    Lh.prototype._showRecursively = function (e, t) {
      const n = this
      let r = []
      return e.forEach(function (e) {
        e.hidden = !!t,
        r = r.concat(e),
        e.children && (r = r.concat(n._showRecursively(e.children, e.collapsed || t)))
      }
      ),
      r
    }
    ,
    Lh.prototype._addDiagram = function (e) {
      const t = this._bpmnjs.getDefinitions().diagrams
      return e.businessObject || (e = this._createNewDiagram(e)),
      t.push(e.di.$parent),
      e
    }
    ,
    Lh.prototype._createNewDiagram = function (e) {
      const t = this._bpmnFactory
      const n = this._elementFactory
      const r = t.create('bpmndi:BPMNPlane', {
        bpmnElement: e
      })
      const o = t.create('bpmndi:BPMNDiagram', {
        plane: r
      })
      return r.$parent = o,
      n.createRoot({
        id: Ds(e),
        type: e.$type,
        di: r,
        businessObject: e,
        collapsed: !0
      })
    }
    ,
    Lh.prototype._removeDiagram = function (e) {
      const t = this._bpmnjs.getDefinitions().diagrams
      const n = H(t, function (t) {
        return t.plane.bpmnElement.id === e.id
      }
      )
      return t.splice(t.indexOf(n), 1),
      n
    }
    ,
    Lh.$inject = ['canvas', 'eventBus', 'modeling', 'elementFactory', 'bpmnFactory', 'bpmnjs', 'elementRegistry'],
    zh.$inject = ['injector', 'modeling'],
    w(zh, Es),
    w(Fh, Es),
    Fh.$inject = ['eventBus'],
    w($h, Es),
    $h.$inject = ['eventBus', 'modeling'],
    w(Hh, Es),
    Hh.$inject = ['eventBus', 'elementFactory', 'modeling'],
    w(qh, Es),
    qh.$inject = ['canvas', 'injector', 'moddle', 'modeling'],
    w(Wh, Es),
    Wh.$inject = ['eventBus', 'modeling'],
    Gh.$inject = ['eventBus', 'modeling', 'translate'],
    w(Gh, Es)
    const Vh = {
      __init__: ['adaptiveLabelPositioningBehavior', 'appendBehavior', 'associationBehavior', 'attachEventBehavior', 'boundaryEventBehavior', 'compensateBoundaryEventBehaviour', 'createBehavior', 'createDataObjectBehavior', 'createParticipantBehavior', 'dataInputAssociationBehavior', 'dataStoreBehavior', 'deleteLaneBehavior', 'detachEventBehavior', 'dropOnFlowBehavior', 'eventBasedGatewayBehavior', 'fixHoverBehavior', 'groupBehavior', 'importDockingFix', 'isHorizontalFix', 'labelBehavior', 'layoutConnectionBehavior', 'messageFlowBehavior', 'nonInterruptingBehavior', 'removeElementBehavior', 'removeEmbeddedLabelBoundsBehavior', 'removeParticipantBehavior', 'replaceConnectionBehavior', 'replaceElementBehaviour', 'resizeBehavior', 'resizeLaneBehavior', 'rootElementReferenceBehavior', 'spaceToolBehavior', 'subProcessPlaneBehavior', 'subProcessStartEventBehavior', 'textAnnotationBehavior', 'toggleCollapseConnectionBehaviour', 'toggleElementCollapseBehaviour', 'unclaimIdBehavior', 'updateFlowNodeRefsBehavior', 'unsetDefaultFlowBehavior'],
      adaptiveLabelPositioningBehavior: ['type', Bd],
      appendBehavior: ['type', Pd],
      associationBehavior: ['type', Od],
      attachEventBehavior: ['type', Td],
      boundaryEventBehavior: ['type', Nd],
      compensateBoundaryEventBehaviour: ['type', Ld],
      createBehavior: ['type', qd],
      createDataObjectBehavior: ['type', Wd],
      createParticipantBehavior: ['type', Ud],
      dataInputAssociationBehavior: ['type', Qd],
      dataStoreBehavior: ['type', Jd],
      deleteLaneBehavior: ['type', mf],
      detachEventBehavior: ['type', vf],
      dropOnFlowBehavior: ['type', yf],
      eventBasedGatewayBehavior: ['type', Ef],
      fixHoverBehavior: ['type', _f],
      groupBehavior: ['type', Cf],
      importDockingFix: ['type', kf],
      isHorizontalFix: ['type', Bf],
      labelBehavior: ['type', Vf],
      layoutConnectionBehavior: ['type', Qf],
      messageFlowBehavior: ['type', rh],
      nonInterruptingBehavior: ['type', ch],
      removeElementBehavior: ['type', ph],
      removeEmbeddedLabelBoundsBehavior: ['type', lh],
      removeParticipantBehavior: ['type', dh],
      replaceConnectionBehavior: ['type', fh],
      replaceElementBehaviour: ['type', hh],
      resizeBehavior: ['type', xh],
      resizeLaneBehavior: ['type', Ph],
      rootElementReferenceBehavior: ['type', Oh],
      spaceToolBehavior: ['type', Rh],
      subProcessPlaneBehavior: ['type', Lh],
      subProcessStartEventBehavior: ['type', zh],
      textAnnotationBehavior: ['type', Fh],
      toggleCollapseConnectionBehaviour: ['type', $h],
      toggleElementCollapseBehaviour: ['type', Hh],
      unclaimIdBehavior: ['type', qh],
      unsetDefaultFlowBehavior: ['type', Wh],
      updateFlowNodeRefsBehavior: ['type', Gh]
    }
    function Qh (e, t) {
      const n = Cr(e, t, -15)
      return n !== 'intersect' ? n : null
    }
    function Yh (e) {
      Np.call(this, e)
    }
    function Kh (e) {
      return !e || br(e)
    }
    function Jh (e) {
      do {
        if (Pi(e, 'bpmn:Process')) { return Ti(e) }
        if (Pi(e, 'bpmn:Participant')) { return Ti(e).processRef || Ti(e) }
      } while (e = e.parent)
    }
    function Xh (e) {
      return Pi(e, 'bpmn:TextAnnotation')
    }
    function Zh (e) {
      return Pi(e, 'bpmn:Group') && !e.labelTarget
    }
    function em (e) {
      return Pi(e, 'bpmn:BoundaryEvent') && om(e, 'bpmn:CompensateEventDefinition')
    }
    function tm (e) {
      return Ti(e).isForCompensation
    }
    function nm (e) {
      for (let t = e; t = t.parent;) {
        if (Pi(t, 'bpmn:FlowElementsContainer')) { return Ti(t) }
        if (Pi(t, 'bpmn:Participant')) { return Ti(t).processRef }
      }
      return null
    }
    function rm (e, t) {
      return nm(e) === nm(t)
    }
    function om (e, t) {
      return !!H(Ti(e).eventDefinitions || [], function (e) {
        return Pi(e, t)
      }
      )
    }
    function im (e, t) {
      return (Ti(e).eventDefinitions || []).every(function (e) {
        return Pi(e, t)
      }
      )
    }
    function am (e, t) {
      const n = (function (e) {
        for (var t = []; e;) { (e = e.parent) && t.push(e) }
        return t
      }(t))
      return n.indexOf(e) !== -1
    }
    function sm (e, t, n) {
      if (Kh(e) || Kh(t)) { return null }
      if (!Pi(n, 'bpmn:DataAssociation')) {
        if (Am(e, t)) {
          return {
            type: 'bpmn:MessageFlow'
          }
        }
        if (Em(e, t)) {
          return {
            type: 'bpmn:SequenceFlow'
          }
        }
      }
      return xm(e, t) || (bm(e, t)
        ? {
            type: 'bpmn:Association',
            associationDirection: 'One'
          }
        : !!ym(e, t) && {
            type: 'bpmn:Association',
            associationDirection: 'None'
          })
    }
    function cm (e, t) {
      return !(!br(e) && !Zh(e)) || !(Pi(t, 'bpmn:Participant') && !Zi(t)) && (Pi(e, 'bpmn:Participant')
        ? Pi(t, 'bpmn:Process') || Pi(t, 'bpmn:Collaboration')
        : Oi(e, ['bpmn:DataInput', 'bpmn:DataOutput']) && e.parent
          ? t === e.parent
          : Pi(e, 'bpmn:Lane')
            ? Pi(t, 'bpmn:Participant') || Pi(t, 'bpmn:Lane')
            : !(Pi(e, 'bpmn:BoundaryEvent') && (n = e,
              !Ti(n).cancelActivity || !pm(n) && !um(n))) && (Pi(e, 'bpmn:FlowElement') && !Pi(e, 'bpmn:DataStoreReference')
                ? Pi(t, 'bpmn:FlowElementsContainer') ? Zi(t) : Oi(t, ['bpmn:Participant', 'bpmn:Lane'])
                : Pi(e, 'bpmn:DataStoreReference') && Pi(t, 'bpmn:Collaboration')
                  ? Q(Ti(t).get('participants'), function (e) {
                    return !!e.get('processRef')
                  }
                  )
                  : Oi(e, ['bpmn:Artifact', 'bpmn:DataAssociation', 'bpmn:DataStoreReference']) ? Oi(t, ['bpmn:Collaboration', 'bpmn:Lane', 'bpmn:Participant', 'bpmn:Process', 'bpmn:SubProcess']) : !!Pi(e, 'bpmn:MessageFlow') && (Pi(t, 'bpmn:Collaboration') || e.source.parent == t || e.target.parent == t)))
      let n
    }
    function lm (e) {
      return Pi(e, 'bpmn:Lane')
    }
    function pm (e) {
      const t = Ti(e)
      return t && !(t.eventDefinitions && t.eventDefinitions.length)
    }
    function um (e) {
      return dm(e, ['bpmn:MessageEventDefinition', 'bpmn:TimerEventDefinition', 'bpmn:SignalEventDefinition', 'bpmn:ConditionalEventDefinition'])
    }
    function dm (e, t) {
      return t.some(function (t) {
        return om(e, t)
      }
      )
    }
    function fm (e, t, n, r) {
      if (Array.isArray(e) || (e = [e]),
      e.length !== 1) { return !1 }
      const o = e[0]
      return !br(o) && !!(function (e) {
        return !!(function (e) {
          return !br(e) && Pi(e, 'bpmn:BoundaryEvent')
        }(e)) || !(!Pi(e, 'bpmn:IntermediateThrowEvent') || !pm(e)) || Pi(e, 'bpmn:IntermediateCatchEvent') && um(e)
      }(o)) && !ta(t) && !(!Pi(t, 'bpmn:Activity') || tm(t)) && !(r && !Qh(r, t)) && !(function (e) {
        return Pi(e, 'bpmn:ReceiveTask') && H(e.incoming, function (e) {
          return Pi(e.source, 'bpmn:EventBasedGateway')
        }
        )
      }(t)) && 'attach'
    }
    function hm (e, t, n) {
      if (!t) { return !1 }
      const r = {
        replacements: []
      }
      return G(e, function (e) {
        ta(t) || Pi(e, 'bpmn:StartEvent') && e.type !== 'label' && cm(e, t) && ((function (e) {
          return e && !1 !== Ti(e).isInterrupting
        }(e)) || r.replacements.push({
          oldElementId: e.id,
          newElementType: 'bpmn:StartEvent'
        }),
        ((function (e) {
          return na(e, 'bpmn:ErrorEventDefinition')
        }(e)) || (function (e) {
          return na(e, 'bpmn:EscalationEventDefinition')
        }(e)) || (function (e) {
          return na(e, 'bpmn:CompensateEventDefinition')
        }(e))) && r.replacements.push({
          oldElementId: e.id,
          newElementType: 'bpmn:StartEvent'
        }),
        dm(e, ['bpmn:MessageEventDefinition', 'bpmn:TimerEventDefinition', 'bpmn:SignalEventDefinition', 'bpmn:ConditionalEventDefinition']) && Pi(t, 'bpmn:SubProcess') && r.replacements.push({
          oldElementId: e.id,
          newElementType: 'bpmn:StartEvent'
        })),
        Pi(t, 'bpmn:Transaction') || om(e, 'bpmn:CancelEventDefinition') && e.type !== 'label' && (Pi(e, 'bpmn:EndEvent') && cm(e, t) && r.replacements.push({
          oldElementId: e.id,
          newElementType: 'bpmn:EndEvent'
        }),
        Pi(e, 'bpmn:BoundaryEvent') && fm(e, t, 0, n) && r.replacements.push({
          oldElementId: e.id,
          newElementType: 'bpmn:BoundaryEvent'
        }))
      }
      ),
      !!r.replacements.length && r
    }
    function mm (e, t) {
      return !Q(e, lm) && (!t || e.every(function (e) {
        return cm(e, t)
      }
      ))
    }
    function vm (e, t, n, r) {
      return !!t && (!(!br(e) && !Zh(e)) || !(function (e, t) {
        return e === t
      }(n, t)) && (!n || !am(n, t)) && (cm(e, t) || wm(e, t)))
    }
    function gm (e, t) {
      return Pi(e, 'bpmn:SubProcess') ? Zi(e) && (!t || t.width >= 100 && t.height >= 80) : !!(Pi(e, 'bpmn:Lane') || Pi(e, 'bpmn:Participant') || Xh(e) || Zh(e))
    }
    function ym (e, t) {
      return !(am(t, e) || am(e, t) || !(function (e, t) {
        const n = Xh(e)
        const r = Xh(t)
        return (n || r) && n !== r
      }(e, t)) && !xm(e, t))
    }
    function bm (e, t) {
      return rm(e, t) && em(e) && Pi(t, 'bpmn:Activity') && (n = e,
      !t.attachers.includes(n)) && !ta(t)
      let n
    }
    function Am (e, t) {
      return !(Cm(e) && !Cm(t)) && Pi(n = e, 'bpmn:InteractionNode') && !Pi(n, 'bpmn:BoundaryEvent') && (!Pi(n, 'bpmn:Event') || Pi(n, 'bpmn:ThrowEvent') && im(n, 'bpmn:MessageEventDefinition')) && (function (e) {
        return Pi(e, 'bpmn:InteractionNode') && !tm(e) && (!Pi(e, 'bpmn:Event') || Pi(e, 'bpmn:CatchEvent') && im(e, 'bpmn:MessageEventDefinition')) && !(Pi(e, 'bpmn:BoundaryEvent') && !om(e, 'bpmn:MessageEventDefinition'))
      }(t)) && !(function (e, t) {
        return Jh(e) === Jh(t)
      }(e, t))
      let n
    }
    function Em (e, t) {
      return Pi(n = e, 'bpmn:FlowNode') && !Pi(n, 'bpmn:EndEvent') && !ta(n) && !(Pi(n, 'bpmn:IntermediateThrowEvent') && om(n, 'bpmn:LinkEventDefinition')) && !em(n) && !tm(n) && (function (e) {
        return Pi(e, 'bpmn:FlowNode') && !Pi(e, 'bpmn:StartEvent') && !Pi(e, 'bpmn:BoundaryEvent') && !ta(e) && !(Pi(e, 'bpmn:IntermediateCatchEvent') && om(e, 'bpmn:LinkEventDefinition')) && !tm(e)
      }(t)) && rm(e, t) && !(Pi(e, 'bpmn:EventBasedGateway') && !(function (e) {
        return Pi(e, 'bpmn:ReceiveTask') || Pi(e, 'bpmn:IntermediateCatchEvent') && (om(e, 'bpmn:MessageEventDefinition') || om(e, 'bpmn:TimerEventDefinition') || om(e, 'bpmn:ConditionalEventDefinition') || om(e, 'bpmn:SignalEventDefinition'))
      }(t)))
      let n
    }
    function xm (e, t) {
      return Oi(e, ['bpmn:DataObjectReference', 'bpmn:DataStoreReference']) && Oi(t, ['bpmn:Activity', 'bpmn:ThrowEvent'])
        ? {
            type: 'bpmn:DataInputAssociation'
          }
        : !(!Oi(t, ['bpmn:DataObjectReference', 'bpmn:DataStoreReference']) || !Oi(e, ['bpmn:Activity', 'bpmn:CatchEvent'])) && {
            type: 'bpmn:DataOutputAssociation'
          }
    }
    function wm (e, t, n) {
      if (!t) { return !1 }
      if (Array.isArray(e)) {
        if (e.length !== 1) { return !1 }
        e = e[0]
      }
      return t.source !== e && t.target !== e && Oi(t, ['bpmn:SequenceFlow', 'bpmn:MessageFlow']) && !br(t) && Pi(e, 'bpmn:FlowNode') && !Pi(e, 'bpmn:BoundaryEvent') && cm(e, t.parent)
    }
    function _m (e, t) {
      return !!br(t) || !(Pi(t, 'bpmn:Lane') && !(function (e, t) {
        return e && t && e.indexOf(t) !== -1
      }(e, t.parent)))
    }
    function Cm (e) {
      return Hd(e, 'bpmn:Process') || Hd(e, 'bpmn:Collaboration')
    }
    w(Yh, Np),
    Yh.$inject = ['eventBus'],
    Yh.prototype.init = function () {
      this.addRule('connection.start', function (e) {
        return Kh(t = e.source) ? null : Oi(t, ['bpmn:FlowNode', 'bpmn:InteractionNode', 'bpmn:DataObjectReference', 'bpmn:DataStoreReference', 'bpmn:Group', 'bpmn:TextAnnotation'])
        let t
      }
      ),
      this.addRule('connection.create', function (e) {
        const t = e.source
        const n = e.target
        const r = e.hints || {}
        const o = r.targetParent
        if (r.targetAttach) { return !1 }
        o && (n.parent = o)
        try {
          return sm(t, n)
        } finally {
          o && (n.parent = null)
        }
      }
      ),
      this.addRule('connection.reconnect', function (e) {
        const t = e.connection
        return sm(e.source, e.target, t)
      }
      ),
      this.addRule('connection.updateWaypoints', function (e) {
        return {
          type: e.connection.type
        }
      }
      ),
      this.addRule('shape.resize', function (e) {
        return gm(e.shape, e.newBounds)
      }
      ),
      this.addRule('elements.create', function (e) {
        const t = e.elements
        const n = e.position
        const r = e.target
        return !(yr(r) && !wm(t, r)) && V(t, function (e) {
          return yr(e) ? sm(e.source, e.target, e) : e.host ? fm(e, e.host, 0, n) : vm(e, r, null)
        }
        )
      }
      ),
      this.addRule('elements.move', function (e) {
        const t = e.target
        const n = e.shapes
        const r = e.position
        return fm(n, t, 0, r) || hm(n, t, r) || mm(n, t) || wm(n, t)
      }
      ),
      this.addRule('shape.create', function (e) {
        return vm(e.shape, e.target, e.source, e.position)
      }
      ),
      this.addRule('shape.attach', function (e) {
        return fm(e.shape, e.target, 0, e.position)
      }
      ),
      this.addRule('element.copy', function (e) {
        const t = e.element
        return _m(e.elements, t)
      }
      )
    }
    ,
    Yh.prototype.canConnectMessageFlow = Am,
    Yh.prototype.canConnectSequenceFlow = Em,
    Yh.prototype.canConnectDataAssociation = xm,
    Yh.prototype.canConnectAssociation = ym,
    Yh.prototype.canConnectCompensationAssociation = bm,
    Yh.prototype.canMove = mm,
    Yh.prototype.canAttach = fm,
    Yh.prototype.canReplace = hm,
    Yh.prototype.canDrop = cm,
    Yh.prototype.canInsert = wm,
    Yh.prototype.canCreate = vm,
    Yh.prototype.canConnect = sm,
    Yh.prototype.canResize = gm,
    Yh.prototype.canCopy = _m
    const Sm = {
      __depends__: [hu],
      __init__: ['bpmnRules'],
      bpmnRules: ['type', Yh]
    }
    function km (e, t) {
      e.on('saveXML.start', 2e3, function () {
        G(t.getRootElements(), function (e) {
          let t; const n = Ri(e)
          t = Y(W(zt([e], !1), function (t) {
            return t !== e && !t.labelTarget
          }
          ), Ri),
          n.set('planeElement', t)
        }
        )
      }
      )
    }
    km.$inject = ['eventBus', 'canvas']
    const jm = {
      __init__: ['bpmnDiOrdering'],
      bpmnDiOrdering: ['type', km]
    }
    function Bm (e) {
      Es.call(this, e)
      const t = this
      this.preExecute(['shape.create', 'connection.create'], function (e) {
        const n = e.context
        const r = n.shape || n.connection
        const o = n.parent
        const i = t.getOrdering(r, o)
        i && (void 0 !== i.parent && (n.parent = i.parent),
        n.parentIndex = i.index)
      }
      ),
      this.preExecute(['shape.move', 'connection.move'], function (e) {
        const n = e.context
        const r = n.shape || n.connection
        const o = n.newParent || r.parent
        const i = t.getOrdering(r, o)
        i && (void 0 !== i.parent && (n.newParent = i.parent),
        n.newParentIndex = i.index)
      }
      )
    }
    function Dm (e, t, n) {
      Bm.call(this, e)
      const r = [{
        type: 'bpmn:SubProcess',
        order: {
          level: 6
        }
      }, {
        type: 'bpmn:SequenceFlow',
        order: {
          level: 9,
          containers: ['bpmn:Participant', 'bpmn:FlowElementsContainer']
        }
      }, {
        type: 'bpmn:DataAssociation',
        order: {
          level: 9,
          containers: ['bpmn:Collaboration', 'bpmn:FlowElementsContainer']
        }
      }, {
        type: 'bpmn:TextAnnotation',
        order: {
          level: 9
        }
      }, {
        type: 'bpmn:MessageFlow',
        order: {
          level: 9,
          containers: ['bpmn:Collaboration']
        }
      }, {
        type: 'bpmn:Association',
        order: {
          level: 6,
          containers: ['bpmn:Participant', 'bpmn:FlowElementsContainer', 'bpmn:Collaboration']
        }
      }, {
        type: 'bpmn:BoundaryEvent',
        order: {
          level: 8
        }
      }, {
        type: 'bpmn:Group',
        order: {
          level: 10,
          containers: ['bpmn:Collaboration', 'bpmn:FlowElementsContainer']
        }
      }, {
        type: 'bpmn:FlowElement',
        order: {
          level: 5
        }
      }, {
        type: 'bpmn:Participant',
        order: {
          level: -2
        }
      }, {
        type: 'bpmn:Lane',
        order: {
          level: -1
        }
      }]
      function o (e) {
        let t = e.order
        if (t || (e.order = t = (function (e) {
          if (e.labelTarget) {
            return {
              level: 10
            }
          }
          const t = H(r, function (t) {
            return Oi(e, [t.type])
          }
          )
          return t && t.order || {
            level: 1
          }
        }(e))),
        !t) { throw new Error('no order for <' + e.id + '>') }
        return t
      }
      this.getOrdering = function (e, n) {
        if (e.labelTarget || Pi(e, 'bpmn:TextAnnotation')) {
          return {
            parent: t.findRoot(n) || t.getRootElement(),
            index: -1
          }
        }
        const r = o(e)
        r.containers && (n = (function (e, t, n) {
          for (var r = t; r && !Oi(r, n);) { r = r.parent }
          if (!r) { throw new Error('no parent for <' + e.id + '> in <' + (t && t.id) + '>') }
          return r
        }(e, n, r.containers)))
        const i = n.children.indexOf(e)
        let a = q(n.children, function (t) {
          return !(!e.labelTarget && t.labelTarget) && r.level < o(t).level
        }
        )
        return a !== -1 && i !== -1 && i < a && (a -= 1),
        {
          index: a,
          parent: n
        }
      }
    }
    Bm.prototype.getOrdering = function (e, t) {
      return null
    }
    ,
    w(Bm, Es),
    Dm.$inject = ['eventBus', 'canvas', 'translate'],
    w(Dm, Bm)
    const Pm = {
      __depends__: [La],
      __init__: ['bpmnOrderingProvider'],
      bpmnOrderingProvider: ['type', Dm]
    }
    function Om () {}
    Om.prototype.get = function () {
      return this._data
    }
    ,
    Om.prototype.set = function (e) {
      this._data = e
    }
    ,
    Om.prototype.clear = function () {
      const e = this._data
      return delete this._data,
      e
    }
    ,
    Om.prototype.isEmpty = function () {
      return !this._data
    }

    const Tm = {
      clipboard: ['type', Om]
    }
    const Rm = 'drop-ok'
    const Nm = 'drop-not-ok'
    const Mm = 'attach-ok'
    const Im = 'new-parent'
    const Lm = 'create'
    function zm (e, t, n, r, o) {
      function i (t, n) {
        [Mm, Rm, Nm, Im].forEach(function (r) {
          r === n ? e.addMarker(t, r) : e.removeMarker(t, r)
        }
        )
      }
      function a () {
        const e = t.context()
        e && e.prefix === Lm && t.cancel()
      }
      n.on(['create.move', 'create.hover'], function (e) {
        const t = e.context
        const n = t.elements
        const r = e.hover
        const a = t.source
        const s = t.hints || {}
        if (!r) {
          return t.canExecute = !1,
          void (t.target = null)
        }
        Fm(e)
        const c = {
          x: e.x,
          y: e.y
        }
        const l = t.canExecute = r && (function (e, t, n, r, i) {
          if (!t) { return !1 }
          const a = H(e = W(e, function (t) {
            const n = t.labelTarget
            return !(t.parent || br(t) && e.indexOf(n) !== -1)
          }
          ), function (e) {
            return !yr(e)
          }
          )
          let s = !1
          let c = !1
          let l = !1
          $m(e) && (s = o.allowed('shape.attach', {
            position: n,
            shape: a,
            target: t
          })),
          s || (l = $m(e)
            ? o.allowed('shape.create', {
              position: n,
              shape: a,
              source: r,
              target: t
            })
            : o.allowed('elements.create', {
              elements: e,
              position: n,
              target: t
            }))
          const p = i.connectionTarget
          return l || s
            ? (a && r && (c = o.allowed('connection.create', {
                source: p === r ? a : r,
                target: p === r ? r : a,
                hints: {
                  targetParent: t,
                  targetAttach: s
                }
              })),
              {
                attach: s,
                connect: c
              })
            : (l === null || s === null) && null
        }(n, r, c, a, s))
        r && l !== null && (t.target = r,
        l && l.attach ? i(r, Mm) : i(r, l ? Im : Nm))
      }
      ),
      n.on(['create.end', 'create.out', 'create.cleanup'], function (e) {
        const t = e.hover
        t && i(t, null)
      }
      ),
      n.on('create.end', function (e) {
        const t = e.context
        const n = t.source
        let o = t.shape
        let i = t.elements
        const a = t.target
        const s = t.canExecute
        const c = s && s.attach
        const l = s && s.connect
        const p = t.hints || {}
        if (!1 === s || !a) { return !1 }
        Fm(e)
        const u = {
          x: e.x,
          y: e.y
        }
        o = l
          ? r.appendShape(n, o, u, a, {
            attach: c,
            connection: !0 === l ? {} : l,
            connectionTarget: p.connectionTarget
          })
          : H(i = r.createElements(i, u, a, le({}, p, {
            attach: c
          })), function (e) {
            return !yr(e)
          }
          ),
        le(t, {
          elements: i,
          shape: o
        }),
        le(e, {
          elements: i,
          shape: o
        })
      }
      ),
      n.on('create.init', function () {
        n.on('elements.changed', a),
        n.once(['create.cancel', 'create.end'], 2e3, function () {
          n.off('elements.changed', a)
        }
        )
      }
      ),
      this.start = function (e, n, r) {
        M(n) || (n = [n])
        const o = H(n, function (e) {
          return !yr(e)
        }
        )
        if (o) {
          r = le({
            elements: n,
            hints: {},
            shape: o
          }, r || {}),
          G(n, function (e) {
            L(e.x) || (e.x = 0),
            L(e.y) || (e.y = 0)
          }
          )
          const i = Ft(W(n, function (e) {
            return !e.hidden
          }
          ))
          G(n, function (e) {
            yr(e) && (e.waypoints = Y(e.waypoints, function (e) {
              return {
                x: e.x - i.x - i.width / 2,
                y: e.y - i.y - i.height / 2
              }
            }
            )),
            le(e, {
              x: e.x - i.x - i.width / 2,
              y: e.y - i.y - i.height / 2
            })
          }
          ),
          t.init(e, Lm, {
            cursor: 'grabbing',
            autoActivate: !0,
            data: {
              shape: o,
              elements: n,
              context: r
            }
          })
        }
      }
    }
    function Fm (e) {
      const t = e.context.createConstraints
      t && (t.left && (e.x = Math.max(e.x, t.left)),
      t.right && (e.x = Math.min(e.x, t.right)),
      t.top && (e.y = Math.max(e.y, t.top)),
      t.bottom && (e.y = Math.min(e.y, t.bottom)))
    }
    function $m (e) {
      return e && e.length === 1 && !yr(e[0])
    }
    function Hm (e, t, n, r, o) {
      t.on('create.move', 750, function (t) {
        const i = t.hover
        const a = t.context
        const s = a.elements
        let c = a.dragGroup
        c || (c = a.dragGroup = (function (e) {
          const t = et('g')
          We(t, o.cls('djs-drag-group', ['no-events']))
          const i = et('g')
          return e.forEach(function (e) {
            let o
            e.hidden || (e.waypoints
              ? (o = n._createContainer('connection', i),
                n.drawConnection(to(o), e))
              : (o = n._createContainer('shape', i),
                n.drawShape(to(o), e),
                ro(o, e.x, e.y)),
            r.addDragger(e, t, o))
          }
          ),
          t
        }(s))),
        i
          ? (c.parentNode || Fe(e.getActiveLayer(), c),
            ro(c, t.x, t.y))
          : Qe(c)
      }
      ),
      t.on('create.cleanup', function (e) {
        const t = e.context.dragGroup
        t && Qe(t)
      }
      )
    }
    zm.$inject = ['canvas', 'dragging', 'eventBus', 'modeling', 'rules'],
    Hm.$inject = ['canvas', 'eventBus', 'graphicsFactory', 'previewSupport', 'styles']
    const qm = {
      __depends__: [pu, Ad, hu, us],
      __init__: ['create', 'createPreview'],
      create: ['type', zm],
      createPreview: ['type', Hm]
    }
    function Wm (e) {
      const t = this
      function n (e) {
        t._lastMoveEvent = e
      }
      this._lastMoveEvent = null,
      e.on('canvas.init', function (e) {
        (t._svg = e.svg).addEventListener('mousemove', n)
      }
      ),
      e.on('canvas.destroy', function () {
        t._lastMouseEvent = null,
        t._svg.removeEventListener('mousemove', n)
      }
      )
    }
    Wm.$inject = ['eventBus'],
    Wm.prototype.getLastMoveEvent = function () {
      return this._lastMoveEvent || ((e = document.createEvent('MouseEvent')).initMouseEvent && e.initMouseEvent('mousemove', !0, !0, window, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null),
      e)
      let e
    }

    const Gm = {
      __init__: ['mouse'],
      mouse: ['type', Wm]
    }
    function Um (e, t, n, r, o, i, a, s) {
      this._canvas = e,
      this._create = t,
      this._clipboard = n,
      this._elementFactory = r,
      this._eventBus = o,
      this._modeling = i,
      this._mouse = a,
      this._rules = s,
      o.on('copyPaste.copyElement', function (e) {
        const t = e.descriptor
        const n = e.element
        const r = e.elements
        t.priority = 1,
        t.id = n.id
        const o = H(r, function (e) {
          return e === n.parent
        }
        )
        o && (t.parent = n.parent.id),
        (function (e) {
          return !!e.host
        }(n)) && (t.priority = 2,
        t.host = n.host.id),
        yr(n) && (t.priority = 3,
        t.source = n.source.id,
        t.target = n.target.id,
        t.waypoints = (function (e) {
          return Y(e.waypoints, function (e) {
            return (e = Vm(e)).original && (e.original = Vm(e.original)),
            e
          }
          )
        }(n))),
        br(n) && (t.priority = 4,
        t.labelTarget = n.labelTarget.id),
        G(['x', 'y', 'width', 'height'], function (e) {
          L(n[e]) && (t[e] = n[e])
        }
        ),
        t.hidden = n.hidden,
        t.collapsed = n.collapsed
      }
      ),
      o.on('copyPaste.pasteElements', function (e) {
        le(e.hints, {
          createElementsBehavior: !1
        })
      }
      )
    }
    function Vm (e) {
      return le({}, e)
    }
    function Qm (e, t) {
      const n = t.indexOf(e)
      return n === -1 ? t : t.splice(n, 1)
    }
    Um.$inject = ['canvas', 'create', 'clipboard', 'elementFactory', 'eventBus', 'modeling', 'mouse', 'rules'],
    Um.prototype.copy = function (e) {
      let t, n
      return M(e) || (e = e ? [e] : []),
      n = !1 === (t = this._eventBus.fire('copyPaste.canCopyElements', {
        elements: e
      }))
        ? {}
        : this.createTree(M(t) ? t : e),
      this._clipboard.set(n),
      this._eventBus.fire('copyPaste.elementsCopied', {
        elements: e,
        tree: n
      }),
      n
    }
    ,
    Um.prototype.paste = function (e) {
      const t = this._clipboard.get()
      if (!this._clipboard.isEmpty()) {
        const n = e && e.hints || {}
        this._eventBus.fire('copyPaste.pasteElements', {
          hints: n
        })
        const r = this._createElements(t)
        if (e && e.element && e.point) { return this._paste(r, e.element, e.point, n) }
        this._create.start(this._mouse.getLastMoveEvent(), r, {
          hints: n || {}
        })
      }
    }
    ,
    Um.prototype._paste = function (e, t, n, r) {
      G(e, function (e) {
        L(e.x) || (e.x = 0),
        L(e.y) || (e.y = 0)
      }
      )
      const o = Ft(e)
      return G(e, function (e) {
        yr(e) && (e.waypoints = Y(e.waypoints, function (e) {
          return {
            x: e.x - o.x - o.width / 2,
            y: e.y - o.y - o.height / 2
          }
        }
        )),
        le(e, {
          x: e.x - o.x - o.width / 2,
          y: e.y - o.y - o.height / 2
        })
      }
      ),
      this._modeling.createElements(e, n, t, le({}, r))
    }
    ,
    Um.prototype._createElements = function (e) {
      const t = this
      const n = this._eventBus
      const r = {}
      const o = []
      return G(e, function (e, i) {
        i = parseInt(i, 10),
        G(e = te(e, 'priority'), function (e) {
          let i; const a = le({}, ue(e, ['priority']))
          return r[e.parent] ? a.parent = r[e.parent] : delete a.parent,
          n.fire('copyPaste.pasteElement', {
            cache: r,
            descriptor: a
          }),
          yr(a)
            ? (a.source = r[e.source],
              a.target = r[e.target],
              i = r[e.id] = t.createConnection(a),
              void o.push(i))
            : br(a)
              ? (a.labelTarget = r[a.labelTarget],
                i = r[e.id] = t.createLabel(a),
                void o.push(i))
              : (a.host && (a.host = r[a.host]),
                i = r[e.id] = t.createShape(a),
                void o.push(i))
        }
        )
      }
      ),
      o
    }
    ,
    Um.prototype.createConnection = function (e) {
      return this._elementFactory.createConnection(ue(e, ['id']))
    }
    ,
    Um.prototype.createLabel = function (e) {
      return this._elementFactory.createLabel(ue(e, ['id']))
    }
    ,
    Um.prototype.createShape = function (e) {
      return this._elementFactory.createShape(ue(e, ['id']))
    }
    ,
    Um.prototype.hasRelations = function (e, t) {
      let n, r
      return !(yr(e) && (n = H(t, ne({
        id: e.source.id
      })),
      r = H(t, ne({
        id: e.target.id
      })),
      !n || !r) || br(e) && !H(t, ne({
        id: e.labelTarget.id
      })))
    }
    ,
    Um.prototype.createTree = function (e) {
      const t = this._rules
      const n = this
      const r = {}
      let o = []
      function i (e, t) {
        const n = H(o, function (t) {
          return e === t.element
        }
        )
        n
          ? n.depth < t && (o = (function (e, t) {
            const n = t.indexOf(e)
            return n !== -1 && t.splice(n, 1),
            t
          }(n, o)),
          o.push({
            element: n.element,
            depth: t
          }))
          : o.push({
            element: e,
            depth: t
          })
      }
      return Lt(Nt(e), function (e, t, r) {
        if (!br(e)) {
          G(e.labels, function (e) {
            i(e, r)
          }
          ),
          G([e.attachers, e.incoming, e.outgoing], function (e) {
            e && e.length && G(e, function (e) {
              G(e.labels, function (e) {
                i(e, r)
              }
              ),
              i(e, r)
            }
            )
          }
          ),
          i(e, r)
          let o = []
          return e.children && (o = e.children.slice()),
          n._eventBus.fire('copyPaste.createTree', {
            element: e,
            children: o
          }),
          o
        }
      }
      ),
      e = Y(o, function (e) {
        return e.element
      }
      ),
      o = Y(o, function (t) {
        return t.descriptor = {},
        n._eventBus.fire('copyPaste.copyElement', {
          descriptor: t.descriptor,
          element: t.element,
          elements: e
        }),
        t
      }
      ),
      o = te(o, function (e) {
        return e.descriptor.priority
      }
      ),
      e = Y(o, function (e) {
        return e.element
      }
      ),
      G(o, function (o) {
        const i = o.depth
        n.hasRelations(o.element, e) && (function (e, n) {
          return t.allowed('element.copy', {
            element: e,
            elements: n
          })
        }(o.element, e))
          ? (r[i] || (r[i] = []),
            r[i].push(o.descriptor))
          : Qm(o.element, e)
      }
      ),
      r
    }

    const Ym = {
      __depends__: [Tm, qm, Gm, hu],
      __init__: ['copyPaste'],
      copyPaste: ['type', Um]
    }
    function Km (e, t, n) {
      M(n) || (n = [n]),
      G(n, function (n) {
        T(e[n]) || (t[n] = e[n])
      }
      )
    }
    function Jm (e, t, n) {
      function r (t, r) {
        const o = e.create(t.$type)
        return n.copyElement(t, o, null, r)
      }
      t.on('copyPaste.copyElement', 750, function (e) {
        const t = e.descriptor
        const n = e.element
        const o = Ti(n)
        if (br(n)) { return t }
        const i = t.businessObject = r(o, !0)
        const a = t.di = r(Ri(n), !0)
        a.bpmnElement = i,
        Km(i, t, 'name'),
        Km(a, t, 'isExpanded'),
        o.default && (t.default = o.default.id)
      }
      )
      const o = '-bpmn-js-refs'
      t.on('copyPaste.pasteElement', function (e) {
        const t = e.cache
        const n = e.descriptor
        let o = n.businessObject
        let i = n.di
        if (br(n)) {
          return n.businessObject = Ti(t[n.labelTarget]),
          void (n.di = Ri(t[n.labelTarget]))
        }
        o = n.businessObject = r(o),
        (i = n.di = r(i)).bpmnElement = o,
        Km(n, o, ['isExpanded', 'name']),
        n.type = o.$type
      }
      ),
      t.on('copyPaste.copyElement', 750, function (e) {
        const t = e.descriptor
        const n = e.element
        if (Pi(n, 'bpmn:Participant')) {
          const o = Ti(n)
          o.processRef && (t.processRef = r(o.processRef, !0))
        }
      }
      ),
      t.on('copyPaste.pasteElement', function (e) {
        const t = e.descriptor
        const n = t.processRef
        n && (t.processRef = r(n))
      }
      ),
      t.on('copyPaste.pasteElement', 750, function (e) {
        const t = e.cache
        !(function (e, t) {
          e[o] = t
        }(t, (function (e, t, n) {
          const r = Ti(e)
          return e.default && (n[e.default] = {
            element: r,
            property: 'default'
          }),
          e.host && (Ti(e).attachedToRef = Ti(t[e.host])),
          ue(n, U(n, function (t, n, o) {
            const i = n.element
            const a = n.property
            return o === e.id && (i.set(a, r),
            t.push(e.id)),
            t
          }
          , []))
        }(e.descriptor, t, (function (e) {
          return e[o] = e[o] || {}
        }(t))))))
      }
      )
    }
    Jm.$inject = ['bpmnFactory', 'eventBus', 'moddleCopy']
    const Xm = ['artifacts', 'dataInputAssociations', 'dataOutputAssociations', 'default', 'flowElements', 'lanes', 'incoming', 'outgoing', 'categoryValue']
    function Zm (e, t, n) {
      this._bpmnFactory = t,
      this._eventBus = e,
      this._moddle = n,
      e.on('moddleCopy.canCopyProperties', function (e) {
        const t = e.propertyNames
        if (t && t.length) {
          return te(t, function (e) {
            return e === 'extensionElements'
          }
          )
        }
      }
      ),
      e.on('moddleCopy.canCopyProperty', function (e) {
        const t = e.parent
        const n = I(t) && t.$descriptor
        const r = e.propertyName
        return (!r || Xm.indexOf(r) === -1) && !(r && n && !H(n.properties, ne({
          name: r
        }))) && void 0
      }
      ),
      e.on('moddleCopy.canSetCopiedProperty', function (e) {
        let t; const n = e.property
        if ('bpmn:ExtensionElements',
        (t = n) && z(t.$instanceOf) && t.$instanceOf('bpmn:ExtensionElements') && (!n.values || !n.values.length)) { return !1 }
      }
      )
    }
    function ev (e, t) {
      return U(e.properties, function (e, n) {
        return t && n.default ? e : e.concat(n.name)
      }
      , [])
    }
    Zm.$inject = ['eventBus', 'bpmnFactory', 'moddle'],
    Zm.prototype.copyElement = function (e, t, n) {
      const r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]
      const o = this
      n && !M(n) && (n = [n]),
      n = n || ev(e.$descriptor)
      const i = this._eventBus.fire('moddleCopy.canCopyProperties', {
        propertyNames: n,
        sourceElement: e,
        targetElement: t,
        clone: r
      })
      return !1 === i || (M(i) && (n = i),
      G(n, function (n) {
        let i
        $(e, n) && (i = e.get(n))
        const a = o.copyProperty(i, t, n, r)
        R(a) && !1 !== o._eventBus.fire('moddleCopy.canSetCopiedProperty', {
          parent: t,
          property: a,
          propertyName: n
        }) && t.set(n, a)
      }
      )),
      t
    }
    ,
    Zm.prototype.copyProperty = function (e, t, n) {
      const r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]
      const o = this
      let i = this._eventBus.fire('moddleCopy.canCopyProperty', {
        parent: t,
        property: e,
        propertyName: n,
        clone: r
      })
      if (!1 !== i) {
        if (i) {
          return I(i) && i.$type && !i.$parent && (i.$parent = t),
          i
        }
        const a = this._moddle.getPropertyDescriptor(t, n)
        if (!a.isReference) {
          if (a.isId) { return e && this._copyId(e, t, r) }
          if (M(e)) {
            return U(e, function (e, a) {
              return (i = o.copyProperty(a, t, n, r)) ? e.concat(i) : e
            }
            , [])
          }
          if (I(e) && e.$type) {
            if (this._moddle.getElementDescriptor(e).isGeneric) { return }
            return (i = o._bpmnFactory.create(e.$type)).$parent = t,
            i = o.copyElement(e, i, null, r)
          }
          return e
        }
      }
    }
    ,
    Zm.prototype._copyId = function (e, t) {
      return arguments.length > 2 && void 0 !== arguments[2] && arguments[2]
        ? e
        : this._moddle.ids.assigned(e)
          ? void 0
          : (this._moddle.ids.claim(e, t),
            e)
    }

    const tv = {
      __depends__: [Ym],
      __init__: ['bpmnCopyPaste', 'moddleCopy'],
      bpmnCopyPaste: ['type', Jm],
      moddleCopy: ['type', Zm]
    }
    const nv = Math.round
    function rv (e, t) {
      this._modeling = e,
      this._eventBus = t
    }
    function ov (e, t) {
      t.on('replace.end', 500, function (t) {
        const n = t.newElement
        const r = t.hints
        !1 !== (void 0 === r ? {} : r).select && e.select(n)
      }
      )
    }
    rv.$inject = ['modeling', 'eventBus'],
    rv.prototype.replaceElement = function (e, t, n) {
      if (e.waypoints) { return null }
      const r = this._modeling
      const o = this._eventBus
      o.fire('replace.start', {
        element: e,
        attrs: t,
        hints: n
      })
      const i = t.width || e.width
      const a = t.height || e.height
      const s = t.x || e.x
      const c = t.y || e.y
      const l = nv(s + i / 2)
      const p = nv(c + a / 2)
      const u = r.replaceShape(e, le({}, t, {
        x: l,
        y: p,
        width: i,
        height: a
      }), n)
      return o.fire('replace.end', {
        element: e,
        newElement: u,
        hints: n
      }),
      u
    }
    ,
    ov.$inject = ['selection', 'eventBus']
    const iv = {
      __init__: ['replace', 'replaceSelectionBehavior'],
      replaceSelectionBehavior: ['type', ov],
      replace: ['type', rv]
    }
    function av (e) {
      return av = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      av(e)
    }
    function sv (e, t) {
      const n = Object.keys(e)
      if (Object.getOwnPropertySymbols) {
        let r = Object.getOwnPropertySymbols(e)
        t && (r = r.filter(function (t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable
        }
        )),
        n.push.apply(n, r)
      }
      return n
    }
    function cv (e) {
      for (let t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {}
        t % 2
          ? sv(Object(n), !0).forEach(function (t) {
            let r, o, i
            r = e,
            o = t,
            i = n[t],
            o = (function (e) {
              const t = (function (e, t) {
                if (av(e) != 'object' || !e) { return e }
                const n = e[Symbol.toPrimitive]
                if (void 0 !== n) {
                  const r = n.call(e, 'string')
                  if (av(r) != 'object') { return r }
                  throw new TypeError('@@toPrimitive must return a primitive value.')
                }
                return String(e)
              }(e))
              return av(t) == 'symbol' ? t : t + ''
            }(o)),
            o in r
              ? Object.defineProperty(r, o, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
              })
              : r[o] = i
          }
          )
          : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
            : sv(Object(n)).forEach(function (t) {
              Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
            }
            )
      }
      return e
    }
    const lv = ['cancelActivity', 'instantiate', 'eventGatewayType', 'triggeredByEvent', 'isInterrupting']
    function pv (e, t, n, r, o, i) {
      this.replaceElement = function (a, s, c) {
        c = c || {}
        const l = s.type
        const p = a.businessObject
        if (uv(p) && l === 'bpmn:SubProcess' && (function (e, t) {
          const n = e && $(e, 'collapsed') ? e.collapsed : !Zi(e)
          return n !== (t && ($(t, 'collapsed') || $(t, 'isExpanded')) ? $(t, 'collapsed') ? t.collapsed : !t.isExpanded : n)
        }(a, s))) {
          return r.toggleCollapse(a),
          a
        }
        let u = e.create(l)
        const d = {
          type: l,
          businessObject: u,
          di: {}
        }
        l === 'bpmn:ExclusiveGateway' && (d.di.isMarkerVisible = !0),
        (function (e, t, n) {
          M(n) || (n = [n]),
          G(n, function (n) {
            T(e[n]) || (t[n] = e[n])
          }
          )
        }(a.di, d.di, ['fill', 'stroke', 'background-color', 'border-color', 'color']))
        const f = (function (e, t) {
          return e.filter(function (e) {
            return t.includes(e)
          }
          )
        }(ev(p.$descriptor), ev(u.$descriptor, !0)))
        le(u, pe(s, lv))
        const h = W(f, function (e) {
          return e === 'eventDefinitions' ? dv(a, s.eventDefinitionType) : e === 'loopCharacteristics' ? !ta(u) : !($(u, e) || e === 'processRef' && !1 === s.isExpanded || e === 'triggeredByEvent' || e === 'isForCompensation' && ta(u))
        }
        )
        if (u = n.copyElement(p, u, h),
        s.eventDefinitionType && (dv(u, s.eventDefinitionType) || (d.eventDefinitionType = s.eventDefinitionType,
        d.eventDefinitionAttrs = s.eventDefinitionAttrs)),
        Pi(p, 'bpmn:Activity')) {
          if (uv(p)) { d.isExpanded = Zi(a) } else if (s && $(s, 'isExpanded')) {
            d.isExpanded = s.isExpanded
            const m = t.getDefaultSize(u, {
              isExpanded: d.isExpanded
            })
            d.width = m.width,
            d.height = m.height,
            d.x = a.x - (d.width - a.width) / 2,
            d.y = a.y - (d.height - a.height) / 2
          }
          Zi(a) && !Pi(p, 'bpmn:Task') && d.isExpanded && (d.width = a.width,
          d.height = a.height)
        }
        return uv(p) && !uv(u) && (c.moveChildren = !1),
        Pi(p, 'bpmn:Participant') && (!0 === s.isExpanded ? u.processRef = e.create('bpmn:Process') : c.moveChildren = !1,
        d.width = a.width,
        d.height = t.getDefaultSize(d).height),
        i.allowed('shape.resize', {
          shape: u
        }) || (d.height = t.getDefaultSize(d).height,
        d.width = t.getDefaultSize(d).width),
        u.name = p.name,
        Oi(p, ['bpmn:ExclusiveGateway', 'bpmn:InclusiveGateway', 'bpmn:Activity']) && Oi(u, ['bpmn:ExclusiveGateway', 'bpmn:InclusiveGateway', 'bpmn:Activity']) && (u.default = p.default),
        s.host && !Pi(p, 'bpmn:BoundaryEvent') && Pi(u, 'bpmn:BoundaryEvent') && (d.host = s.host),
        d.type !== 'bpmn:DataStoreReference' && d.type !== 'bpmn:DataObjectReference' || (d.x = a.x + (a.width - d.width) / 2),
        o.replaceElement(a, d, cv(cv({}, c), {}, {
          targetElement: s
        }))
      }
    }
    function uv (e) {
      return Pi(e, 'bpmn:SubProcess')
    }
    function dv (e, t) {
      const n = Ti(e)
      return t && n.get('eventDefinitions').some(function (e) {
        return Pi(e, t)
      }
      )
    }
    pv.$inject = ['bpmnFactory', 'elementFactory', 'moddleCopy', 'modeling', 'replace', 'rules']
    const fv = {
      __depends__: [tv, iv, us],
      bpmnReplace: ['type', pv]
    }
    function hv (e, t) {
      this._eventBus = e,
      this._dragging = t,
      this._tools = [],
      this._active = null
    }
    hv.$inject = ['eventBus', 'dragging'],
    hv.prototype.registerTool = function (e, t) {
      const n = this._tools
      if (!t) { throw new Error('A tool has to be registered with it\'s "events"') }
      n.push(e),
      this.bindEvents(e, t)
    }
    ,
    hv.prototype.isActive = function (e) {
      return e && this._active === e
    }
    ,
    hv.prototype.length = function (e) {
      return this._tools.length
    }
    ,
    hv.prototype.setActive = function (e) {
      const t = this._eventBus
      this._active !== e && (this._active = e,
      t.fire('tool-manager.update', {
        tool: e
      }))
    }
    ,
    hv.prototype.bindEvents = function (e, t) {
      const n = this._eventBus
      const r = this._dragging
      const o = []
      n.on(t.tool + '.init', function (t) {
        if (!t.context.reactivate && this.isActive(e)) {
          return this.setActive(null),
          void r.cancel()
        }
        this.setActive(e)
      }
      , this),
      G(t, function (e) {
        o.push(e + '.ended'),
        o.push(e + '.canceled')
      }
      ),
      n.on(o, 250, function (e) {
        this._active && ((function (e) {
          const t = e.originalEvent && e.originalEvent.target
          return t && sn(t, '.group[data-group="tools"]')
        }(e)) || this.setActive(null))
      }
      , this)
    }

    const mv = {
      __depends__: [pu],
      __init__: ['toolManager'],
      toolManager: ['type', hv]
    }
    function vv (e, t) {
      return e.indexOf(t) !== -1
    }
    function gv (e) {
      return (function (e) {
        if (Array.isArray(e)) { return yv(e) }
      }(e)) || (function (e) {
        if (typeof Symbol !== 'undefined' && e[Symbol.iterator] != null || e['@@iterator'] != null) { return Array.from(e) }
      }(e)) || (function (e, t) {
        if (e) {
          if (typeof e === 'string') { return yv(e, t) }
          let n = Object.prototype.toString.call(e).slice(8, -1)
          return n === 'Object' && e.constructor && (n = e.constructor.name),
          n === 'Map' || n === 'Set' ? Array.from(e) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? yv(e, t) : void 0
        }
      }(e)) || (function () {
        throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
      }())
    }
    function yv (e, t) {
      (t == null || t > e.length) && (t = e.length)
      for (var n = 0, r = new Array(t); n < t; n++) { r[n] = e[n] }
      return r
    }
    const bv = Math.abs
    const Av = Math.round
    const Ev = {
      x: 'width',
      y: 'height'
    }
    const xv = 'crosshair'
    const wv = {
      n: 'top',
      w: 'left',
      s: 'bottom',
      e: 'right'
    }
    const _v = 1500
    const Cv = {
      n: 's',
      w: 'e',
      s: 'n',
      e: 'w'
    }
    function Sv (e, t, n, r, o, i, a) {
      this._canvas = e,
      this._dragging = t,
      this._eventBus = n,
      this._modeling = r,
      this._rules = o,
      this._toolManager = i,
      this._mouse = a
      const s = this
      i.registerTool('space', {
        tool: 'spaceTool.selection',
        dragging: 'spaceTool'
      }),
      n.on('spaceTool.selection.end', function (e) {
        n.once('spaceTool.selection.ended', function () {
          s.activateMakeSpace(e.originalEvent)
        }
        )
      }
      ),
      n.on('spaceTool.move', _v, function (e) {
        const t = e.context
        let n = t.initialized
        n || (n = t.initialized = s.init(e, t)),
        n && jv(e)
      }
      ),
      n.on('spaceTool.end', function (e) {
        const t = e.context
        const r = t.axis
        const o = t.direction
        const i = t.movingShapes
        const a = t.resizingShapes
        const c = t.start
        if (t.initialized) {
          jv(e)
          const l = {
            x: 0,
            y: 0
          }
          l[r] = Av(e['d' + r]),
          s.makeSpace(i, a, l, o, c),
          n.once('spaceTool.ended', function (e) {
            s.activateSelection(e.originalEvent, !0, !0)
          }
          )
        }
      }
      )
    }
    function kv (e) {
      return {
        top: e.top - 20,
        right: e.right + 20,
        bottom: e.bottom + 20,
        left: e.left - 20
      }
    }
    function jv (e) {
      let t; let n; const r = e.context.spaceToolConstraints
      r && (L(r.left) && (t = Math.max(e.x, r.left),
      e.dx = e.dx + t - e.x,
      e.x = t),
      L(r.right) && (t = Math.min(e.x, r.right),
      e.dx = e.dx + t - e.x,
      e.x = t),
      L(r.top) && (n = Math.max(e.y, r.top),
      e.dy = e.dy + n - e.y,
      e.y = n),
      L(r.bottom) && (n = Math.min(e.y, r.bottom),
      e.dy = e.dy + n - e.y,
      e.y = n))
    }
    function Bv (e, t) {
      return e.indexOf(t) !== -1
    }
    Sv.$inject = ['canvas', 'dragging', 'eventBus', 'modeling', 'rules', 'toolManager', 'mouse'],
    Sv.prototype.activateSelection = function (e, t, n) {
      this._dragging.init(e, 'spaceTool.selection', {
        autoActivate: t,
        cursor: xv,
        data: {
          context: {
            reactivate: n
          }
        },
        trapClick: !1
      })
    }
    ,
    Sv.prototype.activateMakeSpace = function (e) {
      this._dragging.init(e, 'spaceTool', {
        autoActivate: !0,
        cursor: xv,
        data: {
          context: {}
        }
      })
    }
    ,
    Sv.prototype.makeSpace = function (e, t, n, r, o) {
      return this._modeling.createSpace(e, t, n, r, o)
    }
    ,
    Sv.prototype.init = function (e, t) {
      const n = bv(e.dx) > bv(e.dy) ? 'x' : 'y'
      let r = e['d' + n]
      const o = e[n] - r
      if (bv(r) < 5) { return !1 }
      r < 0 && (r *= -1),
      Ja(e) && (r *= -1)
      const i = (function (e, t) {
        if (e === 'x') {
          if (t > 0) { return 'e' }
          if (t < 0) { return 'w' }
        }
        if (e === 'y') {
          if (t > 0) { return 's' }
          if (t < 0) { return 'n' }
        }
        return null
      }(n, r))
      let a = this._canvas.getRootElement()
      !Xa(e) && e.hover && (a = e.hover)
      const s = [].concat(gv(zt(a, !0)), gv(a.attachers || []))
      const c = this.calculateAdjustments(s, n, r, o)
      const l = (function (e, t, n, r, o) {
        const i = e.movingShapes
        const a = e.resizingShapes
        if (a.length) {
          let s; let c; const l = {}
          return G(a, function (e) {
            let p; let u; let d; let f; let h; let m; const v = e.attachers; const g = e.children; const y = xr(e); const b = W(g, function (e) {
              return !(yr(e) || br(e) || Bv(i, e) || Bv(a, e))
            }
            ); const A = W(g, function (e) {
              return !yr(e) && !br(e) && Bv(i, e)
            }
            ); const E = []; const x = []
            b.length && (u = kv(xr(Ft(b))),
            p = r - y[wv[n]] + u[wv[n]],
            n === 'n' ? l.bottom = c = L(c) ? Math.min(c, p) : p : n === 'w' ? l.right = c = L(c) ? Math.min(c, p) : p : n === 's' ? l.top = s = L(s) ? Math.max(s, p) : p : n === 'e' && (l.left = s = L(s) ? Math.max(s, p) : p)),
            A.length && (d = kv(xr(Ft(A))),
            p = r - d[wv[Cv[n]]] + y[wv[Cv[n]]],
            n === 'n' ? l.bottom = c = L(c) ? Math.min(c, p) : p : n === 'w' ? l.right = c = L(c) ? Math.min(c, p) : p : n === 's' ? l.top = s = L(s) ? Math.max(s, p) : p : n === 'e' && (l.left = s = L(s) ? Math.max(s, p) : p)),
            v && v.length && (v.forEach(function (e) {
              Bv(i, e) ? E.push(e) : x.push(e)
            }
            ),
            E.length && (f = xr(Ft(E.map(_r))),
            h = y[wv[Cv[n]]] - (f[wv[Cv[n]]] - r)),
            x.length && (m = xr(Ft(x.map(_r)))[wv[n]] - (y[wv[n]] - r)),
            n === 'n'
              ? (p = Math.min(h || 1 / 0, m || 1 / 0),
                l.bottom = c = L(c) ? Math.min(c, p) : p)
              : n === 'w'
                ? (p = Math.min(h || 1 / 0, m || 1 / 0),
                  l.right = c = L(c) ? Math.min(c, p) : p)
                : n === 's'
                  ? (p = Math.max(h || -1 / 0, m || -1 / 0),
                    l.top = s = L(s) ? Math.max(s, p) : p)
                  : n === 'e' && (p = Math.max(h || -1 / 0, m || -1 / 0),
                  l.left = s = L(s) ? Math.max(s, p) : p))
            const w = o && o[e.id]
            w && (n === 'n'
              ? (p = r + e[Ev[t]] - w[Ev[t]],
                l.bottom = c = L(c) ? Math.min(c, p) : p)
              : n === 'w'
                ? (p = r + e[Ev[t]] - w[Ev[t]],
                  l.right = c = L(c) ? Math.min(c, p) : p)
                : n === 's'
                  ? (p = r - e[Ev[t]] + w[Ev[t]],
                    l.top = s = L(s) ? Math.max(s, p) : p)
                  : n === 'e' && (p = r - e[Ev[t]] + w[Ev[t]],
                  l.left = s = L(s) ? Math.max(s, p) : p))
          }
          ),
          l
        }
      }(c, n, i, o, this._eventBus.fire('spaceTool.getMinDimensions', {
        axis: n,
        direction: i,
        shapes: c.resizingShapes,
        start: o
      })))
      return le(t, c, {
        axis: n,
        direction: i,
        spaceToolConstraints: l,
        start: o
      }),
      ac('resize-' + (n === 'x' ? 'ew' : 'ns')),
      !0
    }
    ,
    Sv.prototype.calculateAdjustments = function (e, t, n, r) {
      const o = this._rules
      const i = []
      const a = []
      const s = []
      const c = []
      function l (e) {
        i.includes(e) || i.push(e)
        const t = e.label
        t && !i.includes(t) && i.push(t)
      }
      G(e, function (e) {
        if (e.parent && !br(e)) {
          if (yr(e)) { c.push(e) } else {
            const i = e[t]
            const p = i + e[Ev[t]]
            if ((function (e) {
              return !!e.host
            }(e)) && (n > 0 && _r(e)[t] > r || n < 0 && _r(e)[t] < r)) { s.push(e) } else {
              let u
              if (!(n > 0 && i > r || n < 0 && p < r)) {
                return i < r && p > r && o.allowed('shape.resize', {
                  shape: e
                })
                  ? (u = e,
                    void (a.includes(u) || a.push(u)))
                  : void 0
              }
              l(e)
            }
          }
        }
      }
      ),
      G(i, function (e) {
        const t = e.attachers
        t && G(t, function (e) {
          l(e)
        }
        )
      }
      )
      let p = i.concat(a)
      return G(s, function (e) {
        const t = e.host
        Bv(p, t) && l(e)
      }
      ),
      p = i.concat(a),
      G(c, function (e) {
        const t = e.source
        const n = e.target
        const r = e.label
        Bv(p, t) && Bv(p, n) && r && l(r)
      }
      ),
      {
        movingShapes: i,
        resizingShapes: a
      }
    }
    ,
    Sv.prototype.toggle = function () {
      if (this.isActive()) { return this._dragging.cancel() }
      const e = this._mouse.getLastMoveEvent()
      this.activateSelection(e, !!e)
    }
    ,
    Sv.prototype.isActive = function () {
      const e = this._dragging.context()
      return !!e && /^spaceTool/.test(e.prefix)
    }

    const Dv = 'djs-dragging'
    const Pv = 'djs-resizing'
    const Ov = Math.max
    function Tv (e, t, n, r, o) {
      function i (e, t) {
        G(e, function (e) {
          o.addDragger(e, t),
          n.addMarker(e, Dv)
        }
        )
      }
      e.on('spaceTool.selection.start', function (e) {
        const t = n.getLayer('space')
        const o = e.context
        const i = et('g')
        We(i, r.cls('djs-crosshair-group', ['no-events'])),
        Fe(t, i)
        const a = et('path')
        We(a, 'd', 'M 0,-10000 L 0,10000'),
        Ue(a).add('djs-crosshair'),
        Fe(i, a)
        const s = et('path')
        We(s, 'd', 'M -10000,0 L 10000,0'),
        Ue(s).add('djs-crosshair'),
        Fe(i, s),
        o.crosshairGroup = i
      }
      ),
      e.on('spaceTool.selection.move', function (e) {
        ro(e.context.crosshairGroup, e.x, e.y)
      }
      ),
      e.on('spaceTool.selection.cleanup', function (e) {
        const t = e.context.crosshairGroup
        t && Qe(t)
      }
      ),
      e.on('spaceTool.move', 250, function (e) {
        const a = e.context
        let s = a.line
        const c = a.axis
        const l = a.movingShapes
        const p = a.resizingShapes
        if (a.initialized) {
          if (!a.dragGroup) {
            const u = n.getLayer('space')
            We(s = et('path'), 'd', 'M0,0 L0,0'),
            Ue(s).add('djs-crosshair'),
            Fe(u, s),
            a.line = s
            const d = et('g')
            We(d, r.cls('djs-drag-group', ['no-events'])),
            Fe(n.getActiveLayer(), d),
            i(l, d),
            i(a.movingConnections = t.filter(function (e) {
              let t = !1
              G(l, function (n) {
                G(n.outgoing, function (n) {
                  e === n && (t = !0)
                }
                )
              }
              )
              let n = !1
              G(l, function (t) {
                G(t.incoming, function (t) {
                  e === t && (n = !0)
                }
                )
              }
              )
              let r = !1
              G(p, function (t) {
                G(t.outgoing, function (t) {
                  e === t && (r = !0)
                }
                )
              }
              )
              let o = !1
              return G(p, function (t) {
                G(t.incoming, function (t) {
                  e === t && (o = !0)
                }
                )
              }
              ),
              yr(e) && (t || r) && (n || o)
            }
            ), d),
            a.dragGroup = d
          }
          if (!a.frameGroup) {
            const f = et('g')
            We(f, r.cls('djs-frame-group', ['no-events'])),
            Fe(n.getActiveLayer(), f)
            const h = []
            G(p, function (e) {
              const t = o.addFrame(e, f)
              const r = t.getBBox()
              h.push({
                element: t,
                initialBounds: r
              }),
              n.addMarker(e, Pv)
            }
            ),
            a.frameGroup = f,
            a.frames = h
          }
          We(s, {
            d: {
              x: 'M' + e.x + ', -10000 L' + e.x + ', 10000',
              y: 'M -10000, ' + e.y + ' L 10000, ' + e.y
            }[c]
          })
          const m = {
            x: e.dx,
            y: e.dy
          }
          m[{
            x: 'y',
            y: 'x'
          }[a.axis]] = 0,
          ro(a.dragGroup, m.x, m.y),
          G(a.frames, function (e) {
            let t; let n; const r = e.element; const o = e.initialBounds
            a.direction === 'e'
              ? We(r, {
                width: Ov(o.width + m.x, 5)
              })
              : We(r, {
                width: t = Ov(o.width - m.x, 5),
                x: o.x + o.width - t
              }),
            a.direction === 's'
              ? We(r, {
                height: Ov(o.height + m.y, 5)
              })
              : We(r, {
                height: n = Ov(o.height - m.y, 5),
                y: o.y + o.height - n
              })
          }
          )
        }
      }
      ),
      e.on('spaceTool.cleanup', function (e) {
        const t = e.context
        const r = t.movingShapes
        const o = t.movingConnections
        const i = t.resizingShapes
        const a = t.line
        const s = t.dragGroup
        const c = t.frameGroup
        G(r, function (e) {
          n.removeMarker(e, Dv)
        }
        ),
        G(o, function (e) {
          n.removeMarker(e, Dv)
        }
        ),
        s && (Qe(a),
        Qe(s)),
        G(i, function (e) {
          n.removeMarker(e, Pv)
        }
        ),
        c && Qe(c)
      }
      )
    }
    Tv.$inject = ['eventBus', 'elementRegistry', 'canvas', 'styles', 'previewSupport']
    const Rv = {
      __init__: ['spaceToolPreview'],
      __depends__: [pu, hu, mv, Ad, Gm],
      spaceTool: ['type', Sv],
      spaceToolPreview: ['type', Tv]
    }
    function Nv (e) {
      e.invoke(Sv, this)
    }
    Nv.$inject = ['injector'],
    w(Nv, Sv),
    Nv.prototype.calculateAdjustments = function (e, t, n, r) {
      const o = Sv.prototype.calculateAdjustments.call(this, e, t, n, r)
      return o.resizingShapes = o.resizingShapes.filter(function (e) {
        return !(Pi(e, 'bpmn:TextAnnotation') || (function (e) {
          return Pi(e, 'bpmn:Participant') && !Ti(e).processRef
        }(e)) && (t === 'y' && ea(e) || t === 'x' && !ea(e)))
      }
      ),
      o
    }

    const Mv = {
      __depends__: [Rv],
      spaceTool: ['type', Nv]
    }
    function Iv (e, t) {
      this._handlerMap = {},
      this._stack = [],
      this._stackIdx = -1,
      this._currentExecution = {
        actions: [],
        dirty: [],
        trigger: null
      },
      this._injector = t,
      this._eventBus = e,
      this._uid = 1,
      e.on(['diagram.destroy', 'diagram.clear'], function () {
        this.clear(!1)
      }
      , this)
    }
    Iv.$inject = ['eventBus', 'injector'],
    Iv.prototype.execute = function (e, t) {
      if (!e) { throw new Error('command required') }
      this._currentExecution.trigger = 'execute'
      const n = {
        command: e,
        context: t
      }
      this._pushAction(n),
      this._internalExecute(n),
      this._popAction()
    }
    ,
    Iv.prototype.canExecute = function (e, t) {
      const n = {
        command: e,
        context: t
      }
      const r = this._getHandler(e)
      let o = this._fire(e, 'canExecute', n)
      if (void 0 === o) {
        if (!r) { return !1 }
        r.canExecute && (o = r.canExecute(t))
      }
      return o
    }
    ,
    Iv.prototype.clear = function (e) {
      this._stack.length = 0,
      this._stackIdx = -1,
      !1 !== e && this._fire('changed', {
        trigger: 'clear'
      })
    }
    ,
    Iv.prototype.undo = function () {
      let e; let t = this._getUndoAction()
      if (t) {
        for (this._currentExecution.trigger = 'undo',
        this._pushAction(t); t && (this._internalUndo(t),
          (e = this._getUndoAction()) && e.id === t.id);) { t = e }
        this._popAction()
      }
    }
    ,
    Iv.prototype.redo = function () {
      let e; let t = this._getRedoAction()
      if (t) {
        for (this._currentExecution.trigger = 'redo',
        this._pushAction(t); t && (this._internalExecute(t, !0),
          (e = this._getRedoAction()) && e.id === t.id);) { t = e }
        this._popAction()
      }
    }
    ,
    Iv.prototype.register = function (e, t) {
      this._setHandler(e, t)
    }
    ,
    Iv.prototype.registerHandler = function (e, t) {
      if (!e || !t) { throw new Error('command and handlerCls must be defined') }
      const n = this._injector.instantiate(t)
      this.register(e, n)
    }
    ,
    Iv.prototype.canUndo = function () {
      return !!this._getUndoAction()
    }
    ,
    Iv.prototype.canRedo = function () {
      return !!this._getRedoAction()
    }
    ,
    Iv.prototype._getRedoAction = function () {
      return this._stack[this._stackIdx + 1]
    }
    ,
    Iv.prototype._getUndoAction = function () {
      return this._stack[this._stackIdx]
    }
    ,
    Iv.prototype._internalUndo = function (e) {
      const t = this
      const n = e.command
      const r = e.context
      const o = this._getHandler(n)
      this._atomicDo(function () {
        t._fire(n, 'revert', e),
        o.revert && t._markDirty(o.revert(r)),
        t._revertedAction(e),
        t._fire(n, 'reverted', e)
      }
      )
    }
    ,
    Iv.prototype._fire = function (e, t, n) {
      arguments.length < 3 && (n = t,
      t = null)
      let r; const o = t ? [e + '.' + t, t] : [e]
      n = this._eventBus.createEvent(n)
      for (let i = 0, a = o; i < a.length; i++) {
        const s = a[i]
        if (r = this._eventBus.fire('commandStack.' + s, n),
        n.cancelBubble) { break }
      }
      return r
    }
    ,
    Iv.prototype._createId = function () {
      return this._uid++
    }
    ,
    Iv.prototype._atomicDo = function (e) {
      const t = this._currentExecution
      t.atomic = !0
      try {
        e()
      } finally {
        t.atomic = !1
      }
    }
    ,
    Iv.prototype._internalExecute = function (e, t) {
      const n = this
      const r = e.command
      const o = e.context
      const i = this._getHandler(r)
      if (!i) { throw new Error('no command handler registered for <' + r + '>') }
      this._pushAction(e),
      t || (this._fire(r, 'preExecute', e),
      i.preExecute && i.preExecute(o),
      this._fire(r, 'preExecuted', e)),
      this._atomicDo(function () {
        n._fire(r, 'execute', e),
        i.execute && n._markDirty(i.execute(o)),
        n._executedAction(e, t),
        n._fire(r, 'executed', e)
      }
      ),
      t || (this._fire(r, 'postExecute', e),
      i.postExecute && i.postExecute(o),
      this._fire(r, 'postExecuted', e)),
      this._popAction()
    }
    ,
    Iv.prototype._pushAction = function (e) {
      const t = this._currentExecution
      const n = t.actions
      const r = n[0]
      if (t.atomic) { throw new Error('illegal invocation in <execute> or <revert> phase (action: ' + e.command + ')') }
      e.id || (e.id = r && r.id || this._createId()),
      n.push(e)
    }
    ,
    Iv.prototype._popAction = function () {
      const e = this._currentExecution
      const t = e.trigger
      const n = e.actions
      const r = e.dirty
      n.pop(),
      n.length || (this._eventBus.fire('elements.changed', {
        elements: Z('id', r.reverse())
      }),
      r.length = 0,
      this._fire('changed', {
        trigger: t
      }),
      e.trigger = null)
    }
    ,
    Iv.prototype._markDirty = function (e) {
      const t = this._currentExecution
      e && (e = M(e) ? e : [e],
      t.dirty = t.dirty.concat(e))
    }
    ,
    Iv.prototype._executedAction = function (e, t) {
      const n = ++this._stackIdx
      t || this._stack.splice(n, this._stack.length, e)
    }
    ,
    Iv.prototype._revertedAction = function (e) {
      this._stackIdx--
    }
    ,
    Iv.prototype._getHandler = function (e) {
      return this._handlerMap[e]
    }
    ,
    Iv.prototype._setHandler = function (e, t) {
      if (!e || !t) { throw new Error('command and handler required') }
      if (this._handlerMap[e]) { throw new Error('overriding handler for command <' + e + '>') }
      this._handlerMap[e] = t
    }

    const Lv = {
      commandStack: ['type', Iv]
    }
    function zv (e, t) {
      if (typeof t !== 'function') { throw new Error('removeFn iterator must be a function') }
      if (e) {
        for (var n; n = e[0];) { t(n) }
        return e
      }
    }
    function Fv (e, t, n) {
      Es.call(this, t)
      const r = e.get('movePreview', !1)
      t.on('shape.move.start', 1400, function (e) {
        const t = e.context
        const n = t.shapes
        const r = t.validatedShapes
        t.shapes = $v(n),
        t.validatedShapes = $v(r)
      }
      ),
      r && t.on('shape.move.start', 250, function (e) {
        const t = e.context
        const n = t.shapes
        const o = []
        G(n, function (e) {
          G(e.labels, function (n) {
            n.hidden || t.shapes.indexOf(n) !== -1 || o.push(n),
            e.labelTarget && o.push(e)
          }
          )
        }
        ),
        G(o, function (e) {
          r.makeDraggable(t, e, !0)
        }
        )
      }
      ),
      this.preExecuted('elements.move', 1400, function (e) {
        const t = e.context.closure
        const n = t.enclosedElements
        const r = []
        G(n, function (e) {
          G(e.labels, function (e) {
            n[e.id] || r.push(e)
          }
          )
        }
        ),
        t.addAll(r)
      }
      ),
      this.preExecute(['connection.delete', 'shape.delete'], function (e) {
        const t = e.context
        zv((t.connection || t.shape).labels, function (e) {
          n.removeShape(e, {
            nested: !0
          })
        }
        )
      }
      ),
      this.execute('shape.delete', function (e) {
        const t = e.context
        const n = t.shape
        const r = n.labelTarget
        r && (t.labelTargetIndex = jn(r.labels, n),
        t.labelTarget = r,
        n.labelTarget = null)
      }
      ),
      this.revert('shape.delete', function (e) {
        const t = e.context
        const n = t.shape
        const r = t.labelTarget
        const o = t.labelTargetIndex
        r && (kn(r.labels, n, o),
        n.labelTarget = r)
      }
      )
    }
    function $v (e) {
      return W(e, function (t) {
        return e.indexOf(t.labelTarget) === -1
      }
      )
    }
    w(Fv, Es),
    Fv.$inject = ['injector', 'eventBus', 'modeling']
    const Hv = {
      __init__: ['labelSupport'],
      labelSupport: ['type', Fv]
    }
    const qv = 'attach-ok'
    function Wv (e, t, n, r, o) {
      Es.call(this, t)
      const i = e.get('movePreview', !1)
      t.on('shape.move.start', 1401, function (e) {
        let t; let n; const r = e.context; const o = r.shapes; const i = r.validatedShapes
        r.shapes = (n = Gv(t = o),
        ee('id', t, n)),
        r.validatedShapes = (function (e) {
          const t = X(e, 'id')
          return W(e, function (e) {
            for (; e;) {
              if (e.host && t[e.host.id]) { return !1 }
              e = e.parent
            }
            return !0
          }
          )
        }(i))
      }
      ),
      i && t.on('shape.move.start', 251, function (e) {
        const t = e.context
        G(Gv(t.shapes), function (e) {
          i.makeDraggable(t, e, !0),
          G(e.labels, function (e) {
            i.makeDraggable(t, e, !0)
          }
          )
        }
        )
      }
      ),
      i && t.on('shape.move.start', function (e) {
        const r = e.context.shapes
        if (r.length === 1) {
          const o = r[0].host
          o && (n.addMarker(o, qv),
          t.once(['shape.move.out', 'shape.move.cleanup'], function () {
            n.removeMarker(o, qv)
          }
          ))
        }
      }
      ),
      this.preExecuted('elements.move', 1401, function (e) {
        const t = e.context
        const n = t.closure
        G(Gv(t.shapes), function (e) {
          n.add(e, n.topLevel[e.host.id])
        }
        )
      }
      ),
      this.postExecuted('elements.move', function (e) {
        const t = e.context
        const n = t.shapes
        const r = t.newHost
        r && n.length !== 1 || G(r
          ? n
          : W(n, function (e) {
            let t; const r = e.host
            return (function (e) {
              return !!e.host
            }(e)) && (t = r,
            !(n.indexOf(t) !== -1))
          }
          ), function (e) {
          o.updateAttachment(e, r)
        }
        )
      }
      ),
      this.postExecuted('elements.move', function (e) {
        G(e.context.shapes, function (e) {
          G(e.attachers, function (e) {
            G(e.outgoing.slice(), function (e) {
              r.allowed('connection.reconnect', {
                connection: e,
                source: e.source,
                target: e.target
              }) || o.removeConnection(e)
            }
            ),
            G(e.incoming.slice(), function (e) {
              r.allowed('connection.reconnect', {
                connection: e,
                source: e.source,
                target: e.target
              }) || o.removeConnection(e)
            }
            )
          }
          )
        }
        )
      }
      ),
      this.postExecute('shape.create', function (e) {
        const t = e.context
        const n = t.shape
        const r = t.host
        r && o.updateAttachment(n, r)
      }
      ),
      this.postExecute('shape.replace', function (e) {
        const t = e.context
        const n = t.oldShape
        const i = t.newShape
        zv(n.attachers, function (e) {
          r.allowed('elements.move', {
            target: i,
            shapes: [e]
          }) === 'attach'
            ? o.updateAttachment(e, i)
            : o.removeShape(e)
        }
        ),
        i.attachers.length && G(i.attachers, function (e) {
          const t = Wf(e, n, i)
          o.moveShape(e, t, e.parent)
        }
        )
      }
      ),
      this.postExecute('shape.resize', function (e) {
        const t = e.context
        const n = t.shape
        const r = t.oldBounds
        const i = t.newBounds
        const a = n.attachers
        !1 !== (t.hints || {}).attachSupport && G(a, function (e) {
          const t = Wf(e, r, i)
          o.moveShape(e, t, e.parent),
          G(e.labels, function (e) {
            o.moveShape(e, t, e.parent)
          }
          )
        }
        )
      }
      ),
      this.preExecute('shape.delete', function (e) {
        const t = e.context.shape
        zv(t.attachers, function (e) {
          o.removeShape(e)
        }
        ),
        t.host && o.updateAttachment(t, null)
      }
      )
    }
    function Gv (e) {
      return D(Y(e, function (e) {
        return e.attachers || []
      }
      ))
    }
    w(Wv, Es),
    Wv.$inject = ['injector', 'eventBus', 'canvas', 'rules', 'modeling']
    const Uv = {
      __depends__: [hu],
      __init__: ['attachSupport'],
      attachSupport: ['type', Wv]
    }
    function Vv (e) {
      this._model = e
    }
    function Qv (e, t, n, r) {
      Es.call(this, e),
      this._bpmnFactory = t,
      this._translate = r
      const o = this
      function i (e) {
        G(e.context.oldRoot.children, function (e) {
          Pi(e, 'bpmn:BaseElement') && o.updateParent(e)
        }
        )
      }
      function a (e) {
        const t = e.context.shape
        Pi(t, 'bpmn:BaseElement') && o.updateBounds(t)
      }
      function s (e) {
        o.updateConnection(e.context)
      }
      function c (e) {
        o.updateConnectionWaypoints(e.context.connection)
      }
      function l (e) {
        o.updateAttachment(e.context)
      }
      function p (e) {
        const n = e.context.element
        const r = la(n)
        const o = Ri(n)
        const i = o && o.get('label')
        ia(n) || Os(n) || (r && !i ? o.set('label', t.create('bpmndi:BPMNLabel')) : !r && i && o.set('label', void 0))
      }
      this.executed(['connection.layout', 'connection.create'], function (e) {
        let t; const r = e.context; const o = r.hints || {}
        r.cropped || !1 === o.createElementsBehavior || ((t = r.connection).waypoints = n.getCroppedWaypoints(t),
        r.cropped = !0)
      }
      ),
      this.reverted(['connection.layout'], function (e) {
        delete e.context.cropped
      }
      ),
      this.executed(['shape.move', 'shape.create', 'shape.delete', 'connection.create', 'connection.move', 'connection.delete'], Yv(function (e) {
        const t = e.context
        o.updateParent(t.shape || t.connection, t.oldParent)
      }
      )),
      this.reverted(['shape.move', 'shape.create', 'shape.delete', 'connection.create', 'connection.move', 'connection.delete'], Yv(function (e) {
        const t = e.context
        const n = t.shape || t.connection
        const r = t.parent || t.newParent
        o.updateParent(n, r)
      }
      )),
      this.executed(['canvas.updateRoot'], i),
      this.reverted(['canvas.updateRoot'], i),
      this.executed(['shape.move', 'shape.create', 'shape.resize'], Yv(function (e) {
        e.context.shape.type !== 'label' && a(e)
      }
      )),
      this.reverted(['shape.move', 'shape.create', 'shape.resize'], Yv(function (e) {
        e.context.shape.type !== 'label' && a(e)
      }
      )),
      e.on('shape.changed', function (e) {
        e.element.type === 'label' && a({
          context: {
            shape: e.element
          }
        })
      }
      ),
      this.executed(['connection.create', 'connection.move', 'connection.delete', 'connection.reconnect'], Yv(s)),
      this.reverted(['connection.create', 'connection.move', 'connection.delete', 'connection.reconnect'], Yv(s)),
      this.executed(['connection.layout', 'connection.move', 'connection.updateWaypoints'], Yv(c)),
      this.reverted(['connection.layout', 'connection.move', 'connection.updateWaypoints'], Yv(c)),
      this.executed('connection.reconnect', Yv(function (e) {
        const t = e.context
        const n = t.connection
        const r = t.oldSource
        const o = t.newSource
        const i = Ti(n)
        const a = Ti(r)
        const s = Ti(o)
        i.conditionExpression && !Oi(s, ['bpmn:Activity', 'bpmn:ExclusiveGateway', 'bpmn:InclusiveGateway']) && (t.oldConditionExpression = i.conditionExpression,
        delete i.conditionExpression),
        r !== o && a.default === i && (t.oldDefault = a.default,
        delete a.default)
      }
      )),
      this.reverted('connection.reconnect', Yv(function (e) {
        const t = e.context
        const n = t.connection
        const r = t.oldSource
        const o = t.newSource
        const i = Ti(n)
        const a = Ti(r)
        const s = Ti(o)
        t.oldConditionExpression && (i.conditionExpression = t.oldConditionExpression),
        t.oldDefault && (a.default = t.oldDefault,
        delete s.default)
      }
      )),
      this.executed(['element.updateAttachment'], Yv(l)),
      this.reverted(['element.updateAttachment'], Yv(l)),
      this.executed('element.updateLabel', Yv(p)),
      this.reverted('element.updateLabel', Yv(p))
    }
    function Yv (e) {
      return function (t) {
        const n = t.context
        Pi(n.shape || n.connection || n.element, 'bpmn:BaseElement') && e(t)
      }
    }
    function Kv (e, t, n) {
      Yr.call(this),
      this._bpmnFactory = e,
      this._moddle = t,
      this._translate = n
    }
    function Jv (e, t, n) {
      return void 0 === t[n]
        ? t
        : (e[n] = t[n],
          ue(t, [n]))
    }
    function Xv (e, t) {
      this._modeling = e,
      this._canvas = t
    }
    function Zv (e) {
      this._modeling = e
    }
    function eg (e, t) {
      this._canvas = e,
      this._layouter = t
    }
    Vv.$inject = ['moddle'],
    Vv.prototype._needsId = function (e) {
      return Oi(e, ['bpmn:RootElement', 'bpmn:FlowElement', 'bpmn:MessageFlow', 'bpmn:DataAssociation', 'bpmn:Artifact', 'bpmn:Participant', 'bpmn:Lane', 'bpmn:LaneSet', 'bpmn:Process', 'bpmn:Collaboration', 'bpmndi:BPMNShape', 'bpmndi:BPMNEdge', 'bpmndi:BPMNDiagram', 'bpmndi:BPMNPlane', 'bpmn:Property', 'bpmn:CategoryValue'])
    }
    ,
    Vv.prototype._ensureId = function (e) {
      let t
      e.id
        ? this._model.ids.claim(e.id, e)
        : (t = Pi(e, 'bpmn:Activity') ? 'Activity' : Pi(e, 'bpmn:Event') ? 'Event' : Pi(e, 'bpmn:Gateway') ? 'Gateway' : Oi(e, ['bpmn:SequenceFlow', 'bpmn:MessageFlow']) ? 'Flow' : (e.$type || '').replace(/^[^:]*:/g, ''),
          t += '_',
          !e.id && this._needsId(e) && (e.id = this._model.ids.nextPrefixed(t, e)))
    }
    ,
    Vv.prototype.create = function (e, t) {
      const n = this._model.create(e, t || {})
      return this._ensureId(n),
      n
    }
    ,
    Vv.prototype.createDiLabel = function () {
      return this.create('bpmndi:BPMNLabel', {
        bounds: this.createDiBounds()
      })
    }
    ,
    Vv.prototype.createDiShape = function (e, t) {
      return this.create('bpmndi:BPMNShape', le({
        bpmnElement: e,
        bounds: this.createDiBounds()
      }, t))
    }
    ,
    Vv.prototype.createDiBounds = function (e) {
      return this.create('dc:Bounds', e)
    }
    ,
    Vv.prototype.createDiWaypoints = function (e) {
      const t = this
      return Y(e, function (e) {
        return t.createDiWaypoint(e)
      }
      )
    }
    ,
    Vv.prototype.createDiWaypoint = function (e) {
      return this.create('dc:Point', pe(e, ['x', 'y']))
    }
    ,
    Vv.prototype.createDiEdge = function (e, t) {
      return this.create('bpmndi:BPMNEdge', le({
        bpmnElement: e,
        waypoint: this.createDiWaypoints([])
      }, t))
    }
    ,
    Vv.prototype.createDiPlane = function (e, t) {
      return this.create('bpmndi:BPMNPlane', le({
        bpmnElement: e
      }, t))
    }
    ,
    w(Qv, Es),
    Qv.$inject = ['eventBus', 'bpmnFactory', 'connectionDocking', 'translate'],
    Qv.prototype.updateAttachment = function (e) {
      const t = e.shape
      const n = t.businessObject
      const r = t.host
      n.attachedToRef = r && r.businessObject
    }
    ,
    Qv.prototype.updateParent = function (e, t) {
      if (!(br(e) || Pi(e, 'bpmn:DataStoreReference') && e.parent && Pi(e.parent, 'bpmn:Collaboration'))) {
        const n = e.parent
        const r = e.businessObject
        const o = Ri(e)
        let i = n && n.businessObject
        const a = Ri(n)
        Pi(e, 'bpmn:FlowNode') && this.updateFlowNodeRefs(r, i, t && t.businessObject),
        Pi(e, 'bpmn:DataOutputAssociation') && (i = e.source ? e.source.businessObject : null),
        Pi(e, 'bpmn:DataInputAssociation') && (i = e.target ? e.target.businessObject : null),
        this.updateSemanticParent(r, i),
        Pi(e, 'bpmn:DataObjectReference') && r.dataObjectRef && this.updateSemanticParent(r.dataObjectRef, i),
        this.updateDiParent(o, a)
      }
    }
    ,
    Qv.prototype.updateBounds = function (e) {
      const t = Ri(e)
      const n = (function (e) {
        if (Pi(e, 'bpmn:Activity')) {
          const t = Ri(e)
          if (t) {
            const n = t.get('label')
            if (n) { return n.get('bounds') }
          }
        }
      }(e))
      if (n) {
        const r = uc(n, t.get('bounds'))
        le(n, {
          x: e.x + r.x,
          y: e.y + r.y
        })
      }
      const o = br(e) ? this._getLabel(t) : t
      let i = o.bounds
      i || (i = this._bpmnFactory.createDiBounds(),
      o.set('bounds', i)),
      le(i, {
        x: e.x,
        y: e.y,
        width: e.width,
        height: e.height
      })
    }
    ,
    Qv.prototype.updateFlowNodeRefs = function (e, t, n) {
      n !== t && (Pi(n, 'bpmn:Lane') && Sn(n.get('flowNodeRef'), e),
      Pi(t, 'bpmn:Lane') && kn(t.get('flowNodeRef'), e))
    }
    ,
    Qv.prototype.updateDiConnection = function (e, t, n) {
      const r = Ri(e)
      const o = Ri(t)
      const i = Ri(n)
      r.sourceElement && r.sourceElement.bpmnElement !== Ti(t) && (r.sourceElement = t && o),
      r.targetElement && r.targetElement.bpmnElement !== Ti(n) && (r.targetElement = n && i)
    }
    ,
    Qv.prototype.updateDiParent = function (e, t) {
      if (t && !Pi(t, 'bpmndi:BPMNPlane') && (t = t.$parent),
      e.$parent !== t) {
        const n = (t || e.$parent).get('planeElement')
        t
          ? (n.push(e),
            e.$parent = t)
          : (Sn(n, e),
            e.$parent = null)
      }
    }
    ,
    Qv.prototype.getLaneSet = function (e) {
      let t, n
      return Pi(e, 'bpmn:Lane')
        ? ((t = e.childLaneSet) || (t = this._bpmnFactory.create('bpmn:LaneSet'),
          e.childLaneSet = t,
          t.$parent = e),
          t)
        : (Pi(e, 'bpmn:Participant') && (e = e.processRef),
          (t = (n = e.get('laneSets'))[0]) || ((t = this._bpmnFactory.create('bpmn:LaneSet')).$parent = e,
          n.push(t)),
          t)
    }
    ,
    Qv.prototype.updateSemanticParent = function (e, t, n) {
      let r; const o = this._translate
      if (e.$parent !== t && (!Pi(e, 'bpmn:DataInput') && !Pi(e, 'bpmn:DataOutput') || (Pi(t, 'bpmn:Participant') && 'processRef' in t && (t = t.processRef),
      !('ioSpecification' in t) || t.ioSpecification !== e.$parent))) {
        if (Pi(e, 'bpmn:Lane')) {
          t && (t = this.getLaneSet(t)),
          r = 'lanes'
        } else if (Pi(e, 'bpmn:FlowElement')) {
          if (t) {
            if (Pi(t, 'bpmn:Participant')) { t = t.processRef } else if (Pi(t, 'bpmn:Lane')) {
              do {
                t = t.$parent.$parent
              } while (Pi(t, 'bpmn:Lane'))
            }
          }
          r = 'flowElements'
        } else if (Pi(e, 'bpmn:Artifact')) {
          for (; t && !Pi(t, 'bpmn:Process') && !Pi(t, 'bpmn:SubProcess') && !Pi(t, 'bpmn:Collaboration');) {
            if (Pi(t, 'bpmn:Participant')) {
              t = t.processRef
              break
            }
            t = t.$parent
          }
          r = 'artifacts'
        } else if (Pi(e, 'bpmn:MessageFlow')) { r = 'messageFlows' } else if (Pi(e, 'bpmn:Participant')) {
          r = 'participants'
          let i; const a = e.processRef
          a && (i = (function (e) {
            for (; e && !Pi(e, 'bpmn:Definitions');) { e = e.$parent }
            return e
          }(e.$parent || t)),
          e.$parent && (Sn(i.get('rootElements'), a),
          a.$parent = null),
          t && (kn(i.get('rootElements'), a),
          a.$parent = i))
        } else { Pi(e, 'bpmn:DataOutputAssociation') ? r = 'dataOutputAssociations' : Pi(e, 'bpmn:DataInputAssociation') && (r = 'dataInputAssociations') }
        if (!r) {
          throw new Error(o('no parent for {element} in {parent}', {
            element: e.id,
            parent: t.id
          }))
        }
        let s
        if (e.$parent && Sn(s = e.$parent.get(r), e),
        t
          ? ((s = t.get(r)).push(e),
            e.$parent = t)
          : e.$parent = null,
        n) {
          let c = n.get(r)
          Sn(s, e),
          t && (c || (c = [],
          t.set(r, c)),
          c.push(e))
        }
      }
    }
    ,
    Qv.prototype.updateConnectionWaypoints = function (e) {
      Ri(e).set('waypoint', this._bpmnFactory.createDiWaypoints(e.waypoints))
    }
    ,
    Qv.prototype.updateConnection = function (e) {
      let t; const n = e.connection; const r = Ti(n); const o = n.source; const i = Ti(o); const a = n.target; const s = Ti(n.target)
      if (Pi(r, 'bpmn:DataAssociation')) {
        Pi(r, 'bpmn:DataInputAssociation')
          ? (r.get('sourceRef')[0] = i,
            t = e.parent || e.newParent || s,
            this.updateSemanticParent(r, s, t))
          : Pi(r, 'bpmn:DataOutputAssociation') && (t = e.parent || e.newParent || i,
          this.updateSemanticParent(r, i, t),
          r.targetRef = s)
      } else {
        const c = Pi(r, 'bpmn:SequenceFlow')
        r.sourceRef !== i && (c && (Sn(r.sourceRef && r.sourceRef.get('outgoing'), r),
        i && i.get('outgoing') && i.get('outgoing').push(r)),
        r.sourceRef = i),
        r.targetRef !== s && (c && (Sn(r.targetRef && r.targetRef.get('incoming'), r),
        s && s.get('incoming') && s.get('incoming').push(r)),
        r.targetRef = s)
      }
      this.updateConnectionWaypoints(n),
      this.updateDiConnection(n, o, a)
    }
    ,
    Qv.prototype._getLabel = function (e) {
      return e.label || (e.label = this._bpmnFactory.createDiLabel()),
      e.label
    }
    ,
    w(Kv, Yr),
    Kv.$inject = ['bpmnFactory', 'moddle', 'translate'],
    Kv.prototype._baseCreate = Yr.prototype.create,
    Kv.prototype.create = function (e, t) {
      if (e === 'label') {
        const n = t.di || this._bpmnFactory.createDiLabel()
        return this._baseCreate(e, le({
          type: 'label',
          di: n
        }, ra, t))
      }
      return this.createElement(e, t)
    }
    ,
    Kv.prototype.createElement = function (e, t) {
      let n; let r; let o; const i = this._translate; let a = (t = le({}, t || {})).businessObject; let s = t.di
      if (!a) {
        if (!t.type) { throw new Error(i('no shape type specified')) }
        ji(a = this._bpmnFactory.create(t.type))
      }
      if (!Oi(s, ['bpmndi:BPMNShape', 'bpmndi:BPMNEdge', 'bpmndi:BPMNDiagram', 'bpmndi:BPMNPlane'])) {
        const c = le({}, s || {}, {
          id: a.id + '_di'
        })
        s = e === 'root' ? this._bpmnFactory.createDiPlane(a, c) : e === 'connection' ? this._bpmnFactory.createDiEdge(a, c) : this._bpmnFactory.createDiShape(a, c)
      }
      return Pi(a, 'bpmn:Group') && (t = le({
        isFrame: !0
      }, t)),
      (t = (function (e, t, n) {
        return G(['processRef', 'isInterrupting', 'associationDirection', 'isForCompensation'], function (n) {
          t = Jv(e, t, n)
        }
        ),
        t
      }(a, t))).isExpanded && (t = Jv(s, t, 'isExpanded')),
      Oi(a, ['bpmn:Lane', 'bpmn:Participant']) && (t = Jv(s, t, 'isHorizontal')),
      Pi(a, 'bpmn:SubProcess') && (t.collapsed = !Zi(a, s)),
      Pi(a, 'bpmn:ExclusiveGateway') && ($(s, 'isMarkerVisible') ? void 0 === s.isMarkerVisible && (s.isMarkerVisible = !1) : s.isMarkerVisible = !0),
      R(t.triggeredByEvent) && (a.triggeredByEvent = t.triggeredByEvent,
      delete t.triggeredByEvent),
      R(t.cancelActivity) && (a.cancelActivity = t.cancelActivity,
      delete t.cancelActivity),
      t.eventDefinitionType && (r = a.get('eventDefinitions') || [],
      o = this._bpmnFactory.create(t.eventDefinitionType, t.eventDefinitionAttrs),
      t.eventDefinitionType === 'bpmn:ConditionalEventDefinition' && (o.condition = this._bpmnFactory.create('bpmn:FormalExpression')),
      r.push(o),
      o.$parent = a,
      a.eventDefinitions = r,
      delete t.eventDefinitionType),
      n = this.getDefaultSize(a, s),
      t = le({
        id: a.id
      }, n, t, {
        businessObject: a,
        di: s
      }),
      this._baseCreate(e, t)
    }
    ,
    Kv.prototype.getDefaultSize = function (e, t) {
      const n = Ti(e)
      return t = t || Ri(e),
      Pi(n, 'bpmn:SubProcess')
        ? Zi(n, t)
          ? {
              width: 350,
              height: 200
            }
          : {
              width: 100,
              height: 80
            }
        : Pi(n, 'bpmn:Task')
          ? {
              width: 100,
              height: 80
            }
          : Pi(n, 'bpmn:Gateway')
            ? {
                width: 50,
                height: 50
              }
            : Pi(n, 'bpmn:Event')
              ? {
                  width: 36,
                  height: 36
                }
              : Pi(n, 'bpmn:Participant')
                ? Zi(n, t)
                  ? {
                      width: 600,
                      height: 250
                    }
                  : {
                      width: 400,
                      height: 60
                    }
                : Pi(n, 'bpmn:Lane')
                  ? {
                      width: 400,
                      height: 100
                    }
                  : Pi(n, 'bpmn:DataObjectReference')
                    ? {
                        width: 36,
                        height: 50
                      }
                    : Pi(n, 'bpmn:DataStoreReference')
                      ? {
                          width: 50,
                          height: 50
                        }
                      : Pi(n, 'bpmn:TextAnnotation')
                        ? {
                            width: 100,
                            height: 30
                          }
                        : Pi(n, 'bpmn:Group')
                          ? {
                              width: 300,
                              height: 300
                            }
                          : {
                              width: 100,
                              height: 80
                            }
    }
    ,
    Kv.prototype.createParticipantShape = function (e) {
      return I(e) || (e = {
        isExpanded: e
      }),
      !1 !== (e = le({
        type: 'bpmn:Participant'
      }, e || {})).isExpanded && (e.processRef = this._bpmnFactory.create('bpmn:Process')),
      this.createShape(e)
    }
    ,
    Xv.$inject = ['modeling', 'canvas'],
    Xv.prototype.preExecute = function (e) {
      const t = this._modeling
      const n = e.elements
      const r = e.alignment
      G(n, function (e) {
        const n = {
          x: 0,
          y: 0
        }
        R(r.left) ? n.x = r.left - e.x : R(r.right) ? n.x = r.right - e.width - e.x : R(r.center) ? n.x = r.center - Math.round(e.width / 2) - e.x : R(r.top) ? n.y = r.top - e.y : R(r.bottom) ? n.y = r.bottom - e.height - e.y : R(r.middle) && (n.y = r.middle - Math.round(e.height / 2) - e.y),
        t.moveElements([e], n, e.parent)
      }
      )
    }
    ,
    Xv.prototype.postExecute = function (e) {}
    ,
    Zv.$inject = ['modeling'],
    Zv.prototype.preExecute = function (e) {
      const t = e.source
      if (!t) { throw new Error('source required') }
      const n = e.target || t.parent
      let r = e.shape
      const o = e.hints || {}
      r = e.shape = this._modeling.createShape(r, e.position, n, {
        attach: o.attach
      }),
      e.shape = r
    }
    ,
    Zv.prototype.postExecute = function (e) {
      let t; let n; const r = e.hints || {}
      t = e.source,
      n = e.shape,
      Q(t.outgoing, function (e) {
        return e.target === n
      }
      ) || (r.connectionTarget === e.source ? this._modeling.connect(e.shape, e.source, e.connection) : this._modeling.connect(e.source, e.shape, e.connection))
    }
    ,
    eg.$inject = ['canvas', 'layouter'],
    eg.prototype.execute = function (e) {
      const t = e.connection
      const n = e.source
      const r = e.target
      const o = e.parent
      const i = e.parentIndex
      const a = e.hints
      if (!n || !r) { throw new Error('source and target required') }
      if (!o) { throw new Error('parent required') }
      return t.source = n,
      t.target = r,
      t.waypoints || (t.waypoints = this._layouter.layoutConnection(t, a)),
      this._canvas.addConnection(t, o, i),
      t
    }
    ,
    eg.prototype.revert = function (e) {
      const t = e.connection
      return this._canvas.removeConnection(t),
      t.source = null,
      t.target = null,
      t
    }

    const tg = Math.round
    function ng (e) {
      this._modeling = e
    }
    ng.$inject = ['modeling'],
    ng.prototype.preExecute = function (e) {
      const t = e.elements
      const n = e.parent
      const r = e.parentIndex
      const o = e.position
      const i = e.hints
      const a = this._modeling
      G(t, function (e) {
        L(e.x) || (e.x = 0),
        L(e.y) || (e.y = 0)
      }
      )
      const s = Ft(W(t, function (e) {
        return !e.hidden
      }
      ))
      G(t, function (e) {
        yr(e) && (e.waypoints = Y(e.waypoints, function (e) {
          return {
            x: tg(e.x - s.x - s.width / 2 + o.x),
            y: tg(e.y - s.y - s.height / 2 + o.y)
          }
        }
        )),
        le(e, {
          x: tg(e.x - s.x - s.width / 2 + o.x),
          y: tg(e.y - s.y - s.height / 2 + o.y)
        })
      }
      )
      const c = Nt(t)
      const l = {}
      G(t, function (e) {
        if (yr(e)) { l[e.id] = L(r) ? a.createConnection(l[e.source.id], l[e.target.id], r, e, e.parent || n, i) : a.createConnection(l[e.source.id], l[e.target.id], e, e.parent || n, i) } else {
          let t = le({}, i)
          c.indexOf(e) === -1 && (t.autoResize = !1),
          br(e) && (t = ue(t, ['attach'])),
          l[e.id] = L(r) ? a.createShape(e, pe(e, ['x', 'y', 'width', 'height']), e.parent || n, r, t) : a.createShape(e, pe(e, ['x', 'y', 'width', 'height']), e.parent || n, t)
        }
      }
      ),
      e.elements = J(l)
    }

    const rg = Math.round
    function og (e) {
      this._canvas = e
    }
    function ig (e) {
      og.call(this, e)
    }
    og.$inject = ['canvas'],
    og.prototype.execute = function (e) {
      const t = e.shape
      const n = e.position
      const r = e.parent
      const o = e.parentIndex
      if (!r) { throw new Error('parent required') }
      if (!n) { throw new Error('position required') }
      return void 0 !== n.width
        ? le(t, n)
        : le(t, {
          x: n.x - rg(t.width / 2),
          y: n.y - rg(t.height / 2)
        }),
      this._canvas.addShape(t, r, o),
      t
    }
    ,
    og.prototype.revert = function (e) {
      const t = e.shape
      return this._canvas.removeShape(t),
      t
    }
    ,
    w(ig, og),
    ig.$inject = ['canvas']
    const ag = og.prototype.execute
    ig.prototype.execute = function (e) {
      const t = e.shape
      return (function (e) {
        ['width', 'height'].forEach(function (t) {
          void 0 === e[t] && (e[t] = 0)
        }
        )
      }(t)),
      t.labelTarget = e.labelTarget,
      ag.call(this, e)
    }

    const sg = og.prototype.revert
    function cg (e, t) {
      this._canvas = e,
      this._modeling = t
    }
    function lg (e, t) {
      this._modeling = e,
      this._elementRegistry = t
    }
    function pg (e, t) {
      this._canvas = e,
      this._modeling = t
    }
    function ug (e) {
      this._modeling = e
    }
    ig.prototype.revert = function (e) {
      return e.shape.labelTarget = null,
      sg.call(this, e)
    }
    ,
    cg.$inject = ['canvas', 'modeling'],
    cg.prototype.preExecute = function (e) {
      const t = this._modeling
      const n = e.connection
      zv(n.incoming, function (e) {
        t.removeConnection(e, {
          nested: !0
        })
      }
      ),
      zv(n.outgoing, function (e) {
        t.removeConnection(e, {
          nested: !0
        })
      }
      )
    }
    ,
    cg.prototype.execute = function (e) {
      const t = e.connection
      const n = t.parent
      return e.parent = n,
      e.parentIndex = jn(n.children, t),
      e.source = t.source,
      e.target = t.target,
      this._canvas.removeConnection(t),
      t.source = null,
      t.target = null,
      t
    }
    ,
    cg.prototype.revert = function (e) {
      const t = e.connection
      const n = e.parent
      const r = e.parentIndex
      return t.source = e.source,
      t.target = e.target,
      kn(n.children, t, r),
      this._canvas.addConnection(t, n),
      t
    }
    ,
    lg.$inject = ['modeling', 'elementRegistry'],
    lg.prototype.postExecute = function (e) {
      const t = this._modeling
      const n = this._elementRegistry
      G(e.elements, function (e) {
        n.get(e.id) && (e.waypoints ? t.removeConnection(e) : t.removeShape(e))
      }
      )
    }
    ,
    pg.$inject = ['canvas', 'modeling'],
    pg.prototype.preExecute = function (e) {
      const t = this._modeling
      const n = e.shape
      zv(n.incoming, function (e) {
        t.removeConnection(e, {
          nested: !0
        })
      }
      ),
      zv(n.outgoing, function (e) {
        t.removeConnection(e, {
          nested: !0
        })
      }
      ),
      zv(n.children, function (e) {
        yr(e)
          ? t.removeConnection(e, {
            nested: !0
          })
          : t.removeShape(e, {
            nested: !0
          })
      }
      )
    }
    ,
    pg.prototype.execute = function (e) {
      const t = this._canvas
      const n = e.shape
      const r = n.parent
      return e.oldParent = r,
      e.oldParentIndex = jn(r.children, n),
      t.removeShape(n),
      n
    }
    ,
    pg.prototype.revert = function (e) {
      const t = this._canvas
      const n = e.shape
      const r = e.oldParent
      const o = e.oldParentIndex
      return kn(r.children, n, o),
      t.addShape(n, r),
      n
    }
    ,
    ug.$inject = ['modeling']
    const dg = {
      x: 'y',
      y: 'x'
    }
    function fg (e, t) {
      this._layouter = e,
      this._canvas = t
    }
    function hg () {}
    function mg () {
      this.allShapes = {},
      this.allConnections = {},
      this.enclosedElements = {},
      this.enclosedConnections = {},
      this.topLevel = {}
    }
    function vg (e) {
      this._modeling = e
    }
    function gg (e) {
      this._helper = new vg(e)
    }
    function yg (e) {
      this._modeling = e,
      this._helper = new vg(e)
    }
    function bg (e) {
      this._modeling = e
    }
    function Ag (e) {
      return e.original || e
    }
    function Eg (e, t) {
      this._modeling = e,
      this._rules = t
    }
    function xg (e) {
      this._modeling = e
    }
    function wg (e) {
      this._modeling = e
    }
    function _g (e) {
      return le({}, e)
    }
    function Cg (e) {
      switch (e) {
        case 'n':
        case 's':
          return 'y'
        case 'w':
        case 'e':
          return 'x'
      }
    }
    function Sg (e, t, n) {
      const r = Cg(n)
      return /e|s/.test(n) ? e[r] > t : /n|w/.test(n) ? e[r] < t : void 0
    }
    function kg (e, t) {
      return e.indexOf(t) !== -1
    }
    function jg (e) {
      this._modeling = e
    }
    function Bg (e) {
      let t = {}
      return G(e, function (e) {
        t[e.id] = e.hidden,
        e.children && (t = le({}, t, Bg(e.children)))
      }
      ),
      t
    }
    function Dg (e, t) {
      let n = []
      return G(e, function (e) {
        e.hidden = t,
        n = n.concat(e),
        e.children && (n = n.concat(Dg(e.children, e.collapsed || t)))
      }
      ),
      n
    }
    function Pg (e, t) {
      let n = []
      return G(e, function (e) {
        e.hidden = t[e.id],
        n = n.concat(e),
        e.children && (n = n.concat(Pg(e.children, t)))
      }
      ),
      n
    }
    function Og (e) {
      this._modeling = e
    }
    function Tg (e, t) {
      return Sn(e && e.attachers, t)
    }
    function Rg (e, t, n) {
      if (e) {
        let r = e.attachers
        r || (e.attachers = r = []),
        kn(r, t, n)
      }
    }
    function Ng () {}
    function Mg (e) {
      return Mg = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      Mg(e)
    }
    function Ig (e, t, n) {
      this._eventBus = e,
      this._elementFactory = t,
      this._commandStack = n
      const r = this
      e.on('diagram.init', function () {
        r.registerHandlers(n)
      }
      )
    }
    function Lg (e) {
      this._elementRegistry = e
    }
    function zg (e, t) {
      G(t, function (t, n) {
        e.set(n, t)
      }
      )
    }
    ug.prototype.preExecute = function (e) {
      const t = this._modeling
      const n = e.groups
      const r = e.axis
      const o = e.dimension
      function i (e, t) {
        e.range.min = Math.min(t[r], e.range.min),
        e.range.max = Math.max(t[r] + t[o], e.range.max)
      }
      function a (e) {
        return e[r] + e[o] / 2
      }
      function s (e) {
        return e.length - 1
      }
      function c (e) {
        return e.max - e.min
      }
      let l; let p; const u = n[0]; const d = s(n); const f = n[d]; let h = 0
      G(n, function (e, l) {
        let p, u, f
        e.elements.length < 2
          ? l && l !== n.length - 1 && (i(e, e.elements[0]),
          h += c(e.range))
          : (u = (p = te(e.elements, r))[0],
            l === d && (u = p[s(p)]),
            f = a(u),
            e.range = null,
            G(p, function (n) {
              !(function (e, n) {
                const o = {
                  y: 0
                }
                o[r] = e - a(n),
                o[r] && (o[dg[r]] = 0,
                t.moveElements([n], o, n.parent))
              }(f, n)),
              e.range !== null
                ? i(e, n)
                : e.range = {
                  min: n[r],
                  max: n[r] + n[o]
                }
            }
            ),
            l && l !== n.length - 1 && (h += c(e.range)))
      }
      ),
      p = Math.abs(f.range.min - u.range.max),
      (l = Math.round((p - h) / (n.length - 1))) < n.length - 1 || G(n, function (e, i) {
        let a; const s = {}
        e !== u && e !== f && (a = n[i - 1],
        e.range.max = 0,
        G(e.elements, function (n, i) {
          s[dg[r]] = 0,
          s[r] = a.range.max - n[r] + l,
          e.range.min !== n[r] && (s[r] += n[r] - e.range.min),
          s[r] && t.moveElements([n], s, n.parent),
          e.range.max = Math.max(n[r] + n[o], i ? e.range.max : 0)
        }
        ))
      }
      )
    }
    ,
    ug.prototype.postExecute = function (e) {}
    ,
    fg.$inject = ['layouter', 'canvas'],
    fg.prototype.execute = function (e) {
      const t = e.connection
      return le(e, {
        oldWaypoints: t.waypoints
      }),
      t.waypoints = this._layouter.layoutConnection(t, e.hints),
      t
    }
    ,
    fg.prototype.revert = function (e) {
      const t = e.connection
      return t.waypoints = e.oldWaypoints,
      t
    }
    ,
    hg.prototype.execute = function (e) {
      const t = e.connection
      const n = e.delta
      const r = e.newParent || t.parent
      const o = e.newParentIndex
      const i = t.parent
      return e.oldParent = i,
      e.oldParentIndex = Sn(i.children, t),
      kn(r.children, t, o),
      t.parent = r,
      G(t.waypoints, function (e) {
        e.x += n.x,
        e.y += n.y,
        e.original && (e.original.x += n.x,
        e.original.y += n.y)
      }
      ),
      t
    }
    ,
    hg.prototype.revert = function (e) {
      const t = e.connection
      const n = t.parent
      const r = e.oldParent
      const o = e.oldParentIndex
      const i = e.delta
      return Sn(n.children, t),
      kn(r.children, t, o),
      t.parent = r,
      G(t.waypoints, function (e) {
        e.x -= i.x,
        e.y -= i.y,
        e.original && (e.original.x -= i.x,
        e.original.y -= i.y)
      }
      ),
      t
    }
    ,
    mg.prototype.add = function (e, t) {
      return this.addAll([e], t)
    }
    ,
    mg.prototype.addAll = function (e, t) {
      const n = (function (e, t, n) {
        T(t) && (t = !0),
        I(t) && (n = t,
        t = !0)
        const r = qt((n = n || {}).allShapes)
        const o = qt(n.allConnections)
        const i = qt(n.enclosedElements)
        const a = qt(n.enclosedConnections)
        const s = qt(n.topLevel, t && X(e, function (e) {
          return e.id
        }
        ))
        function c (e) {
          s[e.source.id] && s[e.target.id] && (s[e.id] = [e]),
          r[e.source.id] && r[e.target.id] && (a[e.id] = i[e.id] = e),
          o[e.id] = e
        }
        return Lt(e, function (e) {
          if (i[e.id] = e,
          !e.waypoints) {
            return r[e.id] = e,
            G(e.incoming, c),
            G(e.outgoing, c),
            e.children
          }
          a[e.id] = o[e.id] = e
        }
        ),
        {
          allShapes: r,
          allConnections: o,
          topLevel: s,
          enclosedConnections: a,
          enclosedElements: i
        }
      }(e, !!t, this))
      return le(this, n),
      this
    }
    ,
    vg.prototype.moveRecursive = function (e, t, n) {
      return e ? this.moveClosure(this.getClosure(e), t, n) : []
    }
    ,
    vg.prototype.moveClosure = function (e, t, n, r, o) {
      const i = this._modeling
      const a = e.allShapes
      const s = e.allConnections
      const c = e.enclosedConnections
      const l = e.topLevel
      let p = !1
      o && o.parent === n && (p = !0),
      G(a, function (e) {
        i.moveShape(e, t, l[e.id] && !p && n, {
          recurse: !1,
          layout: !1
        })
      }
      ),
      G(s, function (e) {
        const r = !!a[e.source.id]
        const o = !!a[e.target.id]
        c[e.id] && r && o
          ? i.moveConnection(e, t, l[e.id] && !p && n)
          : i.layoutConnection(e, {
            connectionStart: r && Jf(e, e.source, t),
            connectionEnd: o && Xf(e, e.target, t)
          })
      }
      )
    }
    ,
    vg.prototype.getClosure = function (e) {
      return (new mg()).addAll(e, !0)
    }
    ,
    gg.$inject = ['modeling'],
    gg.prototype.preExecute = function (e) {
      e.closure = this._helper.getClosure(e.shapes)
    }
    ,
    gg.prototype.postExecute = function (e) {
      let t; const n = e.hints
      n && n.primaryShape && (t = n.primaryShape,
      n.oldParent = t.parent),
      this._helper.moveClosure(e.closure, e.delta, e.newParent, e.newHost, t)
    }
    ,
    yg.$inject = ['modeling'],
    yg.prototype.execute = function (e) {
      const t = e.shape
      const n = e.delta
      const r = e.newParent || t.parent
      const o = e.newParentIndex
      const i = t.parent
      return e.oldBounds = pe(t, ['x', 'y', 'width', 'height']),
      e.oldParent = i,
      e.oldParentIndex = Sn(i.children, t),
      kn(r.children, t, o),
      le(t, {
        parent: r,
        x: t.x + n.x,
        y: t.y + n.y
      }),
      t
    }
    ,
    yg.prototype.postExecute = function (e) {
      const t = e.shape
      const n = e.delta
      const r = e.hints
      const o = this._modeling
      !1 !== r.layout && (G(t.incoming, function (e) {
        o.layoutConnection(e, {
          connectionEnd: Xf(e, t, n)
        })
      }
      ),
      G(t.outgoing, function (e) {
        o.layoutConnection(e, {
          connectionStart: Jf(e, t, n)
        })
      }
      )),
      !1 !== r.recurse && this.moveChildren(e)
    }
    ,
    yg.prototype.revert = function (e) {
      const t = e.shape
      const n = e.oldParent
      const r = e.oldParentIndex
      const o = e.delta
      return kn(n.children, t, r),
      le(t, {
        parent: n,
        x: t.x - o.x,
        y: t.y - o.y
      }),
      t
    }
    ,
    yg.prototype.moveChildren = function (e) {
      const t = e.delta
      const n = e.shape
      this._helper.moveRecursive(n.children, t, null)
    }
    ,
    yg.prototype.getNewParent = function (e) {
      return e.newParent || e.shape.parent
    }
    ,
    bg.$inject = ['modeling'],
    bg.prototype.execute = function (e) {
      const t = e.newSource
      const n = e.newTarget
      const r = e.connection
      const o = e.dockingOrPoints
      if (!t && !n) { throw new Error('newSource or newTarget required') }
      return M(o) && (e.oldWaypoints = r.waypoints,
      r.waypoints = o),
      t && (e.oldSource = r.source,
      r.source = t),
      n && (e.oldTarget = r.target,
      r.target = n),
      r
    }
    ,
    bg.prototype.postExecute = function (e) {
      const t = e.connection
      const n = e.newSource
      const r = e.newTarget
      const o = e.dockingOrPoints
      const i = e.hints || {}
      const a = {}
      i.connectionStart && (a.connectionStart = i.connectionStart),
      i.connectionEnd && (a.connectionEnd = i.connectionEnd),
      !1 !== i.layoutConnection && (!n || r && i.docking !== 'source' || (a.connectionStart = a.connectionStart || Ag(M(o) ? o[0] : o)),
      !r || n && i.docking !== 'target' || (a.connectionEnd = a.connectionEnd || Ag(M(o) ? o[o.length - 1] : o)),
      i.newWaypoints && (a.waypoints = i.newWaypoints),
      this._modeling.layoutConnection(t, a))
    }
    ,
    bg.prototype.revert = function (e) {
      const t = e.oldSource
      const n = e.oldTarget
      const r = e.oldWaypoints
      const o = e.connection
      return t && (o.source = t),
      n && (o.target = n),
      r && (o.waypoints = r),
      o
    }
    ,
    Eg.$inject = ['modeling', 'rules'],
    Eg.prototype.preExecute = function (e) {
      let t; const n = this; const r = this._modeling; const o = this._rules; const i = e.oldShape; const a = e.newData; const s = e.hints || {}
      function c (e, t, n) {
        return o.allowed('connection.reconnect', {
          connection: n,
          source: e,
          target: t
        })
      }
      let l; const p = {
        x: a.x,
        y: a.y
      }; const u = {
        x: i.x,
        y: i.y,
        width: i.width,
        height: i.height
      }
      t = e.newShape = e.newShape || n.createShape(a, p, i.parent, s),
      i.host && r.updateAttachment(t, i.host),
      !1 !== s.moveChildren && (l = i.children.slice(),
      r.moveElements(l, {
        x: 0,
        y: 0
      }, t, s))
      const d = i.incoming.slice()
      const f = i.outgoing.slice()
      G(d, function (e) {
        c(e.source, t, e) && n.reconnectEnd(e, t, Kf(e, t, u), s)
      }
      ),
      G(f, function (e) {
        const r = e.target
        c(t, r, e) && n.reconnectStart(e, t, Yf(e, t, u), s)
      }
      )
    }
    ,
    Eg.prototype.postExecute = function (e) {
      const t = e.oldShape
      this._modeling.removeShape(t)
    }
    ,
    Eg.prototype.execute = function (e) {}
    ,
    Eg.prototype.revert = function (e) {}
    ,
    Eg.prototype.createShape = function (e, t, n, r) {
      return this._modeling.createShape(e, t, n, r)
    }
    ,
    Eg.prototype.reconnectStart = function (e, t, n, r) {
      this._modeling.reconnectStart(e, t, n, r)
    }
    ,
    Eg.prototype.reconnectEnd = function (e, t, n, r) {
      this._modeling.reconnectEnd(e, t, n, r)
    }
    ,
    xg.$inject = ['modeling'],
    xg.prototype.execute = function (e) {
      const t = e.shape
      const n = e.newBounds
      const r = e.minBounds
      if (void 0 === n.x || void 0 === n.y || void 0 === n.width || void 0 === n.height) { throw new Error('newBounds must have {x, y, width, height} properties') }
      if (r && (n.width < r.width || n.height < r.height)) { throw new Error('width and height cannot be less than minimum height and width') }
      if (!r && n.width < 10 || n.height < 10) { throw new Error('width and height cannot be less than 10px') }
      return e.oldBounds = {
        width: t.width,
        height: t.height,
        x: t.x,
        y: t.y
      },
      le(t, {
        width: n.width,
        height: n.height,
        x: n.x,
        y: n.y
      }),
      t
    }
    ,
    xg.prototype.postExecute = function (e) {
      const t = this._modeling
      const n = e.shape
      const r = e.oldBounds
      !1 !== (e.hints || {}).layout && (G(n.incoming, function (e) {
        t.layoutConnection(e, {
          connectionEnd: Kf(e, n, r)
        })
      }
      ),
      G(n.outgoing, function (e) {
        t.layoutConnection(e, {
          connectionStart: Yf(e, n, r)
        })
      }
      ))
    }
    ,
    xg.prototype.revert = function (e) {
      const t = e.shape
      const n = e.oldBounds
      return le(t, {
        width: n.width,
        height: n.height,
        x: n.x,
        y: n.y
      }),
      t
    }
    ,
    wg.$inject = ['modeling'],
    wg.prototype.preExecute = function (e) {
      const t = e.delta
      const n = e.direction
      const r = e.movingShapes
      const o = e.resizingShapes
      const i = e.start
      const a = {}
      this.moveShapes(r, t),
      G(o, function (e) {
        a[e.id] = (function (e) {
          return {
            x: e.x,
            y: e.y,
            height: e.height,
            width: e.width
          }
        }(e))
      }
      ),
      this.resizeShapes(o, t, n),
      this.updateConnectionWaypoints((function (e, t) {
        const n = []
        return G(e.concat(t), function (r) {
          const o = r.incoming
          const i = r.outgoing
          G(o.concat(i), function (r) {
            const o = r.source
            const i = r.target;
            (vv(e, o) || vv(e, i) || vv(t, o) || vv(t, i)) && (vv(n, r) || n.push(r))
          }
          )
        }
        ),
        n
      }(r, o)), t, n, i, r, o, a)
    }
    ,
    wg.prototype.execute = function () {}
    ,
    wg.prototype.revert = function () {}
    ,
    wg.prototype.moveShapes = function (e, t) {
      const n = this
      G(e, function (e) {
        n._modeling.moveShape(e, t, null, {
          autoResize: !1,
          layout: !1,
          recurse: !1
        })
      }
      )
    }
    ,
    wg.prototype.resizeShapes = function (e, t, n) {
      const r = this
      G(e, function (e) {
        const o = (function (e, t, n) {
          const r = e.x
          const o = e.y
          const i = e.width
          const a = e.height
          const s = n.x
          const c = n.y
          switch (t) {
            case 'n':
              return {
                x: r,
                y: o + c,
                width: i,
                height: a - c
              }
            case 's':
              return {
                x: r,
                y: o,
                width: i,
                height: a + c
              }
            case 'w':
              return {
                x: r + s,
                y: o,
                width: i - s,
                height: a
              }
            case 'e':
              return {
                x: r,
                y: o,
                width: i + s,
                height: a
              }
            default:
              throw new Error('unknown direction: ' + t)
          }
        }(e, n, t))
        r._modeling.resizeShape(e, o, null, {
          attachSupport: !1,
          autoResize: !1,
          layout: !1
        })
      }
      )
    }
    ,
    wg.prototype.updateConnectionWaypoints = function (e, t, n, r, o, i, a) {
      const s = this
      const c = o.concat(i)
      G(e, function (e) {
        const l = e.source
        const p = e.target
        let u = (function (e) {
          return Y(e.waypoints, function (e) {
            return (e = _g(e)).original && (e.original = _g(e.original)),
            e
          }
          )
        }(e))
        const d = Cg(n)
        const f = {}
        kg(c, l) && kg(c, p)
          ? (u = Y(u, function (e) {
              return Sg(e, r, n) && (e[d] = e[d] + t[d]),
              e.original && Sg(e.original, r, n) && (e.original[d] = e.original[d] + t[d]),
              e
            }
            ),
            s._modeling.updateWaypoints(e, u, {
              labelBehavior: !1
            }))
          : (kg(c, l) || kg(c, p)) && (kg(o, l) ? f.connectionStart = Jf(e, l, t) : kg(o, p) ? f.connectionEnd = Xf(e, p, t) : kg(i, l) ? f.connectionStart = Yf(e, l, a[l.id]) : kg(i, p) && (f.connectionEnd = Kf(e, p, a[p.id])),
            s._modeling.layoutConnection(e, f))
      }
      )
    }
    ,
    jg.$inject = ['modeling'],
    jg.prototype.execute = function (e) {
      const t = e.shape
      const n = t.children
      e.oldChildrenVisibility = Bg(n),
      t.collapsed = !t.collapsed
      const r = Dg(n, t.collapsed)
      return [t].concat(r)
    }
    ,
    jg.prototype.revert = function (e) {
      const t = e.shape
      const n = e.oldChildrenVisibility
      const r = Pg(t.children, n)
      return t.collapsed = !t.collapsed,
      [t].concat(r)
    }
    ,
    Og.$inject = ['modeling'],
    Og.prototype.execute = function (e) {
      const t = e.shape
      const n = e.newHost
      const r = t.host
      return e.oldHost = r,
      e.attacherIdx = Tg(r, t),
      Rg(n, t),
      t.host = n,
      t
    }
    ,
    Og.prototype.revert = function (e) {
      const t = e.shape
      const n = e.newHost
      const r = e.oldHost
      const o = e.attacherIdx
      return t.host = r,
      Tg(n, t),
      Rg(r, t, o),
      t
    }
    ,
    Ng.prototype.execute = function (e) {
      const t = e.connection
      const n = e.newWaypoints
      return e.oldWaypoints = t.waypoints,
      t.waypoints = n,
      t
    }
    ,
    Ng.prototype.revert = function (e) {
      const t = e.connection
      const n = e.oldWaypoints
      return t.waypoints = n,
      t
    }
    ,
    Ig.$inject = ['eventBus', 'elementFactory', 'commandStack'],
    Ig.prototype.getHandlers = function () {
      return {
        'shape.append': Zv,
        'shape.create': og,
        'shape.delete': pg,
        'shape.move': yg,
        'shape.resize': xg,
        'shape.replace': Eg,
        'shape.toggleCollapse': jg,
        spaceTool: wg,
        'label.create': ig,
        'connection.create': eg,
        'connection.delete': cg,
        'connection.move': hg,
        'connection.layout': fg,
        'connection.updateWaypoints': Ng,
        'connection.reconnect': bg,
        'elements.create': ng,
        'elements.move': gg,
        'elements.delete': lg,
        'elements.distribute': ug,
        'elements.align': Xv,
        'element.updateAttachment': Og
      }
    }
    ,
    Ig.prototype.registerHandlers = function (e) {
      G(this.getHandlers(), function (t, n) {
        e.registerHandler(n, t)
      }
      )
    }
    ,
    Ig.prototype.moveShape = function (e, t, n, r, o) {
      Mg(r) === 'object' && (o = r,
      r = null)
      const i = {
        shape: e,
        delta: t,
        newParent: n,
        newParentIndex: r,
        hints: o || {}
      }
      this._commandStack.execute('shape.move', i)
    }
    ,
    Ig.prototype.updateAttachment = function (e, t) {
      const n = {
        shape: e,
        newHost: t
      }
      this._commandStack.execute('element.updateAttachment', n)
    }
    ,
    Ig.prototype.moveElements = function (e, t, n, r) {
      let o; const i = (r = r || {}).attach; let a = n
      !0 === i
        ? (o = n,
          a = n.parent)
        : !1 === i && (o = null)
      const s = {
        shapes: e,
        delta: t,
        newParent: a,
        newHost: o,
        hints: r
      }
      this._commandStack.execute('elements.move', s)
    }
    ,
    Ig.prototype.moveConnection = function (e, t, n, r, o) {
      Mg(r) === 'object' && (o = r,
      r = void 0)
      const i = {
        connection: e,
        delta: t,
        newParent: n,
        newParentIndex: r,
        hints: o || {}
      }
      this._commandStack.execute('connection.move', i)
    }
    ,
    Ig.prototype.layoutConnection = function (e, t) {
      const n = {
        connection: e,
        hints: t || {}
      }
      this._commandStack.execute('connection.layout', n)
    }
    ,
    Ig.prototype.createConnection = function (e, t, n, r, o, i) {
      Mg(n) === 'object' && (i = o,
      o = r,
      r = n,
      n = void 0)
      const a = {
        source: e,
        target: t,
        parent: o,
        parentIndex: n,
        connection: r = this._create('connection', r),
        hints: i
      }
      return this._commandStack.execute('connection.create', a),
      a.connection
    }
    ,
    Ig.prototype.createShape = function (e, t, n, r, o) {
      typeof r !== 'number' && (o = r,
      r = void 0)
      let i; let a; const s = (o = o || {}).attach
      e = this._create('shape', e),
      s
        ? (i = n.parent,
          a = n)
        : i = n
      const c = {
        position: t,
        shape: e,
        parent: i,
        parentIndex: r,
        host: a,
        hints: o
      }
      return this._commandStack.execute('shape.create', c),
      c.shape
    }
    ,
    Ig.prototype.createElements = function (e, t, n, r, o) {
      M(e) || (e = [e]),
      typeof r !== 'number' && (o = r,
      r = void 0)
      const i = {
        position: t,
        elements: e,
        parent: n,
        parentIndex: r,
        hints: o = o || {}
      }
      return this._commandStack.execute('elements.create', i),
      i.elements
    }
    ,
    Ig.prototype.createLabel = function (e, t, n, r) {
      n = this._create('label', n)
      const o = {
        labelTarget: e,
        position: t,
        parent: r || e.parent,
        shape: n
      }
      return this._commandStack.execute('label.create', o),
      o.shape
    }
    ,
    Ig.prototype.appendShape = function (e, t, n, r, o) {
      o = o || {}
      const i = {
        source: e,
        position: n,
        target: r,
        shape: t = this._create('shape', t),
        connection: o.connection,
        connectionParent: o.connectionParent,
        hints: o
      }
      return this._commandStack.execute('shape.append', i),
      i.shape
    }
    ,
    Ig.prototype.removeElements = function (e) {
      const t = {
        elements: e
      }
      this._commandStack.execute('elements.delete', t)
    }
    ,
    Ig.prototype.distributeElements = function (e, t, n) {
      const r = {
        groups: e,
        axis: t,
        dimension: n
      }
      this._commandStack.execute('elements.distribute', r)
    }
    ,
    Ig.prototype.removeShape = function (e, t) {
      const n = {
        shape: e,
        hints: t || {}
      }
      this._commandStack.execute('shape.delete', n)
    }
    ,
    Ig.prototype.removeConnection = function (e, t) {
      const n = {
        connection: e,
        hints: t || {}
      }
      this._commandStack.execute('connection.delete', n)
    }
    ,
    Ig.prototype.replaceShape = function (e, t, n) {
      const r = {
        oldShape: e,
        newData: t,
        hints: n || {}
      }
      return this._commandStack.execute('shape.replace', r),
      r.newShape
    }
    ,
    Ig.prototype.alignElements = function (e, t) {
      const n = {
        elements: e,
        alignment: t
      }
      this._commandStack.execute('elements.align', n)
    }
    ,
    Ig.prototype.resizeShape = function (e, t, n, r) {
      const o = {
        shape: e,
        newBounds: t,
        minBounds: n,
        hints: r
      }
      this._commandStack.execute('shape.resize', o)
    }
    ,
    Ig.prototype.createSpace = function (e, t, n, r, o) {
      const i = {
        delta: n,
        direction: r,
        movingShapes: e,
        resizingShapes: t,
        start: o
      }
      this._commandStack.execute('spaceTool', i)
    }
    ,
    Ig.prototype.updateWaypoints = function (e, t, n) {
      const r = {
        connection: e,
        newWaypoints: t,
        hints: n || {}
      }
      this._commandStack.execute('connection.updateWaypoints', r)
    }
    ,
    Ig.prototype.reconnect = function (e, t, n, r, o) {
      const i = {
        connection: e,
        newSource: t,
        newTarget: n,
        dockingOrPoints: r,
        hints: o || {}
      }
      this._commandStack.execute('connection.reconnect', i)
    }
    ,
    Ig.prototype.reconnectStart = function (e, t, n, r) {
      r || (r = {}),
      this.reconnect(e, t, e.target, n, le(r, {
        docking: 'source'
      }))
    }
    ,
    Ig.prototype.reconnectEnd = function (e, t, n, r) {
      r || (r = {}),
      this.reconnect(e, e.source, t, n, le(r, {
        docking: 'target'
      }))
    }
    ,
    Ig.prototype.connect = function (e, t, n, r) {
      return this.createConnection(e, t, n || {}, e.parent, r)
    }
    ,
    Ig.prototype._create = function (e, t) {
      return t instanceof qr ? t : this._elementFactory.create(e, t)
    }
    ,
    Ig.prototype.toggleCollapse = function (e, t) {
      const n = {
        shape: e,
        hints: t || {}
      }
      this._commandStack.execute('shape.toggleCollapse', n)
    }
    ,
    Lg.$inject = ['elementRegistry'],
    Lg.prototype.execute = function (e) {
      const t = e.element
      const n = e.moddleElement
      const r = e.properties
      if (!n) { throw new Error('<moddleElement> required') }
      const o = e.changed || this._getVisualReferences(n).concat(t)
      const i = e.oldProperties || (function (e, t) {
        return U(t, function (t, n) {
          return t[n] = e.get(n),
          t
        }
        , {})
      }(n, K(r)))
      return zg(n, r),
      e.oldProperties = i,
      e.changed = o,
      o
    }
    ,
    Lg.prototype.revert = function (e) {
      const t = e.oldProperties
      const n = e.moddleElement
      const r = e.changed
      return zg(n, t),
      r
    }
    ,
    Lg.prototype._getVisualReferences = function (e) {
      const t = this._elementRegistry
      return Pi(e, 'bpmn:DataObject')
        ? (function (e, t) {
            return t.filter(function (t) {
              return Pi(t, 'bpmn:DataObjectReference') && Ti(t).dataObjectRef === e
            }
            )
          }(e, t))
        : []
    }

    const Fg = 'default'
    const $g = 'id'
    const Hg = {
      width: 0,
      height: 0
    }
    function qg (e, t, n, r, o) {
      this._elementRegistry = e,
      this._moddle = t,
      this._translate = n,
      this._modeling = r,
      this._textRenderer = o
    }
    function Wg (e, t) {
      return $g in e && e[$g] !== t[$g]
    }
    function Gg (e, t) {
      const n = e.businessObject
      const r = Ri(e)
      G(t, function (e, t) {
        t !== 'di'
          ? n.set(t, e)
          : r && (function (e, t) {
            G(t, function (t, n) {
              e.set(n, t)
            }
            )
          }(r, e))
      }
      )
    }
    qg.$inject = ['elementRegistry', 'moddle', 'translate', 'modeling', 'textRenderer'],
    qg.prototype.execute = function (e) {
      const t = e.element
      const n = [t]
      const r = this._translate
      if (!t) { throw new Error(r('element required')) }
      const o = this._elementRegistry
      const i = this._moddle.ids
      const a = t.businessObject
      const s = (function (e) {
        const t = le({}, e)
        return Ug.forEach(function (n) {
          n in e && (t[n] = Ti(t[n]))
        }
        ),
        t
      }(e.properties))
      const c = e.oldProperties || (function (e, t) {
        const n = K(t)
        const r = e.businessObject
        const o = Ri(e)
        return U(n, function (e, n) {
          return e[n] = n !== 'di'
            ? r.get(n)
            : (function (e, t) {
                return U(t, function (t, n) {
                  return t[n] = e && e.get(n),
                  t
                }
                , {})
              }(o, K(t.di))),
          e
        }
        , {})
      }(t, s))
      return Wg(s, a) && (i.unclaim(a[$g]),
      o.updateId(t, s[$g]),
      i.claim(s[$g], a)),
      Fg in s && (s[Fg] && n.push(o.get(s[Fg].id)),
      a[Fg] && n.push(o.get(a[Fg].id))),
      Gg(t, s),
      e.oldProperties = c,
      e.changed = n,
      n
    }
    ,
    qg.prototype.postExecute = function (e) {
      const t = e.element.label
      const n = t && Ti(t).name
      if (n) {
        const r = this._textRenderer.getExternalLabelBounds(t, n)
        this._modeling.resizeShape(t, r, Hg)
      }
    }
    ,
    qg.prototype.revert = function (e) {
      const t = e.element
      const n = e.properties
      const r = e.oldProperties
      const o = t.businessObject
      const i = this._elementRegistry
      const a = this._moddle.ids
      return Gg(t, r),
      Wg(n, o) && (a.unclaim(n[$g]),
      i.updateId(t, r[$g]),
      a.claim(r[$g], o)),
      e.changed
    }

    var Ug = ['default']
    function Vg (e, t) {
      this._canvas = e,
      this._modeling = t
    }
    function Qg (e, t) {
      this._modeling = e,
      this._spaceTool = t
    }
    function Yg (e, t) {
      this._modeling = e,
      this._translate = t
    }
    function Kg (e, t) {
      this._modeling = e,
      this._spaceTool = t
    }
    Vg.$inject = ['canvas', 'modeling'],
    Vg.prototype.execute = function (e) {
      const t = this._canvas
      const n = e.newRoot
      const r = n.businessObject
      const o = t.getRootElement()
      const i = o.businessObject
      const a = i.$parent
      const s = Ri(o)
      return t.setRootElement(n),
      t.removeRootElement(o),
      kn(a.rootElements, r),
      r.$parent = a,
      Sn(a.rootElements, i),
      i.$parent = null,
      o.di = null,
      s.bpmnElement = r,
      n.di = s,
      e.oldRoot = o,
      []
    }
    ,
    Vg.prototype.revert = function (e) {
      const t = this._canvas
      const n = e.newRoot
      const r = n.businessObject
      const o = e.oldRoot
      const i = o.businessObject
      const a = r.$parent
      const s = Ri(n)
      return t.setRootElement(o),
      t.removeRootElement(n),
      Sn(a.rootElements, r),
      r.$parent = null,
      kn(a.rootElements, i),
      i.$parent = a,
      n.di = null,
      s.bpmnElement = i,
      o.di = s,
      []
    }
    ,
    Qg.$inject = ['modeling', 'spaceTool'],
    Qg.prototype.preExecute = function (e) {
      const t = this._spaceTool
      const n = this._modeling
      const r = e.shape
      let o = e.location
      const i = hf(r)
      const a = i === r
      const s = a ? r : r.parent
      const c = ff(s)
      const l = ea(r)
      if (l ? o === 'left' ? o = 'top' : o === 'right' && (o = 'bottom') : o === 'top' ? o = 'left' : o === 'bottom' && (o = 'right'),
      !c.length) {
        const p = l
          ? {
              x: r.x + uf,
              y: r.y,
              width: r.width - uf,
              height: r.height
            }
          : {
              x: r.x,
              y: r.y + uf,
              width: r.width,
              height: r.height - uf
            }
        n.createShape({
          type: 'bpmn:Lane',
          isHorizontal: l
        }, p, s)
      }
      let u; let d; let f; let h; let m; const v = []
      Lt(i, function (e) {
        return v.push(e),
        e.label && v.push(e.label),
        e === r
          ? []
          : W(e.children, function (e) {
            return e !== r
          }
          )
      }
      ),
      o === 'top'
        ? (u = -120,
          f = (d = r.y) + 10,
          h = 'n',
          m = 'y')
        : o === 'left'
          ? (u = -120,
            f = (d = r.x) + 10,
            h = 'w',
            m = 'x')
          : o === 'bottom'
            ? (u = 120,
              f = (d = r.y + r.height) - 10,
              h = 's',
              m = 'y')
            : o === 'right' && (u = 120,
            f = (d = r.x + r.width) - 10,
            h = 'e',
            m = 'x')
      const g = t.calculateAdjustments(v, m, u, f)
      const y = l
        ? {
            x: 0,
            y: u
          }
        : {
            x: u,
            y: 0
          }
      t.makeSpace(g.movingShapes, g.resizingShapes, y, h, f)
      const b = l
        ? {
            x: r.x + (a ? uf : 0),
            y: d - (o === 'top' ? 120 : 0),
            width: r.width - (a ? uf : 0),
            height: 120
          }
        : {
            x: d - (o === 'left' ? 120 : 0),
            y: r.y + (a ? uf : 0),
            width: 120,
            height: r.height - (a ? uf : 0)
          }
      e.newLane = n.createShape({
        type: 'bpmn:Lane',
        isHorizontal: l
      }, b, s)
    }
    ,
    Yg.$inject = ['modeling', 'translate'],
    Yg.prototype.preExecute = function (e) {
      const t = this._modeling
      const n = this._translate
      const r = e.shape
      const o = e.count
      const i = ff(r)
      const a = i.length
      if (a > o) {
        throw new Error(n('more than {count} child lanes', {
          count: o
        }))
      }
      let s; let c; let l; let p; const u = ea(r); const d = u ? r.height : r.width; const f = Math.round(d / o)
      for (p = 0; p < o; p++) {
        s = p === o - 1 ? d - f * p : f,
        c = u
          ? {
              x: r.x + uf,
              y: r.y + p * f,
              width: r.width - uf,
              height: s
            }
          : {
              x: r.x + p * f,
              y: r.y + uf,
              width: s,
              height: r.height - uf
            },
        p < a
          ? t.resizeShape(i[p], c)
          : (l = {
              type: 'bpmn:Lane',
              isHorizontal: u
            },
            t.createShape(l, c, r))
      }
    }
    ,
    Kg.$inject = ['modeling', 'spaceTool'],
    Kg.prototype.preExecute = function (e) {
      const t = e.shape
      const n = e.newBounds
      !1 !== e.balanced ? this.resizeBalanced(t, n) : this.resizeSpace(t, n)
    }
    ,
    Kg.prototype.resizeBalanced = function (e, t) {
      const n = this._modeling
      const r = (function (e, t) {
        const n = hf(e)
        const r = df(n, Pi(n, 'bpmn:Process') ? [] : [n])
        const o = xr(e)
        const i = xr(t)
        const a = (function (e, t) {
          return nf(xr(t), xr(e))
        }(e, t))
        const s = []
        const c = ea(e)
        return r.forEach(function (t) {
          if (t !== e) {
            let n = c ? 0 : a.top
            let r = c ? a.right : 0
            let l = c ? 0 : a.bottom
            let p = c ? a.left : 0
            const u = xr(t)
            a.top && (lf(u.bottom - o.top) < 10 && (l = i.top - u.bottom),
            lf(u.top - o.top) < 5 && (n = i.top - u.top)),
            a.left && (lf(u.right - o.left) < 10 && (r = i.left - u.right),
            lf(u.left - o.left) < 5 && (p = i.left - u.left)),
            a.bottom && (lf(u.top - o.bottom) < 10 && (n = i.bottom - u.top),
            lf(u.bottom - o.bottom) < 5 && (l = i.bottom - u.bottom)),
            a.right && (lf(u.left - o.right) < 10 && (p = i.right - u.left),
            lf(u.right - o.right) < 5 && (r = i.right - u.right)),
            (n || r || l || p) && s.push({
              shape: t,
              newBounds: rf(t, {
                top: n,
                right: r,
                bottom: l,
                left: p
              })
            })
          }
        }
        ),
        s
      }(e, t))
      n.resizeShape(e, t),
      r.forEach(function (e) {
        n.resizeShape(e.shape, e.newBounds)
      }
      )
    }
    ,
    Kg.prototype.resizeSpace = function (e, t) {
      let n; let r; let o; let i; let a; const s = this._spaceTool; const c = xr(e); const l = nf(xr(t), c); const p = hf(e); const u = []; const d = []
      Lt(p, function (e) {
        return u.push(e),
        (Pi(e, 'bpmn:Lane') || Pi(e, 'bpmn:Participant')) && d.push(e),
        e.children
      }
      ),
      (l.bottom || l.top) && (n = l.bottom || l.top,
      r = e.y + (l.bottom ? e.height : 0) + (l.bottom ? -10 : 10),
      o = l.bottom ? 's' : 'n',
      i = l.top > 0 || l.bottom < 0 ? -n : n,
      a = s.calculateAdjustments(u, 'y', i, r),
      s.makeSpace(a.movingShapes, a.resizingShapes, {
        x: 0,
        y: n
      }, o)),
      (l.left || l.right) && (n = l.right || l.left,
      r = e.x + (l.right ? e.width : 0) + (l.right ? -10 : 100),
      o = l.right ? 'e' : 'w',
      i = l.left > 0 || l.right < 0 ? -n : n,
      a = s.calculateAdjustments(d, 'x', i, r),
      s.makeSpace(a.movingShapes, a.resizingShapes, {
        x: n,
        y: 0
      }, o))
    }

    const Jg = 'flowNodeRef'
    const Xg = 'lanes'
    function Zg (e) {
      this._elementRegistry = e
    }
    function ey (e) {
      this._moddle = e
    }
    Zg.$inject = ['elementRegistry'],
    Zg.prototype._computeUpdates = function (e, t) {
      const n = []
      const r = []
      const o = {}
      const i = []
      function a (e) {
        n.indexOf(e) === -1 && (i.push(e),
        n.push(e))
      }
      return t.forEach(function (e) {
        const t = hf(e)
        if (t && n.indexOf(t) === -1) {
          const r = t.children.filter(function (e) {
            return Pi(e, 'bpmn:FlowNode')
          }
          )
          r.forEach(a),
          n.push(t)
        }
      }
      ),
      e.forEach(a),
      i.forEach(function (e) {
        const t = e.businessObject
        const n = t.get(Xg).slice()
        const i = (function (e) {
          if (!e.parent) { return [] }
          const t = (function (e) {
            const t = hf(e)
            return o[t.id] || (o[t.id] = df(t)),
            o[t.id]
          }(e))
          return t.filter(function (t) {
            return n = e,
            r = xr(t),
            o = n.x + n.width / 2,
            i = n.y + n.height / 2,
            o > r.left && o < r.right && i > r.top && i < r.bottom
            let n, r, o, i
          }
          ).map(function (e) {
            return e.businessObject
          }
          )
        }(e))
        r.push({
          flowNode: t,
          remove: n,
          add: i
        })
      }
      ),
      t.forEach(function (e) {
        const t = e.businessObject
        e.parent || t.get(Jg).forEach(function (e) {
          r.push({
            flowNode: e,
            remove: [t],
            add: []
          })
        }
        )
      }
      ),
      r
    }
    ,
    Zg.prototype.execute = function (e) {
      let t = e.updates
      return t || (t = e.updates = this._computeUpdates(e.flowNodeShapes, e.laneShapes)),
      t.forEach(function (e) {
        const t = e.flowNode
        const n = t.get(Xg)
        e.remove.forEach(function (e) {
          Sn(n, e),
          Sn(e.get(Jg), t)
        }
        ),
        e.add.forEach(function (e) {
          kn(n, e),
          kn(e.get(Jg), t)
        }
        )
      }
      ),
      []
    }
    ,
    Zg.prototype.revert = function (e) {
      return e.updates.forEach(function (e) {
        const t = e.flowNode
        const n = t.get(Xg)
        e.add.forEach(function (e) {
          Sn(n, e),
          Sn(e.get(Jg), t)
        }
        ),
        e.remove.forEach(function (e) {
          kn(n, e),
          kn(e.get(Jg), t)
        }
        )
      }
      ),
      []
    }
    ,
    ey.$inject = ['moddle'],
    ey.prototype.execute = function (e) {
      const t = this._moddle.ids
      const n = e.id
      const r = e.element
      return e.claiming ? t.claim(n, r) : t.unclaim(n),
      []
    }
    ,
    ey.prototype.revert = function (e) {
      const t = this._moddle.ids
      const n = e.id
      const r = e.element
      return e.claiming ? t.unclaim(n) : t.claim(n, r),
      []
    }

    const ty = {
      fill: void 0,
      stroke: void 0
    }
    function ny (e) {
      this._commandStack = e,
      this._normalizeColor = function (e) {
        if (e) {
          if (F(e)) {
            const t = (function (e) {
              const t = document.createElement('canvas').getContext('2d')
              return t.fillStyle = 'transparent',
              t.fillStyle = e,
              /^#[0-9a-fA-F]{6}$/.test(t.fillStyle) ? t.fillStyle : null
            }(e))
            if (t) { return t }
          }
          throw new Error('invalid color value: ' + e)
        }
      }
    }
    ny.$inject = ['commandStack'],
    ny.prototype.postExecute = function (e) {
      const t = e.elements
      const n = e.colors || ty
      const r = this
      const o = {}
      'fill' in n && le(o, {
        'background-color': this._normalizeColor(n.fill)
      }),
      'stroke' in n && le(o, {
        'border-color': this._normalizeColor(n.stroke)
      }),
      G(t, function (e) {
        const t = yr(e) ? pe(o, ['border-color']) : o
        const n = Ri(e)
        if ((function (e) {
          'border-color' in e && (e.stroke = e['border-color']),
          'background-color' in e && (e.fill = e['background-color'])
        }(t)),
        br(e)) {
          r._commandStack.execute('element.updateModdleProperties', {
            element: e,
            moddleElement: n.label,
            properties: {
              color: o['border-color']
            }
          })
        } else {
          if (!Oi(n, ['bpmndi:BPMNEdge', 'bpmndi:BPMNShape'])) { return }
          r._commandStack.execute('element.updateProperties', {
            element: e,
            properties: {
              di: t
            }
          })
        }
      }
      )
    }

    const ry = {
      width: 0,
      height: 0
    }
    function oy (e, t, n) {
      function r (e, t) {
        const n = e.label || e
        const r = e.labelTarget || e
        return (function (e, t) {
          const n = e.businessObject
          const r = ca(n)
          r && (r === 'categoryValueRef' ? n.categoryValueRef.value = t : n[r] = t)
        }(n, t)),
        [n, r]
      }
      this.preExecute = function (t) {
        const n = t.element
        const r = n.businessObject
        const o = t.newLabel
        if (!br(n) && ia(n) && !aa(n) && !iy(o)) {
          let i = sa(n)
          i = {
            x: i.x,
            y: i.y + 7
          },
          e.createLabel(n, i, {
            id: r.id + '_label',
            businessObject: r,
            di: n.di
          })
        }
      }
      ,
      this.execute = function (e) {
        return e.oldLabel = la(e.element),
        r(e.element, e.newLabel)
      }
      ,
      this.revert = function (e) {
        return r(e.element, e.oldLabel)
      }
      ,
      this.postExecute = function (n) {
        const r = n.element
        const o = r.label || r
        const i = n.newLabel
        let a = n.newBounds
        const s = n.hints || {}
        if (br(o) || Pi(o, 'bpmn:TextAnnotation')) {
          if (br(o) && iy(i)) {
            !1 !== s.removeShape && e.removeShape(o, {
              unsetLabel: !1
            })
          } else {
            const c = la(r)
            void 0 === a && (a = t.getExternalLabelBounds(o, c)),
            a && e.resizeShape(o, a, ry)
          }
        }
      }
    }
    function iy (e) {
      return !e || !e.trim()
    }
    function ay (e, t, n, r) {
      Ig.call(this, e, t, n),
      this._bpmnRules = r
    }
    function sy () {}
    oy.$inject = ['modeling', 'textRenderer', 'bpmnFactory'],
    w(ay, Ig),
    ay.$inject = ['eventBus', 'elementFactory', 'commandStack', 'bpmnRules'],
    ay.prototype.getHandlers = function () {
      const e = Ig.prototype.getHandlers.call(this)
      return e['element.updateModdleProperties'] = Lg,
      e['element.updateProperties'] = qg,
      e['canvas.updateRoot'] = Vg,
      e['lane.add'] = Qg,
      e['lane.resize'] = Kg,
      e['lane.split'] = Yg,
      e['lane.updateRefs'] = Zg,
      e['id.updateClaim'] = ey,
      e['element.setColor'] = ny,
      e['element.updateLabel'] = oy,
      e
    }
    ,
    ay.prototype.updateLabel = function (e, t, n, r) {
      this._commandStack.execute('element.updateLabel', {
        element: e,
        newLabel: t,
        newBounds: n,
        hints: r || {}
      })
    }
    ,
    ay.prototype.connect = function (e, t, n, r) {
      const o = this._bpmnRules
      if (n || (n = o.canConnect(e, t)),
      n) { return this.createConnection(e, t, n, e.parent, r) }
    }
    ,
    ay.prototype.updateModdleProperties = function (e, t, n) {
      this._commandStack.execute('element.updateModdleProperties', {
        element: e,
        moddleElement: t,
        properties: n
      })
    }
    ,
    ay.prototype.updateProperties = function (e, t) {
      this._commandStack.execute('element.updateProperties', {
        element: e,
        properties: t
      })
    }
    ,
    ay.prototype.resizeLane = function (e, t, n) {
      this._commandStack.execute('lane.resize', {
        shape: e,
        newBounds: t,
        balanced: n
      })
    }
    ,
    ay.prototype.addLane = function (e, t) {
      const n = {
        shape: e,
        location: t
      }
      return this._commandStack.execute('lane.add', n),
      n.newLane
    }
    ,
    ay.prototype.splitLane = function (e, t) {
      this._commandStack.execute('lane.split', {
        shape: e,
        count: t
      })
    }
    ,
    ay.prototype.makeCollaboration = function () {
      const e = this._create('root', {
        type: 'bpmn:Collaboration'
      })
      const t = {
        newRoot: e
      }
      return this._commandStack.execute('canvas.updateRoot', t),
      e
    }
    ,
    ay.prototype.makeProcess = function () {
      const e = {
        newRoot: this._create('root', {
          type: 'bpmn:Process'
        })
      }
      this._commandStack.execute('canvas.updateRoot', e)
    }
    ,
    ay.prototype.updateLaneRefs = function (e, t) {
      this._commandStack.execute('lane.updateRefs', {
        flowNodeShapes: e,
        laneShapes: t
      })
    }
    ,
    ay.prototype.claimId = function (e, t) {
      this._commandStack.execute('id.updateClaim', {
        id: e,
        element: t,
        claiming: !0
      })
    }
    ,
    ay.prototype.unclaimId = function (e, t) {
      this._commandStack.execute('id.updateClaim', {
        id: e,
        element: t
      })
    }
    ,
    ay.prototype.setColor = function (e, t) {
      e.length || (e = [e]),
      this._commandStack.execute('element.setColor', {
        elements: e,
        colors: t
      })
    }
    ,
    sy.prototype.layoutConnection = function (e, t) {
      return [(t = t || {}).connectionStart || _r(t.source || e.source), t.connectionEnd || _r(t.target || e.target)]
    }

    const cy = 20
    const ly = 5
    const py = Math.round
    const uy = 20
    const dy = {
      'h:h': 20,
      'v:v': 20,
      'h:v': -10,
      'v:h': -10
    }
    function fy (e, t, n) {
      let r; let o; let i; const a = Cr(t, e, ly); const s = n.split(':')[0]; const c = py((t.x - e.x) / 2 + e.x); const l = py((t.y - e.y) / 2 + e.y); const p = (i = a,
      {
        t: /top/,
        r: /right/,
        b: /bottom/,
        l: /left/,
        h: /left|right/,
        v: /top|bottom/
      }[s].test(i)); const u = /h|r|l/.test(s); let d = !1; let f = !1
      return p
        ? (r = u
            ? {
                x: c,
                y: e.y
              }
            : {
                x: e.x,
                y: l
              },
          o = u ? 'h:h' : 'v:v')
        : (d = (function (e, t) {
            return !{
              t: /top/,
              r: /right/,
              b: /bottom/,
              l: /left/,
              h: /./,
              v: /./
            }[t].test(e)
          }(a, s)),
          o = u ? 'h:v' : 'v:h',
          d
            ? u
              ? (f = l === e.y,
                r = {
                  x: e.x + cy * (/l/.test(s) ? -1 : 1),
                  y: f ? l + cy : l
                })
              : r = {
                x: (f = c === e.x) ? c + cy : c,
                y: e.y + cy * (/t/.test(s) ? -1 : 1)
              }
            : r = {
              x: c,
              y: l
            }),
      {
        waypoints: my(e, r, o).concat(r),
        directions: o,
        turnNextDirections: f
      }
    }
    function hy (e) {
      return e.split(':').reverse().join(':')
    }
    function my (e, t, n) {
      if (!(function (e) {
        return e && /^h|v|t|r|b|l:h|v|t|r|b|l$/.test(e)
      }(n = n || 'h:h'))) { throw new Error('unknown directions: <' + n + '>: must be specified as <start>:<end> with start/end in { h,v,t,r,b,l }') }
      if (by(n)) {
        const r = (function (e, t, n) {
          return fy(e, t, n)
        }(e, t, n))
        const o = (function (e, t, n) {
          const r = fy(t, e, hy(n))
          return {
            waypoints: r.waypoints.slice().reverse(),
            directions: hy(r.directions),
            turnNextDirections: r.turnNextDirections
          }
        }(e, t, n))
        const i = (function (e, t) {
          let n = e.directions.split(':')[1]
          let r = t.directions.split(':')[0]
          e.turnNextDirections && (n = n == 'h' ? 'v' : 'h'),
          t.turnNextDirections && (r = r == 'h' ? 'v' : 'h')
          const o = n + ':' + r
          return {
            waypoints: my(e.waypoints[e.waypoints.length - 1], t.waypoints[0], o),
            directions: o
          }
        }(r, o))
        return [].concat(r.waypoints, i.waypoints, o.waypoints)
      }
      return (function (e, t, n) {
        const r = py((t.x - e.x) / 2 + e.x)
        const o = py((t.y - e.y) / 2 + e.y)
        if (n === 'h:v') {
          return [{
            x: t.x,
            y: e.y
          }]
        }
        if (n === 'v:h') {
          return [{
            x: e.x,
            y: t.y
          }]
        }
        if (n === 'h:h') {
          return [{
            x: r,
            y: e.y
          }, {
            x: r,
            y: t.y
          }]
        }
        if (n === 'v:v') {
          return [{
            x: e.x,
            y: o
          }, {
            x: t.x,
            y: o
          }]
        }
        throw new Error('invalid directions: can only handle varians of [hv]:[hv]')
      }(e, t, n))
    }
    function vy (e, t, n, r, o) {
      const i = (function (e, t) {
        if (T(e)) { return [] }
        !(function (e) {
          if (!M(e)) { throw new Error('must supply array') }
        }(e))
        const n = oe(t)
        return e.filter(function (e, t) {
          return !n(e, t)
        }
        )
      }(o && o.preferredLayouts || [], 'straight'))[0] || 'h:h'
      const a = Cr(e, t, dy[i] || 0)
      const s = (function (e, t) {
        if (by(t)) { return t }
        switch (e) {
          case 'intersect':
            return 't:t'
          case 'top':
          case 'bottom':
            return 'v:v'
          case 'left':
          case 'right':
            return 'h:h'
          default:
            return t
        }
      }(a, i))
      n = n || _r(e),
      r = r || _r(t)
      const c = s.split(':')
      const l = Ay(n, e, c[0], (function (e) {
        return {
          top: 'bottom',
          bottom: 'top',
          left: 'right',
          right: 'left',
          'top-left': 'bottom-right',
          'bottom-right': 'top-left',
          'top-right': 'bottom-left',
          'bottom-left': 'top-right'
        }[e]
      }(a)))
      return (function (e, t, n) {
        const r = my(e, t, n)
        return r.unshift(e),
        r.push(t),
        Ey(r)
      }(l, Ay(r, t, c[1], a), s))
    }
    function gy (e, t, n) {
      return (function (e, t, n) {
        return e >= t && e <= n
      }(t[e], n[e], n[e] + n[{
        x: 'width',
        y: 'height'
      }[e]]))
    }
    function yy (e, t, n, r) {
      if (function (e) {
        return e.length < 3 || !(e.length > 4) && !!H(e, function (t, n) {
          const r = e[n - 1]
          return r && Dn(t, r) < 3
        }
        )
      }(r)) { return null }
      let o; const i = r[0]; let a = r.slice()
      return a[0] = n,
      a[1] = (function (e, t, n) {
        switch (Tn(t, e)) {
          case 'v':
            return {
              x: n.x,
              y: e.y
            }
          case 'h':
            return {
              x: e.x,
              y: n.y
            }
        }
        return {
          x: e.x,
          y: e.y
        }
      }(a[1], i, n)),
      o = (function (e, t, n) {
        let r
        for (r = e.length - 2; r !== 0; r--) {
          if (Nn(e[r], t, uy) || Nn(e[r], n, uy)) { return e.slice(r) }
        }
        return e
      }(a, e, t)),
      o !== a && (a = yy(e, t, n, o)),
      a && Tn(a) ? null : a
    }
    function by (e) {
      return e && /t|r|b|l/.test(e)
    }
    function Ay (e, t, n, r) {
      if (n === 'h' && (n = /left/.test(r) ? 'l' : 'r'),
      n === 'v' && (n = /top/.test(r) ? 't' : 'b'),
      n === 't') {
        return {
          original: e,
          x: e.x,
          y: t.y
        }
      }
      if (n === 'r') {
        return {
          original: e,
          x: t.x + t.width,
          y: e.y
        }
      }
      if (n === 'b') {
        return {
          original: e,
          x: e.x,
          y: t.y + t.height
        }
      }
      if (n === 'l') {
        return {
          original: e,
          x: t.x,
          y: e.y
        }
      }
      throw new Error('unexpected dockingDirection: <' + n + '>')
    }
    function Ey (e) {
      return e.reduce(function (t, n, r) {
        return Pn(t[t.length - 1], e[r + 1], n, 0) || t.push(n),
        t
      }
      , [])
    }
    const xy = 40
    const wy = {
      top: 'bottom',
      'top-right': 'bottom-left',
      'top-left': 'bottom-right',
      right: 'left',
      bottom: 'top',
      'bottom-right': 'top-left',
      'bottom-left': 'top-right',
      left: 'right'
    }
    const _y = {
      top: 't',
      right: 'r',
      bottom: 'b',
      left: 'l'
    }
    function Cy () {}
    function Sy (e, t) {
      return Pi(t, 'bpmn:Participant') ? 'source' : Pi(e, 'bpmn:Participant') ? 'target' : Dy(t) ? 'source' : Dy(e) || Pi(t, 'bpmn:Event') ? 'target' : Pi(e, 'bpmn:Event') ? 'source' : null
    }
    function ky (e) {
      return Dy(e) ? 'target' : 'source'
    }
    function jy (e, t) {
      return e ? e.original || e : _r(t)
    }
    function By (e, t) {
      return Pi(t, 'bpmn:Activity') && Pi(e, 'bpmn:BoundaryEvent') && t.businessObject.isForCompensation
    }
    function Dy (e) {
      return Pi(e, 'bpmn:SubProcess') && Zi(e)
    }
    function Py (e, t) {
      return e === t
    }
    function Oy (e) {
      const t = /right|left/.exec(e)
      return t && t[0]
    }
    function Ty (e) {
      const t = /top|bottom/.exec(e)
      return t && t[0]
    }
    function Ry (e) {
      return e === 'right' || e === 'left'
    }
    function Ny (e, t) {
      const n = t.waypoints
      const r = n && n.length && Cr(n[0], e)
      return r === 'top' ? ['t:r'] : r === 'right' ? ['r:b'] : r === 'left' ? ['l:t'] : ['b:l']
    }
    function My (e, t, n) {
      let r; let o; let i; let a; const s = _r(e); const c = _r(t); const l = (a = (i = e).host,
      Cr(_r(i), a, -10)); const p = Py(e.host, t); const u = ['top', 'right', 'bottom', 'left'].indexOf(l) !== -1; const d = Cr(c, s, {
        x: e.width / 2 + t.width / 2,
        y: e.height / 2 + t.height / 2
      })
      return p
        ? (function (e, t, n, r, o) {
            const i = t ? e : Ty(e)
            return [_y[i] + ':' + (t ? Ry(e) ? Iy('y', n, r, o) ? 'h' : 'b' : Iy('x', n, r, o) ? 'v' : 'l' : 'v')]
          }(l, u, e, t, n))
        : (r = (function (e, t, n) {
            return n
              ? _y[e]
              : Py(Ty(e), Ty(t)) || (function (e, t) {
                return wy[e] === t
              }(Oy(e), Oy(t)))
                ? _y[Ty(e)]
                : _y[Oy(e)]
          }(l, d, u)),
          o = (function (e, t, n) {
            return n
              ? Ry(e)
                ? (function (e, t) {
                    const n = Oy(e)
                    const r = wy[n]
                    return t.indexOf(r) !== -1
                  }(e, t)) || Py(e, t)
                    ? 'h'
                    : 'v'
                : (function (e, t) {
                    const n = Ty(e)
                    const r = wy[n]
                    return t.indexOf(r) !== -1
                  }(e, t)) || Py(e, t)
                    ? 'v'
                    : 'h'
              : Ry(t) || Py(Ty(e), Ty(t)) && Oy(t) ? 'h' : 'v'
          }(l, d, u)),
          [r + ':' + o])
    }
    function Iy (e, t, n, r) {
      const o = xy
      return !(Ly(e, r, n, o) || Ly(e, r, {
        x: n.x + n.width,
        y: n.y + n.height
      }, o) || Ly(e, r, _r(t), o))
    }
    function Ly (e, t, n, r) {
      return Math.abs(t[e] - n[e]) < r
    }
    function zy (e) {
      return le({
        original: e.point.original || e.point
      }, e.actual)
    }
    function Fy (e, t) {
      this._elementRegistry = e,
      this._graphicsFactory = t
    }
    w(Cy, sy),
    Cy.prototype.layoutConnection = function (e, t) {
      t || (t = {})
      let n; let r; const o = t.source || e.source; const i = t.target || e.target; const a = t.waypoints || e.waypoints; let s = t.connectionStart; let c = t.connectionEnd
      return s || (s = jy(a && a[0], o)),
      c || (c = jy(a && a[a.length - 1], i)),
      (Pi(e, 'bpmn:Association') || Pi(e, 'bpmn:DataAssociation')) && a && !By(o, i)
        ? [].concat([s], a.slice(1, -1), [c])
        : (Pi(e, 'bpmn:MessageFlow')
            ? n = (function (e, t) {
              return {
                preferredLayouts: ['straight', 'v:v'],
                preserveDocking: Sy(e, t)
              }
            }(o, i))
            : (Pi(e, 'bpmn:SequenceFlow') || By(o, i)) && (n = o === i
                ? {
                    preferredLayouts: Ny(o, e)
                  }
                : Pi(o, 'bpmn:BoundaryEvent')
                  ? {
                      preferredLayouts: My(o, i, c)
                    }
                  : Dy(o) || Dy(i)
                    ? (function (e) {
                        return {
                          preferredLayouts: ['straight', 'h:h'],
                          preserveDocking: ky(e)
                        }
                      }(o))
                    : Pi(o, 'bpmn:Gateway')
                      ? {
                          preferredLayouts: ['v:h']
                        }
                      : Pi(i, 'bpmn:Gateway')
                        ? {
                            preferredLayouts: ['h:v']
                          }
                        : {
                            preferredLayouts: ['h:h']
                          }),
          n && (r = Ey(function (e, t, n, r, o, i) {
            let a
            return M(n) && (o = n,
            i = r,
            n = _r(e),
            r = _r(t)),
            o = o || [],
            a = (i = le({
              preferredLayouts: []
            }, i)).preferredLayouts.indexOf('straight') !== -1 && (function (e, t, n, r, o) {
              let i; let a; const s = {}
              return a = Cr(e, t),
              /^(top|bottom|left|right)$/.test(a)
                ? (/top|bottom/.test(a) && (i = 'x'),
                  /left|right/.test(a) && (i = 'y'),
                  o.preserveDocking === 'target'
                    ? gy(i, r, e)
                      ? (s[i] = r[i],
                        [{
                          x: void 0 !== s.x ? s.x : n.x,
                          y: void 0 !== s.y ? s.y : n.y,
                          original: {
                            x: void 0 !== s.x ? s.x : n.x,
                            y: void 0 !== s.y ? s.y : n.y
                          }
                        }, {
                          x: r.x,
                          y: r.y
                        }])
                      : null
                    : gy(i, n, t)
                      ? (s[i] = n[i],
                        [{
                          x: n.x,
                          y: n.y
                        }, {
                          x: void 0 !== s.x ? s.x : r.x,
                          y: void 0 !== s.y ? s.y : r.y,
                          original: {
                            x: void 0 !== s.x ? s.x : r.x,
                            y: void 0 !== s.y ? s.y : r.y
                          }
                        }])
                      : null)
                : null
            }(e, t, n, r, i)),
            a || (a = i.connectionEnd && (function (e, t, n, r) {
              let o = r.slice().reverse()
              return (o = yy(e, t, n, o)) ? o.reverse() : null
            }(t, e, r, o)),
            a || (a = i.connectionStart && yy(e, t, n, o)) || (!i.connectionStart && !i.connectionEnd && o && o.length ? o : vy(e, t, n, r, i)))
          }(o, i, s, c, a, n = le(n, t)))),
          r || [s, c])
    }
    ,
    Fy.$inject = ['elementRegistry', 'graphicsFactory'],
    Fy.prototype.getCroppedWaypoints = function (e, t, n) {
      t = t || e.source,
      n = n || e.target
      const r = this.getDockingPoint(e, t, !0)
      const o = this.getDockingPoint(e, n)
      const i = e.waypoints.slice(r.idx + 1, o.idx)
      return i.unshift(zy(r)),
      i.push(zy(o)),
      i
    }
    ,
    Fy.prototype.getDockingPoint = function (e, t, n) {
      let r; let o; const i = e.waypoints
      return {
        point: o = i[r = n ? 0 : i.length - 1],
        actual: this._getIntersection(t, e, n) || o,
        idx: r
      }
    }
    ,
    Fy.prototype._getIntersection = function (e, t, n) {
      return Sr(this._getShapePath(e), this._getConnectionPath(t), n)
    }
    ,
    Fy.prototype._getConnectionPath = function (e) {
      return this._graphicsFactory.getConnectionPath(e)
    }
    ,
    Fy.prototype._getShapePath = function (e) {
      return this._graphicsFactory.getShapePath(e)
    }
    ,
    Fy.prototype._getGfx = function (e) {
      return this._elementRegistry.getGraphics(e)
    }

    const $y = {
      __init__: ['modeling', 'bpmnUpdater'],
      __depends__: [Vh, Sm, jm, Pm, fv, Lv, Hv, Uv, us, As, Mv],
      bpmnFactory: ['type', Vv],
      bpmnUpdater: ['type', Qv],
      elementFactory: ['type', Kv],
      modeling: ['type', ay],
      layouter: ['type', Cy],
      connectionDocking: ['type', Fy]
    }
    const Hy = Math.round
    function qy (e, t, n, r, o, i) {
      this._complexPreview = e,
      this._connectionDocking = t,
      this._elementFactory = n,
      this._eventBus = r,
      this._layouter = o,
      this._rules = i
    }
    qy.prototype.create = function (e, t, n) {
      const r = this._complexPreview
      const o = this._connectionDocking
      const i = this._elementFactory
      const a = this._eventBus
      const s = this._layouter
      const c = this._rules
      const l = i.createShape(le({
        type: t
      }, n))
      const p = a.fire('autoPlace', {
        source: e,
        shape: l
      })
      if (p) {
        le(l, {
          x: p.x - Hy(l.width / 2),
          y: p.y - Hy(l.height / 2)
        })
        const u = c.allowed('connection.create', {
          source: e,
          target: l,
          hints: {
            targetParent: e.parent
          }
        })
        let d = null
        u && ((d = i.createConnection(u)).waypoints = s.layoutConnection(d, {
          source: e,
          target: l
        }),
        d.waypoints = o.getCroppedWaypoints(d, e, l)),
        r.create({
          created: [l, d].filter(function (e) {
            return !N(e)
          }
          )
        })
      }
    }
    ,
    qy.prototype.cleanUp = function () {
      this._complexPreview.cleanUp()
    }
    ,
    qy.$inject = ['complexPreview', 'connectionDocking', 'elementFactory', 'eventBus', 'layouter', 'rules']
    const Wy = {
      __depends__: [Xp, kd, $y],
      __init__: ['appendPreview'],
      appendPreview: ['type', qy]
    }
    function Gy (e, t) {
      return t.forEach(function (t) {
        t && typeof t !== 'string' && !Array.isArray(t) && Object.keys(t).forEach(function (n) {
          if (n !== 'default' && !(n in e)) {
            const r = Object.getOwnPropertyDescriptor(t, n)
            Object.defineProperty(e, n, r.get
              ? r
              : {
                  enumerable: !0,
                  get: function () {
                    return t[n]
                  }
                })
          }
        }
        )
      }
      ),
      Object.freeze(e)
    }
    Object.prototype.toString,
    Object.prototype.hasOwnProperty
    const Uy = Object.prototype.toString
    function Vy (e) {
      if (!e || !e.nodeType) { throw new Error('A DOM element reference is required') }
      this.el = e,
      this.list = e.classList
    }
    Vy.prototype.add = function (e) {
      return this.list.add(e),
      this
    }
    ,
    Vy.prototype.remove = function (e) {
      return Uy.call(e) == '[object RegExp]'
        ? this.removeMatching(e)
        : (this.list.remove(e),
          this)
    }
    ,
    Vy.prototype.removeMatching = function (e) {
      for (let t = this.array(), n = 0; n < t.length; n++) { e.test(t[n]) && this.remove(t[n]) }
      return this
    }
    ,
    Vy.prototype.toggle = function (e, t) {
      return void 0 !== t ? t !== this.list.toggle(e, t) && this.list.toggle(e) : this.list.toggle(e),
      this
    }
    ,
    Vy.prototype.array = function () {
      return Array.from(this.list)
    }
    ,
    Vy.prototype.has = Vy.prototype.contains = function (e) {
      return this.list.contains(e)
    }

    let Qy; let Yy; let Ky; const Jy = {}
    function Xy () {
      Qy = window.addEventListener ? 'addEventListener' : 'attachEvent',
      Yy = window.removeEventListener ? 'removeEventListener' : 'detachEvent',
      Ky = Qy !== 'addEventListener' ? 'on' : ''
    }
    let Zy; const eb = Jy.bind = function (e, t, n, r) {
      return Qy || Xy(),
      e[Qy](Ky + t, n, r || !1),
      n
    }
    const tb = Jy.unbind = function (e, t, n, r) {
      return Yy || Xy(),
      e[Yy](Ky + t, n, r || !1),
      n
    }
    const nb = Gy({
      __proto__: null,
      bind: eb,
      unbind: tb,
      default: Jy
    }, [Jy]); let rb = !1
    typeof document !== 'undefined' && ((Zy = document.createElement('div')).innerHTML = '  <link/><table></table><a href="/a">a</a><input type="checkbox"/>',
    rb = !Zy.getElementsByTagName('link').length,
    Zy = void 0)
    const ob = {
      legend: [1, '<fieldset>', '</fieldset>'],
      tr: [2, '<table><tbody>', '</tbody></table>'],
      col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
      _default: rb ? [1, 'X<div>', '</div>'] : [0, '', '']
    }
    ob.td = ob.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'],
    ob.option = ob.optgroup = [1, '<select multiple="multiple">', '</select>'],
    ob.thead = ob.tbody = ob.colgroup = ob.caption = ob.tfoot = [1, '<table>', '</table>'],
    ob.polyline = ob.ellipse = ob.polygon = ob.circle = ob.text = ob.line = ob.path = ob.rect = ob.g = [1, '<svg xmlns="http://www.w3.org/2000/svg" version="1.1">', '</svg>']
    const ib = function (e, t) {
      if (typeof e !== 'string') { throw new TypeError('String expected') }
      t || (t = document)
      const n = /<([\w:]+)/.exec(e)
      if (!n) { return t.createTextNode(e) }
      e = e.replace(/^\s+|\s+$/g, '')
      const r = n[1]
      if (r == 'body') {
        return (o = t.createElement('html')).innerHTML = e,
        o.removeChild(o.lastChild)
      }
      let o; const i = Object.prototype.hasOwnProperty.call(ob, r) ? ob[r] : ob._default; let a = i[0]; const s = i[1]; const c = i[2]
      for ((o = t.createElement('div')).innerHTML = s + e + c; a--;) { o = o.lastChild }
      if (o.firstChild == o.lastChild) { return o.removeChild(o.firstChild) }
      for (var l = t.createDocumentFragment(); o.firstChild;) { l.appendChild(o.removeChild(o.firstChild)) }
      return l
    }
    function ab (e) {
      e.parentNode && e.parentNode.removeChild(e)
    }
    const sb = Math.min
    const cb = Math.max
    function lb (e) {
      e.preventDefault()
    }
    function pb (e) {
      e.stopPropagation()
    }
    function ub (e) {
      this.container = e.container,
      this.parent = ib('<div class="djs-direct-editing-parent"><div class="djs-direct-editing-content" contenteditable="true"></div></div>'),
      this.content = ('[contenteditable]',
      (this.parent || document).querySelector('[contenteditable]')),
      this.keyHandler = e.keyHandler || function () {}
      ,
      this.resizeHandler = e.resizeHandler || function () {}
      ,
      this.autoResize = ce(this.autoResize, this),
      this.handlePaste = ce(this.handlePaste, this)
    }
    function db (e, t) {
      this._eventBus = e,
      this._providers = [],
      this._textbox = new ub({
        container: t.getContainer(),
        keyHandler: ce(this._handleKey, this),
        resizeHandler: ce(this._handleResize, this)
      })
    }
    ub.prototype.create = function (e, t, n, r) {
      const o = this.parent
      const i = this.content
      const a = this.container
      r = this.options = r || {}
      const s = pe(t = this.style = t || {}, ['width', 'height', 'maxWidth', 'maxHeight', 'minWidth', 'minHeight', 'left', 'top', 'backgroundColor', 'position', 'overflow', 'border', 'wordWrap', 'textAlign', 'outline', 'transform'])
      le(o.style, {
        width: e.width + 'px',
        height: e.height + 'px',
        maxWidth: e.maxWidth + 'px',
        maxHeight: e.maxHeight + 'px',
        minWidth: e.minWidth + 'px',
        minHeight: e.minHeight + 'px',
        left: e.x + 'px',
        top: e.y + 'px',
        backgroundColor: '#ffffff',
        position: 'absolute',
        overflow: 'visible',
        border: '1px solid #ccc',
        boxSizing: 'border-box',
        wordWrap: 'normal',
        textAlign: 'center',
        outline: 'none'
      }, s)
      const c = pe(t, ['fontFamily', 'fontSize', 'fontWeight', 'lineHeight', 'padding', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft'])
      return le(i.style, {
        boxSizing: 'border-box',
        width: '100%',
        outline: 'none',
        wordWrap: 'break-word'
      }, c),
      r.centerVertically && le(i.style, {
        position: 'absolute',
        top: '50%',
        transform: 'translate(0, -50%)'
      }, c),
      i.innerText = n,
      nb.bind(i, 'keydown', this.keyHandler),
      nb.bind(i, 'mousedown', pb),
      nb.bind(i, 'paste', this.handlePaste),
      r.autoResize && nb.bind(i, 'input', this.autoResize),
      r.resizable && this.resizable(t),
      a.appendChild(o),
      this.setSelection(i.lastChild, i.lastChild && i.lastChild.length),
      o
    }
    ,
    ub.prototype.handlePaste = function (e) {
      let t; const n = this.options; const r = this.style
      if (e.preventDefault(),
      t = e.clipboardData ? e.clipboardData.getData('text/plain') : window.clipboardData.getData('Text'),
      this.insertText(t),
      n.autoResize) {
        const o = this.autoResize(r)
        o && this.resizeHandler(o)
      }
    }
    ,
    ub.prototype.insertText = function (e) {
      e = e.replace(/\r\n|\r|\n/g, '\n'),
      document.execCommand('insertText', !1, e) || this._insertTextIE(e)
    }
    ,
    ub.prototype._insertTextIE = function (e) {
      let t; let n; let r; const o = this.getSelection(); const i = o.startContainer; const a = o.endContainer; const s = o.startOffset; const c = o.endOffset; const l = o.commonAncestorContainer; const p = (t = l.childNodes,
      [].slice.call(t))
      if (l.nodeType === Node.TEXT_NODE) {
        const u = i.textContent
        i.textContent = u.substring(0, s) + e + u.substring(c),
        n = i,
        r = s + e.length
      } else if (i === this.content && a === this.content) {
        const d = document.createTextNode(e)
        this.content.insertBefore(d, p[s]),
        n = d,
        r = d.textContent.length
      } else {
        const f = p.indexOf(i)
        const h = p.indexOf(a)
        p.forEach(function (t, n) {
          n === f ? t.textContent = i.textContent.substring(0, s) + e + a.textContent.substring(c) : n > f && n <= h && ab(t)
        }
        ),
        n = i,
        r = s + e.length
      }
      n && void 0 !== r && setTimeout(function () {
        self.setSelection(n, r)
      }
      )
    }
    ,
    ub.prototype.autoResize = function () {
      const e = this.parent
      const t = this.content
      const n = parseInt(this.style.fontSize) || 12
      if (t.scrollHeight > e.offsetHeight || t.scrollHeight < e.offsetHeight - n) {
        const r = e.getBoundingClientRect()
        const o = t.scrollHeight
        e.style.height = o + 'px',
        this.resizeHandler({
          width: r.width,
          height: r.height,
          dx: 0,
          dy: o - r.height
        })
      }
    }
    ,
    ub.prototype.resizable = function () {
      const e = this
      const t = this.parent
      let n = this.resizeHandle
      const r = parseInt(this.style.minWidth) || 0
      const o = parseInt(this.style.minHeight) || 0
      const i = parseInt(this.style.maxWidth) || 1 / 0
      const a = parseInt(this.style.maxHeight) || 1 / 0
      if (!n) {
        let s, c, l, p
        n = this.resizeHandle = ib('<div class="djs-direct-editing-resize-handle"></div>')
        const u = function (n) {
          lb(n),
          pb(n)
          const u = sb(cb(l + n.clientX - s, r), i)
          const d = sb(cb(p + n.clientY - c, o), a)
          t.style.width = u + 'px',
          t.style.height = d + 'px',
          e.resizeHandler({
            width: l,
            height: p,
            dx: n.clientX - s,
            dy: n.clientY - c
          })
        }
        const d = function e (t) {
          lb(t),
          pb(t),
          nb.unbind(document, 'mousemove', u, !1),
          nb.unbind(document, 'mouseup', e, !1)
        }
        nb.bind(n, 'mousedown', function (e) {
          lb(e),
          pb(e),
          s = e.clientX,
          c = e.clientY
          const n = t.getBoundingClientRect()
          l = n.width,
          p = n.height,
          nb.bind(document, 'mousemove', u),
          nb.bind(document, 'mouseup', d)
        }
        )
      }
      le(n.style, {
        position: 'absolute',
        bottom: '0px',
        right: '0px',
        cursor: 'nwse-resize',
        width: '0',
        height: '0',
        borderTop: (parseInt(this.style.fontSize) / 4 || 3) + 'px solid transparent',
        borderRight: (parseInt(this.style.fontSize) / 4 || 3) + 'px solid #ccc',
        borderBottom: (parseInt(this.style.fontSize) / 4 || 3) + 'px solid #ccc',
        borderLeft: (parseInt(this.style.fontSize) / 4 || 3) + 'px solid transparent'
      }),
      t.appendChild(n)
    }
    ,
    ub.prototype.destroy = function () {
      const e = this.parent
      const t = this.content
      const n = this.resizeHandle
      t.innerText = '',
      e.removeAttribute('style'),
      t.removeAttribute('style'),
      nb.unbind(t, 'keydown', this.keyHandler),
      nb.unbind(t, 'mousedown', pb),
      nb.unbind(t, 'input', this.autoResize),
      nb.unbind(t, 'paste', this.handlePaste),
      n && (n.removeAttribute('style'),
      ab(n)),
      ab(e)
    }
    ,
    ub.prototype.getValue = function () {
      return this.content.innerText.trim()
    }
    ,
    ub.prototype.getSelection = function () {
      return window.getSelection().getRangeAt(0)
    }
    ,
    ub.prototype.setSelection = function (e, t) {
      const n = document.createRange()
      e === null
        ? n.selectNodeContents(this.content)
        : (n.setStart(e, t),
          n.setEnd(e, t))
      const r = window.getSelection()
      r.removeAllRanges(),
      r.addRange(n)
    }
    ,
    db.$inject = ['eventBus', 'canvas'],
    db.prototype.registerProvider = function (e) {
      this._providers.push(e)
    }
    ,
    db.prototype.isActive = function (e) {
      return !(!this._active || e && this._active.element !== e)
    }
    ,
    db.prototype.cancel = function () {
      this._active && (this._fire('cancel'),
      this.close())
    }
    ,
    db.prototype._fire = function (e, t) {
      this._eventBus.fire('directEditing.' + e, t || {
        active: this._active
      })
    }
    ,
    db.prototype.close = function () {
      this._textbox.destroy(),
      this._fire('deactivate'),
      this._active = null,
      this.resizable = void 0
    }
    ,
    db.prototype.complete = function () {
      const e = this._active
      if (e) {
        let t; const n = e.context.bounds; const r = this.$textbox.getBoundingClientRect(); const o = this.getValue()
        o === e.context.text && r.height === n.height && r.width === n.width || (t = this._textbox.container.getBoundingClientRect(),
        e.provider.update(e.element, o, e.context.text, {
          x: r.left - t.left,
          y: r.top - t.top,
          width: r.width,
          height: r.height
        })),
        this._fire('complete'),
        this.close()
      }
    }
    ,
    db.prototype.getValue = function () {
      return this._textbox.getValue()
    }
    ,
    db.prototype._handleKey = function (e) {
      e.stopPropagation()
      const t = e.keyCode || e.charCode
      return t === 27
        ? (e.preventDefault(),
          this.cancel())
        : t !== 13 || e.shiftKey
          ? void 0
          : (e.preventDefault(),
            this.complete())
    }
    ,
    db.prototype._handleResize = function (e) {
      this._fire('resize', e)
    }
    ,
    db.prototype.activate = function (e) {
      let t
      this.isActive() && this.cancel()
      const n = H(this._providers, function (n) {
        return (t = n.activate(e)) ? n : null
      }
      )
      return t && (this.$textbox = this._textbox.create(t.bounds, t.style, t.text, t.options),
      this._active = {
        element: e,
        context: t,
        provider: n
      },
      t.options && t.options.resizable && (this.resizable = !0),
      this._fire('activate')),
      !!t
    }

    const fb = {
      __depends__: [ns],
      __init__: ['directEditing'],
      directEditing: ['type', db]
    }
    function hb (e) {
      return function (t) {
        const n = t.target
        const r = Ti(e)
        const o = r.eventDefinitions && r.eventDefinitions[0]
        const i = r.$type === n.type
        const a = (o && o.$type) === n.eventDefinitionType
        const s = !!n.triggeredByEvent == !!r.triggeredByEvent
        const c = void 0 === n.isExpanded || n.isExpanded === Zi(e)
        return !(i && a && s && c)
      }
    }
    const mb = [{
      label: 'Start event',
      actionName: 'replace-with-none-start',
      className: 'bpmn-icon-start-event-none',
      target: {
        type: 'bpmn:StartEvent'
      }
    }, {
      label: 'Intermediate throw event',
      actionName: 'replace-with-none-intermediate-throwing',
      className: 'bpmn-icon-intermediate-event-none',
      target: {
        type: 'bpmn:IntermediateThrowEvent'
      }
    }, {
      label: 'End event',
      actionName: 'replace-with-none-end',
      className: 'bpmn-icon-end-event-none',
      target: {
        type: 'bpmn:EndEvent'
      }
    }, {
      label: 'Message start event',
      actionName: 'replace-with-message-start',
      className: 'bpmn-icon-start-event-message',
      target: {
        type: 'bpmn:StartEvent',
        eventDefinitionType: 'bpmn:MessageEventDefinition'
      }
    }, {
      label: 'Timer start event',
      actionName: 'replace-with-timer-start',
      className: 'bpmn-icon-start-event-timer',
      target: {
        type: 'bpmn:StartEvent',
        eventDefinitionType: 'bpmn:TimerEventDefinition'
      }
    }, {
      label: 'Conditional start event',
      actionName: 'replace-with-conditional-start',
      className: 'bpmn-icon-start-event-condition',
      target: {
        type: 'bpmn:StartEvent',
        eventDefinitionType: 'bpmn:ConditionalEventDefinition'
      }
    }, {
      label: 'Signal start event',
      actionName: 'replace-with-signal-start',
      className: 'bpmn-icon-start-event-signal',
      target: {
        type: 'bpmn:StartEvent',
        eventDefinitionType: 'bpmn:SignalEventDefinition'
      }
    }]
    const vb = [{
      label: 'Start event',
      actionName: 'replace-with-none-start',
      className: 'bpmn-icon-start-event-none',
      target: {
        type: 'bpmn:StartEvent'
      }
    }, {
      label: 'Intermediate throw event',
      actionName: 'replace-with-none-intermediate-throwing',
      className: 'bpmn-icon-intermediate-event-none',
      target: {
        type: 'bpmn:IntermediateThrowEvent'
      }
    }, {
      label: 'End event',
      actionName: 'replace-with-none-end',
      className: 'bpmn-icon-end-event-none',
      target: {
        type: 'bpmn:EndEvent'
      }
    }]
    const gb = [{
      label: 'Start event',
      actionName: 'replace-with-none-start',
      className: 'bpmn-icon-start-event-none',
      target: {
        type: 'bpmn:StartEvent'
      }
    }, {
      label: 'Intermediate throw event',
      actionName: 'replace-with-none-intermediate-throw',
      className: 'bpmn-icon-intermediate-event-none',
      target: {
        type: 'bpmn:IntermediateThrowEvent'
      }
    }, {
      label: 'End event',
      actionName: 'replace-with-none-end',
      className: 'bpmn-icon-end-event-none',
      target: {
        type: 'bpmn:EndEvent'
      }
    }, {
      label: 'Message intermediate catch event',
      actionName: 'replace-with-message-intermediate-catch',
      className: 'bpmn-icon-intermediate-event-catch-message',
      target: {
        type: 'bpmn:IntermediateCatchEvent',
        eventDefinitionType: 'bpmn:MessageEventDefinition'
      }
    }, {
      label: 'Message intermediate throw event',
      actionName: 'replace-with-message-intermediate-throw',
      className: 'bpmn-icon-intermediate-event-throw-message',
      target: {
        type: 'bpmn:IntermediateThrowEvent',
        eventDefinitionType: 'bpmn:MessageEventDefinition'
      }
    }, {
      label: 'Timer intermediate catch event',
      actionName: 'replace-with-timer-intermediate-catch',
      className: 'bpmn-icon-intermediate-event-catch-timer',
      target: {
        type: 'bpmn:IntermediateCatchEvent',
        eventDefinitionType: 'bpmn:TimerEventDefinition'
      }
    }, {
      label: 'Escalation intermediate throw event',
      actionName: 'replace-with-escalation-intermediate-throw',
      className: 'bpmn-icon-intermediate-event-throw-escalation',
      target: {
        type: 'bpmn:IntermediateThrowEvent',
        eventDefinitionType: 'bpmn:EscalationEventDefinition'
      }
    }, {
      label: 'Conditional intermediate catch event',
      actionName: 'replace-with-conditional-intermediate-catch',
      className: 'bpmn-icon-intermediate-event-catch-condition',
      target: {
        type: 'bpmn:IntermediateCatchEvent',
        eventDefinitionType: 'bpmn:ConditionalEventDefinition'
      }
    }, {
      label: 'Link intermediate catch event',
      actionName: 'replace-with-link-intermediate-catch',
      className: 'bpmn-icon-intermediate-event-catch-link',
      target: {
        type: 'bpmn:IntermediateCatchEvent',
        eventDefinitionType: 'bpmn:LinkEventDefinition',
        eventDefinitionAttrs: {
          name: ''
        }
      }
    }, {
      label: 'Link intermediate throw event',
      actionName: 'replace-with-link-intermediate-throw',
      className: 'bpmn-icon-intermediate-event-throw-link',
      target: {
        type: 'bpmn:IntermediateThrowEvent',
        eventDefinitionType: 'bpmn:LinkEventDefinition',
        eventDefinitionAttrs: {
          name: ''
        }
      }
    }, {
      label: 'Compensation intermediate throw event',
      actionName: 'replace-with-compensation-intermediate-throw',
      className: 'bpmn-icon-intermediate-event-throw-compensation',
      target: {
        type: 'bpmn:IntermediateThrowEvent',
        eventDefinitionType: 'bpmn:CompensateEventDefinition'
      }
    }, {
      label: 'Signal intermediate catch event',
      actionName: 'replace-with-signal-intermediate-catch',
      className: 'bpmn-icon-intermediate-event-catch-signal',
      target: {
        type: 'bpmn:IntermediateCatchEvent',
        eventDefinitionType: 'bpmn:SignalEventDefinition'
      }
    }, {
      label: 'Signal intermediate throw event',
      actionName: 'replace-with-signal-intermediate-throw',
      className: 'bpmn-icon-intermediate-event-throw-signal',
      target: {
        type: 'bpmn:IntermediateThrowEvent',
        eventDefinitionType: 'bpmn:SignalEventDefinition'
      }
    }]
    const yb = [{
      label: 'Start event',
      actionName: 'replace-with-none-start',
      className: 'bpmn-icon-start-event-none',
      target: {
        type: 'bpmn:StartEvent'
      }
    }, {
      label: 'Intermediate throw event',
      actionName: 'replace-with-none-intermediate-throw',
      className: 'bpmn-icon-intermediate-event-none',
      target: {
        type: 'bpmn:IntermediateThrowEvent'
      }
    }, {
      label: 'End event',
      actionName: 'replace-with-none-end',
      className: 'bpmn-icon-end-event-none',
      target: {
        type: 'bpmn:EndEvent'
      }
    }, {
      label: 'Message end event',
      actionName: 'replace-with-message-end',
      className: 'bpmn-icon-end-event-message',
      target: {
        type: 'bpmn:EndEvent',
        eventDefinitionType: 'bpmn:MessageEventDefinition'
      }
    }, {
      label: 'Escalation end event',
      actionName: 'replace-with-escalation-end',
      className: 'bpmn-icon-end-event-escalation',
      target: {
        type: 'bpmn:EndEvent',
        eventDefinitionType: 'bpmn:EscalationEventDefinition'
      }
    }, {
      label: 'Error end event',
      actionName: 'replace-with-error-end',
      className: 'bpmn-icon-end-event-error',
      target: {
        type: 'bpmn:EndEvent',
        eventDefinitionType: 'bpmn:ErrorEventDefinition'
      }
    }, {
      label: 'Cancel end event',
      actionName: 'replace-with-cancel-end',
      className: 'bpmn-icon-end-event-cancel',
      target: {
        type: 'bpmn:EndEvent',
        eventDefinitionType: 'bpmn:CancelEventDefinition'
      }
    }, {
      label: 'Compensation end event',
      actionName: 'replace-with-compensation-end',
      className: 'bpmn-icon-end-event-compensation',
      target: {
        type: 'bpmn:EndEvent',
        eventDefinitionType: 'bpmn:CompensateEventDefinition'
      }
    }, {
      label: 'Signal end event',
      actionName: 'replace-with-signal-end',
      className: 'bpmn-icon-end-event-signal',
      target: {
        type: 'bpmn:EndEvent',
        eventDefinitionType: 'bpmn:SignalEventDefinition'
      }
    }, {
      label: 'Terminate end event',
      actionName: 'replace-with-terminate-end',
      className: 'bpmn-icon-end-event-terminate',
      target: {
        type: 'bpmn:EndEvent',
        eventDefinitionType: 'bpmn:TerminateEventDefinition'
      }
    }]
    const bb = [{
      label: 'Exclusive gateway',
      actionName: 'replace-with-exclusive-gateway',
      className: 'bpmn-icon-gateway-xor',
      target: {
        type: 'bpmn:ExclusiveGateway'
      }
    }, {
      label: 'Parallel gateway',
      actionName: 'replace-with-parallel-gateway',
      className: 'bpmn-icon-gateway-parallel',
      target: {
        type: 'bpmn:ParallelGateway'
      }
    }, {
      label: 'Inclusive gateway',
      actionName: 'replace-with-inclusive-gateway',
      className: 'bpmn-icon-gateway-or',
      target: {
        type: 'bpmn:InclusiveGateway'
      }
    }, {
      label: 'Complex gateway',
      actionName: 'replace-with-complex-gateway',
      className: 'bpmn-icon-gateway-complex',
      target: {
        type: 'bpmn:ComplexGateway'
      }
    }, {
      label: 'Event-based gateway',
      actionName: 'replace-with-event-based-gateway',
      className: 'bpmn-icon-gateway-eventbased',
      target: {
        type: 'bpmn:EventBasedGateway',
        instantiate: !1,
        eventGatewayType: 'Exclusive'
      }
    }]
    const Ab = [{
      label: 'Transaction',
      actionName: 'replace-with-transaction',
      className: 'bpmn-icon-transaction',
      target: {
        type: 'bpmn:Transaction',
        isExpanded: !0
      }
    }, {
      label: 'Event sub-process',
      actionName: 'replace-with-event-subprocess',
      className: 'bpmn-icon-event-subprocess-expanded',
      target: {
        type: 'bpmn:SubProcess',
        triggeredByEvent: !0,
        isExpanded: !0
      }
    }, {
      label: 'Sub-process (collapsed)',
      actionName: 'replace-with-collapsed-subprocess',
      className: 'bpmn-icon-subprocess-collapsed',
      target: {
        type: 'bpmn:SubProcess',
        isExpanded: !1
      }
    }]
    const Eb = [{
      label: 'Transaction',
      actionName: 'replace-with-transaction',
      className: 'bpmn-icon-transaction',
      target: {
        type: 'bpmn:Transaction',
        isExpanded: !0
      }
    }, {
      label: 'Sub-process',
      actionName: 'replace-with-subprocess',
      className: 'bpmn-icon-subprocess-expanded',
      target: {
        type: 'bpmn:SubProcess',
        isExpanded: !0
      }
    }, {
      label: 'Event sub-process',
      actionName: 'replace-with-event-subprocess',
      className: 'bpmn-icon-event-subprocess-expanded',
      target: {
        type: 'bpmn:SubProcess',
        triggeredByEvent: !0,
        isExpanded: !0
      }
    }]
    const xb = Eb
    const wb = [{
      label: 'Task',
      actionName: 'replace-with-task',
      className: 'bpmn-icon-task',
      target: {
        type: 'bpmn:Task'
      }
    }, {
      label: 'User task',
      actionName: 'replace-with-user-task',
      className: 'bpmn-icon-user',
      target: {
        type: 'bpmn:UserTask'
      }
    }, {
      label: 'Service task',
      actionName: 'replace-with-service-task',
      className: 'bpmn-icon-service',
      target: {
        type: 'bpmn:ServiceTask'
      }
    }, {
      label: 'Send task',
      actionName: 'replace-with-send-task',
      className: 'bpmn-icon-send',
      target: {
        type: 'bpmn:SendTask'
      }
    }, {
      label: 'Receive task',
      actionName: 'replace-with-receive-task',
      className: 'bpmn-icon-receive',
      target: {
        type: 'bpmn:ReceiveTask'
      }
    }, {
      label: 'Manual task',
      actionName: 'replace-with-manual-task',
      className: 'bpmn-icon-manual',
      target: {
        type: 'bpmn:ManualTask'
      }
    }, {
      label: 'Business rule task',
      actionName: 'replace-with-rule-task',
      className: 'bpmn-icon-business-rule',
      target: {
        type: 'bpmn:BusinessRuleTask'
      }
    }, {
      label: 'Script task',
      actionName: 'replace-with-script-task',
      className: 'bpmn-icon-script',
      target: {
        type: 'bpmn:ScriptTask'
      }
    }, {
      label: 'Call activity',
      actionName: 'replace-with-call-activity',
      className: 'bpmn-icon-call-activity',
      target: {
        type: 'bpmn:CallActivity'
      }
    }, {
      label: 'Sub-process (collapsed)',
      actionName: 'replace-with-collapsed-subprocess',
      className: 'bpmn-icon-subprocess-collapsed',
      target: {
        type: 'bpmn:SubProcess',
        isExpanded: !1
      }
    }, {
      label: 'Sub-process (expanded)',
      actionName: 'replace-with-expanded-subprocess',
      className: 'bpmn-icon-subprocess-expanded',
      target: {
        type: 'bpmn:SubProcess',
        isExpanded: !0
      }
    }]
    const _b = [{
      label: 'Data store reference',
      actionName: 'replace-with-data-store-reference',
      className: 'bpmn-icon-data-store',
      target: {
        type: 'bpmn:DataStoreReference'
      }
    }]
    const Cb = [{
      label: 'Data object reference',
      actionName: 'replace-with-data-object-reference',
      className: 'bpmn-icon-data-object',
      target: {
        type: 'bpmn:DataObjectReference'
      }
    }]
    const Sb = [{
      label: 'Message boundary event',
      actionName: 'replace-with-message-boundary',
      className: 'bpmn-icon-intermediate-event-catch-message',
      target: {
        type: 'bpmn:BoundaryEvent',
        eventDefinitionType: 'bpmn:MessageEventDefinition',
        cancelActivity: !0
      }
    }, {
      label: 'Timer boundary event',
      actionName: 'replace-with-timer-boundary',
      className: 'bpmn-icon-intermediate-event-catch-timer',
      target: {
        type: 'bpmn:BoundaryEvent',
        eventDefinitionType: 'bpmn:TimerEventDefinition',
        cancelActivity: !0
      }
    }, {
      label: 'Escalation boundary event',
      actionName: 'replace-with-escalation-boundary',
      className: 'bpmn-icon-intermediate-event-catch-escalation',
      target: {
        type: 'bpmn:BoundaryEvent',
        eventDefinitionType: 'bpmn:EscalationEventDefinition',
        cancelActivity: !0
      }
    }, {
      label: 'Conditional boundary event',
      actionName: 'replace-with-conditional-boundary',
      className: 'bpmn-icon-intermediate-event-catch-condition',
      target: {
        type: 'bpmn:BoundaryEvent',
        eventDefinitionType: 'bpmn:ConditionalEventDefinition',
        cancelActivity: !0
      }
    }, {
      label: 'Error boundary event',
      actionName: 'replace-with-error-boundary',
      className: 'bpmn-icon-intermediate-event-catch-error',
      target: {
        type: 'bpmn:BoundaryEvent',
        eventDefinitionType: 'bpmn:ErrorEventDefinition',
        cancelActivity: !0
      }
    }, {
      label: 'Cancel boundary event',
      actionName: 'replace-with-cancel-boundary',
      className: 'bpmn-icon-intermediate-event-catch-cancel',
      target: {
        type: 'bpmn:BoundaryEvent',
        eventDefinitionType: 'bpmn:CancelEventDefinition',
        cancelActivity: !0
      }
    }, {
      label: 'Signal boundary event',
      actionName: 'replace-with-signal-boundary',
      className: 'bpmn-icon-intermediate-event-catch-signal',
      target: {
        type: 'bpmn:BoundaryEvent',
        eventDefinitionType: 'bpmn:SignalEventDefinition',
        cancelActivity: !0
      }
    }, {
      label: 'Compensation boundary event',
      actionName: 'replace-with-compensation-boundary',
      className: 'bpmn-icon-intermediate-event-catch-compensation',
      target: {
        type: 'bpmn:BoundaryEvent',
        eventDefinitionType: 'bpmn:CompensateEventDefinition',
        cancelActivity: !0
      }
    }, {
      label: 'Message boundary event (non-interrupting)',
      actionName: 'replace-with-non-interrupting-message-boundary',
      className: 'bpmn-icon-intermediate-event-catch-non-interrupting-message',
      target: {
        type: 'bpmn:BoundaryEvent',
        eventDefinitionType: 'bpmn:MessageEventDefinition',
        cancelActivity: !1
      }
    }, {
      label: 'Timer boundary event (non-interrupting)',
      actionName: 'replace-with-non-interrupting-timer-boundary',
      className: 'bpmn-icon-intermediate-event-catch-non-interrupting-timer',
      target: {
        type: 'bpmn:BoundaryEvent',
        eventDefinitionType: 'bpmn:TimerEventDefinition',
        cancelActivity: !1
      }
    }, {
      label: 'Escalation boundary event (non-interrupting)',
      actionName: 'replace-with-non-interrupting-escalation-boundary',
      className: 'bpmn-icon-intermediate-event-catch-non-interrupting-escalation',
      target: {
        type: 'bpmn:BoundaryEvent',
        eventDefinitionType: 'bpmn:EscalationEventDefinition',
        cancelActivity: !1
      }
    }, {
      label: 'Conditional boundary event (non-interrupting)',
      actionName: 'replace-with-non-interrupting-conditional-boundary',
      className: 'bpmn-icon-intermediate-event-catch-non-interrupting-condition',
      target: {
        type: 'bpmn:BoundaryEvent',
        eventDefinitionType: 'bpmn:ConditionalEventDefinition',
        cancelActivity: !1
      }
    }, {
      label: 'Signal boundary event (non-interrupting)',
      actionName: 'replace-with-non-interrupting-signal-boundary',
      className: 'bpmn-icon-intermediate-event-catch-non-interrupting-signal',
      target: {
        type: 'bpmn:BoundaryEvent',
        eventDefinitionType: 'bpmn:SignalEventDefinition',
        cancelActivity: !1
      }
    }]
    const kb = [{
      label: 'Message start event',
      actionName: 'replace-with-message-start',
      className: 'bpmn-icon-start-event-message',
      target: {
        type: 'bpmn:StartEvent',
        eventDefinitionType: 'bpmn:MessageEventDefinition',
        isInterrupting: !0
      }
    }, {
      label: 'Timer start event',
      actionName: 'replace-with-timer-start',
      className: 'bpmn-icon-start-event-timer',
      target: {
        type: 'bpmn:StartEvent',
        eventDefinitionType: 'bpmn:TimerEventDefinition',
        isInterrupting: !0
      }
    }, {
      label: 'Conditional start event',
      actionName: 'replace-with-conditional-start',
      className: 'bpmn-icon-start-event-condition',
      target: {
        type: 'bpmn:StartEvent',
        eventDefinitionType: 'bpmn:ConditionalEventDefinition',
        isInterrupting: !0
      }
    }, {
      label: 'Signal start event',
      actionName: 'replace-with-signal-start',
      className: 'bpmn-icon-start-event-signal',
      target: {
        type: 'bpmn:StartEvent',
        eventDefinitionType: 'bpmn:SignalEventDefinition',
        isInterrupting: !0
      }
    }, {
      label: 'Error start event',
      actionName: 'replace-with-error-start',
      className: 'bpmn-icon-start-event-error',
      target: {
        type: 'bpmn:StartEvent',
        eventDefinitionType: 'bpmn:ErrorEventDefinition',
        isInterrupting: !0
      }
    }, {
      label: 'Escalation start event',
      actionName: 'replace-with-escalation-start',
      className: 'bpmn-icon-start-event-escalation',
      target: {
        type: 'bpmn:StartEvent',
        eventDefinitionType: 'bpmn:EscalationEventDefinition',
        isInterrupting: !0
      }
    }, {
      label: 'Compensation start event',
      actionName: 'replace-with-compensation-start',
      className: 'bpmn-icon-start-event-compensation',
      target: {
        type: 'bpmn:StartEvent',
        eventDefinitionType: 'bpmn:CompensateEventDefinition',
        isInterrupting: !0
      }
    }, {
      label: 'Message start event (non-interrupting)',
      actionName: 'replace-with-non-interrupting-message-start',
      className: 'bpmn-icon-start-event-non-interrupting-message',
      target: {
        type: 'bpmn:StartEvent',
        eventDefinitionType: 'bpmn:MessageEventDefinition',
        isInterrupting: !1
      }
    }, {
      label: 'Timer start event (non-interrupting)',
      actionName: 'replace-with-non-interrupting-timer-start',
      className: 'bpmn-icon-start-event-non-interrupting-timer',
      target: {
        type: 'bpmn:StartEvent',
        eventDefinitionType: 'bpmn:TimerEventDefinition',
        isInterrupting: !1
      }
    }, {
      label: 'Conditional start event (non-interrupting)',
      actionName: 'replace-with-non-interrupting-conditional-start',
      className: 'bpmn-icon-start-event-non-interrupting-condition',
      target: {
        type: 'bpmn:StartEvent',
        eventDefinitionType: 'bpmn:ConditionalEventDefinition',
        isInterrupting: !1
      }
    }, {
      label: 'Signal start event (non-interrupting)',
      actionName: 'replace-with-non-interrupting-signal-start',
      className: 'bpmn-icon-start-event-non-interrupting-signal',
      target: {
        type: 'bpmn:StartEvent',
        eventDefinitionType: 'bpmn:SignalEventDefinition',
        isInterrupting: !1
      }
    }, {
      label: 'Escalation start event (non-interrupting)',
      actionName: 'replace-with-non-interrupting-escalation-start',
      className: 'bpmn-icon-start-event-non-interrupting-escalation',
      target: {
        type: 'bpmn:StartEvent',
        eventDefinitionType: 'bpmn:EscalationEventDefinition',
        isInterrupting: !1
      }
    }]
    const jb = [{
      label: 'Sequence flow',
      actionName: 'replace-with-sequence-flow',
      className: 'bpmn-icon-connection'
    }, {
      label: 'Default flow',
      actionName: 'replace-with-default-flow',
      className: 'bpmn-icon-default-flow'
    }, {
      label: 'Conditional flow',
      actionName: 'replace-with-conditional-flow',
      className: 'bpmn-icon-conditional-flow'
    }]
    const Bb = [{
      label: 'Expanded pool/participant',
      actionName: 'replace-with-expanded-pool',
      className: 'bpmn-icon-participant',
      target: {
        type: 'bpmn:Participant',
        isExpanded: !0
      }
    }, {
      label: function (e) {
        let t = 'Empty pool/participant'
        return e.children && e.children.length && (t += ' (removes content)'),
        t
      },
      actionName: 'replace-with-collapsed-pool',
      className: 'bpmn-icon-lane',
      target: {
        type: 'bpmn:Participant',
        isExpanded: !1
      }
    }]
    function Db (e) {
      return Db = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      Db(e)
    }
    function Pb (e, t) {
      const n = Object.keys(e)
      if (Object.getOwnPropertySymbols) {
        let r = Object.getOwnPropertySymbols(e)
        t && (r = r.filter(function (t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable
        }
        )),
        n.push.apply(n, r)
      }
      return n
    }
    function Ob (e) {
      for (let t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {}
        t % 2
          ? Pb(Object(n), !0).forEach(function (t) {
            Tb(e, t, n[t])
          }
          )
          : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
            : Pb(Object(n)).forEach(function (t) {
              Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
            }
            )
      }
      return e
    }
    function Tb (e, t, n) {
      return t = (function (e) {
        const t = (function (e, t) {
          if (Db(e) != 'object' || !e) { return e }
          const n = e[Symbol.toPrimitive]
          if (void 0 !== n) {
            const r = n.call(e, 'string')
            if (Db(r) != 'object') { return r }
            throw new TypeError('@@toPrimitive must return a primitive value.')
          }
          return String(e)
        }(e))
        return Db(t) == 'symbol' ? t : t + ''
      }(t)),
      t in e
        ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
        : e[t] = n,
      e
    }
    function Rb (e, t, n, r, o, i, a, s) {
      this._bpmnFactory = e,
      this._popupMenu = t,
      this._modeling = n,
      this._moddle = r,
      this._bpmnReplace = o,
      this._rules = i,
      this._translate = a,
      this._moddleCopy = s,
      this._register()
    }
    Rb.$inject = ['bpmnFactory', 'popupMenu', 'modeling', 'moddle', 'bpmnReplace', 'rules', 'translate', 'moddleCopy'],
    Rb.prototype._register = function () {
      this._popupMenu.registerProvider('bpmn-replace', this)
    }
    ,
    Rb.prototype.getPopupMenuEntries = function (e) {
      const t = e.businessObject
      const n = this._rules
      let r = []
      if (M(e) || !n.allowed('shape.replace', {
        element: e
      })) { return {} }
      const o = hb(e)
      return Pi(t, 'bpmn:DataObjectReference')
        ? this._createEntries(e, _b)
        : Pi(t, 'bpmn:DataStoreReference') && !Pi(e.parent, 'bpmn:Collaboration')
          ? this._createEntries(e, Cb)
          : Pi(t, 'bpmn:StartEvent') && !Pi(t.$parent, 'bpmn:SubProcess')
            ? (r = W(mb, o),
              this._createEntries(e, r))
            : Pi(t, 'bpmn:Participant')
              ? (r = W(Bb, function (t) {
                  return Zi(e) !== t.target.isExpanded
                }
                ),
                this._createEntries(e, r))
              : Pi(t, 'bpmn:StartEvent') && ta(t.$parent)
                ? (r = W(kb, function (e) {
                    const n = !1 !== e.target.isInterrupting
                    const r = t.isInterrupting === n
                    return o(e) || !o(e) && !r
                  }
                  ),
                  this._createEntries(e, r))
                : Pi(t, 'bpmn:StartEvent') && !ta(t.$parent) && Pi(t.$parent, 'bpmn:SubProcess')
                  ? (r = W(vb, o),
                    this._createEntries(e, r))
                  : Pi(t, 'bpmn:EndEvent')
                    ? (r = W(yb, function (e) {
                        return !(e.target.eventDefinitionType == 'bpmn:CancelEventDefinition' && !Pi(t.$parent, 'bpmn:Transaction')) && o(e)
                      }
                      ),
                      this._createEntries(e, r))
                    : Pi(t, 'bpmn:BoundaryEvent')
                      ? (r = W(Sb, function (e) {
                          const n = e.target
                          if (n.eventDefinitionType == 'bpmn:CancelEventDefinition' && !Pi(t.attachedToRef, 'bpmn:Transaction')) { return !1 }
                          const r = !1 !== n.cancelActivity
                          const i = t.cancelActivity == r
                          return o(e) || !o(e) && !i
                        }
                        ),
                        this._createEntries(e, r))
                      : Pi(t, 'bpmn:IntermediateCatchEvent') || Pi(t, 'bpmn:IntermediateThrowEvent')
                        ? (r = W(gb, o),
                          this._createEntries(e, r))
                        : Pi(t, 'bpmn:Gateway')
                          ? (r = W(bb, o),
                            this._createEntries(e, r))
                          : Pi(t, 'bpmn:Transaction')
                            ? (r = W(Eb, o),
                              this._createEntries(e, r))
                            : ta(t) && Zi(e)
                              ? (r = W(xb, o),
                                this._createEntries(e, r))
                              : Pi(t, 'bpmn:SubProcess') && Zi(e)
                                ? (r = W(Ab, o),
                                  this._createEntries(e, r))
                                : Pi(t, 'bpmn:AdHocSubProcess') && !Zi(e)
                                  ? (r = W(wb, function (e) {
                                      const t = e.target
                                      const n = t.type === 'bpmn:SubProcess'
                                      const r = !0 === t.isExpanded
                                      return hb(t) && (!n || r)
                                    }
                                    ),
                                    this._createEntries(e, r))
                                  : Pi(t, 'bpmn:SequenceFlow')
                                    ? this._createSequenceFlowEntries(e, jb)
                                    : Pi(t, 'bpmn:FlowNode')
                                      ? (r = W(wb, o),
                                        Pi(t, 'bpmn:SubProcess') && !Zi(e) && (r = W(r, function (e) {
                                          return e.label !== 'Sub-process (collapsed)'
                                        }
                                        )),
                                        this._createEntries(e, r))
                                      : {}
    }
    ,
    Rb.prototype.getPopupMenuHeaderEntries = function (e) {
      let t = {}
      return Pi(e, 'bpmn:Activity') && !ta(e) && (t = Ob(Ob({}, t), this._getLoopCharacteristicsHeaderEntries(e))),
      Pi(e, 'bpmn:DataObjectReference') && (t = Ob(Ob({}, t), this._getCollectionHeaderEntries(e))),
      Pi(e, 'bpmn:Participant') && (t = Ob(Ob({}, t), this._getParticipantMultiplicityHeaderEntries(e))),
      !Pi(e, 'bpmn:SubProcess') || Pi(e, 'bpmn:Transaction') || ta(e) || (t = Ob(Ob({}, t), this._getAdHocHeaderEntries(e))),
      ih(e) && (t = Ob(Ob({}, t), this._getNonInterruptingHeaderEntries(e))),
      t
    }
    ,
    Rb.prototype._createEntries = function (e, t) {
      const n = {}
      const r = this
      return G(t, function (t) {
        n[t.actionName] = r._createEntry(t, e)
      }
      ),
      n
    }
    ,
    Rb.prototype._createSequenceFlowEntries = function (e, t) {
      const n = Ti(e)
      let r = {}
      const o = this._modeling
      const i = this._moddle
      const a = this
      return G(t, function (t) {
        switch (t.actionName) {
          case 'replace-with-default-flow':
            n.sourceRef.default !== n && (Pi(n.sourceRef, 'bpmn:ExclusiveGateway') || Pi(n.sourceRef, 'bpmn:InclusiveGateway') || Pi(n.sourceRef, 'bpmn:ComplexGateway') || Pi(n.sourceRef, 'bpmn:Activity')) && (r = Ob(Ob({}, r), {}, Tb({}, t.actionName, a._createEntry(t, e, function () {
              o.updateProperties(e.source, {
                default: n
              })
            }
            ))))
            break
          case 'replace-with-conditional-flow':
            !n.conditionExpression && Pi(n.sourceRef, 'bpmn:Activity') && (r = Ob(Ob({}, r), {}, Tb({}, t.actionName, a._createEntry(t, e, function () {
              const t = i.create('bpmn:FormalExpression', {
                body: ''
              })
              o.updateProperties(e, {
                conditionExpression: t
              })
            }
            ))))
            break
          default:
            Pi(n.sourceRef, 'bpmn:Activity') && n.conditionExpression && (r = Ob(Ob({}, r), {}, Tb({}, t.actionName, a._createEntry(t, e, function () {
              o.updateProperties(e, {
                conditionExpression: void 0
              })
            }
            )))),
            (Pi(n.sourceRef, 'bpmn:ExclusiveGateway') || Pi(n.sourceRef, 'bpmn:InclusiveGateway') || Pi(n.sourceRef, 'bpmn:ComplexGateway') || Pi(n.sourceRef, 'bpmn:Activity')) && n.sourceRef.default === n && (r = Ob(Ob({}, r), {}, Tb({}, t.actionName, a._createEntry(t, e, function () {
              o.updateProperties(e.source, {
                default: void 0
              })
            }
            ))))
        }
      }
      ),
      r
    }
    ,
    Rb.prototype._createEntry = function (e, t, n) {
      const r = this._translate
      const o = this._bpmnReplace.replaceElement
      let i = e.label
      return i && typeof i === 'function' && (i = i(t)),
      n = n || function () {
        return o(t, e.target)
      }
      ,
      {
        label: r(i),
        className: e.className,
        action: n
      }
    }
    ,
    Rb.prototype._getLoopCharacteristicsHeaderEntries = function (e) {
      const t = this
      const n = this._translate
      function r (n, r) {
        if (r.active) {
          t._modeling.updateProperties(e, {
            loopCharacteristics: void 0
          })
        } else {
          const o = e.businessObject.get('loopCharacteristics')
          const i = t._moddle.create(r.options.loopCharacteristics)
          o && t._moddleCopy.copyElement(o, i),
          i.set('isSequential', r.options.isSequential),
          t._modeling.updateProperties(e, {
            loopCharacteristics: i
          })
        }
      }
      let o; let i; let a; const s = Ti(e).loopCharacteristics
      return s && (o = s.isSequential,
      i = void 0 === s.isSequential,
      a = void 0 !== s.isSequential && !s.isSequential),
      {
        'toggle-parallel-mi': {
          className: 'bpmn-icon-parallel-mi-marker',
          title: n('Parallel multi-instance'),
          active: a,
          action: r,
          options: {
            loopCharacteristics: 'bpmn:MultiInstanceLoopCharacteristics',
            isSequential: !1
          }
        },
        'toggle-sequential-mi': {
          className: 'bpmn-icon-sequential-mi-marker',
          title: n('Sequential multi-instance'),
          active: o,
          action: r,
          options: {
            loopCharacteristics: 'bpmn:MultiInstanceLoopCharacteristics',
            isSequential: !0
          }
        },
        'toggle-loop': {
          className: 'bpmn-icon-loop-marker',
          title: n('Loop'),
          active: i,
          action: r,
          options: {
            loopCharacteristics: 'bpmn:StandardLoopCharacteristics'
          }
        }
      }
    }
    ,
    Rb.prototype._getCollectionHeaderEntries = function (e) {
      const t = this
      const n = this._translate
      const r = e.businessObject.dataObjectRef
      if (!r) { return {} }
      const o = r.isCollection
      return {
        'toggle-is-collection': {
          className: 'bpmn-icon-parallel-mi-marker',
          title: n('Collection'),
          active: o,
          action: function (n, o) {
            t._modeling.updateModdleProperties(e, r, {
              isCollection: !o.active
            })
          }
        }
      }
    }
    ,
    Rb.prototype._getParticipantMultiplicityHeaderEntries = function (e) {
      const t = this
      const n = this._bpmnFactory
      const r = this._translate
      const o = e.businessObject.participantMultiplicity
      return {
        'toggle-participant-multiplicity': {
          className: 'bpmn-icon-parallel-mi-marker',
          title: r('Participant multiplicity'),
          active: !!o,
          action: function (r, o) {
            let i
            o.active || (i = n.create('bpmn:ParticipantMultiplicity')),
            t._modeling.updateProperties(e, {
              participantMultiplicity: i
            })
          }
        }
      }
    }
    ,
    Rb.prototype._getAdHocHeaderEntries = function (e) {
      const t = this._translate
      const n = Pi(Ti(e), 'bpmn:AdHocSubProcess')
      const r = this._bpmnReplace.replaceElement
      return {
        'toggle-adhoc': {
          className: 'bpmn-icon-ad-hoc-marker',
          title: t('Ad-hoc'),
          active: n,
          action: function (t, o) {
            return r(e, n
              ? {
                  type: 'bpmn:SubProcess'
                }
              : {
                  type: 'bpmn:AdHocSubProcess'
                }, {
              autoResize: !1,
              layoutConnection: !1
            })
          }
        }
      }
    }
    ,
    Rb.prototype._getNonInterruptingHeaderEntries = function (e) {
      const t = this._translate
      const n = Ti(e)
      const r = this
      const o = ah(e)
      const i = Pi(e, 'bpmn:BoundaryEvent') ? '\n  <svg viewBox="0 0 2048 2048" xmlns="http://www.w3.org/2000/svg">\n     <g transform="translate(0 995.64)" fill="none" stroke="currentColor" stroke-linecap="round">\n        <circle cx="1024" cy="28.357" r="875" stroke-dasharray="418.310422, 361.2328165" stroke-width="100"/>\n        <circle cx="1024" cy="28.357" r="685" stroke-dasharray="348.31044857,261.23283643" stroke-dashoffset="500" stroke-width="100"/>\n     </g>\n  </svg>' : '\n  <svg viewBox="0 0 2048 2048" xmlns="http://www.w3.org/2000/svg">\n    <g transform="translate(0 995.64)">\n      <path d="m1899 28.357c21.545 567.43-598.38 1023.5-1133.6 835.92-548.09-147.21-801.57-873.95-463.59-1330 302.62-480.3 1071.7-507.54 1407.6-49.847 122.14 153.12 190.07 348.07 189.59 543.91z" fill="none" stroke="currentColor" stroke-dasharray="418.310422, 361.2328165" stroke-linecap="round" stroke-width="100"/>\n    </g>\n  </svg>'
      const a = !n[o]
      return {
        'toggle-non-interrupting': {
          imageHtml: i,
          title: t('Toggle non-interrupting'),
          active: a,
          action: function () {
            r._modeling.updateProperties(e, Tb({}, o, !!a))
          }
        }
      }
    }

    const Nb = {
      __depends__: [Dp, fv, Xp],
      __init__: ['replaceMenuProvider'],
      replaceMenuProvider: ['type', Rb]
    }
    function Mb (e, t, n, r, o, i, a, s, c, l, p, u, d) {
      e = e || {},
      r.registerProvider(this),
      this._contextPad = r,
      this._modeling = o,
      this._elementFactory = i,
      this._connect = a,
      this._create = s,
      this._popupMenu = c,
      this._canvas = l,
      this._rules = p,
      this._translate = u,
      this._eventBus = n,
      this._appendPreview = d,
      !1 !== e.autoPlace && (this._autoPlace = t.get('autoPlace', !1)),
      n.on('create.end', 250, function (e) {
        const t = e.context.shape
        if (Ja(e) && r.isOpen(t)) {
          const n = r.getEntries(t)
          n.replace && n.replace.action.click(e, t)
        }
      }
      )
    }
    function Ib (e, t, n) {
      const r = e.$instanceOf(t)
      let o = !1
      return G(e.eventDefinitions || [], function (e) {
        e.$type === n && (o = !0)
      }
      ),
      r && o
    }
    Mb.$inject = ['config.contextPad', 'injector', 'eventBus', 'contextPad', 'modeling', 'elementFactory', 'connect', 'create', 'popupMenu', 'canvas', 'rules', 'translate', 'appendPreview'],
    Mb.prototype.getMultiElementContextPadEntries = function (e) {
      const t = this._modeling
      const n = {}
      return this._isDeleteAllowed(e) && le(n, {
        delete: {
          group: 'edit',
          className: 'bpmn-icon-trash',
          title: this._translate('Delete'),
          action: {
            click: function (e, n) {
              t.removeElements(n.slice())
            }
          }
        }
      }),
      n
    }
    ,
    Mb.prototype._isDeleteAllowed = function (e) {
      const t = this._rules.allowed('elements.delete', {
        elements: e
      })
      return M(t)
        ? V(t, function (e) {
          return n = e,
          t.indexOf(n) !== -1
          let n
        }
        )
        : t
    }
    ,
    Mb.prototype.getContextPadEntries = function (e) {
      const t = this._contextPad
      const n = this._modeling
      const r = this._elementFactory
      const o = this._connect
      const i = this._create
      const a = this._popupMenu
      const s = this._rules
      const c = this._autoPlace
      const l = this._translate
      const p = this._appendPreview
      const u = {}
      if (e.type === 'label') { return u }
      const d = e.businessObject
      function f (e, t) {
        o.start(e, t)
      }
      function h (e, t, n, o) {
        function a (t, n) {
          const a = r.createShape(le({
            type: e
          }, o))
          i.start(t, a, {
            source: n
          }),
          p.cleanUp()
        }
        const s = c
          ? function (t, n) {
            const i = r.createShape(le({
              type: e
            }, o))
            c.append(n, i),
            p.cleanUp()
          }
          : a
        const l = c
          ? function (t, n) {
            return p.create(n, e, o),
            function () {
              p.cleanUp()
            }
          }
          : null
        return {
          group: 'model',
          className: t,
          title: n,
          action: {
            dragstart: a,
            click: s,
            hover: l
          }
        }
      }
      function m (e) {
        return function (r, o) {
          n.splitLane(o, e),
          t.open(o, !0)
        }
      }
      if (Oi(d, ['bpmn:Lane', 'bpmn:Participant']) && Zi(e)) {
        const v = ff(e)
        le(u, {
          'lane-insert-above': {
            group: 'lane-insert-above',
            className: 'bpmn-icon-lane-insert-above',
            title: l('Add lane above'),
            action: {
              click: function (e, t) {
                n.addLane(t, 'top')
              }
            }
          }
        }),
        v.length < 2 && ((ea(e) ? e.height >= 120 : e.width >= 120) && le(u, {
          'lane-divide-two': {
            group: 'lane-divide',
            className: 'bpmn-icon-lane-divide-two',
            title: l('Divide into two lanes'),
            action: {
              click: m(2)
            }
          }
        }),
        (ea(e) ? e.height >= 180 : e.width >= 180) && le(u, {
          'lane-divide-three': {
            group: 'lane-divide',
            className: 'bpmn-icon-lane-divide-three',
            title: l('Divide into three lanes'),
            action: {
              click: m(3)
            }
          }
        })),
        le(u, {
          'lane-insert-below': {
            group: 'lane-insert-below',
            className: 'bpmn-icon-lane-insert-below',
            title: l('Add lane below'),
            action: {
              click: function (e, t) {
                n.addLane(t, 'bottom')
              }
            }
          }
        })
      }
      Pi(d, 'bpmn:FlowNode') && (Pi(d, 'bpmn:EventBasedGateway')
        ? le(u, {
          'append.receive-task': h('bpmn:ReceiveTask', 'bpmn-icon-receive-task', l('Append receive task')),
          'append.message-intermediate-event': h('bpmn:IntermediateCatchEvent', 'bpmn-icon-intermediate-event-catch-message', l('Append message intermediate catch event'), {
            eventDefinitionType: 'bpmn:MessageEventDefinition'
          }),
          'append.timer-intermediate-event': h('bpmn:IntermediateCatchEvent', 'bpmn-icon-intermediate-event-catch-timer', l('Append timer intermediate catch event'), {
            eventDefinitionType: 'bpmn:TimerEventDefinition'
          }),
          'append.condition-intermediate-event': h('bpmn:IntermediateCatchEvent', 'bpmn-icon-intermediate-event-catch-condition', l('Append conditional intermediate catch event'), {
            eventDefinitionType: 'bpmn:ConditionalEventDefinition'
          }),
          'append.signal-intermediate-event': h('bpmn:IntermediateCatchEvent', 'bpmn-icon-intermediate-event-catch-signal', l('Append signal intermediate catch event'), {
            eventDefinitionType: 'bpmn:SignalEventDefinition'
          })
        })
        : Ib(d, 'bpmn:BoundaryEvent', 'bpmn:CompensateEventDefinition')
          ? le(u, {
            'append.compensation-activity': h('bpmn:Task', 'bpmn-icon-task', l('Append compensation activity'), {
              isForCompensation: !0
            })
          })
          : Pi(d, 'bpmn:EndEvent') || d.isForCompensation || Ib(d, 'bpmn:IntermediateThrowEvent', 'bpmn:LinkEventDefinition') || ta(d) || le(u, {
            'append.end-event': h('bpmn:EndEvent', 'bpmn-icon-end-event-none', l('Append end event')),
            'append.gateway': h('bpmn:ExclusiveGateway', 'bpmn-icon-gateway-none', l('Append gateway')),
            'append.append-task': h('bpmn:Task', 'bpmn-icon-task', l('Append task')),
            'append.intermediate-event': h('bpmn:IntermediateThrowEvent', 'bpmn-icon-intermediate-event-none', l('Append intermediate/boundary event'))
          })),
      a.isEmpty(e, 'bpmn-replace') || le(u, {
        replace: {
          group: 'edit',
          className: 'bpmn-icon-screw-wrench',
          title: l('Change element'),
          action: {
            click: function (e, n) {
              const r = le((function (e) {
                const n = t.getPad(e).html.getBoundingClientRect()
                return {
                  x: n.left,
                  y: n.bottom + 5
                }
              }(n)), {
                cursor: {
                  x: e.x,
                  y: e.y
                }
              })
              a.open(n, 'bpmn-replace', r, {
                title: l('Change element'),
                width: 300,
                search: !0
              })
            }
          }
        }
      }),
      Pi(d, 'bpmn:SequenceFlow') && le(u, {
        'append.text-annotation': h('bpmn:TextAnnotation', 'bpmn-icon-text-annotation', l('Add text annotation'))
      }),
      Oi(d, ['bpmn:FlowNode', 'bpmn:InteractionNode', 'bpmn:DataObjectReference', 'bpmn:DataStoreReference']) && le(u, {
        'append.text-annotation': h('bpmn:TextAnnotation', 'bpmn-icon-text-annotation', l('Add text annotation')),
        connect: {
          group: 'connect',
          className: 'bpmn-icon-connection-multi',
          title: l('Connect to other element'),
          action: {
            click: f,
            dragstart: f
          }
        }
      }),
      Pi(d, 'bpmn:TextAnnotation') && le(u, {
        connect: {
          group: 'connect',
          className: 'bpmn-icon-connection-multi',
          title: l('Connect using association'),
          action: {
            click: f,
            dragstart: f
          }
        }
      }),
      Oi(d, ['bpmn:DataObjectReference', 'bpmn:DataStoreReference']) && le(u, {
        connect: {
          group: 'connect',
          className: 'bpmn-icon-connection-multi',
          title: l('Connect using data input association'),
          action: {
            click: f,
            dragstart: f
          }
        }
      }),
      Pi(d, 'bpmn:Group') && le(u, {
        'append.text-annotation': h('bpmn:TextAnnotation', 'bpmn-icon-text-annotation', l('Add text annotation'))
      })
      let g = s.allowed('elements.delete', {
        elements: [e]
      })
      return M(g) && (g = g[0] === e),
      g && le(u, {
        delete: {
          group: 'edit',
          className: 'bpmn-icon-trash',
          title: l('Delete'),
          action: {
            click: function (e, t) {
              n.removeElements([t])
            }
          }
        }
      }),
      u
    }

    const Lb = {
      __depends__: [Wy, fb, Dc, us, hd, qm, Nb],
      __init__: ['contextPadProvider'],
      contextPadProvider: ['type', Mb]
    }
    const zb = {
      horizontal: ['x', 'width'],
      vertical: ['y', 'height']
    }
    function Fb (e, t) {
      this._modeling = e,
      this._filters = [],
      this.registerFilter(function (e) {
        const n = t.allowed('elements.distribute', {
          elements: e
        })
        return M(n) ? n : n ? e : []
      }
      )
    }
    Fb.$inject = ['modeling', 'rules'],
    Fb.prototype.registerFilter = function (e) {
      if (typeof e !== 'function') { throw new Error('the filter has to be a function') }
      this._filters.push(e)
    }
    ,
    Fb.prototype.trigger = function (e, t) {
      let n; let r; const o = this._modeling
      if (!(e.length < 3 || (this._setOrientation(t),
      r = this._filterElements(e),
      (n = this._createGroups(r)).length <= 2))) {
        return o.distributeElements(n, this._axis, this._dimension),
        n
      }
    }
    ,
    Fb.prototype._filterElements = function (e) {
      const t = this._filters
      const n = this._axis
      const r = this._dimension
      let o = [].concat(e)
      return t.length
        ? (G(t, function (e) {
            o = e(o, n, r)
          }
          ),
          o)
        : e
    }
    ,
    Fb.prototype._createGroups = function (e) {
      const t = []
      const n = this
      const r = this._axis
      const o = this._dimension
      if (!r) { throw new Error('must have a defined "axis" and "dimension"') }
      return G(te(e, r), function (e, i) {
        let a; const s = n._findRange(e, r, o); const c = t[t.length - 1]
        c && n._hasIntersection(c.range, s)
          ? t[t.length - 1].elements.push(e)
          : (a = {
              range: s,
              elements: [e]
            },
            t.push(a))
      }
      ),
      t
    }
    ,
    Fb.prototype._setOrientation = function (e) {
      const t = zb[e]
      this._axis = t[0],
      this._dimension = t[1]
    }
    ,
    Fb.prototype._hasIntersection = function (e, t) {
      return Math.max(e.min, e.max) >= Math.min(t.min, t.max) && Math.min(e.min, e.max) <= Math.max(t.min, t.max)
    }
    ,
    Fb.prototype._findRange = function (e) {
      const t = e[this._axis]
      return {
        min: t + 5,
        max: t + e[this._dimension] - 5
      }
    }

    const $b = {
      __init__: ['distributeElements'],
      distributeElements: ['type', Fb]
    }
    function Hb (e) {
      Np.call(this, e)
    }
    Hb.$inject = ['eventBus'],
    w(Hb, Np),
    Hb.prototype.init = function () {
      this.addRule('elements.distribute', function (e) {
        let t = e.elements
        return !((t = Nt(t = W(t, function (e) {
          const t = Oi(e, ['bpmn:Association', 'bpmn:BoundaryEvent', 'bpmn:DataInputAssociation', 'bpmn:DataOutputAssociation', 'bpmn:Lane', 'bpmn:MessageFlow', 'bpmn:SequenceFlow', 'bpmn:TextAnnotation'])
          return !(e.labelTarget || t)
        }
        ))).length < 3) && t
      }
      )
    }

    const qb = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1800 1800">\n                <polyline points="450 400 450 150 1350 150 1350 400" style="fill:none;stroke:currentColor;stroke-width:100;stroke-linejoin:round;"/>\n                <rect x="150" y="450" width="600" height="1200" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>\n                <rect x="1050" y="450" width="600" height="800" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>\n              </svg>'
    const Wb = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1800 1800">\n              <polyline points="400 1350 150 1350 150 450 400 450" style="fill:none;stroke:currentColor;stroke-width:100;stroke-linejoin:round;"/>\n              <rect x="450" y="150" width="1200" height="600" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>\n              <rect x="450" y="1050" width="800" height="600" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>\n            </svg>'
    function Gb (e, t, n, r) {
      this._distributeElements = t,
      this._translate = n,
      this._popupMenu = e,
      this._rules = r,
      e.registerProvider('align-elements', 900, this)
    }
    Gb.$inject = ['popupMenu', 'distributeElements', 'translate', 'rules'],
    Gb.prototype.getPopupMenuEntries = function (e) {
      const t = {}
      return this._isAllowed(e) && le(t, this._getEntries(e)),
      t
    }
    ,
    Gb.prototype._isAllowed = function (e) {
      return this._rules.allowed('elements.distribute', {
        elements: e
      })
    }
    ,
    Gb.prototype._getEntries = function (e) {
      const t = this._distributeElements
      const n = this._translate
      const r = this._popupMenu
      return {
        'distribute-elements-horizontal': {
          group: 'distribute',
          title: n('Distribute elements horizontally'),
          className: 'bjs-align-elements-menu-entry',
          imageHtml: qb,
          action: function (n, o) {
            t.trigger(e, 'horizontal'),
            r.close()
          }
        },
        'distribute-elements-vertical': {
          group: 'distribute',
          title: n('Distribute elements vertically'),
          imageHtml: Wb,
          action: function (n, o) {
            t.trigger(e, 'vertical'),
            r.close()
          }
        }
      }
    }

    const Ub = {
      __depends__: [Dp, $b],
      __init__: ['bpmnDistributeElements', 'distributeElementsMenuProvider'],
      bpmnDistributeElements: ['type', Hb],
      distributeElementsMenuProvider: ['type', Gb]
    }
    const Vb = 'is not a registered action'
    function Qb (e, t) {
      this._actions = {}
      const n = this
      e.on('diagram.init', function () {
        n._registerDefaultActions(t),
        e.fire('editorActions.init', {
          editorActions: n
        })
      }
      )
    }
    function Yb (e, t) {
      return new Error(e + ' ' + t)
    }
    Qb.$inject = ['eventBus', 'injector'],
    Qb.prototype._registerDefaultActions = function (e) {
      const t = e.get('commandStack', !1)
      const n = e.get('modeling', !1)
      const r = e.get('selection', !1)
      const o = e.get('zoomScroll', !1)
      const i = e.get('copyPaste', !1)
      const a = e.get('canvas', !1)
      const s = e.get('rules', !1)
      const c = e.get('keyboardMove', !1)
      const l = e.get('keyboardMoveSelection', !1)
      t && (this.register('undo', function () {
        t.undo()
      }
      ),
      this.register('redo', function () {
        t.redo()
      }
      )),
      i && r && this.register('copy', function () {
        const e = r.get()
        if (e.length) { return i.copy(e) }
      }
      ),
      i && this.register('paste', function () {
        i.paste()
      }
      ),
      o && this.register('stepZoom', function (e) {
        o.stepZoom(e.value)
      }
      ),
      a && this.register('zoom', function (e) {
        a.zoom(e.value)
      }
      ),
      n && r && s && this.register('removeSelection', function () {
        const e = r.get()
        if (e.length) {
          let t; const o = s.allowed('elements.delete', {
            elements: e
          })
          !1 !== o && (t = M(o) ? o : e).length && n.removeElements(t.slice())
        }
      }
      ),
      c && this.register('moveCanvas', function (e) {
        c.moveCanvas(e)
      }
      ),
      l && this.register('moveSelection', function (e) {
        l.moveSelection(e.direction, e.accelerated)
      }
      )
    }
    ,
    Qb.prototype.trigger = function (e, t) {
      if (!this._actions[e]) { throw Yb(e, Vb) }
      return this._actions[e](t)
    }
    ,
    Qb.prototype.register = function (e, t) {
      const n = this
      if (typeof e === 'string') { return this._registerAction(e, t) }
      G(e, function (e, t) {
        n._registerAction(t, e)
      }
      )
    }
    ,
    Qb.prototype._registerAction = function (e, t) {
      if (this.isRegistered(e)) { throw Yb(e, 'is already registered') }
      this._actions[e] = t
    }
    ,
    Qb.prototype.unregister = function (e) {
      if (!this.isRegistered(e)) { throw Yb(e, Vb) }
      this._actions[e] = void 0
    }
    ,
    Qb.prototype.getActions = function () {
      return Object.keys(this._actions)
    }
    ,
    Qb.prototype.isRegistered = function (e) {
      return !!this._actions[e]
    }

    const Kb = {
      __init__: ['editorActions'],
      editorActions: ['type', Qb]
    }
    function Jb (e) {
      e.invoke(Qb, this)
    }
    w(Jb, Qb),
    Jb.$inject = ['injector'],
    Jb.prototype._registerDefaultActions = function (e) {
      Qb.prototype._registerDefaultActions.call(this, e)
      const t = e.get('canvas', !1)
      const n = e.get('elementRegistry', !1)
      const r = e.get('selection', !1)
      const o = e.get('spaceTool', !1)
      const i = e.get('lassoTool', !1)
      const a = e.get('handTool', !1)
      const s = e.get('globalConnect', !1)
      const c = e.get('distributeElements', !1)
      const l = e.get('alignElements', !1)
      const p = e.get('directEditing', !1)
      const u = e.get('searchPad', !1)
      const d = e.get('modeling', !1)
      const f = e.get('contextPad', !1)
      t && n && r && this._registerAction('selectElements', function () {
        const e = t.getRootElement()
        const o = n.filter(function (t) {
          return t !== e
        }
        )
        return r.select(o),
        o
      }
      ),
      o && this._registerAction('spaceTool', function () {
        o.toggle()
      }
      ),
      i && this._registerAction('lassoTool', function () {
        i.toggle()
      }
      ),
      a && this._registerAction('handTool', function () {
        a.toggle()
      }
      ),
      s && this._registerAction('globalConnectTool', function () {
        s.toggle()
      }
      ),
      r && c && this._registerAction('distributeElements', function (e) {
        const t = r.get()
        const n = e.type
        t.length && c.trigger(t, n)
      }
      ),
      r && l && this._registerAction('alignElements', function (e) {
        const t = r.get()
        let n = []
        const o = e.type
        t.length && (n = W(t, function (e) {
          return !Pi(e, 'bpmn:Lane')
        }
        ),
        l.trigger(n, o))
      }
      ),
      r && d && this._registerAction('setColor', function (e) {
        const t = r.get()
        t.length && d.setColor(t, e)
      }
      ),
      r && p && this._registerAction('directEditing', function () {
        const e = r.get()
        e.length && p.activate(e[0])
      }
      ),
      u && this._registerAction('find', function () {
        u.toggle()
      }
      ),
      t && d && this._registerAction('moveToOrigin', function () {
        let e; let r; const o = t.getRootElement()
        e = Ft(r = Pi(o, 'bpmn:Collaboration')
          ? n.filter(function (e) {
            return Pi(e.parent, 'bpmn:Collaboration')
          }
          )
          : n.filter(function (e) {
            return e !== o && !Pi(e.parent, 'bpmn:SubProcess')
          }
          )),
        d.moveElements(r, {
          x: -e.x,
          y: -e.y
        }, o)
      }
      ),
      r && f && this._registerAction('replaceElement', function (e) {
        f.triggerEntry('replace', 'click', e)
      }
      )
    }

    const Xb = {
      __depends__: [Kb],
      editorActions: ['type', Jb]
    }
    function Zb (e) {
      e.on(['create.init', 'shape.move.init'], function (e) {
        const t = e.context
        Oi(e.shape, ['bpmn:Participant', 'bpmn:SubProcess', 'bpmn:TextAnnotation']) && (t.gridSnappingContext || (t.gridSnappingContext = {}),
        t.gridSnappingContext.snapLocation = 'top-left')
      }
      )
    }
    Zb.$inject = ['eventBus']
    const eA = 10
    function tA (e, t, n) {
      return n || (n = 'round'),
      Math[n](e / t) * t
    }
    function nA (e, t, n) {
      const r = !n || !1 !== n.active
      this._eventBus = t
      const o = this
      t.on('diagram.init', 800, function () {
        o.setActive(r)
      }
      ),
      t.on(['create.move', 'create.end', 'bendpoint.move.move', 'bendpoint.move.end', 'connect.move', 'connect.end', 'connectionSegment.move.move', 'connectionSegment.move.end', 'resize.move', 'resize.end', 'shape.move.move', 'shape.move.end'], 1200, function (t) {
        const n = t.originalEvent
        if (!(!o.active || n && Vs(n))) {
          const r = t.context
          let i = r.gridSnappingContext
          i || (i = r.gridSnappingContext = {}),
          ['x', 'y'].forEach(function (n) {
            const r = {}
            const i = (function (e, t, n) {
              const r = e.context
              const o = e.shape
              const i = r.gridSnappingContext
              const a = i.snapLocation
              let s = i.snapOffset
              return s && L(s[t])
                ? s[t]
                : (s || (s = i.snapOffset = {}),
                  L(s[t]) || (s[t] = 0),
                  o
                    ? (n.get(o.id) || (rA(t) ? s[t] += o[t] + o.width / 2 : s[t] += o[t] + o.height / 2),
                      a
                        ? (t === 'x' ? /left/.test(a) ? s[t] -= o.width / 2 : /right/.test(a) && (s[t] += o.width / 2) : /top/.test(a) ? s[t] -= o.height / 2 : /bottom/.test(a) && (s[t] += o.height / 2),
                          s[t])
                        : s[t])
                    : s[t])
            }(t, n, e))
            i && (r.offset = i)
            const a = (function (e, t) {
              const n = e.context
              const r = n.createConstraints
              const o = n.resizeConstraints || {}
              const i = n.gridSnappingContext
              let a = i.snapConstraints
              if (a && a[t]) { return a[t] }
              a || (a = i.snapConstraints = {}),
              a[t] || (a[t] = {})
              const s = n.direction
              r && (rA(t)
                ? (a.x.min = r.left,
                  a.x.max = r.right)
                : (a.y.min = r.top,
                  a.y.max = r.bottom))
              const c = o.min
              const l = o.max
              return c && (rA(t) ? iA(s) ? a.x.max = c.left : a.x.min = c.right : oA(s) ? a.y.max = c.top : a.y.min = c.bottom),
              l && (rA(t) ? iA(s) ? a.x.min = l.left : a.x.max = l.right : oA(s) ? a.y.min = l.top : a.y.max = l.bottom),
              a[t]
            }(t, n))
            a && le(r, a),
            nd(t, n) || o.snapEvent(t, n, r)
          }
          )
        }
      }
      )
    }
    function rA (e) {
      return e === 'x'
    }
    function oA (e) {
      return e.indexOf('n') !== -1
    }
    function iA (e) {
      return e.indexOf('w') !== -1
    }
    function aA (e, t) {
      Es.call(this, e),
      this._gridSnapping = t
      const n = this
      this.preExecute('shape.resize', function (e) {
        const t = e.context
        const r = (t.hints || {}).autoResize
        if (r) {
          const o = t.shape
          const i = t.newBounds
          F(r) ? t.newBounds = n.snapComplex(i, r) : t.newBounds = n.snapSimple(o, i)
        }
      }
      )
    }
    function sA (e, t) {
      e.on(['spaceTool.move', 'spaceTool.end'], 2e3, function (e) {
        let n; const r = e.context
        r.initialized && (r.axis === 'x'
          ? (n = t.snapValue(e.dx),
            e.x = e.x + n - e.dx,
            e.dx = n)
          : (n = t.snapValue(e.dy),
            e.y = e.y + n - e.dy,
            e.dy = n))
      }
      )
    }
    nA.prototype.snapEvent = function (e, t, n) {
      rd(e, t, this.snapValue(e[t], n))
    }
    ,
    nA.prototype.getGridSpacing = function () {
      return eA
    }
    ,
    nA.prototype.snapValue = function (e, t) {
      let n; let r; let o = 0
      return t && t.offset && (o = t.offset),
      e = tA(e += o, eA),
      t && t.min && L(n = t.min) && (n = tA(n + o, eA, 'ceil'),
      e = Math.max(e, n)),
      t && t.max && L(r = t.max) && (r = tA(r + o, eA, 'floor'),
      e = Math.min(e, r)),
      e - o
    }
    ,
    nA.prototype.isActive = function () {
      return this.active
    }
    ,
    nA.prototype.setActive = function (e) {
      this.active = e,
      this._eventBus.fire('gridSnapping.toggle', {
        active: e
      })
    }
    ,
    nA.prototype.toggleActive = function () {
      this.setActive(!this.active)
    }
    ,
    nA.$inject = ['elementRegistry', 'eventBus', 'config.gridSnapping'],
    aA.$inject = ['eventBus', 'gridSnapping', 'modeling'],
    w(aA, Es),
    aA.prototype.snapSimple = function (e, t) {
      const n = this._gridSnapping
      return t.width = n.snapValue(t.width, {
        min: t.width
      }),
      t.height = n.snapValue(t.height, {
        min: t.height
      }),
      t.x = e.x + e.width / 2 - t.width / 2,
      t.y = e.y + e.height / 2 - t.height / 2,
      t
    }
    ,
    aA.prototype.snapComplex = function (e, t) {
      return /w|e/.test(t) && (e = this.snapHorizontally(e, t)),
      /n|s/.test(t) && (e = this.snapVertically(e, t)),
      e
    }
    ,
    aA.prototype.snapHorizontally = function (e, t) {
      const n = this._gridSnapping
      const r = /w/.test(t)
      const o = /e/.test(t)
      const i = {}
      return i.width = n.snapValue(e.width, {
        min: e.width
      }),
      o && (r
        ? (i.x = n.snapValue(e.x, {
            max: e.x
          }),
          i.width += n.snapValue(e.x - i.x, {
            min: e.x - i.x
          }))
        : e.x = e.x + e.width - i.width),
      le(e, i),
      e
    }
    ,
    aA.prototype.snapVertically = function (e, t) {
      const n = this._gridSnapping
      const r = /n/.test(t)
      const o = /s/.test(t)
      const i = {}
      return i.height = n.snapValue(e.height, {
        min: e.height
      }),
      r && (o
        ? (i.y = n.snapValue(e.y, {
            max: e.y
          }),
          i.height += n.snapValue(e.y - i.y, {
            min: e.y - i.y
          }))
        : e.y = e.y + e.height - i.height),
      le(e, i),
      e
    }
    ,
    sA.$inject = ['eventBus', 'gridSnapping']
    const cA = {
      __depends__: [{
        __init__: ['gridSnappingResizeBehavior', 'gridSnappingSpaceToolBehavior'],
        gridSnappingResizeBehavior: ['type', aA],
        gridSnappingSpaceToolBehavior: ['type', sA]
      }],
      __init__: ['gridSnapping'],
      gridSnapping: ['type', nA]
    }
    function lA (e, t) {
      e.on('autoPlace', 2e3, function (e) {
        const n = e.source
        const r = _r(n)
        const o = e.shape
        const i = Yp(n, o)
        return ['x', 'y'].forEach(function (e) {
          const n = {}
          i[e] !== r[e] && (i[e] > r[e] ? n.min = i[e] : n.max = i[e],
          Pi(o, 'bpmn:TextAnnotation') && ((function (e) {
            return e === 'x'
          }(e))
            ? n.offset = -o.width / 2
            : n.offset = -o.height / 2),
          i[e] = t.snapValue(i[e], n))
        }
        ),
        i
      }
      )
    }
    function pA (e, t, n) {
      t.on(['create.start', 'shape.move.start'], 1750, function (t) {
        const r = t.context
        const o = r.shape
        const i = e.getRootElement()
        Pi(o, 'bpmn:Participant') && Pi(i, 'bpmn:Process') && i.children.length && r.createConstraints && (o.width = n.snapValue(o.width, {
          min: o.width
        }),
        o.height = n.snapValue(o.height, {
          min: o.height
        }))
      }
      )
    }
    function uA (e, t, n) {
      Es.call(this, e),
      this._gridSnapping = t
      const r = this
      this.postExecuted(['connection.create', 'connection.layout'], 3e3, function (e) {
        const t = e.context
        const o = t.connection
        const i = t.hints || {}
        const a = o.waypoints
        i.connectionStart || i.connectionEnd || !1 === i.createElementsBehavior || (function (e) {
          return e.length > 3
        }(a)) && n.updateWaypoints(o, r.snapMiddleSegments(a))
      }
      )
    }
    function dA (e, t, n) {
      const r = Tn(t, n)
      const o = {}
      return (function (e) {
        return e === 'h'
      }(r)) && (o.y = e.snapValue(t.y)),
      (function (e) {
        return e === 'v'
      }(r)) && (o.x = e.snapValue(t.x)),
      ('x' in o || 'y' in o) && (t = le({}, t, o),
      n = le({}, n, o)),
      [t, n]
    }
    lA.$inject = ['eventBus', 'gridSnapping'],
    pA.$inject = ['canvas', 'eventBus', 'gridSnapping'],
    uA.$inject = ['eventBus', 'gridSnapping', 'modeling'],
    w(uA, Es),
    uA.prototype.snapMiddleSegments = function (e) {
      let t; const n = this._gridSnapping
      e = e.slice()
      for (let r = 1; r < e.length - 2; r++) {
        t = dA(n, e[r], e[r + 1]),
        e[r] = t[0],
        e[r + 1] = t[1]
      }
      return e
    }

    const fA = {
      __depends__: [cA, {
        __init__: ['gridSnappingAutoPlaceBehavior', 'gridSnappingParticipantBehavior', 'gridSnappingLayoutConnectionBehavior'],
        gridSnappingAutoPlaceBehavior: ['type', lA],
        gridSnappingParticipantBehavior: ['type', pA],
        gridSnappingLayoutConnectionBehavior: ['type', uA]
      }],
      __init__: ['bpmnGridSnapping'],
      bpmnGridSnapping: ['type', Zb]
    }
    function hA (e, t) {
      this._interactionEvents = t
      const n = this
      e.on(['interactionEvents.createHit', 'interactionEvents.updateHit'], function (e) {
        const t = e.element
        const r = e.gfx
        return Pi(t, 'bpmn:Lane') ? n._createParticipantHit(t, r) : Pi(t, 'bpmn:Participant') ? Zi(t) ? n._createParticipantHit(t, r) : n._createDefaultHit(t, r) : Pi(t, 'bpmn:SubProcess') ? Zi(t) ? n._createSubProcessHit(t, r) : n._createDefaultHit(t, r) : void 0
      }
      )
    }
    hA.$inject = ['eventBus', 'interactionEvents'],
    hA.prototype._createDefaultHit = function (e, t) {
      return this._interactionEvents.removeHits(t),
      this._interactionEvents.createDefaultHit(e, t),
      !0
    }
    ,
    hA.prototype._createParticipantHit = function (e, t) {
      this._interactionEvents.removeHits(t),
      this._interactionEvents.createBoxHit(t, 'no-move', {
        width: e.width,
        height: e.height
      }),
      this._interactionEvents.createBoxHit(t, 'click-stroke', {
        width: e.width,
        height: e.height
      })
      const n = ea(e)
        ? {
            width: 30,
            height: e.height
          }
        : {
            width: e.width,
            height: 30
          }
      return this._interactionEvents.createBoxHit(t, 'all', n),
      !0
    }
    ,
    hA.prototype._createSubProcessHit = function (e, t) {
      return this._interactionEvents.removeHits(t),
      this._interactionEvents.createBoxHit(t, 'no-move', {
        width: e.width,
        height: e.height
      }),
      this._interactionEvents.createBoxHit(t, 'click-stroke', {
        width: e.width,
        height: e.height
      }),
      this._interactionEvents.createBoxHit(t, 'all', {
        width: e.width,
        height: 30
      }),
      !0
    }

    const mA = {
      __init__: ['bpmnInteractionEvents'],
      bpmnInteractionEvents: ['type', hA]
    }
    function vA (e) {
      e.invoke(ec, this)
    }
    w(vA, ec),
    vA.$inject = ['injector'],
    vA.prototype.registerBindings = function (e, t) {
      function n (n, r) {
        t.isRegistered(n) && e.addListener(r)
      }
      ec.prototype.registerBindings.call(this, e, t),
      n('selectElements', function (n) {
        const r = n.keyEvent
        if (e.isKey(['a', 'A'], r) && e.isCmd(r)) {
          return t.trigger('selectElements'),
          !0
        }
      }
      ),
      n('find', function (n) {
        const r = n.keyEvent
        if (e.isKey(['f', 'F'], r) && e.isCmd(r)) {
          return t.trigger('find'),
          !0
        }
      }
      ),
      n('spaceTool', function (n) {
        const r = n.keyEvent
        if (!e.hasModifier(r)) {
          return e.isKey(['s', 'S'], r)
            ? (t.trigger('spaceTool'),
              !0)
            : void 0
        }
      }
      ),
      n('lassoTool', function (n) {
        const r = n.keyEvent
        if (!e.hasModifier(r)) {
          return e.isKey(['l', 'L'], r)
            ? (t.trigger('lassoTool'),
              !0)
            : void 0
        }
      }
      ),
      n('handTool', function (n) {
        const r = n.keyEvent
        if (!e.hasModifier(r)) {
          return e.isKey(['h', 'H'], r)
            ? (t.trigger('handTool'),
              !0)
            : void 0
        }
      }
      ),
      n('globalConnectTool', function (n) {
        const r = n.keyEvent
        if (!e.hasModifier(r)) {
          return e.isKey(['c', 'C'], r)
            ? (t.trigger('globalConnectTool'),
              !0)
            : void 0
        }
      }
      ),
      n('directEditing', function (n) {
        const r = n.keyEvent
        if (!e.hasModifier(r)) {
          return e.isKey(['e', 'E'], r)
            ? (t.trigger('directEditing'),
              !0)
            : void 0
        }
      }
      ),
      n('replaceElement', function (n) {
        const r = n.keyEvent
        if (!e.hasModifier(r)) {
          return e.isKey(['r', 'R'], r)
            ? (t.trigger('replaceElement', r),
              !0)
            : void 0
        }
      }
      )
    }

    const gA = {
      __depends__: [tc],
      __init__: ['keyboardBindings'],
      keyboardBindings: ['type', vA]
    }
    const yA = {
      moveSpeed: 1,
      moveSpeedAccelerated: 10
    }
    const bA = 'left'
    const AA = 'right'
    const EA = 'down'
    const xA = {
      ArrowLeft: bA,
      Left: bA,
      ArrowUp: 'up',
      Up: 'up',
      ArrowRight: AA,
      Right: AA,
      ArrowDown: EA,
      Down: EA
    }
    const wA = {
      left: function (e) {
        return {
          x: -e,
          y: 0
        }
      },
      up: function (e) {
        return {
          x: 0,
          y: -e
        }
      },
      right: function (e) {
        return {
          x: e,
          y: 0
        }
      },
      down: function (e) {
        return {
          x: 0,
          y: e
        }
      }
    }
    function _A (e, t, n, r, o) {
      const i = this
      this._config = le({}, yA, e || {}),
      t.addListener(1500, function (e) {
        const n = e.keyEvent
        const r = xA[n.key]
        if (r && !t.isCmd(n)) {
          const o = t.isShift(n)
          return i.moveSelection(r, o),
          !0
        }
      }
      ),
      this.moveSelection = function (e, t) {
        const i = o.get()
        if (i.length) {
          const a = this._config[t ? 'moveSpeedAccelerated' : 'moveSpeed']
          const s = wA[e](a)
          r.allowed('elements.move', {
            shapes: i
          }) && n.moveElements(i, s)
        }
      }
    }
    _A.$inject = ['config.keyboardMoveSelection', 'keyboard', 'modeling', 'rules', 'selection']
    const CA = {
      __depends__: [tc, us],
      __init__: ['keyboardMoveSelection'],
      keyboardMoveSelection: ['type', _A]
    }
    function SA (e, t, n, r) {
      this._dragging = r,
      this._rules = t
      const o = this
      e.on('resize.start', function (e) {
        let t, n, r
        n = (t = e.context).resizeConstraints,
        r = t.minBounds,
        void 0 === n && (void 0 === r && (r = o.computeMinResizeBox(t)),
        t.resizeConstraints = {
          min: xr(r)
        })
      }
      ),
      e.on('resize.move', function (e) {
        const t = {
          x: e.dx,
          y: e.dy
        }
        !(function (e, t) {
          let n; const r = e.shape; const i = e.direction; const a = e.resizeConstraints
          e.delta = t,
          n = (function (e, t, n) {
            const r = n.x
            const o = n.y
            const i = {
              x: e.x,
              y: e.y,
              width: e.width,
              height: e.height
            }
            return t.indexOf('n') !== -1
              ? (i.y = e.y + o,
                i.height = e.height - o)
              : t.indexOf('s') !== -1 && (i.height = e.height + o),
            t.indexOf('e') !== -1
              ? i.width = e.width + r
              : t.indexOf('w') !== -1 && (i.x = e.x + r,
              i.width = e.width - r),
            i
          }(r, i, t)),
          e.newBounds = (function (e, t) {
            if (!t) { return e }
            const n = xr(e)
            return wr({
              top: of('top', n, t),
              right: of('right', n, t),
              bottom: of('bottom', n, t),
              left: of('left', n, t)
            })
          }(n, a)),
          e.canExecute = o.canResize(e)
        }(e.context, t))
      }
      ),
      e.on('resize.end', function (e) {
        !(function (e) {
          const t = e.shape
          const r = e.canExecute
          let o = e.newBounds
          if (r) {
            if (!(function (e, t) {
              return e.x !== t.x || e.y !== t.y || e.width !== t.width || e.height !== t.height
            }(t, o = Ar(o)))) { return }
            n.resizeShape(t, o)
          }
        }(e.context))
      }
      )
    }
    function kA (e, t) {
      const n = _r(e)
      const r = xr(e)
      const o = {
        x: n.x,
        y: n.y
      }
      return t.indexOf('n') !== -1 ? o.y = r.top : t.indexOf('s') !== -1 && (o.y = r.bottom),
      t.indexOf('e') !== -1 ? o.x = r.right : t.indexOf('w') !== -1 && (o.x = r.left),
      o
    }
    function jA (e) {
      const t = 'resize-'
      return e === 'n' || e === 's' ? t + 'ns' : e === 'e' || e === 'w' ? t + 'ew' : e === 'nw' || e === 'se' ? t + 'nwse' : t + 'nesw'
    }
    SA.prototype.canResize = function (e) {
      const t = this._rules
      const n = pe(e, ['newBounds', 'shape', 'delta', 'direction'])
      return t.allowed('shape.resize', n)
    }
    ,
    SA.prototype.activate = function (e, t, n) {
      let r; let o; const i = this._dragging
      if (typeof n === 'string' && (n = {
        direction: n
      }),
      !(o = (r = le({
        shape: t
      }, n)).direction)) { throw new Error('must provide a direction (n|w|s|e|nw|se|ne|sw)') }
      i.init(e, kA(t, o), 'resize', {
        autoActivate: !0,
        cursor: jA(o),
        data: {
          shape: t,
          context: r
        }
      })
    }
    ,
    SA.prototype.computeMinResizeBox = function (e) {
      let t; let n; let r; let o; let i; let a; let s; const c = e.shape
      return t = e.direction,
      n = c,
      r = e.minDimensions || {
        width: 10,
        height: 10
      },
      o = cf(c, e.childrenBoxPadding),
      i = xr(n),
      a = {
        top: /n/.test(t) ? i.bottom - r.height : i.top,
        left: /w/.test(t) ? i.right - r.width : i.left,
        bottom: /s/.test(t) ? i.top + r.height : i.bottom,
        right: /e/.test(t) ? i.left + r.width : i.right
      },
      s = o ? xr(o) : a,
      wr({
        top: ef(a.top, s.top),
        left: ef(a.left, s.left),
        bottom: Zd(a.bottom, s.bottom),
        right: Zd(a.right, s.right)
      })
    }
    ,
    SA.$inject = ['eventBus', 'rules', 'modeling', 'dragging']
    const BA = 'djs-resizing'
    const DA = 'resize-not-ok'
    function PA (e, t, n) {
      e.on('resize.move', 500, function (e) {
        let r, o, i, a
        o = (r = e.context).shape,
        i = r.newBounds,
        (a = r.frame) || (a = r.frame = n.addFrame(o, t.getActiveLayer()),
        t.addMarker(o, BA)),
        i.width > 5 && We(a, {
          x: i.x,
          width: i.width
        }),
        i.height > 5 && We(a, {
          y: i.y,
          height: i.height
        }),
        r.canExecute ? Ue(a).remove(DA) : Ue(a).add(DA)
      }
      ),
      e.on('resize.cleanup', function (e) {
        let n, r
        r = (n = e.context).shape,
        n.frame && Qe(n.frame),
        t.removeMarker(r, BA)
      }
      )
    }
    PA.$inject = ['eventBus', 'canvas', 'previewSupport']
    const OA = 'djs-resizer'
    const TA = ['n', 'w', 's', 'e', 'nw', 'ne', 'se', 'sw']
    function RA (e, t, n, r) {
      this._resize = r,
      this._canvas = t
      const o = this
      e.on('selection.changed', function (e) {
        const t = e.newSelection
        o.removeResizers(),
        t.length === 1 && G(t, ce(o.addResizer, o))
      }
      ),
      e.on('shape.changed', function (e) {
        const t = e.element
        n.isSelected(t) && (o.removeResizers(),
        o.addResizer(t))
      }
      )
    }
    RA.prototype.makeDraggable = function (e, t, n) {
      const r = this._resize
      function o (t) {
        Ka(t) && r.activate(t, e, n)
      }
      vn.bind(t, 'mousedown', o),
      vn.bind(t, 'touchstart', o)
    }
    ,
    RA.prototype._createResizer = function (e, t, n, r) {
      const o = this._getResizersParent()
      const i = (function (e) {
        const t = {
          x: 0,
          y: 0
        }
        return e.indexOf('e') !== -1 ? t.x = 6 : e.indexOf('w') !== -1 && (t.x = -6),
        e.indexOf('s') !== -1 ? t.y = 6 : e.indexOf('n') !== -1 && (t.y = -6),
        t
      }(r))
      const a = et('g')
      Ue(a).add(OA),
      Ue(a).add(OA + '-' + e.id),
      Ue(a).add(OA + '-' + r),
      Fe(o, a)
      const s = et('rect')
      We(s, {
        x: -4 + i.x,
        y: -4 + i.y,
        width: 8,
        height: 8
      }),
      Ue(s).add(OA + '-visual'),
      Fe(a, s)
      const c = et('rect')
      return We(c, {
        x: -10 + i.x,
        y: -10 + i.y,
        width: 20,
        height: 20
      }),
      Ue(c).add(OA + '-hit'),
      Fe(a, c),
      no(a, t, n),
      a
    }
    ,
    RA.prototype.createResizer = function (e, t) {
      const n = kA(e, t)
      const r = this._createResizer(e, n.x, n.y, t)
      this.makeDraggable(e, r, t)
    }
    ,
    RA.prototype.addResizer = function (e) {
      const t = this
      !yr(e) && this._resize.canResize({
        shape: e
      }) && G(TA, function (n) {
        t.createResizer(e, n)
      }
      )
    }
    ,
    RA.prototype.removeResizers = function () {
      Ye(this._getResizersParent())
    }
    ,
    RA.prototype._getResizersParent = function () {
      return this._canvas.getLayer('resizers')
    }
    ,
    RA.$inject = ['eventBus', 'canvas', 'selection', 'resize']
    const NA = {
      __depends__: [hu, pu, Ad],
      __init__: ['resize', 'resizePreview', 'resizeHandles'],
      resize: ['type', SA],
      resizePreview: ['type', PA],
      resizeHandles: ['type', RA]
    }
    function MA (e, t, n, r, o, i, a) {
      function s (e, t) {
        (t || Oi(e, ['bpmn:Task', 'bpmn:TextAnnotation', 'bpmn:Participant']) || IA(e)) && r.activate(e)
      }
      this._bpmnFactory = t,
      this._canvas = n,
      this._modeling = o,
      this._textRenderer = a,
      r.registerProvider(this),
      e.on('element.dblclick', function (e) {
        s(e.element, !0)
      }
      ),
      e.on(['autoPlace.start', 'canvas.viewbox.changing', 'drag.init', 'element.mousedown', 'popupMenu.open', 'root.set', 'selection.changed'], function () {
        r.isActive() && r.complete()
      }
      ),
      e.on(['shape.remove', 'connection.remove'], 2e3, function (e) {
        r.isActive(e.element) && r.cancel()
      }
      ),
      e.on(['commandStack.changed'], function (e) {
        r.isActive() && r.cancel()
      }
      ),
      e.on('directEditing.activate', function (e) {
        i.removeResizers()
      }
      ),
      e.on('create.end', 500, function (e) {
        const t = e.context
        const n = t.shape
        const r = e.context.canExecute
        e.isTouch || r && (t.hints && !1 === t.hints.createElementsBehavior || s(n))
      }
      ),
      e.on('autoPlace.end', 500, function (e) {
        s(e.shape)
      }
      )
    }
    function IA (e) {
      return Pi(e, 'bpmn:SubProcess') && !Zi(e)
    }
    MA.$inject = ['eventBus', 'bpmnFactory', 'canvas', 'directEditing', 'modeling', 'resizeHandles', 'textRenderer'],
    MA.prototype.activate = function (e) {
      const t = la(e)
      if (void 0 !== t) {
        const n = {
          text: t
        }
        le(n, this.getEditingBBox(e))
        const r = {}
        return (Oi(e, ['bpmn:Task', 'bpmn:Participant', 'bpmn:Lane', 'bpmn:CallActivity']) || IA(e)) && le(r, {
          centerVertically: !0
        }),
        ia(e) && le(r, {
          autoResize: !0
        }),
        Pi(e, 'bpmn:TextAnnotation') && le(r, {
          resizable: !0,
          autoResize: !0
        }),
        le(n, {
          options: r
        }),
        n
      }
    }
    ,
    MA.prototype.getEditingBBox = function (e) {
      const t = this._canvas
      const n = e.label || e
      const r = t.getAbsoluteBBox(n)
      const o = r.x + r.width / 2
      const i = r.y + r.height / 2
      const a = {
        x: r.x,
        y: r.y
      }
      const s = t.zoom()
      const c = this._textRenderer.getDefaultStyle()
      const l = this._textRenderer.getExternalStyle()
      const p = l.fontSize * s
      const u = l.lineHeight
      const d = c.fontSize * s
      const f = c.lineHeight
      const h = {
        fontFamily: this._textRenderer.getDefaultStyle().fontFamily,
        fontWeight: this._textRenderer.getDefaultStyle().fontWeight
      }
      if (Pi(e, 'bpmn:Lane') || (function (e) {
        return Pi(e, 'bpmn:Participant') && Zi(e)
      }(e))) {
        const m = ea(e)
        le(a, m
          ? {
              width: r.height,
              height: 30 * s,
              x: r.x - r.height / 2 + 15 * s,
              y: i - 30 * s / 2
            }
          : {
              width: r.width,
              height: 30 * s
            }),
        le(h, {
          fontSize: d + 'px',
          lineHeight: f,
          paddingTop: 7 * s + 'px',
          paddingBottom: 7 * s + 'px',
          paddingLeft: 5 * s + 'px',
          paddingRight: 5 * s + 'px',
          transform: m ? 'rotate(-90deg)' : null
        })
      }
      if (function (e) {
        return Pi(e, 'bpmn:Participant') && !Zi(e)
      }(e)) {
        const v = ea(e)
        le(a, v
          ? {
              width: r.width,
              height: r.height
            }
          : {
              width: r.height,
              height: r.width,
              x: o - r.height / 2,
              y: i - r.width / 2
            }),
        le(h, {
          fontSize: d + 'px',
          lineHeight: f,
          paddingTop: 7 * s + 'px',
          paddingBottom: 7 * s + 'px',
          paddingLeft: 5 * s + 'px',
          paddingRight: 5 * s + 'px',
          transform: v ? null : 'rotate(-90deg)'
        })
      }
      (Oi(e, ['bpmn:Task', 'bpmn:CallActivity']) || IA(e)) && (le(a, {
        width: r.width,
        height: r.height
      }),
      le(h, {
        fontSize: d + 'px',
        lineHeight: f,
        paddingTop: 7 * s + 'px',
        paddingBottom: 7 * s + 'px',
        paddingLeft: 5 * s + 'px',
        paddingRight: 5 * s + 'px'
      })),
      (function (e) {
        return Pi(e, 'bpmn:SubProcess') && Zi(e)
      }(e)) && (le(a, {
        width: r.width,
        x: r.x
      }),
      le(h, {
        fontSize: d + 'px',
        lineHeight: f,
        paddingTop: 7 * s + 'px',
        paddingBottom: 7 * s + 'px',
        paddingLeft: 5 * s + 'px',
        paddingRight: 5 * s + 'px'
      }))
      const g = 90 * s
      const y = 7 * s
      const b = 4 * s
      if (n.labelTarget && (le(a, {
        width: g,
        height: r.height + y + b,
        x: o - g / 2,
        y: r.y - y
      }),
      le(h, {
        fontSize: p + 'px',
        lineHeight: u,
        paddingTop: y + 'px',
        paddingBottom: b + 'px'
      })),
      ia(n) && !aa(n) && !br(n)) {
        const A = sa(e)
        const E = t.getAbsoluteBBox({
          x: A.x,
          y: A.y,
          width: 0,
          height: 0
        })
        const x = p + y + b
        le(a, {
          width: g,
          height: x,
          x: E.x - g / 2,
          y: E.y - x / 2
        }),
        le(h, {
          fontSize: p + 'px',
          lineHeight: u,
          paddingTop: y + 'px',
          paddingBottom: b + 'px'
        })
      }
      return Pi(e, 'bpmn:TextAnnotation') && (le(a, {
        width: r.width,
        height: r.height,
        minWidth: 30 * s,
        minHeight: 10 * s
      }),
      le(h, {
        textAlign: 'left',
        paddingTop: 5 * s + 'px',
        paddingBottom: 7 * s + 'px',
        paddingLeft: 7 * s + 'px',
        paddingRight: 5 * s + 'px',
        fontSize: d + 'px',
        lineHeight: f
      })),
      {
        bounds: a,
        style: h
      }
    }
    ,
    MA.prototype.update = function (e, t, n, r) {
      let o, i, a
      Pi(e, 'bpmn:TextAnnotation') && (i = this._canvas.getAbsoluteBBox(e),
      o = {
        x: e.x,
        y: e.y,
        width: e.width / i.width * r.width,
        height: e.height / i.height * r.height
      }),
      (a = t) && a.trim() || (t = null),
      this._modeling.updateLabel(e, t, o)
    }

    const LA = 'djs-element-hidden'
    const zA = 'djs-label-hidden'
    function FA (e, t, n) {
      let r; let o; let i; const a = this; const s = t.getDefaultLayer()
      e.on('directEditing.activate', function (e) {
        const c = e.active
        if (Pi(r = c.element.label || c.element, 'bpmn:TextAnnotation')) {
          o = t.getAbsoluteBBox(r),
          i = et('g')
          const l = n.getScaledPath('TEXT_ANNOTATION', {
            xScaleFactor: 1,
            yScaleFactor: 1,
            containerWidth: r.width,
            containerHeight: r.height,
            position: {
              mx: 0,
              my: 0
            }
          })
          const p = a.path = et('path')
          We(p, {
            d: l,
            strokeWidth: 2,
            stroke: $A(r)
          }),
          Fe(i, p),
          Fe(s, i),
          ro(i, r.x, r.y)
        }
        Pi(r, 'bpmn:TextAnnotation') || r.labelTarget ? t.addMarker(r, LA) : (Pi(r, 'bpmn:Task') || Pi(r, 'bpmn:CallActivity') || Pi(r, 'bpmn:SubProcess') || Pi(r, 'bpmn:Participant')) && t.addMarker(r, zA)
      }
      ),
      e.on('directEditing.resize', function (e) {
        if (Pi(r, 'bpmn:TextAnnotation')) {
          const t = e.height
          const i = e.dy
          const s = Math.max(r.height / o.height * (t + i), 0)
          const c = n.getScaledPath('TEXT_ANNOTATION', {
            xScaleFactor: 1,
            yScaleFactor: 1,
            containerWidth: r.width,
            containerHeight: s,
            position: {
              mx: 0,
              my: 0
            }
          })
          We(a.path, {
            d: c
          })
        }
      }
      ),
      e.on(['directEditing.complete', 'directEditing.cancel'], function (e) {
        const n = e.active
        n && (t.removeMarker(n.element.label || n.element, LA),
        t.removeMarker(r, zA)),
        r = void 0,
        o = void 0,
        i && (Qe(i),
        i = void 0)
      }
      )
    }
    function $A (e, t) {
      return Ri(e).get('stroke') || t || 'black'
    }
    FA.$inject = ['eventBus', 'canvas', 'pathMap']
    const HA = {
      __depends__: [As, NA, fb],
      __init__: ['labelEditingProvider', 'labelEditingPreview'],
      labelEditingProvider: ['type', MA],
      labelEditingPreview: ['type', FA]
    }
    const qA = new ds('tt')
    function WA (e, t) {
      e.style.display = !1 === t ? 'none' : ''
    }
    const GA = 'djs-tooltip'
    const UA = '.' + GA
    function VA (e, t) {
      let n, r
      this._eventBus = e,
      this._canvas = t,
      this._ids = qA,
      this._tooltipDefaults = {
        show: {
          minZoom: 0.7,
          maxZoom: 5
        }
      },
      this._tooltips = {},
      this._tooltipRoot = (n = t.getContainer(),
      Zt(r = xn('<div class="djs-tooltip-container" />'), {
        position: 'absolute',
        width: '0',
        height: '0'
      }),
      n.insertBefore(r, n.firstChild),
      r)
      const o = this
      yn(this._tooltipRoot, UA, 'mousedown', function (e) {
        e.stopPropagation()
      }
      ),
      yn(this._tooltipRoot, UA, 'mouseover', function (e) {
        o.trigger('mouseover', e)
      }
      ),
      yn(this._tooltipRoot, UA, 'mouseout', function (e) {
        o.trigger('mouseout', e)
      }
      ),
      this._init()
    }
    VA.$inject = ['eventBus', 'canvas'],
    VA.prototype.add = function (e) {
      if (!e.position) { throw new Error('must specifiy tooltip position') }
      if (!e.html) { throw new Error('must specifiy tooltip html') }
      const t = this._ids.next()
      return e = le({}, this._tooltipDefaults, e, {
        id: t
      }),
      this._addTooltip(e),
      e.timeout && this.setTimeout(e),
      t
    }
    ,
    VA.prototype.trigger = function (e, t) {
      const n = t.delegateTarget || t.target
      const r = this.get(en(n, 'data-tooltip-id'))
      r && (e === 'mouseover' && r.timeout && this.clearTimeout(r),
      e === 'mouseout' && r.timeout && (r.timeout = 1e3,
      this.setTimeout(r)))
    }
    ,
    VA.prototype.get = function (e) {
      return typeof e !== 'string' && (e = e.id),
      this._tooltips[e]
    }
    ,
    VA.prototype.clearTimeout = function (e) {
      if (e = this.get(e)) {
        const t = e.removeTimer
        t && (clearTimeout(t),
        e.removeTimer = null)
      }
    }
    ,
    VA.prototype.setTimeout = function (e) {
      if (e = this.get(e)) {
        this.clearTimeout(e)
        const t = this
        e.removeTimer = setTimeout(function () {
          t.remove(e)
        }
        , e.timeout)
      }
    }
    ,
    VA.prototype.remove = function (e) {
      const t = this.get(e)
      t && (Cn(t.html),
      Cn(t.htmlContainer),
      delete t.htmlContainer,
      delete this._tooltips[t.id])
    }
    ,
    VA.prototype.show = function () {
      WA(this._tooltipRoot)
    }
    ,
    VA.prototype.hide = function () {
      WA(this._tooltipRoot, !1)
    }
    ,
    VA.prototype._updateRoot = function (e) {
      const t = e.scale || 1
      const n = e.scale || 1
      const r = 'matrix(' + t + ',0,0,' + n + ',' + -1 * e.x * t + ',' + -1 * e.y * n + ')'
      this._tooltipRoot.style.transform = r,
      this._tooltipRoot.style['-ms-transform'] = r
    }
    ,
    VA.prototype._addTooltip = function (e) {
      let t; const n = e.id; let r = e.html; const o = this._tooltipRoot
      r.get && r.constructor.prototype.jquery && (r = r.get(0)),
      F(r) && (r = xn(r)),
      Zt(t = xn('<div data-tooltip-id="' + n + '" class="' + GA + '">'), {
        position: 'absolute'
      }),
      t.appendChild(r),
      e.type && nn(t).add('djs-tooltip-' + e.type),
      e.className && nn(t).add(e.className),
      e.htmlContainer = t,
      o.appendChild(t),
      this._tooltips[n] = e,
      this._updateTooltip(e)
    }
    ,
    VA.prototype._updateTooltip = function (e) {
      const t = e.position
      !(function (e, t, n) {
        Zt(e, {
          left: t + 'px',
          top: n + 'px'
        })
      }(e.htmlContainer, t.x, t.y))
    }
    ,
    VA.prototype._updateTooltipVisibilty = function (e) {
      G(this._tooltips, function (t) {
        const n = t.show
        const r = t.htmlContainer
        let o = !0
        n && ((n.minZoom > e.scale || n.maxZoom < e.scale) && (o = !1),
        WA(r, o))
      }
      )
    }
    ,
    VA.prototype._init = function () {
      const e = this
      this._eventBus.on('canvas.viewbox.changing', function (t) {
        e.hide()
      }
      ),
      this._eventBus.on('canvas.viewbox.changed', function (t) {
        let n
        n = t.viewbox,
        e._updateRoot(n),
        e._updateTooltipVisibilty(n),
        e.show()
      }
      )
    }

    const QA = {
      __init__: ['tooltips'],
      tooltips: ['type', VA]
    }
    function YA (e, t, n) {
      e.on(['shape.move.rejected', 'create.rejected'], function (e) {
        let r; let o; const i = e.context; const a = i.shape
        Pi(i.target, 'bpmn:Collaboration') && Pi(a, 'bpmn:FlowNode') && (r = e,
        o = n('flow elements must be children of pools/participants'),
        t.add({
          position: {
            x: r.x + 5,
            y: r.y + 5
          },
          type: 'error',
          timeout: 2e3,
          html: '<div>' + o + '</div>'
        }))
      }
      )
    }
    YA.$inject = ['eventBus', 'tooltips', 'translate']
    const KA = {
      __depends__: [QA],
      __init__: ['modelingFeedback'],
      modelingFeedback: ['type', YA]
    }
    const JA = Math.round
    function XA (e, t, n, r, o) {
      function i (e, t, n, r) {
        return o.allowed('elements.move', {
          shapes: e,
          delta: t,
          position: n,
          target: r
        })
      }
      function a (e, n, r, o) {
        if (I(r) && (o = r,
        r = !1),
        !n.waypoints && n.parent && !Ue(e.target).has('djs-hit-no-move')) {
          const i = (function (e) {
            return {
              x: e.x + JA(e.width / 2),
              y: e.y + JA(e.height / 2)
            }
          }(n))
          return t.init(e, i, 'shape.move', {
            cursor: 'grabbing',
            autoActivate: r,
            data: {
              shape: n,
              context: o || {}
            }
          }),
          !0
        }
      }
      e.on('shape.move.start', 1500, function (e) {
        const t = e.context
        const n = e.shape
        let o = r.get().slice()
        o.indexOf(n) === -1 && (o = [n]),
        o = (function (e) {
          const t = X(e, 'id')
          return W(e, function (e) {
            for (; e = e.parent;) {
              if (t[e.id]) { return !1 }
            }
            return !0
          }
          )
        }(o)),
        le(t, {
          shapes: o,
          validatedShapes: o,
          shape: n
        })
      }
      ),
      e.on('shape.move.start', 1250, function (e) {
        const t = e.context
        const n = t.validatedShapes
        if (!(t.canExecute = i(n))) { return !1 }
      }
      ),
      e.on('shape.move.move', 500, function (e) {
        let t; const n = e.context; const r = n.validatedShapes; const o = e.hover; const a = {
          x: e.dx,
          y: e.dy
        }
        t = i(r, a, {
          x: e.x,
          y: e.y
        }, o),
        n.delta = a,
        n.canExecute = t,
        n.target = t !== null ? o : null
      }
      ),
      e.on('shape.move.end', function (e) {
        const t = e.context
        const r = t.delta
        const o = t.canExecute
        const i = o === 'attach'
        const a = t.shapes
        if (!1 === o) { return !1 }
        r.x = JA(r.x),
        r.y = JA(r.y),
        r.x === 0 && r.y === 0 || n.moveElements(a, r, t.target, {
          primaryShape: t.shape,
          attach: i
        })
      }
      ),
      e.on('element.mousedown', function (e) {
        if (Ka(e)) {
          const t = Ga(e)
          if (!t) { throw new Error('must supply DOM mousedown event') }
          return a(t, e.element)
        }
      }
      ),
      this.start = a
    }
    XA.$inject = ['eventBus', 'dragging', 'modeling', 'selection', 'rules']
    const ZA = 'djs-dragging'
    const eE = 'drop-ok'
    const tE = 'drop-not-ok'
    const nE = 'new-parent'
    const rE = 'attach-ok'
    function oE (e, t, n, r) {
      function o (e) {
        const t = zt(e, !0)
        const n = Y(t, function (e) {
          return (e.incoming || []).concat(e.outgoing || [])
        }
        )
        return D(t.concat(n))
      }
      function i (e, n) {
        [rE, eE, tE, nE].forEach(function (r) {
          r === n ? t.addMarker(e, r) : t.removeMarker(e, r)
        }
        )
      }
      e.on('shape.move.start', 499, function (e) {
        let i; let a; const s = e.context; const c = s.shapes; let l = s.allDraggedElements; const p = W(i = o(c), function (e) {
          return !yr(e) || H(i, ne({
            id: e.source.id
          })) && H(i, ne({
            id: e.target.id
          }))
        }
        )
        if (!s.dragGroup) {
          const u = et('g')
          We(u, n.cls('djs-drag-group', ['no-events'])),
          Fe(t.getActiveLayer(), u),
          s.dragGroup = u
        }
        p.forEach(function (e) {
          r.addDragger(e, s.dragGroup)
        }
        ),
        G(l = l ? D([l, o(c)]) : o(c), function (e) {
          t.addMarker(e, ZA)
        }
        ),
        s.allDraggedElements = l,
        s.differentParents = (a = X(c, function (e) {
          return e.parent && e.parent.id
        }
        ),
        K(a).length) !== 1
      }
      ),
      e.on('shape.move.move', 499, function (e) {
        const t = e.context
        const n = t.dragGroup
        const r = t.target
        const o = t.shape.parent
        const a = t.canExecute
        r && (a === 'attach' ? i(r, rE) : t.canExecute && r && r.id !== o.id ? i(r, nE) : i(r, t.canExecute ? eE : tE)),
        ro(n, e.dx, e.dy)
      }
      ),
      e.on(['shape.move.out', 'shape.move.cleanup'], function (e) {
        const t = e.context.target
        t && i(t, null)
      }
      ),
      e.on('shape.move.cleanup', function (e) {
        const n = e.context
        const r = n.allDraggedElements
        const o = n.dragGroup
        G(r, function (e) {
          t.removeMarker(e, ZA)
        }
        ),
        o && Qe(o)
      }
      ),
      this.makeDraggable = function (e, n, o) {
        r.addDragger(n, e.dragGroup),
        o && t.addMarker(n, ZA),
        e.allDraggedElements ? e.allDraggedElements.push(n) : e.allDraggedElements = [n]
      }
    }
    oE.$inject = ['eventBus', 'canvas', 'styles', 'previewSupport']
    const iE = {
      __depends__: [ns, us, os, hu, pu, Ad],
      __init__: ['move', 'movePreview'],
      move: ['type', XA],
      movePreview: ['type', oE]
    }
    function aE (e) {
      return aE = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      aE(e)
    }
    function sE (e, t) {
      const n = Object.keys(e)
      if (Object.getOwnPropertySymbols) {
        let r = Object.getOwnPropertySymbols(e)
        t && (r = r.filter(function (t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable
        }
        )),
        n.push.apply(n, r)
      }
      return n
    }
    const cE = {
      width: 36,
      height: 50
    }
    const lE = {
      width: 50,
      height: 50
    }
    function pE (e, t, n) {
      return et('path', (function (e) {
        for (let t = 1; t < arguments.length; t++) {
          var n = arguments[t] != null ? arguments[t] : {}
          t % 2
            ? sE(Object(n), !0).forEach(function (t) {
              let r, o, i
              r = e,
              o = t,
              i = n[t],
              o = (function (e) {
                const t = (function (e, t) {
                  if (aE(e) != 'object' || !e) { return e }
                  const n = e[Symbol.toPrimitive]
                  if (void 0 !== n) {
                    const r = n.call(e, 'string')
                    if (aE(r) != 'object') { return r }
                    throw new TypeError('@@toPrimitive must return a primitive value.')
                  }
                  return String(e)
                }(e))
                return aE(t) == 'symbol' ? t : t + ''
              }(o)),
              o in r
                ? Object.defineProperty(r, o, {
                  value: i,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0
                })
                : r[o] = i
            }
            )
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
              : sE(Object(n)).forEach(function (t) {
                Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
              }
              )
        }
        return e
      }({
        d: e,
        strokeWidth: 2,
        transform: 'translate('.concat(t.x, ', ').concat(t.y, ')')
      }, n)))
    }
    function uE (e, t) {
      this._styles = t,
      e.registerProvider(this)
    }
    function dE (e, t) {
      let n
      return t === 'bpmn:DataObjectReference' ? n = cE : t === 'bpmn:DataStoreReference' && (n = lE),
      e.width === n.width && e.height === n.height
    }
    uE.$inject = ['outline', 'styles'],
    uE.prototype.getOutline = function (e) {
      let t; const n = this._styles.cls('djs-outline', ['no-fill'])
      if (!br(e)) {
        return Pi(e, 'bpmn:Gateway')
          ? (le((t = et('rect')).style, {
              'transform-box': 'fill-box',
              transform: 'rotate(45deg)',
              'transform-origin': 'center'
            }),
            We(t, le({
              x: 2,
              y: 2,
              rx: 4,
              width: e.width - 4,
              height: e.height - 4
            }, n)))
          : Oi(e, ['bpmn:Task', 'bpmn:SubProcess', 'bpmn:Group'])
            ? We(t = et('rect'), le({
              x: -5,
              y: -5,
              rx: 14,
              width: e.width + 10,
              height: e.height + 10
            }, n))
            : Pi(e, 'bpmn:EndEvent')
              ? We(t = et('circle'), le({
                cx: e.width / 2,
                cy: e.height / 2,
                r: e.width / 2 + 5 + 1
              }, n))
              : Pi(e, 'bpmn:Event')
                ? We(t = et('circle'), le({
                  cx: e.width / 2,
                  cy: e.height / 2,
                  r: e.width / 2 + 5
                }, n))
                : Pi(e, 'bpmn:DataObjectReference') && dE(e, 'bpmn:DataObjectReference')
                  ? t = pE('M44.7648 11.3263L36.9892 2.64074C36.0451 1.58628 34.5651 0.988708 33.1904 0.988708H5.98667C3.22688 0.988708 0.989624 3.34892 0.989624 6.26039V55.0235C0.989624 57.9349 3.22688 60.2952 5.98667 60.2952H40.966C43.7257 60.2952 45.963 57.9349 45.963 55.0235V14.9459C45.963 13.5998 45.6407 12.3048 44.7648 11.3263Z', {
                    x: -6,
                    y: -6
                  }, n)
                  : Pi(e, 'bpmn:DataStoreReference') && dE(e, 'bpmn:DataStoreReference') && (t = pE('M1.03845 48.1347C1.03845 49.3511 1.07295 50.758 1.38342 52.064C1.69949 53.3938 2.32428 54.7154 3.56383 55.6428C6.02533 57.4841 10.1161 58.7685 14.8212 59.6067C19.5772 60.4538 25.1388 60.8738 30.6831 60.8738C36.2276 60.8738 41.7891 60.4538 46.545 59.6067C51.2504 58.7687 55.3412 57.4842 57.8028 55.6429C59.0424 54.7156 59.6673 53.3938 59.9834 52.064C60.2938 50.7579 60.3285 49.351 60.3285 48.1344V13.8415C60.3285 12.6249 60.2938 11.218 59.9834 9.91171C59.6673 8.58194 59.0423 7.2602 57.8027 6.33294C55.341 4.49168 51.2503 3.20723 46.545 2.36914C41.7891 1.522 36.2276 1.10204 30.6831 1.10205C25.1388 1.10206 19.5772 1.52206 14.8213 2.36923C10.1162 3.20734 6.02543 4.49183 3.5639 6.33314C2.32433 7.26038 1.69951 8.58206 1.38343 9.91181C1.07295 11.2179 1.03845 12.6247 1.03845 13.8411V48.1347Z', {
                    x: -6,
                    y: -6
                  }, n)),
        t
      }
    }
    ,
    uE.prototype.updateOutline = function (e, t) {
      if (!br(e)) {
        return Oi(e, ['bpmn:SubProcess', 'bpmn:Group'])
          ? (We(t, {
              width: e.width + 10,
              height: e.height + 10
            }),
            !0)
          : !!Oi(e, ['bpmn:Event', 'bpmn:Gateway', 'bpmn:DataStoreReference', 'bpmn:DataObjectReference'])
      }
    }

    const fE = {
      __depends__: [os],
      __init__: ['outlineProvider'],
      outlineProvider: ['type', uE]
    }
    const hE = '.djs-palette-toggle'
    const mE = '.entry'
    const vE = hE + ', ' + mE
    const gE = 'djs-palette-'
    const yE = 'open'
    const bE = 'two-column'
    function AE (e, t) {
      this._eventBus = e,
      this._canvas = t
      const n = this
      e.on('tool-manager.update', function (e) {
        const t = e.tool
        n.updateToolHighlight(t)
      }
      ),
      e.on('i18n.changed', function () {
        n._update()
      }
      ),
      e.on('diagram.init', function () {
        n._diagramInitialized = !0,
        n._rebuild()
      }
      )
    }
    function EE (e, t) {
      const n = t.getPaletteEntries()
      return z(n)
        ? n(e)
        : (G(n, function (t, n) {
            e[n] = t
          }
          ),
          e)
    }
    AE.$inject = ['eventBus', 'canvas'],
    AE.prototype.registerProvider = function (e, t) {
      t || (t = e,
      e = 1e3),
      this._eventBus.on('palette.getProviders', e, function (e) {
        e.providers.push(t)
      }
      ),
      this._rebuild()
    }
    ,
    AE.prototype.getEntries = function () {
      return this._getProviders().reduce(EE, {})
    }
    ,
    AE.prototype._rebuild = function () {
      this._diagramInitialized && this._getProviders().length && (this._container || this._init(),
      this._update())
    }
    ,
    AE.prototype._init = function () {
      const e = this
      const t = this._eventBus
      const n = this._getParentContainer()
      const r = this._container = xn(AE.HTML_MARKUP)
      n.appendChild(r),
      nn(n).add(gE + 'shown'),
      yn(r, vE, 'click', function (t) {
        if (an(t.delegateTarget, hE)) { return e.toggle() }
        e.trigger('click', t)
      }
      ),
      vn.bind(r, 'mousedown', function (e) {
        e.stopPropagation()
      }
      ),
      yn(r, mE, 'dragstart', function (t) {
        e.trigger('dragstart', t)
      }
      ),
      t.on('canvas.resized', this._layoutChanged, this),
      t.fire('palette.create', {
        container: r
      })
    }
    ,
    AE.prototype._getProviders = function (e) {
      const t = this._eventBus.createEvent({
        type: 'palette.getProviders',
        providers: []
      })
      return this._eventBus.fire(t),
      t.providers
    }
    ,
    AE.prototype._toggleState = function (e) {
      e = e || {}
      let t; const n = this._getParentContainer(); const r = this._container; const o = this._eventBus; const i = nn(r); const a = nn(n)
      t = 'twoColumn' in e ? e.twoColumn : this._needsCollapse(n.clientHeight, this._entries || {}),
      i.toggle(bE, t),
      a.toggle(gE + bE, t),
      'open' in e && (i.toggle(yE, e.open),
      a.toggle(gE + yE, e.open)),
      o.fire('palette.changed', {
        twoColumn: t,
        open: this.isOpen()
      })
    }
    ,
    AE.prototype._update = function () {
      const e = wn('.djs-palette-entries', this._container)
      const t = this._entries = this.getEntries()
      on(e),
      G(t, function (t, n) {
        const r = t.group || 'default'
        let o = wn('[data-group=' + Cs(r) + ']', e)
        o || (en(o = xn('<div class="group"></div>'), 'data-group', r),
        e.appendChild(o))
        const i = t.html || (t.separator ? '<hr class="separator" />' : '<div class="entry" draggable="true"></div>')
        const a = xn(i)
        if (o.appendChild(a),
        !t.separator && (en(a, 'data-action', n),
        t.title && en(a, 'title', t.title),
        t.className && (function (e, t) {
          const n = nn(e);
          (M(t) ? t : t.split(/\s+/g)).forEach(function (e) {
            n.add(e)
          }
          )
        }(a, t.className)),
        t.imageUrl)) {
          const s = xn('<img>')
          en(s, 'src', t.imageUrl),
          a.appendChild(s)
        }
      }
      ),
      this.open()
    }
    ,
    AE.prototype.trigger = function (e, t, n) {
      let r; let o; const i = t.delegateTarget || t.target
      return i
        ? (r = en(i, 'data-action'),
          o = t.originalEvent || t,
          this.triggerEntry(r, e, o, n))
        : t.preventDefault()
    }
    ,
    AE.prototype.triggerEntry = function (e, t, n, r) {
      let o, i
      if ((o = this._entries[e]) && (i = o.action,
      !1 !== this._eventBus.fire('palette.trigger', {
        entry: o,
        event: n
      }))) {
        if (z(i)) {
          if (t === 'click') { return i(n, r) }
        } else if (i[t]) { return i[t](n, r) }
        n.preventDefault()
      }
    }
    ,
    AE.prototype._layoutChanged = function () {
      this._toggleState({})
    }
    ,
    AE.prototype._needsCollapse = function (e, t) {
      return e < 46 * Object.keys(t).length + 50
    }
    ,
    AE.prototype.close = function () {
      this._toggleState({
        open: !1,
        twoColumn: !1
      })
    }
    ,
    AE.prototype.open = function () {
      this._toggleState({
        open: !0
      })
    }
    ,
    AE.prototype.toggle = function () {
      this.isOpen() ? this.close() : this.open()
    }
    ,
    AE.prototype.isActiveTool = function (e) {
      return e && this._activeTool === e
    }
    ,
    AE.prototype.updateToolHighlight = function (e) {
      let t
      this._toolsContainer || (t = wn('.djs-palette-entries', this._container),
      this._toolsContainer = wn('[data-group=tools]', t)),
      G(this._toolsContainer.children, function (t) {
        let n = t.getAttribute('data-action')
        if (n) {
          const r = nn(t)
          n = n.replace('-tool', ''),
          r.contains('entry') && n === e ? r.add('highlighted-entry') : r.remove('highlighted-entry')
        }
      }
      )
    }
    ,
    AE.prototype.isOpen = function () {
      return nn(this._container).has(yE)
    }
    ,
    AE.prototype._getParentContainer = function () {
      return this._canvas.getContainer()
    }
    ,
    AE.HTML_MARKUP = '<div class="djs-palette"><div class="djs-palette-entries"></div><div class="djs-palette-toggle"></div></div>'
    const xE = {
      __init__: ['palette'],
      palette: ['type', AE]
    }
    function wE (e) {
      return (function (e) {
        if (Array.isArray(e)) { return _E(e) }
      }(e)) || (function (e) {
        if (typeof Symbol !== 'undefined' && e[Symbol.iterator] != null || e['@@iterator'] != null) { return Array.from(e) }
      }(e)) || (function (e, t) {
        if (e) {
          if (typeof e === 'string') { return _E(e, t) }
          let n = Object.prototype.toString.call(e).slice(8, -1)
          return n === 'Object' && e.constructor && (n = e.constructor.name),
          n === 'Map' || n === 'Set' ? Array.from(e) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? _E(e, t) : void 0
        }
      }(e)) || (function () {
        throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
      }())
    }
    function _E (e, t) {
      (t == null || t > e.length) && (t = e.length)
      for (var n = 0, r = new Array(t); n < t; n++) { r[n] = e[n] }
      return r
    }
    const CE = 'crosshair'
    function SE (e, t, n, r, o, i, a) {
      this._selection = o,
      this._dragging = n,
      this._mouse = a
      const s = this
      i.registerTool('lasso', {
        tool: 'lasso.selection',
        dragging: 'lasso'
      }),
      e.on('lasso.selection.end', function (t) {
        const n = t.originalEvent.target;
        (t.hover || n instanceof SVGElement) && e.once('lasso.selection.ended', function () {
          s.activateLasso(t.originalEvent, !0)
        }
        )
      }
      ),
      e.on('lasso.end', 0, function (e) {
        const t = e.context
        const n = kE(e)
        const o = r.filter(function (e) {
          return e
        }
        )
        const i = Xa(e)
        s.select(o, n, i ? t.selection : [])
      }
      ),
      e.on('lasso.start', function (e) {
        const n = e.context
        n.bbox = kE(e),
        (function (e) {
          let n; const r = t.getActiveLayer()
          We(n = e.frame = et('rect'), {
            class: 'djs-lasso-overlay',
            width: 1,
            height: 1,
            x: 0,
            y: 0
          }),
          Fe(r, n)
        }(n)),
        n.selection = o.get()
      }
      ),
      e.on('lasso.move', function (e) {
        const t = e.context
        t.bbox = kE(e),
        (function (e) {
          const t = e.frame
          const n = e.bbox
          We(t, {
            x: n.x,
            y: n.y,
            width: n.width,
            height: n.height
          })
        }(t))
      }
      ),
      e.on('lasso.cleanup', function (e) {
        !(function (e) {
          e.frame && Qe(e.frame)
        }(e.context))
      }
      ),
      e.on('element.mousedown', 1500, function (e) {
        if (Xa(e)) {
          return s.activateLasso(e.originalEvent),
          !0
        }
      }
      )
    }
    function kE (e) {
      const t = {
        x: e.x - e.dx,
        y: e.y - e.dy
      }
      const n = {
        x: e.x,
        y: e.y
      }
      return t.x <= n.x && t.y < n.y || t.x < n.x && t.y <= n.y
        ? {
            x: t.x,
            y: t.y,
            width: n.x - t.x,
            height: n.y - t.y
          }
        : t.x >= n.x && t.y < n.y || t.x > n.x && t.y <= n.y
          ? {
              x: n.x,
              y: t.y,
              width: t.x - n.x,
              height: n.y - t.y
            }
          : t.x <= n.x && t.y > n.y || t.x < n.x && t.y >= n.y
            ? {
                x: t.x,
                y: n.y,
                width: n.x - t.x,
                height: t.y - n.y
              }
            : t.x >= n.x && t.y > n.y || t.x > n.x && t.y >= n.y
              ? {
                  x: n.x,
                  y: n.y,
                  width: t.x - n.x,
                  height: t.y - n.y
                }
              : {
                  x: n.x,
                  y: n.y,
                  width: 0,
                  height: 0
                }
    }
    SE.$inject = ['eventBus', 'canvas', 'dragging', 'elementRegistry', 'selection', 'toolManager', 'mouse'],
    SE.prototype.activateLasso = function (e, t) {
      this._dragging.init(e, 'lasso', {
        autoActivate: t,
        cursor: CE,
        data: {
          context: {}
        }
      })
    }
    ,
    SE.prototype.activateSelection = function (e, t) {
      this._dragging.init(e, 'lasso.selection', {
        trapClick: !1,
        autoActivate: t,
        cursor: CE,
        data: {
          context: {}
        },
        keepSelection: !0
      })
    }
    ,
    SE.prototype.select = function (e, t) {
      const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : []
      const r = (function (e, t) {
        const n = {}
        return G(e, function (e) {
          let r = e
          r.waypoints && (r = Ft(r)),
          !L(t.y) && r.x > t.x && (n[e.id] = e),
          !L(t.x) && r.y > t.y && (n[e.id] = e),
          r.x > t.x && r.y > t.y && (L(t.width) && L(t.height) && r.width + r.x < t.width + t.x && r.height + r.y < t.height + t.y ? n[e.id] = e : L(t.width) && L(t.height) || (n[e.id] = e))
        }
        ),
        n
      }(e, t))
      this._selection.select([].concat(wE(n), wE(J(r))))
    }
    ,
    SE.prototype.toggle = function () {
      if (this.isActive()) { return this._dragging.cancel() }
      const e = this._mouse.getLastMoveEvent()
      this.activateSelection(e, !!e)
    }
    ,
    SE.prototype.isActive = function () {
      const e = this._dragging.context()
      return e && /^lasso/.test(e.prefix)
    }

    const jE = {
      __depends__: [mv, Gm],
      __init__: ['lassoTool'],
      lassoTool: ['type', SE]
    }
    function BE (e) {
      return BE = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      BE(e)
    }
    const DE = 1500
    const PE = 'grab'
    function OE (e, t, n, r, o, i) {
      this._dragging = n,
      this._mouse = i
      const a = this
      const s = r.get('keyboard', !1)
      o.registerTool('hand', {
        tool: 'hand',
        dragging: 'hand.move'
      }),
      e.on('element.mousedown', DE, function (e) {
        if (Ja(e)) {
          return a.activateMove(e.originalEvent, !0),
          !1
        }
      }
      ),
      s && s.addListener(DE, function (e) {
        if (TE(e.keyEvent) && !a.isActive()) {
          const t = a._mouse.getLastMoveEvent()
          a.activateMove(t, !!t)
        }
      }
      , 'keyboard.keydown'),
      s && s.addListener(DE, function (e) {
        TE(e.keyEvent) && a.isActive() && a.toggle()
      }
      , 'keyboard.keyup'),
      e.on('hand.end', function (t) {
        const n = t.originalEvent.target
        if (!(t.hover || n instanceof SVGElement)) { return !1 }
        e.once('hand.ended', function () {
          a.activateMove(t.originalEvent, {
            reactivate: !0
          })
        }
        )
      }
      ),
      e.on('hand.move.move', function (e) {
        const n = t.viewbox().scale
        t.scroll({
          dx: e.dx * n,
          dy: e.dy * n
        })
      }
      ),
      e.on('hand.move.end', function (t) {
        const n = t.context.reactivate
        return !Ja(t) && n && e.once('hand.move.ended', function (e) {
          a.activateHand(e.originalEvent, !0, !0)
        }
        ),
        !1
      }
      )
    }
    function TE (e) {
      return Qs('Space', e)
    }
    OE.$inject = ['eventBus', 'canvas', 'dragging', 'injector', 'toolManager', 'mouse'],
    OE.prototype.activateMove = function (e, t, n) {
      BE(t) === 'object' && (n = t,
      t = !1),
      this._dragging.init(e, 'hand.move', {
        autoActivate: t,
        cursor: PE,
        data: {
          context: n || {}
        }
      })
    }
    ,
    OE.prototype.activateHand = function (e, t, n) {
      this._dragging.init(e, 'hand', {
        trapClick: !1,
        autoActivate: t,
        cursor: PE,
        data: {
          context: {
            reactivate: n
          }
        }
      })
    }
    ,
    OE.prototype.toggle = function () {
      if (this.isActive()) { return this._dragging.cancel() }
      const e = this._mouse.getLastMoveEvent()
      this.activateHand(e, !!e)
    }
    ,
    OE.prototype.isActive = function () {
      const e = this._dragging.context()
      return !!e && /^(hand|hand\.move)$/.test(e.prefix)
    }

    const RE = {
      __depends__: [mv, Gm],
      __init__: ['handTool'],
      handTool: ['type', OE]
    }
    const NE = 'connect-ok'
    const ME = 'connect-not-ok'
    function IE (e, t, n, r, o, i, a) {
      const s = this
      this._dragging = t,
      this._rules = i,
      this._mouse = a,
      o.registerTool('global-connect', {
        tool: 'global-connect',
        dragging: 'global-connect.drag'
      }),
      e.on('global-connect.hover', function (e) {
        const t = e.context
        const n = e.hover
        const o = t.canStartConnect = s.canStartConnect(n)
        o !== null && (t.startTarget = n,
        r.addMarker(n, o ? NE : ME))
      }
      ),
      e.on(['global-connect.out', 'global-connect.cleanup'], function (e) {
        const t = e.context.startTarget
        const n = e.context.canStartConnect
        t && r.removeMarker(t, n ? NE : ME)
      }
      ),
      e.on(['global-connect.ended'], function (t) {
        const r = t.context.startTarget
        const o = {
          x: t.x,
          y: t.y
        }
        if (s.canStartConnect(r)) {
          return e.once('element.out', function () {
            e.once(['connect.ended', 'connect.canceled'], function () {
              e.fire('global-connect.drag.ended')
            }
            ),
            n.start(null, r, o)
          }
          ),
          !1
        }
      }
      )
    }
    IE.$inject = ['eventBus', 'dragging', 'connect', 'canvas', 'toolManager', 'rules', 'mouse'],
    IE.prototype.start = function (e, t) {
      this._dragging.init(e, 'global-connect', {
        autoActivate: t,
        trapClick: !1,
        data: {
          context: {}
        }
      })
    }
    ,
    IE.prototype.toggle = function () {
      if (this.isActive()) { return this._dragging.cancel() }
      const e = this._mouse.getLastMoveEvent()
      return this.start(e, !!e)
    }
    ,
    IE.prototype.isActive = function () {
      const e = this._dragging.context()
      return e && /^global-connect/.test(e.prefix)
    }
    ,
    IE.prototype.canStartConnect = function (e) {
      return this._rules.allowed('connection.start', {
        source: e
      })
    }

    const LE = {
      __depends__: [hd, hu, pu, mv, Gm],
      globalConnect: ['type', IE]
    }
    function zE (e, t, n, r, o, i, a, s) {
      this._palette = e,
      this._create = t,
      this._elementFactory = n,
      this._spaceTool = r,
      this._lassoTool = o,
      this._handTool = i,
      this._globalConnect = a,
      this._translate = s,
      e.registerProvider(this)
    }
    zE.$inject = ['palette', 'create', 'elementFactory', 'spaceTool', 'lassoTool', 'handTool', 'globalConnect', 'translate'],
    zE.prototype.getPaletteEntries = function () {
      const e = {}
      const t = this._create
      const n = this._elementFactory
      const r = this._spaceTool
      const o = this._lassoTool
      const i = this._handTool
      const a = this._globalConnect
      const s = this._translate
      function c (e, r, o, i, a) {
        function s (r) {
          const o = n.createShape(le({
            type: e
          }, a))
          t.start(r, o)
        }
        return {
          group: r,
          className: o,
          title: i,
          action: {
            dragstart: s,
            click: s
          }
        }
      }
      function l (e) {
        const r = n.createShape({
          type: 'bpmn:SubProcess',
          x: 0,
          y: 0,
          isExpanded: !0
        })
        const o = n.createShape({
          type: 'bpmn:StartEvent',
          x: 40,
          y: 82,
          parent: r
        })
        t.start(e, [r, o], {
          hints: {
            autoSelect: [r]
          }
        })
      }
      function p (e) {
        t.start(e, n.createParticipantShape())
      }
      return le(e, {
        'hand-tool': {
          group: 'tools',
          className: 'bpmn-icon-hand-tool',
          title: s('Activate hand tool'),
          action: {
            click: function (e) {
              i.activateHand(e)
            }
          }
        },
        'lasso-tool': {
          group: 'tools',
          className: 'bpmn-icon-lasso-tool',
          title: s('Activate lasso tool'),
          action: {
            click: function (e) {
              o.activateSelection(e)
            }
          }
        },
        'space-tool': {
          group: 'tools',
          className: 'bpmn-icon-space-tool',
          title: s('Activate create/remove space tool'),
          action: {
            click: function (e) {
              r.activateSelection(e)
            }
          }
        },
        'global-connect-tool': {
          group: 'tools',
          className: 'bpmn-icon-connection-multi',
          title: s('Activate global connect tool'),
          action: {
            click: function (e) {
              a.start(e)
            }
          }
        },
        'tool-separator': {
          group: 'tools',
          separator: !0
        },
        'create.start-event': c('bpmn:StartEvent', 'event', 'bpmn-icon-start-event-none', s('Create start event')),
        'create.intermediate-event': c('bpmn:IntermediateThrowEvent', 'event', 'bpmn-icon-intermediate-event-none', s('Create intermediate/boundary event')),
        'create.end-event': c('bpmn:EndEvent', 'event', 'bpmn-icon-end-event-none', s('Create end event')),
        'create.exclusive-gateway': c('bpmn:ExclusiveGateway', 'gateway', 'bpmn-icon-gateway-none', s('Create gateway')),
        'create.task': c('bpmn:Task', 'activity', 'bpmn-icon-task', s('Create task')),
        'create.data-object': c('bpmn:DataObjectReference', 'data-object', 'bpmn-icon-data-object', s('Create data object reference')),
        'create.data-store': c('bpmn:DataStoreReference', 'data-store', 'bpmn-icon-data-store', s('Create data store reference')),
        'create.subprocess-expanded': {
          group: 'activity',
          className: 'bpmn-icon-subprocess-expanded',
          title: s('Create expanded sub-process'),
          action: {
            dragstart: l,
            click: l
          }
        },
        'create.participant-expanded': {
          group: 'collaboration',
          className: 'bpmn-icon-participant',
          title: s('Create pool/participant'),
          action: {
            dragstart: p,
            click: p
          }
        },
        'create.group': c('bpmn:Group', 'artifact', 'bpmn-icon-group', s('Create group'))
      }),
      e
    }

    const FE = {
      __depends__: [xE, qm, Mv, jE, RE, LE, La],
      __init__: ['paletteProvider'],
      paletteProvider: ['type', zE]
    }
    function $E (e, t, n, r, o) {
      Es.call(this, e),
      e.on('shape.move.move', 250, function (e) {
        const i = e.context
        const a = i.canExecute
        i.visualReplacements || (i.visualReplacements = {}),
        a && a.replacements
          ? (function (e) {
              G(e.canExecute.replacements, function (i) {
                const a = i.oldElementId
                const s = {
                  type: i.newElementType
                }
                if (!e.visualReplacements[a]) {
                  const c = t.get(a)
                  le(s, {
                    x: c.x,
                    y: c.y
                  })
                  const l = n.createShape(s)
                  r.addShape(l, c.parent)
                  const p = Le('[data-element-id="' + Cs(c.id) + '"]', e.dragGroup)
                  p && We(p, {
                    display: 'none'
                  })
                  const u = o.addDragger(l, e.dragGroup)
                  e.visualReplacements[a] = u,
                  r.removeShape(l)
                }
              }
              )
            }(i))
          : (function (e) {
              const t = e.visualReplacements
              G(t, function (n, r) {
                const o = Le('[data-element-id="' + Cs(r) + '"]', e.dragGroup)
                o && We(o, {
                  display: 'inline'
                }),
                n.remove(),
                t[r] && delete t[r]
              }
              )
            }(i))
      }
      )
    }
    $E.$inject = ['eventBus', 'elementRegistry', 'elementFactory', 'canvas', 'previewSupport'],
    w($E, Es)
    const HE = {
      __depends__: [Ad],
      __init__: ['bpmnReplacePreview'],
      bpmnReplacePreview: ['type', $E]
    }
    const qE = ['x', 'y']
    const WE = Math.abs
    function GE (e) {
      e.on(['connect.hover', 'connect.move', 'connect.end'], 1250, function (e) {
        let t; const n = e.context; const r = n.canExecute; const o = n.start; const i = n.hover; const a = n.source; const s = n.target
        e.originalEvent && Vs(e.originalEvent) || (n.initialConnectionStart || (n.initialConnectionStart = n.connectionStart),
        r && i && (function (e, t, n) {
          qE.forEach(function (r) {
            const o = QE(r, t)
            e[r] < t[r] + n ? rd(e, r, t[r] + n) : e[r] > t[r] + o - n && rd(e, r, t[r] + o - n)
          }
          )
        }(e, i, (function (e) {
          return Pi(e, 'bpmn:Task') ? 10 : 20
        }(i)))),
        i && (t = r,
        Q(['bpmn:Association', 'bpmn:DataInputAssociation', 'bpmn:DataOutputAssociation', 'bpmn:SequenceFlow'], function (e) {
          return VE(t, e)
        }
        ))
          ? (n.connectionStart = td(o),
            Oi(i, ['bpmn:Event', 'bpmn:Gateway']) && UE(e, td(i)),
            Oi(i, ['bpmn:Task', 'bpmn:SubProcess']) && (function (e, t) {
              const n = td(t)
              qE.forEach(function (r) {
                (function (e, t, n) {
                  return e[n] > t[n] + 20 && e[n] < t[n] + QE(n, t) - 20
                }
                )(e, t, r) && rd(e, r, n[r])
              }
              )
            }(e, i)),
            Pi(a, 'bpmn:BoundaryEvent') && s === a.host && (function (e) {
              const t = e.context
              const n = t.source
              const r = t.target
              if (!(function (e) {
                const t = e.hover
                const n = e.source
                return t && n && t === n
              }(t))) {
                const o = td(n)
                const i = Cr(o, r, -10)
                const a = [];
                /top|bottom/.test(i) && a.push('x'),
                /left|right/.test(i) && a.push('y'),
                a.forEach(function (t) {
                  let n; const r = e[t]
                  WE(r - o[t]) < 40 && (n = r > o[t] ? o[t] + 40 : o[t] - 40,
                  rd(e, t, n))
                }
                )
              }
            }(e)))
          : VE(r, 'bpmn:MessageFlow')
            ? (Pi(o, 'bpmn:Event') && (n.connectionStart = td(o)),
              Pi(i, 'bpmn:Event') && UE(e, td(i)))
            : n.connectionStart = n.initialConnectionStart)
      }
      )
    }
    function UE (e, t) {
      rd(e, 'x', t.x),
      rd(e, 'y', t.y)
    }
    function VE (e, t) {
      return e && e.type === t
    }
    function QE (e, t) {
      return e === 'x' ? t.width : t.height
    }
    function YE () {
      this._targets = {},
      this._snapOrigins = {},
      this._snapLocations = [],
      this._defaultSnaps = {}
    }
    function KE () {
      this._snapValues = {}
    }
    GE.$inject = ['eventBus'],
    YE.prototype.getSnapOrigin = function (e) {
      return this._snapOrigins[e]
    }
    ,
    YE.prototype.setSnapOrigin = function (e, t) {
      this._snapOrigins[e] = t,
      this._snapLocations.indexOf(e) === -1 && this._snapLocations.push(e)
    }
    ,
    YE.prototype.addDefaultSnap = function (e, t) {
      let n = this._defaultSnaps[e]
      n || (n = this._defaultSnaps[e] = []),
      n.push(t)
    }
    ,
    YE.prototype.getSnapLocations = function () {
      return this._snapLocations
    }
    ,
    YE.prototype.setSnapLocations = function (e) {
      this._snapLocations = e
    }
    ,
    YE.prototype.pointsForTarget = function (e) {
      const t = e.id || e
      let n = this._targets[t]
      return n || (n = this._targets[t] = new KE()).initDefaults(this._defaultSnaps),
      n
    }
    ,
    KE.prototype.add = function (e, t) {
      let n = this._snapValues[e]
      n || (n = this._snapValues[e] = {
        x: [],
        y: []
      }),
      n.x.indexOf(t.x) === -1 && n.x.push(t.x),
      n.y.indexOf(t.y) === -1 && n.y.push(t.y)
    }
    ,
    KE.prototype.snap = function (e, t, n, r) {
      const o = this._snapValues[t]
      return o && (function (e, t, n) {
        let r, o
        for (n = void 0 === n ? 10 : n,
        r = 0; r < t.length; r++) {
          if (o = t[r],
          Ju(o - e) <= n) { return o }
        }
      }(e[n], o[n], r))
    }
    ,
    KE.prototype.initDefaults = function (e) {
      const t = this
      G(e || {}, function (e, n) {
        G(e, function (e) {
          t.add(n, e)
        }
        )
      }
      )
    }

    const JE = 1250
    function XE (e, t, n) {
      const r = this
      this._elementRegistry = e,
      t.on(['create.start', 'shape.move.start'], function (e) {
        r.initSnap(e)
      }
      ),
      t.on(['create.move', 'create.end', 'shape.move.move', 'shape.move.end'], JE, function (e) {
        const t = e.context
        const o = t.shape
        const i = t.snapContext
        const a = t.target
        if ((!e.originalEvent || !Vs(e.originalEvent)) && !nd(e) && a) {
          let s = i.pointsForTarget(a)
          s.initialized || ((s = r.addSnapTargetPoints(s, o, a)).initialized = !0),
          n.snap(e, s)
        }
      }
      ),
      t.on(['create.cleanup', 'shape.move.cleanup'], function () {
        n.hide()
      }
      )
    }
    function ZE (e, t) {
      t.invoke(XE, this),
      e.on(['create.move', 'create.end'], 1500, ex),
      e.on(['create.move', 'create.end', 'shape.move.move', 'shape.move.end'], 1500, function (e) {
        const t = e.context
        const n = t.canExecute
        const r = t.target
        n && (n === 'attach' || n.attach) && !nd(e) && (function (e, t) {
          let n; const r = xr(t); const o = Qh(e, t); const i = e.context.shape
          n = i.parent
            ? {
                x: 0,
                y: 0
              }
            : _r(i),
          /top/.test(o) ? rd(e, 'y', r.top - n.y) : /bottom/.test(o) && rd(e, 'y', r.bottom - n.y),
          /left/.test(o) ? rd(e, 'x', r.left - n.x) : /right/.test(o) && rd(e, 'x', r.right - n.x)
        }(e, r))
      }
      )
    }
    function ex (e) {
      const t = e.context.createConstraints
      if (t) {
        const n = t.top
        const r = t.right
        const o = t.bottom
        const i = t.left;
        (i && i >= e.x || r && r <= e.x) && rd(e, 'x', e.x),
        (n && n >= e.y || o && o <= e.y) && rd(e, 'y', e.y)
      }
    }
    function tx (e, t) {
      return e.indexOf(t) !== -1
    }
    function nx (e, t, n) {
      return t
        ? {
            x: e.x - n.x,
            y: e.y - n.y
          }
        : {
            x: e.x,
            y: e.y
          }
    }
    function rx (e, t) {
      const n = this
      e.on(['resize.start'], function (e) {
        n.initSnap(e)
      }
      ),
      e.on(['resize.move', 'resize.end'], 1250, function (e) {
        const r = e.context
        const o = r.shape
        const i = o.parent
        const a = r.direction
        const s = r.snapContext
        if (!(e.originalEvent && Vs(e.originalEvent) || nd(e))) {
          let c = s.pointsForTarget(i)
          c.initialized || ((c = n.addSnapTargetPoints(c, o, i, a)).initialized = !0),
          (function (e) {
            return e === 'n' || e === 's'
          }(a)) && rd(e, 'x', e.x),
          (function (e) {
            return e === 'e' || e === 'w'
          }(a)) && rd(e, 'y', e.y),
          t.snap(e, c)
        }
      }
      ),
      e.on(['resize.cleanup'], function () {
        t.hide()
      }
      )
    }
    function ox (e, t) {
      const n = _r(e)
      const r = xr(e)
      const o = {
        x: n.x,
        y: n.y
      }
      return t.indexOf('n') !== -1 ? o.y = r.top : t.indexOf('s') !== -1 && (o.y = r.bottom),
      t.indexOf('e') !== -1 ? o.x = r.right : t.indexOf('w') !== -1 && (o.x = r.left),
      o
    }
    function ix (e) {
      this._canvas = e,
      this._asyncHide = se(ce(this.hide, this), 1e3)
    }
    XE.$inject = ['elementRegistry', 'eventBus', 'snapping'],
    XE.prototype.initSnap = function (e) {
      let t; const n = this._elementRegistry; const r = e.context; const o = r.shape; let i = r.snapContext
      i || (i = r.snapContext = new YE())
      const a = (t = n.get(o.id)
        ? td(o, e)
        : {
            x: e.x + td(o).x,
            y: e.y + td(o).y
          }).x - o.width / 2
      const s = t.y - o.height / 2
      const c = t.x + o.width / 2
      const l = t.y + o.height / 2
      return i.setSnapOrigin('mid', {
        x: t.x - e.x,
        y: t.y - e.y
      }),
      br(o) || (i.setSnapOrigin('top-left', {
        x: a - e.x,
        y: s - e.y
      }),
      i.setSnapOrigin('bottom-right', {
        x: c - e.x,
        y: l - e.y
      })),
      i
    }
    ,
    XE.prototype.addSnapTargetPoints = function (e, t, n) {
      return G(this.getSnapTargets(t, n), function (n) {
        if (br(n)) { br(t) && e.add('mid', td(n)) } else if (yr(n)) {
          if (n.waypoints.length < 3) { return }
          G(n.waypoints.slice(1, -1), function (t) {
            e.add('mid', t)
          }
          )
        } else { e.add('mid', td(n)) }
      }
      ),
      L(t.x) && L(t.y)
        ? (this._elementRegistry.get(t.id) && e.add('mid', td(t)),
          e)
        : e
    }
    ,
    XE.prototype.getSnapTargets = function (e, t) {
      return od(t).filter(function (e) {
        return !e.hidden
      }
      )
    }
    ,
    w(ZE, XE),
    ZE.$inject = ['eventBus', 'injector'],
    ZE.prototype.initSnap = function (e) {
      const t = XE.prototype.initSnap.call(this, e)
      const n = e.shape
      const r = !!this._elementRegistry.get(n.id)
      return G(n.outgoing, function (n) {
        let o = n.waypoints[0]
        o = o.original || o,
        t.setSnapOrigin(n.id + '-docking', nx(o, r, e))
      }
      ),
      G(n.incoming, function (n) {
        let o = n.waypoints[n.waypoints.length - 1]
        o = o.original || o,
        t.setSnapOrigin(n.id + '-docking', nx(o, r, e))
      }
      ),
      Pi(n, 'bpmn:Participant') && t.setSnapLocations(['top-left', 'bottom-right', 'mid']),
      t
    }
    ,
    ZE.prototype.addSnapTargetPoints = function (e, t, n) {
      XE.prototype.addSnapTargetPoints.call(this, e, t, n)
      const r = this.getSnapTargets(t, n)
      G(r, function (n) {
        let r;
        (Pi(r = n, 'bpmn:SubProcess') && Zi(r) || Pi(r, 'bpmn:Participant') || ('bpmn:TextAnnotation',
        [t, n].every(function (e) {
          return Pi(e, 'bpmn:TextAnnotation')
        }
        ))) && (e.add('top-left', Zu(n)),
        e.add('bottom-right', ed(n)))
      }
      )
      const o = this._elementRegistry
      return G(t.incoming, function (n) {
        if (o.get(t.id)) {
          tx(r, n.source) || e.add('mid', _r(n.source))
          const i = n.waypoints[0]
          e.add(n.id + '-docking', i.original || i)
        }
      }
      ),
      G(t.outgoing, function (n) {
        if (o.get(t.id)) {
          tx(r, n.target) || e.add('mid', _r(n.target))
          const i = n.waypoints[n.waypoints.length - 1]
          e.add(n.id + '-docking', i.original || i)
        }
      }
      ),
      Pi(n, 'bpmn:SequenceFlow') && (e = this.addSnapTargetPoints(e, t, n.parent)),
      e
    }
    ,
    ZE.prototype.getSnapTargets = function (e, t) {
      return XE.prototype.getSnapTargets.call(this, e, t).filter(function (e) {
        return !Pi(e, 'bpmn:Lane')
      }
      )
    }
    ,
    rx.prototype.initSnap = function (e) {
      const t = e.context
      const n = t.shape
      const r = t.direction
      let o = t.snapContext
      o || (o = t.snapContext = new YE())
      const i = ox(n, r)
      return o.setSnapOrigin('corner', {
        x: i.x - e.x,
        y: i.y - e.y
      }),
      o
    }
    ,
    rx.prototype.addSnapTargetPoints = function (e, t, n, r) {
      return G(this.getSnapTargets(t, n), function (t) {
        e.add('corner', ed(t)),
        e.add('corner', Zu(t))
      }
      ),
      e.add('corner', ox(t, r)),
      e
    }
    ,
    rx.$inject = ['eventBus', 'snapping'],
    rx.prototype.getSnapTargets = function (e, t) {
      return od(t).filter(function (t) {
        return n = e,
        !(t.host === n || yr(t) || (function (e) {
          return !!e.hidden
        }(t)) || br(t))
        let n
      }
      )
    }
    ,
    ix.$inject = ['canvas'],
    ix.prototype.snap = function (e, t) {
      const n = e.context.snapContext
      const r = n.getSnapLocations()
      const o = {
        x: nd(e, 'x'),
        y: nd(e, 'y')
      }
      G(r, function (r) {
        const i = n.getSnapOrigin(r)
        const a = {
          x: e.x + i.x,
          y: e.y + i.y
        }
        if (G(['x', 'y'], function (e) {
          let n
          o[e] || void 0 !== (n = t.snap(a, r, e, 7)) && (o[e] = {
            value: n,
            originValue: n - i[e]
          })
        }
        ),
        o.x && o.y) { return !1 }
      }
      ),
      this.showSnapLine('vertical', o.x && o.x.value),
      this.showSnapLine('horizontal', o.y && o.y.value),
      G(['x', 'y'], function (t) {
        const n = o[t]
        I(n) && rd(e, t, n.originValue)
      }
      )
    }
    ,
    ix.prototype._createLine = function (e) {
      const t = this._canvas.getLayer('snap')
      const n = et('path')
      return We(n, {
        d: 'M0,0 L0,0'
      }),
      Ue(n).add('djs-snap-line'),
      Fe(t, n),
      {
        update: function (t) {
          L(t)
            ? We(n, e === 'horizontal'
              ? {
                  d: 'M-100000,' + t + ' L+100000,' + t,
                  display: ''
                }
              : {
                  d: 'M ' + t + ',-100000 L ' + t + ', +100000',
                  display: ''
                })
            : We(n, {
              display: 'none'
            })
        }
      }
    }
    ,
    ix.prototype._createSnapLines = function () {
      this._snapLines = {
        horizontal: this._createLine('horizontal'),
        vertical: this._createLine('vertical')
      }
    }
    ,
    ix.prototype.showSnapLine = function (e, t) {
      const n = this.getSnapLine(e)
      n && n.update(t),
      this._asyncHide()
    }
    ,
    ix.prototype.getSnapLine = function (e) {
      return this._snapLines || this._createSnapLines(),
      this._snapLines[e]
    }
    ,
    ix.prototype.hide = function () {
      G(this._snapLines, function (e) {
        e.update()
      }
      )
    }

    const ax = {
      __depends__: [{
        __init__: ['createMoveSnapping', 'resizeSnapping', 'snapping'],
        createMoveSnapping: ['type', XE],
        resizeSnapping: ['type', rx],
        snapping: ['type', ix]
      }],
      __init__: ['connectSnapping', 'createMoveSnapping'],
      connectSnapping: ['type', GE],
      createMoveSnapping: ['type', ZE]
    }
    function sx (e, t, n, r, o) {
      this._open = !1,
      this._results = [],
      this._eventMaps = [],
      this._canvas = e,
      this._eventBus = t,
      this._overlays = n,
      this._selection = r,
      this._translate = o,
      this._container = this._getBoxHtml(),
      this._searchInput = wn(sx.INPUT_SELECTOR, this._container),
      this._resultsContainer = wn(sx.RESULTS_CONTAINER_SELECTOR, this._container),
      this._canvas.getContainer().appendChild(this._container),
      t.on(['canvas.destroy', 'diagram.destroy'], this.close, this)
    }
    function cx (e, t, n) {
      const r = (function (e) {
        let t = ''
        return e.forEach(function (e) {
          e.matched ? t += '<strong class="' + sx.RESULT_HIGHLIGHT_CLASS + '">' + ks(e.matched) + '</strong>' : t += ks(e.normal)
        }
        ),
        t !== '' ? t : null
      }(t))
      const o = xn(n)
      o.innerHTML = r,
      e.appendChild(o)
    }
    sx.$inject = ['canvas', 'eventBus', 'overlays', 'selection', 'translate'],
    sx.prototype._bindEvents = function () {
      const e = this
      function t (t, n, r, o) {
        e._eventMaps.push({
          el: t,
          type: r,
          listener: yn(t, n, r, o)
        })
      }
      t(document, 'html', 'click', function (t) {
        e.close()
      }
      ),
      t(this._container, sx.INPUT_SELECTOR, 'click', function (e) {
        e.stopPropagation(),
        e.delegateTarget.focus()
      }
      ),
      t(this._container, sx.RESULT_SELECTOR, 'mouseover', function (t) {
        t.stopPropagation(),
        e._scrollToNode(t.delegateTarget),
        e._preselect(t.delegateTarget)
      }
      ),
      t(this._container, sx.RESULT_SELECTOR, 'click', function (t) {
        t.stopPropagation(),
        e._select(t.delegateTarget)
      }
      ),
      t(this._container, sx.INPUT_SELECTOR, 'keydown', function (e) {
        Qs('ArrowUp', e) && e.preventDefault(),
        Qs('ArrowDown', e) && e.preventDefault()
      }
      ),
      t(this._container, sx.INPUT_SELECTOR, 'keyup', function (t) {
        if (Qs('Escape', t)) { return e.close() }
        if (Qs('Enter', t)) {
          const n = e._getCurrentResult()
          return n ? e._select(n) : e.close()
        }
        return Qs('ArrowUp', t) ? e._scrollToDirection(!0) : Qs('ArrowDown', t) ? e._scrollToDirection() : void (Qs(['ArrowLeft', 'ArrowRight'], t) || e._search(t.delegateTarget.value))
      }
      )
    }
    ,
    sx.prototype._unbindEvents = function () {
      this._eventMaps.forEach(function (e) {
        bn(e.el, e.type, e.listener)
      }
      )
    }
    ,
    sx.prototype._search = function (e) {
      const t = this
      if (this._clearResults(),
      e && e !== '') {
        const n = this._searchProvider.find(e)
        if (n.length) {
          n.forEach(function (e) {
            const n = e.element.id
            const r = t._createResultNode(e, n)
            t._results[n] = {
              element: e.element,
              node: r
            }
          }
          )
          const r = wn(sx.RESULT_SELECTOR, this._resultsContainer)
          this._scrollToNode(r),
          this._preselect(r)
        }
      }
    }
    ,
    sx.prototype._scrollToDirection = function (e) {
      const t = this._getCurrentResult()
      if (t) {
        const n = e ? t.previousElementSibling : t.nextElementSibling
        n && (this._scrollToNode(n),
        this._preselect(n))
      }
    }
    ,
    sx.prototype._scrollToNode = function (e) {
      if (e && e !== this._getCurrentResult()) {
        const t = e.offsetTop
        const n = this._resultsContainer.scrollTop
        const r = t - this._resultsContainer.clientHeight + e.clientHeight
        t < n ? this._resultsContainer.scrollTop = t : n < r && (this._resultsContainer.scrollTop = r)
      }
    }
    ,
    sx.prototype._clearResults = function () {
      on(this._resultsContainer),
      this._results = [],
      this._resetOverlay(),
      this._eventBus.fire('searchPad.cleared')
    }
    ,
    sx.prototype._getCurrentResult = function () {
      return wn(sx.RESULT_SELECTED_SELECTOR, this._resultsContainer)
    }
    ,
    sx.prototype._createResultNode = function (e, t) {
      const n = xn(sx.RESULT_HTML)
      return e.primaryTokens.length > 0 && cx(n, e.primaryTokens, sx.RESULT_PRIMARY_HTML),
      cx(n, e.secondaryTokens, sx.RESULT_SECONDARY_HTML),
      en(n, sx.RESULT_ID_ATTRIBUTE, t),
      this._resultsContainer.appendChild(n),
      n
    }
    ,
    sx.prototype.registerProvider = function (e) {
      this._searchProvider = e
    }
    ,
    sx.prototype.open = function () {
      if (!this._searchProvider) { throw new Error('no search provider registered') }
      this.isOpen() || (this._bindEvents(),
      this._open = !0,
      nn(this._container).add('open'),
      this._searchInput.focus(),
      this._eventBus.fire('searchPad.opened'))
    }
    ,
    sx.prototype.close = function () {
      this.isOpen() && (this._unbindEvents(),
      this._open = !1,
      nn(this._container).remove('open'),
      this._clearResults(),
      this._searchInput.value = '',
      this._searchInput.blur(),
      this._resetOverlay(),
      this._eventBus.fire('searchPad.closed'))
    }
    ,
    sx.prototype.toggle = function () {
      this.isOpen() ? this.close() : this.open()
    }
    ,
    sx.prototype.isOpen = function () {
      return this._open
    }
    ,
    sx.prototype._preselect = function (e) {
      const t = this._getCurrentResult()
      if (e !== t) {
        t && nn(t).remove(sx.RESULT_SELECTED_CLASS)
        const n = en(e, sx.RESULT_ID_ATTRIBUTE)
        const r = this._results[n].element
        nn(e).add(sx.RESULT_SELECTED_CLASS),
        this._resetOverlay(r),
        this._canvas.scrollToElement(r, {
          top: 400
        }),
        this._selection.select(r),
        this._eventBus.fire('searchPad.preselected', r)
      }
    }
    ,
    sx.prototype._select = function (e) {
      const t = en(e, sx.RESULT_ID_ATTRIBUTE)
      const n = this._results[t].element
      this.close(),
      this._resetOverlay(),
      this._canvas.scrollToElement(n, {
        top: 400
      }),
      this._selection.select(n),
      this._eventBus.fire('searchPad.selected', n)
    }
    ,
    sx.prototype._resetOverlay = function (e) {
      if (this._overlayId && this._overlays.remove(this._overlayId),
      e) {
        const t = (function (e) {
          const t = e.width + 12
          const n = e.height + 12
          const r = {
            width: t + 'px',
            height: n + 'px'
          }
          const o = xn('<div class="' + sx.OVERLAY_CLASS + '"></div>')
          return Zt(o, r),
          {
            position: {
              bottom: n - 6,
              right: t - 6
            },
            show: !0,
            html: o
          }
        }(Ft(e)))
        this._overlayId = this._overlays.add(e, t)
      }
    }
    ,
    sx.prototype._getBoxHtml = function () {
      const e = xn(sx.BOX_HTML)
      const t = wn(sx.INPUT_SELECTOR, e)
      return t && t.setAttribute('aria-label', this._translate('Search in diagram')),
      e
    }
    ,
    sx.CONTAINER_SELECTOR = '.djs-search-container',
    sx.INPUT_SELECTOR = '.djs-search-input input',
    sx.RESULTS_CONTAINER_SELECTOR = '.djs-search-results',
    sx.RESULT_SELECTOR = '.djs-search-result',
    sx.RESULT_SELECTED_CLASS = 'djs-search-result-selected',
    sx.RESULT_SELECTED_SELECTOR = '.' + sx.RESULT_SELECTED_CLASS,
    sx.RESULT_ID_ATTRIBUTE = 'data-result-id',
    sx.RESULT_HIGHLIGHT_CLASS = 'djs-search-highlight',
    sx.OVERLAY_CLASS = 'djs-search-overlay',
    sx.BOX_HTML = '<div class="djs-search-container djs-draggable djs-scrollable"><div class="djs-search-input"><input type="text"/></div><div class="djs-search-results"></div></div>',
    sx.RESULT_HTML = '<div class="djs-search-result"></div>',
    sx.RESULT_PRIMARY_HTML = '<div class="djs-search-result-primary"></div>',
    sx.RESULT_SECONDARY_HTML = '<p class="djs-search-result-secondary"></p>'
    const lx = {
      __depends__: [La, ys, us],
      searchPad: ['type', sx]
    }
    function px (e, t, n) {
      this._elementRegistry = e,
      this._canvas = n,
      t.registerProvider(this)
    }
    function ux (e) {
      return W(e, function (e) {
        return !!e.matched
      }
      ).length > 0
    }
    function dx (e, t) {
      const n = []
      const r = e
      if (!e) { return n }
      e = e.toLowerCase(),
      t = t.toLowerCase()
      const o = e.indexOf(t)
      return o > -1
        ? (o !== 0 && n.push({
            normal: r.substr(0, o)
          }),
          n.push({
            matched: r.substr(o, t.length)
          }),
          t.length + o < e.length && n.push({
            normal: r.substr(t.length + o, e.length)
          }))
        : n.push({
          normal: r
        }),
      n
    }
    px.$inject = ['elementRegistry', 'searchPad', 'canvas'],
    px.prototype.find = function (e) {
      const t = this._canvas.getRootElement()
      let n = this._elementRegistry.filter(function (e) {
        return !e.labelTarget
      }
      )
      return n = W(n, function (e) {
        return e !== t
      }
      ),
      te(n = W(n = Y(n, function (t) {
        return {
          primaryTokens: dx(la(t), e),
          secondaryTokens: dx(t.id, e),
          element: t
        }
      }
      ), function (e) {
        return ux(e.primaryTokens) || ux(e.secondaryTokens)
      }
      ), function (e) {
        return la(e.element) + e.element.id
      }
      )
    }

    const fx = {
      __depends__: [lx],
      __init__: ['bpmnSearch'],
      bpmnSearch: ['type', px]
    }
    function hx (e) {
      Xi.call(this, e)
    }
    w(hx, Xi),
    hx.Viewer = Hs,
    hx.NavigatedViewer = Ac,
    hx.prototype.createDiagram = function () {
      return this.importXML('<?xml version="1.0" encoding="UTF-8"?><bpmn:definitions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:bpmn="http://www.omg.org/spec/BPMN/20100524/MODEL" xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI" xmlns:dc="http://www.omg.org/spec/DD/20100524/DC" targetNamespace="http://bpmn.io/schema/bpmn" id="Definitions_1"><bpmn:process id="Process_1" isExecutable="false"><bpmn:startEvent id="StartEvent_1"/></bpmn:process><bpmndi:BPMNDiagram id="BPMNDiagram_1"><bpmndi:BPMNPlane id="BPMNPlane_1" bpmnElement="Process_1"><bpmndi:BPMNShape id="_BPMNShape_StartEvent_2" bpmnElement="StartEvent_1"><dc:Bounds height="36.0" width="36.0" x="173.0" y="102.0"/></bpmndi:BPMNShape></bpmndi:BPMNPlane></bpmndi:BPMNDiagram></bpmn:definitions>')
    }
    ,
    hx.prototype._interactionModules = [oc, fc, bc],
    hx.prototype._modelingModules = [Ip, Xp, du, ru, cd, hd, vd, Lb, tv, qm, Ub, Xb, fA, mA, gA, CA, HA, $y, KA, iE, fE, FE, HE, NA, ax, fx],
    hx.prototype._modules = [].concat(Hs.prototype._modules, hx.prototype._interactionModules, hx.prototype._modelingModules)
    const mx = {
      offset: {
        x: 150,
        y: 75
      },
      tolerance: 50,
      alignOnSave: !0
    }
    function vx (e, t, n, r, o, i) {
      function a (e, n) {
        const r = n.offset
        const o = n.tolerance
        const i = {}
        return ['x', 'y'].forEach(function (n) {
          let a = -e[n] + r[n]
          const s = t.get('gridSnapping', !1)
          s && (a = (function (e, t, n) {
            return n || (n = 'round'),
            Math[n](e / t) * t
          }(a, s.getGridSpacing()))),
          i[n] = Math.abs(a) < o ? 0 : a
        }
        ),
        i
      }
      function s () {
        const t = o.viewbox().inner
        const n = o.getRootElement().children
        if (n.length) {
          const i = a(t, e)
          i.x === 0 && i.y === 0 || r.execute('elements.alignToOrigin', {
            elements: n,
            delta: i
          })
        }
      }
      function c (e) {
        return function (t) {
          n.once('commandStack.changed', function () {
            const n = t.delta
            const r = o.viewbox().scale
            o.scroll({
              dx: e * n.x * r,
              dy: e * n.y * r
            })
          }
          )
        }
      }
      let l, p, u
      e = (function (e) {
        const t = le({}, mx, e || {})
        return L(t.offset) && (t.offset = {
          x: t.offset,
          y: t.offset
        }),
        t
      }(e)),
      r.register('elements.alignToOrigin', {
        preExecute: function (e) {
          const t = e.delta
          const n = e.elements
          i.moveElements(n, t)
        },
        execute: c(-1),
        revert: c(1)
      }),
      e.alignOnSave && (l = t.get('_parent', !1),
      p = n,
      ((u = l && l._eventBus) || p).on('saveXML.start', 1250, s),
      u && p.on('diagram.destroy', function () {
        u.off('saveXML.start', s)
      }
      )),
      this.align = s,
      this.computeAdjustment = a,
      this._config = e
    }
    vx.$inject = ['config.alignToOrigin', 'injector', 'eventBus', 'commandStack', 'canvas', 'modeling']
    const gx = {
      __init__: ['alignToOrigin'],
      alignToOrigin: ['type', vx]
    }
    function yx (e, t) {
      if (!e) { throw new Error('config.exporter = { name, version } not configured') }
      const n = e.name
      const r = e.version
      if (!n || !r) { throw new Error('config.exporter = { name, version } missing required props') }
      t.on('saveXML.start', function (e) {
        const t = e.definitions
        t.exporter = n,
        t.exporterVersion = r
      }
      )
    }
    yx.$inject = ['config.exporter', 'eventBus']
    const bx = {
      __init__: [yx]
    }
    function Ax (e) {
      return Ax = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      Ax(e)
    }
    function Ex (e, t) {
      const n = Object.keys(e)
      if (Object.getOwnPropertySymbols) {
        let r = Object.getOwnPropertySymbols(e)
        t && (r = r.filter(function (t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable
        }
        )),
        n.push.apply(n, r)
      }
      return n
    }
    function xx (e) {
      for (let t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {}
        t % 2
          ? Ex(Object(n), !0).forEach(function (t) {
            let r, o, i
            r = e,
            o = t,
            i = n[t],
            o = (function (e) {
              const t = (function (e, t) {
                if (Ax(e) != 'object' || !e) { return e }
                const n = e[Symbol.toPrimitive]
                if (void 0 !== n) {
                  const r = n.call(e, 'string')
                  if (Ax(r) != 'object') { return r }
                  throw new TypeError('@@toPrimitive must return a primitive value.')
                }
                return String(e)
              }(e))
              return Ax(t) == 'symbol' ? t : t + ''
            }(o)),
            o in r
              ? Object.defineProperty(r, o, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
              })
              : r[o] = i
          }
          )
          : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
            : Ex(Object(n)).forEach(function (t) {
              Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
            }
            )
      }
      return e
    }
    function wx (e, t, n, r) {
      this._contextPad = e,
      this._popupMenu = t,
      this._canvas = n,
      this._translate = r,
      e.registerProvider(this)
    }
    wx.$inject = ['contextPad', 'popupMenu', 'canvas', 'translate'],
    wx.prototype.getContextPadEntries = function (e) {
      return this._createPopupAction([e])
    }
    ,
    wx.prototype.getMultiElementContextPadEntries = function (e) {
      return this._createPopupAction(e)
    }
    ,
    wx.prototype._createPopupAction = function (e) {
      const t = this._canvas
      const n = this._translate
      const r = this._contextPad
      const o = this._popupMenu
      return {
        'set-color': {
          group: 'edit',
          className: 'bpmn-icon-color',
          title: n('Set color'),
          html: '<div class="entry">'.concat('<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="currentColor">\n  <path d="m12.5 5.5.3-.4 3.6-3.6c.5-.5 1.3-.5 1.7 0l1 1c.5.4.5 1.2 0 1.7l-3.6 3.6-.4.2v.2c0 1.4.6 2 1 2.7v.6l-1.7 1.6c-.2.2-.4.2-.6 0L7.3 6.6a.4.4 0 0 1 0-.6l.3-.3.5-.5.8-.8c.2-.2.4-.1.6 0 .9.5 1.5 1.1 3 1.1zm-9.9 6 4.2-4.2 6.3 6.3-4.2 4.2c-.3.3-.9.3-1.2 0l-.8-.8-.9-.8-2.3-2.9" />\n</svg>', '</div>'),
          action: {
            click: function (n, i) {
              const a = xx(xx({}, (function (e, t, n) {
                const r = e.getContainer()
                const o = t.getPad(n).html
                const i = r.getBoundingClientRect()
                const a = o.getBoundingClientRect()
                const s = a.top - i.top
                return {
                  x: a.left - i.left,
                  y: s + a.height + 5
                }
              }(t, r, e))), {}, {
                cursor: {
                  x: n.x,
                  y: n.y
                }
              })
              o.open(e, 'color-picker', a)
            }
          }
        }
      }
    }

    const _x = [{
      label: 'Default',
      fill: void 0,
      stroke: void 0
    }, {
      label: 'Blue',
      fill: '#BBDEFB',
      stroke: '#0D4372'
    }, {
      label: 'Orange',
      fill: '#FFE0B2',
      stroke: '#6B3C00'
    }, {
      label: 'Green',
      fill: '#C8E6C9',
      stroke: '#205022'
    }, {
      label: 'Red',
      fill: '#FFCDD2',
      stroke: '#831311'
    }, {
      label: 'Purple',
      fill: '#E1BEE7',
      stroke: '#5B176D'
    }]
    function Cx (e, t, n, r, o) {
      this._popupMenu = n,
      this._modeling = r,
      this._translate = o,
      this._colors = e && e.colors || _x,
      this._defaultFillColor = t && t.defaultFillColor || 'white',
      this._defaultStrokeColor = t && t.defaultStrokeColor || 'rgb(34, 36, 42)',
      this._popupMenu.registerProvider('color-picker', this)
    }
    function Sx (e, t, n) {
      return function () {
        e.setColor(t, n)
      }
    }
    Cx.$inject = ['config.colorPicker', 'config.bpmnRenderer', 'popupMenu', 'modeling', 'translate'],
    Cx.prototype.getEntries = function (e) {
      const t = this
      return this._colors.map(function (n) {
        const r = '\n    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 25 25" height="100%" width="100%">\n      <rect rx="2" x="1" y="1" width="22" height="22" fill="var(--fill-color)" stroke="var(--stroke-color)" style="stroke-width:2"></rect>\n    </svg>\n  '.replace('var(--fill-color)', n.fill || t._defaultFillColor).replace('var(--stroke-color)', n.stroke || t._defaultStrokeColor)
        return {
          title: t._translate(n.label),
          id: n.label.toLowerCase() + '-color',
          imageHtml: r,
          action: Sx(t._modeling, e, n)
        }
      }
      )
    }

    const kx = {
      __init__: ['colorContextPadProvider', 'colorPopupProvider'],
      colorContextPadProvider: ['type', wx],
      colorPopupProvider: ['type', Cx]
    }
    function jx () {
      return function (e, t) {
        if (I(e)) { return e }
        if (!e && t.defaultValue) { return t.defaultValue }
        const n = e.split(/,/)
        if (n.length !== 2) { throw new Error('expected delta to match (\\d*,\\d*)') }
        return {
          x: parseInt(n[0], 10) || 0,
          y: parseInt(n[1], 10) || 0
        }
      }
    }
    function Bx (e) {
      return function (t, n) {
        if (I(t)) { return t }
        const r = e.get(t)
        if (!r) {
          if (n.optional) { return null }
          throw t ? new Error('element with id <' + t + '> does not exist') : new Error('argument required')
        }
        return r
      }
    }
    function Dx (e) {
      return function (t, n) {
        return F(t) ? t = t.split(',') : M(t) || (t = [t]),
        t.map(function (t) {
          if (I(t)) { return t }
          const r = e.get(t)
          if (!r) {
            if (n.optional) { return null }
            throw t ? new Error('element with id <' + t + '> does not exist') : new Error('argument required')
          }
          return r
        }
        ).filter(function (e) {
          return e
        }
        )
      }
    }
    function Px (e) {
      return function (t, n) {
        const r = e.element(t, n).parse(t)
        if (r && r.waypoints) { throw new Error('element <' + t + '> is a connection') }
        return r
      }
    }
    function Ox (e) {
      return function (t, n) {
        return e.elements(t, n).parse(t).filter(function (e) {
          if (e.waypoints) { throw new Error('element <' + e.id + '> is a connection') }
          return !0
        }
        )
      }
    }
    function Tx (e, t) {
      return {
        args: [e.shape('source'), e.string('type'), e.point('delta', {
          defaultValue: {
            x: 200,
            y: 0
          }
        })],
        exec: function (e, n, r) {
          const o = {
            x: e.x + e.width / 2 + r.x,
            y: e.y + e.height / 2 + r.y
          }
          return t.appendShape(e, {
            type: n
          }, o).id
        }
      }
    }
    function Rx (e, t) {
      return {
        args: [e.elements('elements'), e.string('colors')],
        exec: function (e, n) {
          t.setColor(e, (function (e) {
            if (I(e)) { return e }
            const t = M(e) ? e : e.split(',')
            const n = {}
            return ['fill', 'stroke'].forEach(function (e, r) {
              const o = t[r]
              o && (n[e] = o === 'unset' ? void 0 : o)
            }
            ),
            n
          }(n)))
        }
      }
    }
    function Nx (e, t) {
      return {
        args: [e.shape('source'), e.shape('target'), e.string('type'), e.shape('parent', {
          optional: !0
        })],
        exec: function (e, n, r, o) {
          return t.createConnection(e, n, {
            type: r
          }, o || e.parent).id
        }
      }
    }
    function Mx (e, t) {
      return {
        args: [e.string('type'), e.point('position'), e.shape('parent'), e.bool('isAttach', {
          optional: !0
        })],
        exec: function (e, n, r, o) {
          let i
          return o && (i = {
            attach: !0
          }),
          t.createShape({
            type: e
          }, n, r, i).id
        }
      }
    }
    function Ix (e) {
      return {
        args: [e.element('element')],
        exec: function (e) {
          return e
        }
      }
    }
    function Lx (e, t) {
      return {
        exec: function () {
          return t.filter(function () {
            return !0
          }
          ).map(function (e) {
            return e.id
          }
          )
        }
      }
    }
    function zx (e, t) {
      return {
        args: [e.shapes('shapes'), e.point('delta'), e.shape('newParent', {
          optional: !0
        }), e.bool('isAttach', {
          optional: !0
        })],
        exec: function (e, n, r, o) {
          let i
          return o && (i = {
            attach: !0
          }),
          t.moveElements(e, n, r, i),
          e
        }
      }
    }
    function Fx (e) {
      return {
        exec: function () {
          e.redo()
        }
      }
    }
    function $x (e, t) {
      return {
        args: [e.string('format')],
        exec: function (e) {
          if (e === 'svg') {
            t.saveSVG().then(function (e) {
              const t = e.svg
              console.info(t)
            }
            ).catch(function (e) {
              console.error(e)
            }
            )
          } else {
            if (e !== 'bpmn') { throw new Error('unknown format, <svg> and <bpmn> are available') }
            t.saveXML().then(function (e) {
              const t = e.xml
              console.info(t)
            }
            ).catch(function (e) {
              console.error(e)
            }
            )
          }
        }
      }
    }
    function Hx (e, t) {
      return {
        args: [e.element('element'), e.string('newLabel')],
        exec: function (e, n) {
          return t.updateLabel(e, n),
          e
        }
      }
    }
    function qx (e, t) {
      return {
        args: [e.element('element')],
        exec: function (e) {
          return t.setRootElement(e),
          e
        }
      }
    }
    function Wx (e) {
      return {
        exec: function () {
          e.undo()
        }
      }
    }
    function Gx (e, t) {
      return {
        args: [e.shape('shape')],
        exec: function (e) {
          return t.removeShape(e)
        }
      }
    }
    function Ux (e, t) {
      return {
        args: [e.element('connection')],
        exec: function (e) {
          return t.removeConnection(e)
        }
      }
    }
    function Vx (e, t) {
      return {
        args: [e.elements('elements')],
        exec: function (e) {
          return t.removeElements(e)
        }
      }
    }
    function Qx (e) {
      e._registerParser('point', jx),
      e._registerParser('element', Bx),
      e._registerParser('elements', Dx),
      e._registerParser('shape', Px),
      e._registerParser('shapes', Ox),
      e._registerCommand('append', Tx),
      e._registerCommand('connect', Nx),
      e._registerCommand('color', Rx),
      e._registerCommand('create', Mx),
      e._registerCommand('element', Ix),
      e._registerCommand('elements', Lx),
      e._registerCommand('move', zx),
      e._registerCommand('redo', Fx),
      e._registerCommand('save', $x),
      e._registerCommand('setLabel', Hx),
      e._registerCommand('setRoot', qx),
      e._registerCommand('undo', Wx),
      e._registerCommand('removeShape', Gx),
      e._registerCommand('removeConnection', Ux),
      e._registerCommand('remove', Vx)
    }
    function Yx (e) {
      return Array.prototype.slice.call(e)
    }
    function Kx () {
      return function (e, t) {
        if (M(e) && (e = e.join(' ')),
        e === '' || e) { return e }
        if (t.defaultValue) { return t.defaultValue }
        throw new Error('no value given')
      }
    }
    function Jx () {
      return function (e, t) {
        if (e) { return e && e !== 'false' }
        if (t.defaultValue) { return t.defaultValue }
        if (!t.optional) { throw new Error('no value given') }
      }
    }
    function Xx () {
      return function (e, t) {
        if (e === 0 || e) { return L(e) ? e : parseFloat(e, 10) }
        if (t.defaultValue) { return t.defaultValue }
        throw new Error('no value given')
      }
    }
    function Zx (e, t) {
      this._commands = {},
      this._params = {},
      this._injector = t,
      this._registerParsers(),
      this._registerCommands(),
      this._bind(e)
    }
    Bx.$inject = ['elementRegistry'],
    Dx.$inject = ['elementRegistry'],
    Px.$inject = ['cli._params'],
    Ox.$inject = ['cli._params'],
    Tx.$inject = ['cli._params', 'modeling'],
    Rx.$inject = ['cli._params', 'modeling'],
    Nx.$inject = ['cli._params', 'modeling'],
    Mx.$inject = ['cli._params', 'modeling'],
    Ix.$inject = ['cli._params'],
    Lx.$inject = ['cli._params', 'elementRegistry'],
    zx.$inject = ['cli._params', 'modeling'],
    Fx.$inject = ['commandStack'],
    $x.$inject = ['cli._params', 'bpmnjs'],
    Hx.$inject = ['cli._params', 'modeling'],
    qx.$inject = ['cli._params', 'canvas'],
    Wx.$inject = ['commandStack'],
    Gx.$inject = ['cli._params', 'modeling'],
    Ux.$inject = ['cli._params', 'modeling'],
    Vx.$inject = ['cli._params', 'modeling'],
    Qx.$inject = ['cli'],
    Zx.$inject = ['config', 'injector'],
    Zx.prototype = {},
    Zx.prototype._bind = function (e) {
      e.cli && e.cli.bindTo && (console.info('bpmn-js-cli is available via window.' + e.cli.bindTo),
      window[e.cli.bindTo] = this)
    }
    ,
    Zx.prototype._registerParser = function (e, t) {
      let n; const r = this._injector.invoke(t)
      if (!z(r)) { throw new Error('parser must be a Function<String, Object> -> Object') }
      this._params[e] = (n = r,
      function (e, t) {
        return {
          name: e,
          parse: function (e) {
            return n(e, t || {})
          }
        }
      }
      )
    }
    ,
    Zx.prototype._registerCommand = function (e, t) {
      const n = z(t) ? this._injector.invoke(t) : t
      n.args = n.args || [],
      this._commands[e] = n
      const r = this
      this[e] = function () {
        const t = Yx(arguments)
        return t.unshift(e),
        r.exec.apply(r, t)
      }
    }
    ,
    Zx.prototype._registerParsers = function () {
      this._registerParser('string', Kx),
      this._registerParser('number', Xx),
      this._registerParser('bool', Jx)
    }
    ,
    Zx.prototype._registerCommands = function () {
      const e = this
      this._registerCommand('help', {
        exec: function () {
          let t = 'available commands:\n'
          return G(e._commands, function (e, n) {
            t += '\n\t' + n
          }
          ),
          t
        }
      })
    }
    ,
    Zx.prototype.parseArguments = function (e, t) {
      const n = []
      const r = t.args.length - 1
      return G(t.args, function (o, i) {
        let a
        a = i === r && e.length > t.args.length ? e.slice(i) : e[i]
        try {
          n.push(o.parse(a))
        } catch (e) {
          throw new Error('could not parse <' + o.name + '>: ' + e.message)
        }
      }
      ),
      n
    }
    ,
    Zx.prototype.exec = function () {
      let e = []
      Yx(arguments).forEach(function (t) {
        F(t) ? e = e.concat(t.split(/\s+/)) : e.push(t)
      }
      )
      let t; let n; const r = e.shift(); const o = this._commands[r]
      if (!o) { throw new Error('no command <' + r + '>, execute <commands> to get a list of available commands') }
      try {
        t = this.parseArguments(e, o),
        n = o.exec.apply(this, t)
      } catch (t) {
        throw new Error('failed to execute <' + r + '> with args <[' + e.join(', ') + ']> : ' + t.stack)
      }
      return n
    }

    const ew = {
      __init__: ['cliInitializer'],
      cli: ['type', Zx],
      cliInitializer: ['type', Qx]
    }
    const tw = Object.prototype.toString
    function nw (e) {
      if (!e || !e.nodeType) { throw new Error('A DOM element reference is required') }
      this.el = e,
      this.list = e.classList
    }
    nw.prototype.add = function (e) {
      return this.list.add(e),
      this
    }
    ,
    nw.prototype.remove = function (e) {
      return tw.call(e) == '[object RegExp]'
        ? this.removeMatching(e)
        : (this.list.remove(e),
          this)
    }
    ,
    nw.prototype.removeMatching = function (e) {
      for (let t = this.array(), n = 0; n < t.length; n++) { e.test(t[n]) && this.remove(t[n]) }
      return this
    }
    ,
    nw.prototype.toggle = function (e, t) {
      return void 0 !== t ? t !== this.list.toggle(e, t) && this.list.toggle(e) : this.list.toggle(e),
      this
    }
    ,
    nw.prototype.array = function () {
      return Array.from(this.list)
    }
    ,
    nw.prototype.has = nw.prototype.contains = function (e) {
      return this.list.contains(e)
    }

    let rw; let ow; let iw; const aw = {}
    function sw () {
      rw = window.addEventListener ? 'addEventListener' : 'attachEvent',
      ow = window.removeEventListener ? 'removeEventListener' : 'detachEvent',
      iw = rw !== 'addEventListener' ? 'on' : ''
    }
    aw.bind = function (e, t, n, r) {
      return rw || sw(),
      e[rw](iw + t, n, r || !1),
      n
    }
    ,
    aw.unbind = function (e, t, n, r) {
      return ow || sw(),
      e[ow](iw + t, n, r || !1),
      n
    }

    const cw = 1e5
    const lw = 1e5
    function pw (e, t) {
      this._canvas = e
      const n = this
      t.on('diagram.init', function () {
        n._init(),
        n.toggle(!0)
      }
      ),
      t.on('gridSnapping.toggle', function (e) {
        const t = e.active
        n.toggle(t),
        n._centerGridAroundViewbox()
      }
      ),
      t.on('canvas.viewbox.changed', function (e) {
        const t = e.viewbox
        n._centerGridAroundViewbox(t)
      }
      )
    }
    pw.prototype._init = function () {
      let e = ('defs',
      (this._canvas._svg || document).querySelector('defs'))
      e || (e = et('defs'),
      Fe(this._canvas._svg, e))
      const t = this._pattern = et('pattern')
      const n = 'djs-grid-pattern-' + Math.trunc(1e6 * Math.random())
      We(t, {
        id: n,
        width: eA,
        height: eA,
        patternUnits: 'userSpaceOnUse'
      })
      const r = this._circle = et('circle')
      We(r, {
        cx: 0.5,
        cy: 0.5,
        r: 0.5,
        fill: '#ccc'
      }),
      Fe(t, r),
      Fe(e, t),
      We(this._gfx = et('rect'), {
        x: -5e4,
        y: -5e4,
        width: cw,
        height: lw,
        fill: 'url(#'.concat(n, ')')
      })
    }
    ,
    pw.prototype._centerGridAroundViewbox = function (e) {
      e || (e = this._canvas.viewbox())
      const t = _r(e)
      We(this._gfx, {
        x: -5e4 + tA(t.x, eA),
        y: -5e4 + tA(t.y, eA)
      })
    }
    ,
    pw.prototype.isVisible = function () {
      return this._visible
    }
    ,
    pw.prototype.toggle = function (e) {
      if (void 0 === e && (e = !this._visible),
      e !== this._visible) {
        const t = this._getParent()
        e ? Fe(t, this._gfx) : Ye(t),
        this._visible = e
      }
    }
    ,
    pw.prototype._getParent = function () {
      return this._canvas.getLayer('djs-grid', -2)
    }
    ,
    pw.$inject = ['canvas', 'eventBus']
    const uw = {
      __init__: ['grid'],
      grid: ['type', pw]
    }
    function dw (e) {
      return dw = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      dw(e)
    }
    function fw (e, t) {
      return (function (e) {
        if (Array.isArray(e)) { return e }
      }(e)) || (function (e, t) {
        let n = e == null ? null : typeof Symbol !== 'undefined' && e[Symbol.iterator] || e['@@iterator']
        if (n != null) {
          let r; let o; let i; let a; const s = []; let c = !0; let l = !1
          try {
            if (i = (n = n.call(e)).next,
            t === 0) {
              if (Object(n) !== n) { return }
              c = !1
            } else {
              for (; !(c = (r = i.call(n)).done) && (s.push(r.value),
              s.length !== t); c = !0)
                ;
            }
          } catch (e) {
            l = !0,
            o = e
          } finally {
            try {
              if (!c && n.return != null && (a = n.return(),
              Object(a) !== a)) { return }
            } finally {
              if (l) { throw o }
            }
          }
          return s
        }
      }(e, t)) || mw(e, t) || (function () {
        throw new TypeError('Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
      }())
    }
    function hw (e) {
      return (function (e) {
        if (Array.isArray(e)) { return vw(e) }
      }(e)) || (function (e) {
        if (typeof Symbol !== 'undefined' && e[Symbol.iterator] != null || e['@@iterator'] != null) { return Array.from(e) }
      }(e)) || mw(e) || (function () {
        throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
      }())
    }
    function mw (e, t) {
      if (e) {
        if (typeof e === 'string') { return vw(e, t) }
        let n = Object.prototype.toString.call(e).slice(8, -1)
        return n === 'Object' && e.constructor && (n = e.constructor.name),
        n === 'Map' || n === 'Set' ? Array.from(e) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? vw(e, t) : void 0
      }
    }
    function vw (e, t) {
      (t == null || t > e.length) && (t = e.length)
      for (var n = 0, r = new Array(t); n < t; n++) { r[n] = e[n] }
      return r
    }
    function gw (e, t) {
      const n = Object.keys(e)
      if (Object.getOwnPropertySymbols) {
        let r = Object.getOwnPropertySymbols(e)
        t && (r = r.filter(function (t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable
        }
        )),
        n.push.apply(n, r)
      }
      return n
    }
    function yw (e) {
      for (let t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {}
        t % 2
          ? gw(Object(n), !0).forEach(function (t) {
            let r, o, i
            r = e,
            o = t,
            i = n[t],
            o = (function (e) {
              const t = (function (e, t) {
                if (dw(e) != 'object' || !e) { return e }
                const n = e[Symbol.toPrimitive]
                if (void 0 !== n) {
                  const r = n.call(e, 'string')
                  if (dw(r) != 'object') { return r }
                  throw new TypeError('@@toPrimitive must return a primitive value.')
                }
                return String(e)
              }(e))
              return dw(t) == 'symbol' ? t : t + ''
            }(o)),
            o in r
              ? Object.defineProperty(r, o, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
              })
              : r[o] = i
          }
          )
          : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
            : gw(Object(n)).forEach(function (t) {
              Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
            }
            )
      }
      return e
    }
    const bw = Object.prototype.toString
    const Aw = Object.prototype.hasOwnProperty
    function Ew (e) {
      return void 0 === e
    }
    function xw (e) {
      return bw.call(e) === '[object Array]'
    }
    function ww (e) {
      return bw.call(e) === '[object Object]'
    }
    function _w (e) {
      return bw.call(e) === '[object Number]'
    }
    function Cw (e) {
      const t = bw.call(e)
      return t === '[object Function]' || t === '[object AsyncFunction]' || t === '[object GeneratorFunction]' || t === '[object AsyncGeneratorFunction]' || t === '[object Proxy]'
    }
    function Sw (e, t) {
      return Aw.call(e, t)
    }
    function kw (e, t) {
      let n; const r = (function (e) {
        return Cw(e)
          ? e
          : function (t) {
            return t === e
          }
      }(t))
      return jw(e, function (e, t) {
        if (r(e, t)) {
          return n = e,
          !1
        }
      }
      ),
      n
    }
    function jw (e, t) {
      let n
      if (!Ew(e)) {
        const r = xw(e) ? Dw : Bw
        for (const o in e) {
          if (Sw(e, o) && !1 === t(n = e[o], r(o))) { return n }
        }
      }
    }
    function Bw (e) {
      return e
    }
    function Dw (e) {
      return Number(e)
    }
    function Pw (e) {
      for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) { n[r - 1] = arguments[r] }
      return Object.assign.apply(Object, [e].concat(n))
    }
    const Ow = {
      id: 'events',
      name: 'Events'
    }
    const Tw = {
      id: 'tasks',
      name: 'Tasks'
    }
    const Rw = {
      id: 'data',
      name: 'Data'
    }
    const Nw = {
      id: 'participants',
      name: 'Participants'
    }
    const Mw = {
      id: 'subprocess',
      name: 'Sub-processes'
    }
    const Iw = {
      id: 'gateways',
      name: 'Gateways'
    }
    const Lw = [{
      label: 'Start event',
      actionName: 'none-start-event',
      className: 'bpmn-icon-start-event-none',
      target: {
        type: 'bpmn:StartEvent'
      }
    }, {
      label: 'Intermediate throw event',
      actionName: 'none-intermediate-throwing',
      className: 'bpmn-icon-intermediate-event-none',
      target: {
        type: 'bpmn:IntermediateThrowEvent'
      }
    }, {
      label: 'Boundary event',
      actionName: 'none-boundary-event',
      className: 'bpmn-icon-intermediate-event-none',
      target: {
        type: 'bpmn:BoundaryEvent'
      }
    }, {
      label: 'End event',
      actionName: 'none-end-event',
      className: 'bpmn-icon-end-event-none',
      target: {
        type: 'bpmn:EndEvent'
      }
    }].map(function (e) {
      return yw(yw({}, e), {}, {
        group: Ow
      })
    }
    )
    const zw = [{
      label: 'Message start event',
      actionName: 'message-start',
      className: 'bpmn-icon-start-event-message',
      target: {
        type: 'bpmn:StartEvent',
        eventDefinitionType: 'bpmn:MessageEventDefinition'
      }
    }, {
      label: 'Timer start event',
      actionName: 'timer-start',
      className: 'bpmn-icon-start-event-timer',
      target: {
        type: 'bpmn:StartEvent',
        eventDefinitionType: 'bpmn:TimerEventDefinition'
      }
    }, {
      label: 'Conditional start event',
      actionName: 'conditional-start',
      className: 'bpmn-icon-start-event-condition',
      target: {
        type: 'bpmn:StartEvent',
        eventDefinitionType: 'bpmn:ConditionalEventDefinition'
      }
    }, {
      label: 'Signal start event',
      actionName: 'signal-start',
      className: 'bpmn-icon-start-event-signal',
      target: {
        type: 'bpmn:StartEvent',
        eventDefinitionType: 'bpmn:SignalEventDefinition'
      }
    }].map(function (e) {
      return yw(yw({}, e), {}, {
        group: Ow
      })
    }
    )
    const Fw = [{
      label: 'Message intermediate catch event',
      actionName: 'message-intermediate-catch',
      className: 'bpmn-icon-intermediate-event-catch-message',
      target: {
        type: 'bpmn:IntermediateCatchEvent',
        eventDefinitionType: 'bpmn:MessageEventDefinition'
      }
    }, {
      label: 'Message intermediate throw event',
      actionName: 'message-intermediate-throw',
      className: 'bpmn-icon-intermediate-event-throw-message',
      target: {
        type: 'bpmn:IntermediateThrowEvent',
        eventDefinitionType: 'bpmn:MessageEventDefinition'
      }
    }, {
      label: 'Timer intermediate catch event',
      actionName: 'timer-intermediate-catch',
      className: 'bpmn-icon-intermediate-event-catch-timer',
      target: {
        type: 'bpmn:IntermediateCatchEvent',
        eventDefinitionType: 'bpmn:TimerEventDefinition'
      }
    }, {
      label: 'Escalation intermediate throw event',
      actionName: 'escalation-intermediate-throw',
      className: 'bpmn-icon-intermediate-event-throw-escalation',
      target: {
        type: 'bpmn:IntermediateThrowEvent',
        eventDefinitionType: 'bpmn:EscalationEventDefinition'
      }
    }, {
      label: 'Conditional intermediate catch event',
      actionName: 'conditional-intermediate-catch',
      className: 'bpmn-icon-intermediate-event-catch-condition',
      target: {
        type: 'bpmn:IntermediateCatchEvent',
        eventDefinitionType: 'bpmn:ConditionalEventDefinition'
      }
    }, {
      label: 'Link intermediate catch event',
      actionName: 'link-intermediate-catch',
      className: 'bpmn-icon-intermediate-event-catch-link',
      target: {
        type: 'bpmn:IntermediateCatchEvent',
        eventDefinitionType: 'bpmn:LinkEventDefinition',
        eventDefinitionAttrs: {
          name: ''
        }
      }
    }, {
      label: 'Link intermediate throw event',
      actionName: 'link-intermediate-throw',
      className: 'bpmn-icon-intermediate-event-throw-link',
      target: {
        type: 'bpmn:IntermediateThrowEvent',
        eventDefinitionType: 'bpmn:LinkEventDefinition',
        eventDefinitionAttrs: {
          name: ''
        }
      }
    }, {
      label: 'Compensation intermediate throw event',
      actionName: 'compensation-intermediate-throw',
      className: 'bpmn-icon-intermediate-event-throw-compensation',
      target: {
        type: 'bpmn:IntermediateThrowEvent',
        eventDefinitionType: 'bpmn:CompensateEventDefinition'
      }
    }, {
      label: 'Signal intermediate catch event',
      actionName: 'signal-intermediate-catch',
      className: 'bpmn-icon-intermediate-event-catch-signal',
      target: {
        type: 'bpmn:IntermediateCatchEvent',
        eventDefinitionType: 'bpmn:SignalEventDefinition'
      }
    }, {
      label: 'Signal intermediate throw event',
      actionName: 'signal-intermediate-throw',
      className: 'bpmn-icon-intermediate-event-throw-signal',
      target: {
        type: 'bpmn:IntermediateThrowEvent',
        eventDefinitionType: 'bpmn:SignalEventDefinition'
      }
    }].map(function (e) {
      return yw(yw({}, e), {}, {
        group: Ow
      })
    }
    )
    const $w = [{
      label: 'Message boundary event',
      actionName: 'message-boundary',
      className: 'bpmn-icon-intermediate-event-catch-message',
      target: {
        type: 'bpmn:BoundaryEvent',
        eventDefinitionType: 'bpmn:MessageEventDefinition'
      }
    }, {
      label: 'Timer boundary event',
      actionName: 'timer-boundary',
      className: 'bpmn-icon-intermediate-event-catch-timer',
      target: {
        type: 'bpmn:BoundaryEvent',
        eventDefinitionType: 'bpmn:TimerEventDefinition'
      }
    }, {
      label: 'Escalation boundary event',
      actionName: 'escalation-boundary',
      className: 'bpmn-icon-intermediate-event-catch-escalation',
      target: {
        type: 'bpmn:BoundaryEvent',
        eventDefinitionType: 'bpmn:EscalationEventDefinition'
      }
    }, {
      label: 'Conditional boundary event',
      actionName: 'conditional-boundary',
      className: 'bpmn-icon-intermediate-event-catch-condition',
      target: {
        type: 'bpmn:BoundaryEvent',
        eventDefinitionType: 'bpmn:ConditionalEventDefinition'
      }
    }, {
      label: 'Error boundary event',
      actionName: 'error-boundary',
      className: 'bpmn-icon-intermediate-event-catch-error',
      target: {
        type: 'bpmn:BoundaryEvent',
        eventDefinitionType: 'bpmn:ErrorEventDefinition'
      }
    }, {
      label: 'Cancel boundary event',
      actionName: 'cancel-boundary',
      className: 'bpmn-icon-intermediate-event-catch-cancel',
      target: {
        type: 'bpmn:BoundaryEvent',
        eventDefinitionType: 'bpmn:CancelEventDefinition'
      }
    }, {
      label: 'Signal boundary event',
      actionName: 'signal-boundary',
      className: 'bpmn-icon-intermediate-event-catch-signal',
      target: {
        type: 'bpmn:BoundaryEvent',
        eventDefinitionType: 'bpmn:SignalEventDefinition'
      }
    }, {
      label: 'Compensation boundary event',
      actionName: 'compensation-boundary',
      className: 'bpmn-icon-intermediate-event-catch-compensation',
      target: {
        type: 'bpmn:BoundaryEvent',
        eventDefinitionType: 'bpmn:CompensateEventDefinition'
      }
    }, {
      label: 'Message boundary event (non-interrupting)',
      actionName: 'non-interrupting-message-boundary',
      className: 'bpmn-icon-intermediate-event-catch-non-interrupting-message',
      target: {
        type: 'bpmn:BoundaryEvent',
        eventDefinitionType: 'bpmn:MessageEventDefinition',
        cancelActivity: !1
      }
    }, {
      label: 'Timer boundary event (non-interrupting)',
      actionName: 'non-interrupting-timer-boundary',
      className: 'bpmn-icon-intermediate-event-catch-non-interrupting-timer',
      target: {
        type: 'bpmn:BoundaryEvent',
        eventDefinitionType: 'bpmn:TimerEventDefinition',
        cancelActivity: !1
      }
    }, {
      label: 'Escalation boundary event (non-interrupting)',
      actionName: 'non-interrupting-escalation-boundary',
      className: 'bpmn-icon-intermediate-event-catch-non-interrupting-escalation',
      target: {
        type: 'bpmn:BoundaryEvent',
        eventDefinitionType: 'bpmn:EscalationEventDefinition',
        cancelActivity: !1
      }
    }, {
      label: 'Conditional boundary event (non-interrupting)',
      actionName: 'non-interrupting-conditional-boundary',
      className: 'bpmn-icon-intermediate-event-catch-non-interrupting-condition',
      target: {
        type: 'bpmn:BoundaryEvent',
        eventDefinitionType: 'bpmn:ConditionalEventDefinition',
        cancelActivity: !1
      }
    }, {
      label: 'Signal boundary event (non-interrupting)',
      actionName: 'non-interrupting-signal-boundary',
      className: 'bpmn-icon-intermediate-event-catch-non-interrupting-signal',
      target: {
        type: 'bpmn:BoundaryEvent',
        eventDefinitionType: 'bpmn:SignalEventDefinition',
        cancelActivity: !1
      }
    }].map(function (e) {
      return yw(yw({}, e), {}, {
        group: Ow
      })
    }
    )
    const Hw = [{
      label: 'Message end event',
      actionName: 'message-end',
      className: 'bpmn-icon-end-event-message',
      target: {
        type: 'bpmn:EndEvent',
        eventDefinitionType: 'bpmn:MessageEventDefinition'
      }
    }, {
      label: 'Escalation end event',
      actionName: 'escalation-end',
      className: 'bpmn-icon-end-event-escalation',
      target: {
        type: 'bpmn:EndEvent',
        eventDefinitionType: 'bpmn:EscalationEventDefinition'
      }
    }, {
      label: 'Error end event',
      actionName: 'error-end',
      className: 'bpmn-icon-end-event-error',
      target: {
        type: 'bpmn:EndEvent',
        eventDefinitionType: 'bpmn:ErrorEventDefinition'
      }
    }, {
      label: 'Cancel end event',
      actionName: 'cancel-end',
      className: 'bpmn-icon-end-event-cancel',
      target: {
        type: 'bpmn:EndEvent',
        eventDefinitionType: 'bpmn:CancelEventDefinition'
      }
    }, {
      label: 'Compensation end event',
      actionName: 'compensation-end',
      className: 'bpmn-icon-end-event-compensation',
      target: {
        type: 'bpmn:EndEvent',
        eventDefinitionType: 'bpmn:CompensateEventDefinition'
      }
    }, {
      label: 'Signal end event',
      actionName: 'signal-end',
      className: 'bpmn-icon-end-event-signal',
      target: {
        type: 'bpmn:EndEvent',
        eventDefinitionType: 'bpmn:SignalEventDefinition'
      }
    }, {
      label: 'Terminate end event',
      actionName: 'terminate-end',
      className: 'bpmn-icon-end-event-terminate',
      target: {
        type: 'bpmn:EndEvent',
        eventDefinitionType: 'bpmn:TerminateEventDefinition'
      }
    }].map(function (e) {
      return yw(yw({}, e), {}, {
        group: Ow
      })
    }
    )
    const qw = [{
      label: 'Exclusive gateway',
      actionName: 'exclusive-gateway',
      className: 'bpmn-icon-gateway-xor',
      target: {
        type: 'bpmn:ExclusiveGateway'
      }
    }, {
      label: 'Parallel gateway',
      actionName: 'parallel-gateway',
      className: 'bpmn-icon-gateway-parallel',
      target: {
        type: 'bpmn:ParallelGateway'
      }
    }, {
      label: 'Inclusive gateway',
      search: 'or',
      actionName: 'inclusive-gateway',
      className: 'bpmn-icon-gateway-or',
      target: {
        type: 'bpmn:InclusiveGateway'
      },
      rank: -1
    }, {
      label: 'Complex gateway',
      actionName: 'complex-gateway',
      className: 'bpmn-icon-gateway-complex',
      target: {
        type: 'bpmn:ComplexGateway'
      },
      rank: -1
    }, {
      label: 'Event-based gateway',
      actionName: 'event-based-gateway',
      className: 'bpmn-icon-gateway-eventbased',
      target: {
        type: 'bpmn:EventBasedGateway',
        instantiate: !1,
        eventGatewayType: 'Exclusive'
      }
    }].map(function (e) {
      return yw(yw({}, e), {}, {
        group: Iw
      })
    }
    )
    const Ww = [{
      label: 'Call activity',
      actionName: 'call-activity',
      className: 'bpmn-icon-call-activity',
      target: {
        type: 'bpmn:CallActivity'
      }
    }, {
      label: 'Transaction',
      actionName: 'transaction',
      className: 'bpmn-icon-transaction',
      target: {
        type: 'bpmn:Transaction',
        isExpanded: !0
      }
    }, {
      label: 'Event sub-process',
      search: 'subprocess',
      actionName: 'event-subprocess',
      className: 'bpmn-icon-event-subprocess-expanded',
      target: {
        type: 'bpmn:SubProcess',
        triggeredByEvent: !0,
        isExpanded: !0
      }
    }, {
      label: 'Sub-process (collapsed)',
      search: 'subprocess',
      actionName: 'collapsed-subprocess',
      className: 'bpmn-icon-subprocess-collapsed',
      target: {
        type: 'bpmn:SubProcess',
        isExpanded: !1
      }
    }, {
      label: 'Sub-process (expanded)',
      search: 'subprocess',
      actionName: 'expanded-subprocess',
      className: 'bpmn-icon-subprocess-collapsed',
      target: {
        type: 'bpmn:SubProcess',
        isExpanded: !0
      }
    }].map(function (e) {
      return yw(yw({}, e), {}, {
        group: Mw
      })
    }
    )
    const Gw = [{
      label: 'Task',
      actionName: 'task',
      className: 'bpmn-icon-task',
      target: {
        type: 'bpmn:Task'
      }
    }, {
      label: 'User task',
      actionName: 'user-task',
      className: 'bpmn-icon-user',
      target: {
        type: 'bpmn:UserTask'
      }
    }, {
      label: 'Service task',
      actionName: 'service-task',
      className: 'bpmn-icon-service',
      target: {
        type: 'bpmn:ServiceTask'
      }
    }, {
      label: 'Send task',
      actionName: 'send-task',
      className: 'bpmn-icon-send',
      target: {
        type: 'bpmn:SendTask'
      },
      rank: -1
    }, {
      label: 'Receive task',
      actionName: 'receive-task',
      className: 'bpmn-icon-receive',
      target: {
        type: 'bpmn:ReceiveTask'
      },
      rank: -1
    }, {
      label: 'Manual task',
      actionName: 'manual-task',
      className: 'bpmn-icon-manual',
      target: {
        type: 'bpmn:ManualTask'
      },
      rank: -1
    }, {
      label: 'Business rule task',
      actionName: 'rule-task',
      className: 'bpmn-icon-business-rule',
      target: {
        type: 'bpmn:BusinessRuleTask'
      }
    }, {
      label: 'Script task',
      actionName: 'script-task',
      className: 'bpmn-icon-script',
      target: {
        type: 'bpmn:ScriptTask'
      }
    }].map(function (e) {
      return yw(yw({}, e), {}, {
        group: Tw
      })
    }
    )
    const Uw = [{
      label: 'Data store reference',
      actionName: 'data-store-reference',
      className: 'bpmn-icon-data-store',
      target: {
        type: 'bpmn:DataStoreReference'
      }
    }, {
      label: 'Data object reference',
      actionName: 'data-object-reference',
      className: 'bpmn-icon-data-object',
      target: {
        type: 'bpmn:DataObjectReference'
      }
    }].map(function (e) {
      return yw(yw({}, e), {}, {
        group: Rw
      })
    }
    )
    const Vw = [{
      label: 'Expanded pool/participant',
      search: 'Non-empty pool/participant',
      actionName: 'expanded-pool',
      className: 'bpmn-icon-participant',
      target: {
        type: 'bpmn:Participant',
        isExpanded: !0
      }
    }, {
      label: 'Empty pool/participant',
      search: 'Collapsed pool/participant',
      actionName: 'collapsed-pool',
      className: 'bpmn-icon-lane',
      target: {
        type: 'bpmn:Participant',
        isExpanded: !1
      }
    }].map(function (e) {
      return yw(yw({}, e), {}, {
        group: Nw
      })
    }
    )
    const Qw = [].concat(hw(qw), hw(Gw), hw(Ww), hw(Lw), hw(zw), hw(Fw), hw(Hw), hw($w), hw(Uw), hw(Vw))
    function Yw (e, t, n, r, o, i, a) {
      this._elementFactory = e,
      this._popupMenu = t,
      this._create = n,
      this._autoPlace = r,
      this._rules = o,
      this._create = n,
      this._mouse = i,
      this._translate = a,
      this.register()
    }
    function Kw (e, t, n, r) {
      this._contextPad = e,
      this._popupMenu = t,
      this._translate = n,
      this._canvas = r,
      this.register()
    }
    function Jw (e, t) {
      t && (e.super_ = t,
      e.prototype = Object.create(t.prototype, {
        constructor: {
          value: e,
          enumerable: !1,
          writable: !0,
          configurable: !0
        }
      }))
    }
    function Xw (e, t) {
      const n = e_(e)
      return n && typeof n.$instanceOf === 'function' && n.$instanceOf(t)
    }
    function Zw (e, t) {
      return !!kw(t, function (t) {
        return Xw(e, t)
      }
      )
    }
    function e_ (e) {
      return e && e.businessObject || e
    }
    function t_ (e) {
      this._eventBus = e
    }
    function n_ (e) {
      return function (t, n, r, o, i) {
        (Cw(t) || _w(t)) && (i = o,
        o = r,
        r = n,
        n = t,
        t = null),
        this.on(t, e, n, r, o, i)
      }
    }
    function r_ (e) {
      t_.call(this, e),
      this.init()
    }
    function o_ (e) {
      r_.call(this, e)
    }
    Yw.$inject = ['elementFactory', 'popupMenu', 'create', 'autoPlace', 'rules', 'mouse', 'translate'],
    Yw.prototype.register = function () {
      this._popupMenu.registerProvider('bpmn-append', this)
    }
    ,
    Yw.prototype.getPopupMenuEntries = function (e) {
      const t = this
      const n = this._rules
      const r = this._translate
      const o = {}
      return n.allowed('shape.append', {
        element: e
      })
        ? (this._filterEntries(Qw).forEach(function (n) {
            const i = n.actionName
            const a = n.className
            const s = n.label
            const c = n.target
            const l = n.description
            const p = n.group
            const u = n.search
            const d = n.rank
            o['append-'.concat(i)] = {
              label: s && r(s),
              className: a,
              description: l,
              group: p && yw(yw({}, p), {}, {
                name: r(p.name)
              }),
              search: u,
              rank: d,
              action: t._createEntryAction(e, c)
            }
          }
          ),
          o)
        : []
    }
    ,
    Yw.prototype._filterEntries = function (e) {
      return e.filter(function (e) {
        const t = e.target
        const n = t.type
        const r = t.eventDefinitionType
        return !(['bpmn:StartEvent', 'bpmn:Participant'].includes(n) || n === 'bpmn:BoundaryEvent' && Ew(r))
      }
      )
    }
    ,
    Yw.prototype._createEntryAction = function (e, t) {
      const n = this._elementFactory
      const r = this._autoPlace
      const o = this._create
      const i = this._mouse
      const a = function (r) {
        const a = n.create('shape', t)
        return r instanceof KeyboardEvent && (r = i.getLastMoveEvent()),
        o.start(r, a, {
          source: e
        })
      }
      return {
        click: this._canAutoPlaceElement(t)
          ? function () {
            const o = n.create('shape', t)
            r.append(e, o)
          }
          : a,
        dragstart: a
      }
    }
    ,
    Yw.prototype._canAutoPlaceElement = function (e) {
      const t = e.type
      return !(t === 'bpmn:BoundaryEvent' || t === 'bpmn:SubProcess' && e.triggeredByEvent || t === 'bpmn:IntermediateCatchEvent' && e.eventDefinitionType === 'bpmn:LinkEventDefinition')
    }
    ,
    Kw.$inject = ['contextPad', 'popupMenu', 'translate', 'canvas'],
    Kw.prototype.register = function () {
      this._contextPad.registerProvider(this)
    }
    ,
    Kw.prototype.getContextPadEntries = function (e) {
      const t = this._popupMenu
      const n = this._translate
      const r = this._getAppendMenuPosition.bind(this)
      if (!t.isEmpty(e, 'bpmn-append')) {
        return {
          append: {
            group: 'model',
            html: '<div class="entry">'.concat('<svg width="22" height="22" viewBox="0 0 5.82 5.82" xmlns="http://www.w3.org/2000/svg" fill="currentColor">\n  <path d="M1.3 3.4c.3 0 .5-.2.5-.5s-.2-.4-.5-.4c-.2 0-.4.1-.4.4 0 .3.2.5.4.5zM3 3.4c.2 0 .4-.2.4-.5s-.2-.4-.4-.4c-.3 0-.5.1-.5.4 0 .3.2.5.5.5zM4.6 3.4c.2 0 .4-.2.4-.5s-.2-.4-.4-.4c-.3 0-.5.1-.5.4 0 .3.2.5.5.5z"/>\n</svg>', '</div>'),
            title: n('Append element'),
            action: {
              click: function (e, o) {
                const i = Pw(r(o), {
                  cursor: {
                    x: e.x,
                    y: e.y
                  }
                })
                t.open(o, 'bpmn-append', i, {
                  title: n('Append element'),
                  width: 300,
                  search: !0
                })
              }
            }
          }
        }
      }
    }
    ,
    Kw.prototype._getAppendMenuPosition = function (e) {
      const t = this._contextPad.getPad(e).html.getBoundingClientRect()
      return {
        x: t.right + 5,
        y: t.top
      }
    }
    ,
    t_.$inject = ['eventBus'],
    t_.prototype.on = function (e, t, n, r, o, i) {
      if ((Cw(t) || _w(t)) && (i = o,
      o = r,
      r = n,
      n = t,
      t = null),
      Cw(n) && (i = o,
      o = r,
      r = n,
      n = 1e3),
      ww(o) && (i = o,
      o = !1),
      !Cw(r)) { throw new Error('handlerFn must be a function') }
      xw(e) || (e = [e])
      const a = this._eventBus
      jw(e, function (e) {
        const s = ['commandStack', e, t].filter(function (e) {
          return e
        }
        ).join('.')
        a.on(s, n, o
          ? (function (e, t) {
              return function (n) {
                return e.call(t || null, n.context, n.command, n)
              }
            }(r, i))
          : r, i)
      }
      )
    }
    ,
    t_.prototype.canExecute = n_('canExecute'),
    t_.prototype.preExecute = n_('preExecute'),
    t_.prototype.preExecuted = n_('preExecuted'),
    t_.prototype.execute = n_('execute'),
    t_.prototype.executed = n_('executed'),
    t_.prototype.postExecute = n_('postExecute'),
    t_.prototype.postExecuted = n_('postExecuted'),
    t_.prototype.revert = n_('revert'),
    t_.prototype.reverted = n_('reverted'),
    r_.$inject = ['eventBus'],
    Jw(r_, t_),
    r_.prototype.addRule = function (e, t, n) {
      const r = this
      typeof e === 'string' && (e = [e]),
      e.forEach(function (e) {
        r.canExecute(e, t, function (e, t, r) {
          return n(e)
        }
        , !0)
      }
      )
    }
    ,
    r_.prototype.init = function () {}
    ,
    Jw(o_, r_),
    o_.$inject = ['eventBus'],
    o_.prototype.init = function () {
      this.addRule('shape.append', function (e) {
        let t; const n = e.element; const r = e_(n)
        return (!ww(t = n) || !Sw(t, 'labelTarget')) && !Zw(n, ['bpmn:EndEvent', 'bpmn:Group', 'bpmn:TextAnnotation', 'bpmn:Lane', 'bpmn:Participant', 'bpmn:DataStoreReference', 'bpmn:DataObjectReference']) && !n.waypoints && (!Xw(n, 'bpmn:IntermediateThrowEvent') || !kw(e_(n).eventDefinitions || [], function (e) {
          return Xw(e, 'bpmn:LinkEventDefinition')
        }
        )) && (!Xw(n, 'bpmn:SubProcess') || !r.triggeredByEvent) && void 0
      }
      )
    }

    let i_; const a_ = {
      __init__: ['appendMenuProvider', 'appendContextPadProvider', 'appendRules'],
      appendMenuProvider: ['type', Yw],
      appendContextPadProvider: ['type', Kw],
      appendRules: ['type', o_]
    }
    function s_ (e, t, n, r, o, i) {
      this._elementFactory = e,
      this._popupMenu = t,
      this._create = n,
      this._autoPlace = r,
      this._mouse = o,
      this._translate = i,
      this.register()
    }
    function c_ (e, t, n, r, o) {
      this._palette = e,
      this._translate = t,
      this._popupMenu = n,
      this._canvas = r,
      this._mouse = o,
      this.register()
    }
    s_.$inject = ['elementFactory', 'popupMenu', 'create', 'autoPlace', 'mouse', 'translate'],
    s_.prototype.register = function () {
      this._popupMenu.registerProvider('bpmn-create', this)
    }
    ,
    s_.prototype.getPopupMenuEntries = function () {
      const e = this
      const t = {}
      return Qw.forEach(function (n) {
        const r = n.actionName
        const o = n.className
        const i = n.label
        const a = n.target
        const s = n.description
        const c = n.group
        const l = n.search
        const p = n.rank
        const u = e._createEntryAction(a)
        t['create-'.concat(r)] = {
          label: i && e._translate(i),
          className: o,
          description: s,
          group: c && yw(yw({}, c), {}, {
            name: e._translate(c.name)
          }),
          search: l,
          rank: p,
          action: {
            click: u,
            dragstart: u
          }
        }
      }
      ),
      t
    }
    ,
    s_.prototype._createEntryAction = function (e) {
      let t; const n = this._create; const r = this._mouse; const o = this._popupMenu; const i = this._elementFactory
      return function (a) {
        return o.close(),
        t = e.type === 'bpmn:Participant' ? i.createParticipantShape(e) : i.create('shape', e),
        a instanceof KeyboardEvent && (a = r.getLastMoveEvent()),
        n.start(a, t)
      }
    }
    ,
    typeof document !== 'undefined' && ((i_ = document.createElement('div')).innerHTML = '  <link/><table></table><a href="/a">a</a><input type="checkbox"/>',
    i_.getElementsByTagName('link').length,
    i_ = void 0),
    c_.$inject = ['palette', 'translate', 'popupMenu', 'canvas', 'mouse'],
    c_.prototype.register = function () {
      this._palette.registerProvider(900, this)
    }
    ,
    c_.prototype.getPaletteEntries = function (e) {
      const t = this._translate
      const n = this._popupMenu
      const r = this._canvas
      const o = this._mouse
      return {
        create: {
          group: 'create',
          html: '<div class="entry"> '.concat('<svg width="46" height="46" viewBox="-2 -2 9.82 9.82" xmlns="http://www.w3.org/2000/svg" fill="currentColor">\n  <path d="M1.3 3.4c.3 0 .5-.2.5-.5s-.2-.4-.5-.4c-.2 0-.4.1-.4.4 0 .3.2.5.4.5zM3 3.4c.2 0 .4-.2.4-.5s-.2-.4-.4-.4c-.3 0-.5.1-.5.4 0 .3.2.5.5.5zM4.6 3.4c.2 0 .4-.2.4-.5s-.2-.4-.4-.4c-.3 0-.5.1-.5.4 0 .3.2.5.5.5z"/>\n</svg>', '</div>'),
          title: t('Create element'),
          action: {
            click: function (e) {
              const i = (function (e) {
                if (e instanceof KeyboardEvent) {
                  return {
                    x: (e = o.getLastMoveEvent()).x,
                    y: e.y
                  }
                }
                let t; const n = e && e.target || (t = t || document).querySelector('.djs-palette [data-action="create"]'); const r = n.getBoundingClientRect()
                return n && {
                  x: r.left + r.width / 2 + 35,
                  y: r.top + r.height / 2 + 10
                }
              }(e))
              const a = r.getRootElement()
              n.open(a, 'bpmn-create', i, {
                title: t('Create element'),
                width: 300,
                search: !0
              })
            }
          }
        }
      }
    }

    const l_ = {
      __init__: ['createMenuProvider', 'createPaletteProvider'],
      createMenuProvider: ['type', s_],
      createPaletteProvider: ['type', c_]
    }
    function p_ (e) {
      this._injector = e,
      this.registerActions()
    }
    p_.$inject = ['injector'],
    p_.prototype.registerActions = function () {
      const e = this._injector.get('editorActions', !1)
      const t = this._injector.get('selection', !1)
      const n = this._injector.get('contextPad', !1)
      const r = this._injector.get('palette', !1)
      const o = this._injector.get('popupMenu', !1)
      const i = {}
      t && n && r && o && r && Pw(i, {
        appendElement: function (e) {
          const i = t && t.get()
          i.length != 1 || o.isEmpty(i[0], 'bpmn-append') ? r.triggerEntry('create', 'click', e) : n.triggerEntry('append', 'click', e)
        }
      }),
      r && Pw(i, {
        createElement: function (e) {
          r.triggerEntry('create', 'click', e)
        }
      }),
      e && e.register(i)
    }

    const u_ = {
      __depends__: [a_, l_],
      __init__: ['createAppendEditorActions'],
      createAppendEditorActions: ['type', p_]
    }
    const d_ = ['c', 'C']
    const f_ = ['v', 'V']
    const h_ = ['y', 'Y']
    const m_ = ['z', 'Z']
    function v_ (e) {
      return !e.altKey && (e.ctrlKey || e.metaKey)
    }
    function g_ (e, t) {
      return (e = xw(e) ? e : [e]).indexOf(t.key) !== -1 || e.indexOf(t.code) !== -1
    }
    function y_ (e) {
      return e.shiftKey
    }
    const b_ = 500
    function A_ (e, t) {
      const n = this
      e.on('editorActions.init', b_, function (e) {
        const r = e.editorActions
        n.registerBindings(t, r)
      }
      )
    }
    function E_ (e) {
      this._injector = e,
      this._keyboard = this._injector.get('keyboard', !1),
      this._editorActions = this._injector.get('editorActions', !1),
      this._keyboard && this._injector.invoke(A_, this)
    }
    A_.$inject = ['eventBus', 'keyboard'],
    A_.prototype.registerBindings = function (e, t) {
      function n (n, r) {
        t.isRegistered(n) && e.addListener(r)
      }
      n('undo', function (e) {
        if (v_(n = e.keyEvent) && !y_(n) && g_(m_, n)) {
          return t.trigger('undo'),
          !0
        }
        let n
      }
      ),
      n('redo', function (e) {
        if (v_(n = e.keyEvent) && (g_(h_, n) || g_(m_, n) && y_(n))) {
          return t.trigger('redo'),
          !0
        }
        let n
      }
      ),
      n('copy', function (e) {
        if (v_(n = e.keyEvent) && g_(d_, n)) {
          return t.trigger('copy'),
          !0
        }
        let n
      }
      ),
      n('paste', function (e) {
        if (v_(n = e.keyEvent) && g_(f_, n)) {
          return t.trigger('paste'),
          !0
        }
        let n
      }
      ),
      n('stepZoom', function (e) {
        const n = e.keyEvent
        if (g_(['+', 'Add', '='], n) && v_(n)) {
          return t.trigger('stepZoom', {
            value: 1
          }),
          !0
        }
      }
      ),
      n('stepZoom', function (e) {
        const n = e.keyEvent
        if (g_(['-', 'Subtract'], n) && v_(n)) {
          return t.trigger('stepZoom', {
            value: -1
          }),
          !0
        }
      }
      ),
      n('zoom', function (e) {
        const n = e.keyEvent
        if (g_('0', n) && v_(n)) {
          return t.trigger('zoom', {
            value: 1
          }),
          !0
        }
      }
      ),
      n('removeSelection', function (e) {
        if (g_(['Backspace', 'Delete', 'Del'], e.keyEvent)) {
          return t.trigger('removeSelection'),
          !0
        }
      }
      )
    }
    ,
    Jw(E_, A_),
    E_.$inject = ['injector'],
    E_.prototype.registerBindings = function () {
      const e = this._keyboard
      const t = this._editorActions
      function n (n, r) {
        t && t.isRegistered(n) && e && e.addListener(r)
      }
      A_.prototype.registerBindings.call(this, e, t),
      n('appendElement', function (n) {
        const r = n.keyEvent
        if (!e || !e.hasModifier(r)) {
          return e && e.isKey(['a', 'A'], r)
            ? (t && t.trigger('appendElement', r),
              !0)
            : void 0
        }
      }
      ),
      n('createElement', function (n) {
        const r = n.keyEvent
        if (!e || !e.hasModifier(r)) {
          return e && e.isKey(['n', 'N'], r)
            ? (t && t.trigger('createElement', r),
              !0)
            : void 0
        }
      }
      )
    }

    const x_ = {
      __depends__: [a_, l_, u_, {
        __depends__: [a_, l_],
        __init__: ['createAppendKeyboardBindings'],
        createAppendKeyboardBindings: ['type', E_]
      }]
    }
    function w_ (e, t, n, r, o, i, a) {
      this._popupMenu = e,
      this._translate = t,
      this._elementTemplates = n,
      this._autoPlace = r,
      this._create = o,
      this._mouse = i,
      this._rules = a,
      this.register()
    }
    function __ (e, t, n, r, o) {
      this._popupMenu = e,
      this._translate = t,
      this._elementTemplates = n,
      this._mouse = r,
      this._create = o,
      this.register()
    }
    function C_ (e, t, n) {
      this._popupMenu = e,
      this._translate = t,
      this._elementTemplates = n,
      this.register()
    }
    w_.$inject = ['popupMenu', 'translate', 'elementTemplates', 'autoPlace', 'create', 'move', 'rules'],
    w_.prototype.register = function () {
      this._popupMenu.registerProvider('bpmn-append', this)
    }
    ,
    w_.prototype.getPopupMenuEntries = function (e) {
      const t = this
      return function (n) {
        if (!t._rules.allowed('shape.append', {
          element: e
        })) { return [] }
        const r = t._filterTemplates(t._elementTemplates.getLatest())
        return Pw(n, t.getTemplateEntries(e, r)),
        n
      }
    }
    ,
    w_.prototype.getTemplateEntries = function (e, t) {
      const n = this
      const r = {}
      return t.map(function (t) {
        const o = t.icon
        const i = void 0 === o ? {} : o
        const a = t.category
        const s = 'append.template-'.concat(t.id)
        const c = {
          id: 'templates',
          name: n._translate('Templates')
        }
        r[s] = {
          label: t.name,
          description: t.description,
          documentationRef: t.documentationRef,
          imageUrl: i.contents,
          group: a || c,
          action: n._getEntryAction(e, t)
        }
      }
      ),
      r
    }
    ,
    w_.prototype._filterTemplates = function (e) {
      return e.filter(function (e) {
        const t = e.appliesTo
        const n = e.elementType
        const r = n && n.value || t[0]
        return !['bpmn:StartEvent', 'bpmn:Participant'].includes(r) && r !== 'bpmn:SequenceFlow'
      }
      )
    }
    ,
    w_.prototype._getEntryAction = function (e, t) {
      const n = this
      return {
        click: function () {
          const r = n._elementTemplates.createElement(t)
          n._autoPlace.append(e, r)
        },
        dragstart: function (r) {
          const o = n._elementTemplates.createElement(t)
          r instanceof KeyboardEvent && (r = n._mouse.getLastMoveEvent()),
          n._create.start(r, o, {
            source: e
          })
        }
      }
    }
    ,
    __.$inject = ['popupMenu', 'translate', 'elementTemplates', 'mouse', 'create'],
    __.prototype.register = function () {
      this._popupMenu.registerProvider('bpmn-create', this)
    }
    ,
    __.prototype.getPopupMenuEntries = function (e) {
      const t = this
      return function (n) {
        return Pw(n, t.getTemplateEntries(e)),
        n
      }
    }
    ,
    __.prototype.getTemplateEntries = function () {
      const e = this
      const t = this._elementTemplates.getLatest()
      const n = {}
      return t.map(function (t) {
        const r = t.icon
        const o = void 0 === r ? {} : r
        const i = t.category
        const a = 'create.template-'.concat(t.id)
        const s = {
          id: 'templates',
          name: e._translate('Templates')
        }
        n[a] = {
          label: t.name,
          description: t.description,
          documentationRef: t.documentationRef,
          imageUrl: o.contents,
          group: i || s,
          action: {
            click: e._getEntryAction(t),
            dragstart: e._getEntryAction(t)
          }
        }
      }
      ),
      n
    }
    ,
    __.prototype._getEntryAction = function (e) {
      const t = this._create
      const n = this._popupMenu
      const r = this._elementTemplates
      const o = this._mouse
      return function (i) {
        n.close()
        const a = r.createElement(e)
        return i instanceof KeyboardEvent && (i = o.getLastMoveEvent()),
        t.start(i, a)
      }
    }
    ,
    C_.$inject = ['popupMenu', 'translate', 'elementTemplates'],
    C_.prototype.register = function () {
      this._popupMenu.registerProvider('bpmn-replace', this)
    }
    ,
    C_.prototype.getPopupMenuEntries = function (e) {
      const t = this
      return function (n) {
        let r = Object.entries(n)
        return (r = [].concat(hw(r), hw(t.getTemplateEntries(e)))).reduce(function (e, t) {
          const n = fw(t, 2)
          const r = n[0]
          const o = n[1]
          return e[r] = o,
          e
        }
        , {})
      }
    }
    ,
    C_.prototype.getTemplateEntries = function (e) {
      const t = this
      return this._getMatchingTemplates(e).map(function (n) {
        const r = n.icon
        const o = void 0 === r ? {} : r
        const i = n.category
        const a = 'replace.template-'.concat(n.id)
        const s = {
          id: 'templates',
          name: t._translate('Templates')
        }
        return [a, {
          label: n.name,
          description: n.description,
          documentationRef: n.documentationRef,
          imageUrl: o.contents,
          group: i || s,
          action: function () {
            t._elementTemplates.applyTemplate(e, n)
          }
        }]
      }
      )
    }
    ,
    C_.prototype._getMatchingTemplates = function (e) {
      return this._elementTemplates.getLatest().filter(function (t) {
        return Zw(e, t.appliesTo) && !(function (e, t) {
          const n = e_(e)
          return !!n && n.get('zeebe:modelerTemplate') === t.id
        }(e, t))
      }
      )
    }

    const S_ = [{
      label: 'Transaction',
      actionName: 'replace-with-transaction',
      className: 'bpmn-icon-transaction',
      target: {
        type: 'bpmn:Transaction',
        isExpanded: !0
      }
    }, {
      label: 'Sub-process',
      actionName: 'replace-with-subprocess',
      className: 'bpmn-icon-subprocess-expanded',
      target: {
        type: 'bpmn:SubProcess',
        isExpanded: !0
      }
    }, {
      label: 'Event sub-process',
      actionName: 'replace-with-event-subprocess',
      className: 'bpmn-icon-event-subprocess-expanded',
      target: {
        type: 'bpmn:SubProcess',
        triggeredByEvent: !0,
        isExpanded: !0
      }
    }]
    const k_ = S_
    const j_ = Object.freeze({
      __proto__: null,
      BOUNDARY_EVENT: [{
        label: 'Message boundary event',
        actionName: 'replace-with-message-boundary',
        className: 'bpmn-icon-intermediate-event-catch-message',
        target: {
          type: 'bpmn:BoundaryEvent',
          eventDefinitionType: 'bpmn:MessageEventDefinition',
          cancelActivity: !0
        }
      }, {
        label: 'Timer boundary event',
        actionName: 'replace-with-timer-boundary',
        className: 'bpmn-icon-intermediate-event-catch-timer',
        target: {
          type: 'bpmn:BoundaryEvent',
          eventDefinitionType: 'bpmn:TimerEventDefinition',
          cancelActivity: !0
        }
      }, {
        label: 'Escalation boundary event',
        actionName: 'replace-with-escalation-boundary',
        className: 'bpmn-icon-intermediate-event-catch-escalation',
        target: {
          type: 'bpmn:BoundaryEvent',
          eventDefinitionType: 'bpmn:EscalationEventDefinition',
          cancelActivity: !0
        }
      }, {
        label: 'Conditional boundary event',
        actionName: 'replace-with-conditional-boundary',
        className: 'bpmn-icon-intermediate-event-catch-condition',
        target: {
          type: 'bpmn:BoundaryEvent',
          eventDefinitionType: 'bpmn:ConditionalEventDefinition',
          cancelActivity: !0
        }
      }, {
        label: 'Error boundary event',
        actionName: 'replace-with-error-boundary',
        className: 'bpmn-icon-intermediate-event-catch-error',
        target: {
          type: 'bpmn:BoundaryEvent',
          eventDefinitionType: 'bpmn:ErrorEventDefinition',
          cancelActivity: !0
        }
      }, {
        label: 'Cancel boundary event',
        actionName: 'replace-with-cancel-boundary',
        className: 'bpmn-icon-intermediate-event-catch-cancel',
        target: {
          type: 'bpmn:BoundaryEvent',
          eventDefinitionType: 'bpmn:CancelEventDefinition',
          cancelActivity: !0
        }
      }, {
        label: 'Signal boundary event',
        actionName: 'replace-with-signal-boundary',
        className: 'bpmn-icon-intermediate-event-catch-signal',
        target: {
          type: 'bpmn:BoundaryEvent',
          eventDefinitionType: 'bpmn:SignalEventDefinition',
          cancelActivity: !0
        }
      }, {
        label: 'Compensation boundary event',
        actionName: 'replace-with-compensation-boundary',
        className: 'bpmn-icon-intermediate-event-catch-compensation',
        target: {
          type: 'bpmn:BoundaryEvent',
          eventDefinitionType: 'bpmn:CompensateEventDefinition',
          cancelActivity: !0
        }
      }, {
        label: 'Message boundary event (non-interrupting)',
        actionName: 'replace-with-non-interrupting-message-boundary',
        className: 'bpmn-icon-intermediate-event-catch-non-interrupting-message',
        target: {
          type: 'bpmn:BoundaryEvent',
          eventDefinitionType: 'bpmn:MessageEventDefinition',
          cancelActivity: !1
        }
      }, {
        label: 'Timer boundary event (non-interrupting)',
        actionName: 'replace-with-non-interrupting-timer-boundary',
        className: 'bpmn-icon-intermediate-event-catch-non-interrupting-timer',
        target: {
          type: 'bpmn:BoundaryEvent',
          eventDefinitionType: 'bpmn:TimerEventDefinition',
          cancelActivity: !1
        }
      }, {
        label: 'Escalation boundary event (non-interrupting)',
        actionName: 'replace-with-non-interrupting-escalation-boundary',
        className: 'bpmn-icon-intermediate-event-catch-non-interrupting-escalation',
        target: {
          type: 'bpmn:BoundaryEvent',
          eventDefinitionType: 'bpmn:EscalationEventDefinition',
          cancelActivity: !1
        }
      }, {
        label: 'Conditional boundary event (non-interrupting)',
        actionName: 'replace-with-non-interrupting-conditional-boundary',
        className: 'bpmn-icon-intermediate-event-catch-non-interrupting-condition',
        target: {
          type: 'bpmn:BoundaryEvent',
          eventDefinitionType: 'bpmn:ConditionalEventDefinition',
          cancelActivity: !1
        }
      }, {
        label: 'Signal boundary event (non-interrupting)',
        actionName: 'replace-with-non-interrupting-signal-boundary',
        className: 'bpmn-icon-intermediate-event-catch-non-interrupting-signal',
        target: {
          type: 'bpmn:BoundaryEvent',
          eventDefinitionType: 'bpmn:SignalEventDefinition',
          cancelActivity: !1
        }
      }],
      DATA_OBJECT_REFERENCE: [{
        label: 'Data store reference',
        actionName: 'replace-with-data-store-reference',
        className: 'bpmn-icon-data-store',
        target: {
          type: 'bpmn:DataStoreReference'
        }
      }],
      DATA_STORE_REFERENCE: [{
        label: 'Data object reference',
        actionName: 'replace-with-data-object-reference',
        className: 'bpmn-icon-data-object',
        target: {
          type: 'bpmn:DataObjectReference'
        }
      }],
      END_EVENT: [{
        label: 'Start event',
        actionName: 'replace-with-none-start',
        className: 'bpmn-icon-start-event-none',
        target: {
          type: 'bpmn:StartEvent'
        }
      }, {
        label: 'Intermediate throw event',
        actionName: 'replace-with-none-intermediate-throw',
        className: 'bpmn-icon-intermediate-event-none',
        target: {
          type: 'bpmn:IntermediateThrowEvent'
        }
      }, {
        label: 'End event',
        actionName: 'replace-with-none-end',
        className: 'bpmn-icon-end-event-none',
        target: {
          type: 'bpmn:EndEvent'
        }
      }, {
        label: 'Message end event',
        actionName: 'replace-with-message-end',
        className: 'bpmn-icon-end-event-message',
        target: {
          type: 'bpmn:EndEvent',
          eventDefinitionType: 'bpmn:MessageEventDefinition'
        }
      }, {
        label: 'Escalation end event',
        actionName: 'replace-with-escalation-end',
        className: 'bpmn-icon-end-event-escalation',
        target: {
          type: 'bpmn:EndEvent',
          eventDefinitionType: 'bpmn:EscalationEventDefinition'
        }
      }, {
        label: 'Error end event',
        actionName: 'replace-with-error-end',
        className: 'bpmn-icon-end-event-error',
        target: {
          type: 'bpmn:EndEvent',
          eventDefinitionType: 'bpmn:ErrorEventDefinition'
        }
      }, {
        label: 'Cancel end event',
        actionName: 'replace-with-cancel-end',
        className: 'bpmn-icon-end-event-cancel',
        target: {
          type: 'bpmn:EndEvent',
          eventDefinitionType: 'bpmn:CancelEventDefinition'
        }
      }, {
        label: 'Compensation end event',
        actionName: 'replace-with-compensation-end',
        className: 'bpmn-icon-end-event-compensation',
        target: {
          type: 'bpmn:EndEvent',
          eventDefinitionType: 'bpmn:CompensateEventDefinition'
        }
      }, {
        label: 'Signal end event',
        actionName: 'replace-with-signal-end',
        className: 'bpmn-icon-end-event-signal',
        target: {
          type: 'bpmn:EndEvent',
          eventDefinitionType: 'bpmn:SignalEventDefinition'
        }
      }, {
        label: 'Terminate end event',
        actionName: 'replace-with-terminate-end',
        className: 'bpmn-icon-end-event-terminate',
        target: {
          type: 'bpmn:EndEvent',
          eventDefinitionType: 'bpmn:TerminateEventDefinition'
        }
      }],
      EVENT_SUB_PROCESS: k_,
      EVENT_SUB_PROCESS_START_EVENT: [{
        label: 'Message start event',
        actionName: 'replace-with-message-start',
        className: 'bpmn-icon-start-event-message',
        target: {
          type: 'bpmn:StartEvent',
          eventDefinitionType: 'bpmn:MessageEventDefinition',
          isInterrupting: !0
        }
      }, {
        label: 'Timer start event',
        actionName: 'replace-with-timer-start',
        className: 'bpmn-icon-start-event-timer',
        target: {
          type: 'bpmn:StartEvent',
          eventDefinitionType: 'bpmn:TimerEventDefinition',
          isInterrupting: !0
        }
      }, {
        label: 'Conditional start event',
        actionName: 'replace-with-conditional-start',
        className: 'bpmn-icon-start-event-condition',
        target: {
          type: 'bpmn:StartEvent',
          eventDefinitionType: 'bpmn:ConditionalEventDefinition',
          isInterrupting: !0
        }
      }, {
        label: 'Signal start event',
        actionName: 'replace-with-signal-start',
        className: 'bpmn-icon-start-event-signal',
        target: {
          type: 'bpmn:StartEvent',
          eventDefinitionType: 'bpmn:SignalEventDefinition',
          isInterrupting: !0
        }
      }, {
        label: 'Error start event',
        actionName: 'replace-with-error-start',
        className: 'bpmn-icon-start-event-error',
        target: {
          type: 'bpmn:StartEvent',
          eventDefinitionType: 'bpmn:ErrorEventDefinition',
          isInterrupting: !0
        }
      }, {
        label: 'Escalation start event',
        actionName: 'replace-with-escalation-start',
        className: 'bpmn-icon-start-event-escalation',
        target: {
          type: 'bpmn:StartEvent',
          eventDefinitionType: 'bpmn:EscalationEventDefinition',
          isInterrupting: !0
        }
      }, {
        label: 'Compensation start event',
        actionName: 'replace-with-compensation-start',
        className: 'bpmn-icon-start-event-compensation',
        target: {
          type: 'bpmn:StartEvent',
          eventDefinitionType: 'bpmn:CompensateEventDefinition',
          isInterrupting: !0
        }
      }, {
        label: 'Message start event (non-interrupting)',
        actionName: 'replace-with-non-interrupting-message-start',
        className: 'bpmn-icon-start-event-non-interrupting-message',
        target: {
          type: 'bpmn:StartEvent',
          eventDefinitionType: 'bpmn:MessageEventDefinition',
          isInterrupting: !1
        }
      }, {
        label: 'Timer start event (non-interrupting)',
        actionName: 'replace-with-non-interrupting-timer-start',
        className: 'bpmn-icon-start-event-non-interrupting-timer',
        target: {
          type: 'bpmn:StartEvent',
          eventDefinitionType: 'bpmn:TimerEventDefinition',
          isInterrupting: !1
        }
      }, {
        label: 'Conditional start event (non-interrupting)',
        actionName: 'replace-with-non-interrupting-conditional-start',
        className: 'bpmn-icon-start-event-non-interrupting-condition',
        target: {
          type: 'bpmn:StartEvent',
          eventDefinitionType: 'bpmn:ConditionalEventDefinition',
          isInterrupting: !1
        }
      }, {
        label: 'Signal start event (non-interrupting)',
        actionName: 'replace-with-non-interrupting-signal-start',
        className: 'bpmn-icon-start-event-non-interrupting-signal',
        target: {
          type: 'bpmn:StartEvent',
          eventDefinitionType: 'bpmn:SignalEventDefinition',
          isInterrupting: !1
        }
      }, {
        label: 'Escalation start event (non-interrupting)',
        actionName: 'replace-with-non-interrupting-escalation-start',
        className: 'bpmn-icon-start-event-non-interrupting-escalation',
        target: {
          type: 'bpmn:StartEvent',
          eventDefinitionType: 'bpmn:EscalationEventDefinition',
          isInterrupting: !1
        }
      }],
      GATEWAY: [{
        label: 'Exclusive gateway',
        actionName: 'replace-with-exclusive-gateway',
        className: 'bpmn-icon-gateway-xor',
        target: {
          type: 'bpmn:ExclusiveGateway'
        }
      }, {
        label: 'Parallel gateway',
        actionName: 'replace-with-parallel-gateway',
        className: 'bpmn-icon-gateway-parallel',
        target: {
          type: 'bpmn:ParallelGateway'
        }
      }, {
        label: 'Inclusive gateway',
        actionName: 'replace-with-inclusive-gateway',
        className: 'bpmn-icon-gateway-or',
        target: {
          type: 'bpmn:InclusiveGateway'
        }
      }, {
        label: 'Complex gateway',
        actionName: 'replace-with-complex-gateway',
        className: 'bpmn-icon-gateway-complex',
        target: {
          type: 'bpmn:ComplexGateway'
        }
      }, {
        label: 'Event-based gateway',
        actionName: 'replace-with-event-based-gateway',
        className: 'bpmn-icon-gateway-eventbased',
        target: {
          type: 'bpmn:EventBasedGateway',
          instantiate: !1,
          eventGatewayType: 'Exclusive'
        }
      }],
      INTERMEDIATE_EVENT: [{
        label: 'Start event',
        actionName: 'replace-with-none-start',
        className: 'bpmn-icon-start-event-none',
        target: {
          type: 'bpmn:StartEvent'
        }
      }, {
        label: 'Intermediate throw event',
        actionName: 'replace-with-none-intermediate-throw',
        className: 'bpmn-icon-intermediate-event-none',
        target: {
          type: 'bpmn:IntermediateThrowEvent'
        }
      }, {
        label: 'End event',
        actionName: 'replace-with-none-end',
        className: 'bpmn-icon-end-event-none',
        target: {
          type: 'bpmn:EndEvent'
        }
      }, {
        label: 'Message intermediate catch event',
        actionName: 'replace-with-message-intermediate-catch',
        className: 'bpmn-icon-intermediate-event-catch-message',
        target: {
          type: 'bpmn:IntermediateCatchEvent',
          eventDefinitionType: 'bpmn:MessageEventDefinition'
        }
      }, {
        label: 'Message intermediate throw event',
        actionName: 'replace-with-message-intermediate-throw',
        className: 'bpmn-icon-intermediate-event-throw-message',
        target: {
          type: 'bpmn:IntermediateThrowEvent',
          eventDefinitionType: 'bpmn:MessageEventDefinition'
        }
      }, {
        label: 'Timer intermediate catch event',
        actionName: 'replace-with-timer-intermediate-catch',
        className: 'bpmn-icon-intermediate-event-catch-timer',
        target: {
          type: 'bpmn:IntermediateCatchEvent',
          eventDefinitionType: 'bpmn:TimerEventDefinition'
        }
      }, {
        label: 'Escalation intermediate throw event',
        actionName: 'replace-with-escalation-intermediate-throw',
        className: 'bpmn-icon-intermediate-event-throw-escalation',
        target: {
          type: 'bpmn:IntermediateThrowEvent',
          eventDefinitionType: 'bpmn:EscalationEventDefinition'
        }
      }, {
        label: 'Conditional intermediate catch event',
        actionName: 'replace-with-conditional-intermediate-catch',
        className: 'bpmn-icon-intermediate-event-catch-condition',
        target: {
          type: 'bpmn:IntermediateCatchEvent',
          eventDefinitionType: 'bpmn:ConditionalEventDefinition'
        }
      }, {
        label: 'Link intermediate catch event',
        actionName: 'replace-with-link-intermediate-catch',
        className: 'bpmn-icon-intermediate-event-catch-link',
        target: {
          type: 'bpmn:IntermediateCatchEvent',
          eventDefinitionType: 'bpmn:LinkEventDefinition',
          eventDefinitionAttrs: {
            name: ''
          }
        }
      }, {
        label: 'Link intermediate throw event',
        actionName: 'replace-with-link-intermediate-throw',
        className: 'bpmn-icon-intermediate-event-throw-link',
        target: {
          type: 'bpmn:IntermediateThrowEvent',
          eventDefinitionType: 'bpmn:LinkEventDefinition',
          eventDefinitionAttrs: {
            name: ''
          }
        }
      }, {
        label: 'Compensation intermediate throw event',
        actionName: 'replace-with-compensation-intermediate-throw',
        className: 'bpmn-icon-intermediate-event-throw-compensation',
        target: {
          type: 'bpmn:IntermediateThrowEvent',
          eventDefinitionType: 'bpmn:CompensateEventDefinition'
        }
      }, {
        label: 'Signal intermediate catch event',
        actionName: 'replace-with-signal-intermediate-catch',
        className: 'bpmn-icon-intermediate-event-catch-signal',
        target: {
          type: 'bpmn:IntermediateCatchEvent',
          eventDefinitionType: 'bpmn:SignalEventDefinition'
        }
      }, {
        label: 'Signal intermediate throw event',
        actionName: 'replace-with-signal-intermediate-throw',
        className: 'bpmn-icon-intermediate-event-throw-signal',
        target: {
          type: 'bpmn:IntermediateThrowEvent',
          eventDefinitionType: 'bpmn:SignalEventDefinition'
        }
      }],
      PARTICIPANT: [{
        label: 'Expanded pool/participant',
        actionName: 'replace-with-expanded-pool',
        className: 'bpmn-icon-participant',
        target: {
          type: 'bpmn:Participant',
          isExpanded: !0
        }
      }, {
        label: function (e) {
          let t = 'Empty pool/participant'
          return e.children && e.children.length && (t += ' (removes content)'),
          t
        },
        actionName: 'replace-with-collapsed-pool',
        className: 'bpmn-icon-lane',
        target: {
          type: 'bpmn:Participant',
          isExpanded: !1
        }
      }],
      SEQUENCE_FLOW: [{
        label: 'Sequence flow',
        actionName: 'replace-with-sequence-flow',
        className: 'bpmn-icon-connection'
      }, {
        label: 'Default flow',
        actionName: 'replace-with-default-flow',
        className: 'bpmn-icon-default-flow'
      }, {
        label: 'Conditional flow',
        actionName: 'replace-with-conditional-flow',
        className: 'bpmn-icon-conditional-flow'
      }],
      START_EVENT: [{
        label: 'Start event',
        actionName: 'replace-with-none-start',
        className: 'bpmn-icon-start-event-none',
        target: {
          type: 'bpmn:StartEvent'
        }
      }, {
        label: 'Intermediate throw event',
        actionName: 'replace-with-none-intermediate-throwing',
        className: 'bpmn-icon-intermediate-event-none',
        target: {
          type: 'bpmn:IntermediateThrowEvent'
        }
      }, {
        label: 'End event',
        actionName: 'replace-with-none-end',
        className: 'bpmn-icon-end-event-none',
        target: {
          type: 'bpmn:EndEvent'
        }
      }, {
        label: 'Message start event',
        actionName: 'replace-with-message-start',
        className: 'bpmn-icon-start-event-message',
        target: {
          type: 'bpmn:StartEvent',
          eventDefinitionType: 'bpmn:MessageEventDefinition'
        }
      }, {
        label: 'Timer start event',
        actionName: 'replace-with-timer-start',
        className: 'bpmn-icon-start-event-timer',
        target: {
          type: 'bpmn:StartEvent',
          eventDefinitionType: 'bpmn:TimerEventDefinition'
        }
      }, {
        label: 'Conditional start event',
        actionName: 'replace-with-conditional-start',
        className: 'bpmn-icon-start-event-condition',
        target: {
          type: 'bpmn:StartEvent',
          eventDefinitionType: 'bpmn:ConditionalEventDefinition'
        }
      }, {
        label: 'Signal start event',
        actionName: 'replace-with-signal-start',
        className: 'bpmn-icon-start-event-signal',
        target: {
          type: 'bpmn:StartEvent',
          eventDefinitionType: 'bpmn:SignalEventDefinition'
        }
      }],
      START_EVENT_SUB_PROCESS: [{
        label: 'Start event',
        actionName: 'replace-with-none-start',
        className: 'bpmn-icon-start-event-none',
        target: {
          type: 'bpmn:StartEvent'
        }
      }, {
        label: 'Intermediate throw event',
        actionName: 'replace-with-none-intermediate-throwing',
        className: 'bpmn-icon-intermediate-event-none',
        target: {
          type: 'bpmn:IntermediateThrowEvent'
        }
      }, {
        label: 'End event',
        actionName: 'replace-with-none-end',
        className: 'bpmn-icon-end-event-none',
        target: {
          type: 'bpmn:EndEvent'
        }
      }],
      SUBPROCESS_EXPANDED: [{
        label: 'Transaction',
        actionName: 'replace-with-transaction',
        className: 'bpmn-icon-transaction',
        target: {
          type: 'bpmn:Transaction',
          isExpanded: !0
        }
      }, {
        label: 'Event sub-process',
        actionName: 'replace-with-event-subprocess',
        className: 'bpmn-icon-event-subprocess-expanded',
        target: {
          type: 'bpmn:SubProcess',
          triggeredByEvent: !0,
          isExpanded: !0
        }
      }, {
        label: 'Sub-process (collapsed)',
        actionName: 'replace-with-collapsed-subprocess',
        className: 'bpmn-icon-subprocess-collapsed',
        target: {
          type: 'bpmn:SubProcess',
          isExpanded: !1
        }
      }],
      TASK: [{
        label: 'Task',
        actionName: 'replace-with-task',
        className: 'bpmn-icon-task',
        target: {
          type: 'bpmn:Task'
        }
      }, {
        label: 'User task',
        actionName: 'replace-with-user-task',
        className: 'bpmn-icon-user',
        target: {
          type: 'bpmn:UserTask'
        }
      }, {
        label: 'Service task',
        actionName: 'replace-with-service-task',
        className: 'bpmn-icon-service',
        target: {
          type: 'bpmn:ServiceTask'
        }
      }, {
        label: 'Send task',
        actionName: 'replace-with-send-task',
        className: 'bpmn-icon-send',
        target: {
          type: 'bpmn:SendTask'
        }
      }, {
        label: 'Receive task',
        actionName: 'replace-with-receive-task',
        className: 'bpmn-icon-receive',
        target: {
          type: 'bpmn:ReceiveTask'
        }
      }, {
        label: 'Manual task',
        actionName: 'replace-with-manual-task',
        className: 'bpmn-icon-manual',
        target: {
          type: 'bpmn:ManualTask'
        }
      }, {
        label: 'Business rule task',
        actionName: 'replace-with-rule-task',
        className: 'bpmn-icon-business-rule',
        target: {
          type: 'bpmn:BusinessRuleTask'
        }
      }, {
        label: 'Script task',
        actionName: 'replace-with-script-task',
        className: 'bpmn-icon-script',
        target: {
          type: 'bpmn:ScriptTask'
        }
      }, {
        label: 'Call activity',
        actionName: 'replace-with-call-activity',
        className: 'bpmn-icon-call-activity',
        target: {
          type: 'bpmn:CallActivity'
        }
      }, {
        label: 'Sub-process (collapsed)',
        actionName: 'replace-with-collapsed-subprocess',
        className: 'bpmn-icon-subprocess-collapsed',
        target: {
          type: 'bpmn:SubProcess',
          isExpanded: !1
        }
      }, {
        label: 'Sub-process (expanded)',
        actionName: 'replace-with-expanded-subprocess',
        className: 'bpmn-icon-subprocess-expanded',
        target: {
          type: 'bpmn:SubProcess',
          isExpanded: !0
        }
      }],
      TRANSACTION: S_
    })
    const B_ = Object.values(j_)
    function D_ (e, t, n) {
      this._popupMenu = e,
      this._translate = t,
      this._elementTemplates = n,
      this.register()
    }
    function P_ (e, t, n) {
      const r = e[t]
      return !!r && n.findIndex(function (e) {
        return fw(e, 1)[0] === r.actionName
      }
      )
    }
    D_.$inject = ['popupMenu', 'translate', 'elementTemplates'],
    D_.prototype.register = function () {
      this._popupMenu.registerProvider('bpmn-replace', this)
    }
    ,
    D_.prototype.getPopupMenuEntries = function (e) {
      const t = this
      return function (n) {
        const r = Object.entries(n)
        return t._elementTemplates && t._elementTemplates.get(e) && t.addPlainElementEntry(e, r, t._translate, t._elementTemplates),
        r.reduce(function (e, t) {
          const n = fw(t, 2)
          const r = n[0]
          const o = n[1]
          return e[r] = o,
          e
        }
        , {})
      }
    }
    ,
    D_.prototype.addPlainElementEntry = function (e, t, n, r) {
      const o = this.getPlainEntry(e, t, n, r)
      if (o) {
        const i = fw(o, 2)
        const a = i[0]
        const s = i[1]
        t.splice(a, 0, [s.id, s])
      }
    }
    ,
    D_.prototype.getPlainEntry = function (e, t, n, r) {
      const o = (function (e) {
        const t = function (e, t) {
          return t.target && !(function (e) {
            return function (t) {
              const n = t.target
              const r = e_(e)
              const o = r.eventDefinitions && r.eventDefinitions[0]
              const i = r.$type === n.type
              const a = (o && o.$type) === n.eventDefinitionType
              const s = !!n.triggeredByEvent == !!r.triggeredByEvent
              const c = void 0 === n.isExpanded || n.isExpanded === (function (e, t) {
                return !Xw(e, 'bpmn:CallActivity') && (Xw(e, 'bpmn:SubProcess')
                  ? (t = t || (function (e) {
                      return e && e.di
                    }(e)),
                    !(!t || !Xw(t, 'bpmndi:BPMNPlane')) || t && !!t.isExpanded)
                  : !Xw(e, 'bpmn:Participant') || !!e_(e).processRef)
              }(e))
              return !(i && a && s && c)
            }
          }(e))(t)
        }
        return B_.reduce(function (n, r) {
          if (n) { return n }
          const o = r.findIndex(function (n) {
            return t(e, n)
          }
          )
          return o !== -1
            ? {
                options: r,
                option: r[o],
                optionIndex: o
              }
            : void 0
        }
        , null)
      }(e)) || {}
      const i = o.options
      const a = o.option
      const s = o.optionIndex
      if (!i) { return null }
      const c = {
        id: 'replace-remove-element-template',
        action: function () {
          r.removeTemplate(e)
        },
        label: n(a.label),
        className: a.className
      }
      const l = P_(i, s - 1, t)
      if (l) { return [l + 1, c] }
      const p = P_(i, s + 1, t)
      return p ? [p, c] : [0, c]
    }

    const O_ = n(9371)
    const T_ = n.n(O_)
    const R_ = n(7913)
    const N_ = n.n(R_)
    function M_ (e, t, n) {
      return N_()('data:' + n + ';charset=UTF-8,' + encodeURIComponent(e), t, n)
    }
    const I_ = /\{\{[ ]*ID(?::([^ }]+))?[ ]*\}\}/g
    const L_ = new j([32, 36, 1])
    const z_ = n.g.track = n.g.track || function () {}

    const F_ = typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__
    function $_ (e) {
      return $_ = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      $_(e)
    }
    function H_ (e) {
      return e && e.Math == Math ? e : void 0
    }
    const q_ = (typeof globalThis === 'undefined' ? 'undefined' : $_(globalThis)) == 'object' && H_(globalThis) || (typeof window === 'undefined' ? 'undefined' : $_(window)) == 'object' && H_(window) || (typeof self === 'undefined' ? 'undefined' : $_(self)) == 'object' && H_(self) || (void 0 === n.g ? 'undefined' : $_(n.g)) == 'object' && H_(n.g) || (function () {
      return this
    }()) || {}
    function W_ () {
      return q_
    }
    function G_ (e, t, n) {
      const r = n || q_
      const o = r.__SENTRY__ = r.__SENTRY__ || {}
      return o[e] || (o[e] = t())
    }
    const U_ = ['debug', 'info', 'warn', 'error', 'log', 'assert', 'trace']
    const V_ = {}
    function Q_ (e) {
      if (!('console' in q_)) { return e() }
      const t = q_.console
      const n = {}
      const r = Object.keys(V_)
      r.forEach(function (e) {
        const r = V_[e]
        n[e] = t[e],
        t[e] = r
      }
      )
      try {
        return e()
      } finally {
        r.forEach(function (e) {
          t[e] = n[e]
        }
        )
      }
    }
    let Y_; let K_; const J_ = (Y_ = !1,
    K_ = {
      enable: function () {
        Y_ = !0
      },
      disable: function () {
        Y_ = !1
      },
      isEnabled: function () {
        return Y_
      }
    },
    F_
      ? U_.forEach(function (e) {
        K_[e] = function () {
          for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++) { n[r] = arguments[r] }
          Y_ && Q_(function () {
            let t;
            (t = q_.console)[e].apply(t, [''.concat('Sentry Logger ', '[').concat(e, ']:')].concat(n))
          }
          )
        }
      }
      )
      : U_.forEach(function (e) {
        K_[e] = function () {}
      }
      ),
    K_)
    function X_ (e) {
      return X_ = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      X_(e)
    }
    const Z_ = Object.prototype.toString
    function eC (e) {
      switch (Z_.call(e)) {
        case '[object Error]':
        case '[object Exception]':
        case '[object DOMException]':
          return !0
        default:
          return pC(e, Error)
      }
    }
    function tC (e, t) {
      return Z_.call(e) === '[object '.concat(t, ']')
    }
    function nC (e) {
      return tC(e, 'ErrorEvent')
    }
    function rC (e) {
      return tC(e, 'DOMError')
    }
    function oC (e) {
      return tC(e, 'String')
    }
    function iC (e) {
      return X_(e) === 'object' && e !== null && '__sentry_template_string__' in e && '__sentry_template_values__' in e
    }
    function aC (e) {
      return e === null || iC(e) || X_(e) !== 'object' && typeof e !== 'function'
    }
    function sC (e) {
      return tC(e, 'Object')
    }
    function cC (e) {
      return typeof Event !== 'undefined' && pC(e, Event)
    }
    function lC (e) {
      return Boolean(e && e.then && typeof e.then === 'function')
    }
    function pC (e, t) {
      try {
        return e instanceof t
      } catch (e) {
        return !1
      }
    }
    function uC (e) {
      return !(X_(e) !== 'object' || e === null || !e.__isVue && !e._isVue)
    }
    const dC = W_()
    const fC = 80
    function hC (e) {
      const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
      if (!e) { return '<unknown>' }
      try {
        for (var n, r = e, o = [], i = 0, a = 0, s = Array.isArray(t) ? t : t.keyAttrs, c = !Array.isArray(t) && t.maxStringLength || fC; r && i++ < 5 && !((n = mC(r, s)) === 'html' || i > 1 && a + 3 * o.length + n.length >= c);) {
          o.push(n),
          a += n.length,
          r = r.parentNode
        }
        return o.reverse().join(' > ')
      } catch (e) {
        return '<unknown>'
      }
    }
    function mC (e, t) {
      let n; let r; let o; let i; let a; const s = e; const c = []
      if (!s || !s.tagName) { return '' }
      if (dC.HTMLElement && s instanceof HTMLElement && s.dataset && s.dataset.sentryComponent) { return s.dataset.sentryComponent }
      c.push(s.tagName.toLowerCase())
      const l = t && t.length
        ? t.filter(function (e) {
          return s.getAttribute(e)
        }
        ).map(function (e) {
          return [e, s.getAttribute(e)]
        }
        )
        : null
      if (l && l.length) {
        l.forEach(function (e) {
          c.push('['.concat(e[0], '="').concat(e[1], '"]'))
        }
        )
      } else if (s.id && c.push('#'.concat(s.id)),
      (n = s.className) && oC(n)) {
        for (r = n.split(/\s+/),
        a = 0; a < r.length; a++) { c.push('.'.concat(r[a])) }
      }
      const p = ['aria-label', 'type', 'name', 'title', 'alt']
      for (a = 0; a < p.length; a++) {
        o = p[a],
        (i = s.getAttribute(o)) && c.push('['.concat(o, '="').concat(i, '"]'))
      }
      return c.join('')
    }
    function vC (e) {
      const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
      return typeof e !== 'string' || t === 0 || e.length <= t ? e : ''.concat(e.slice(0, t), '...')
    }
    function gC (e, t) {
      if (!Array.isArray(e)) { return '' }
      for (var n = [], r = 0; r < e.length; r++) {
        const o = e[r]
        try {
          uC(o) ? n.push('[VueViewModel]') : n.push(String(o))
        } catch (e) {
          n.push('[value cannot be serialized]')
        }
      }
      return n.join(t)
    }
    function yC (e) {
      const t = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]
      return (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : []).some(function (n) {
        return (function (e, t) {
          const n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]
          return !!oC(e) && (tC(t, 'RegExp') ? t.test(e) : !!oC(t) && (n ? e === t : e.includes(t)))
        }(e, n, t))
      }
      )
    }
    function bC (e) {
      return bC = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      bC(e)
    }
    function AC (e, t) {
      const n = Object.keys(e)
      if (Object.getOwnPropertySymbols) {
        let r = Object.getOwnPropertySymbols(e)
        t && (r = r.filter(function (t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable
        }
        )),
        n.push.apply(n, r)
      }
      return n
    }
    function EC (e) {
      for (let t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {}
        t % 2
          ? AC(Object(n), !0).forEach(function (t) {
            let r, o, i
            r = e,
            o = t,
            i = n[t],
            o = (function (e) {
              const t = (function (e, t) {
                if (bC(e) != 'object' || !e) { return e }
                const n = e[Symbol.toPrimitive]
                if (void 0 !== n) {
                  const r = n.call(e, 'string')
                  if (bC(r) != 'object') { return r }
                  throw new TypeError('@@toPrimitive must return a primitive value.')
                }
                return String(e)
              }(e))
              return bC(t) == 'symbol' ? t : t + ''
            }(o)),
            o in r
              ? Object.defineProperty(r, o, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
              })
              : r[o] = i
          }
          )
          : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
            : AC(Object(n)).forEach(function (t) {
              Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
            }
            )
      }
      return e
    }
    function xC (e, t, n) {
      if (t in e) {
        const r = e[t]
        const o = n(r)
        typeof o === 'function' && _C(o, r),
        e[t] = o
      }
    }
    function wC (e, t, n) {
      try {
        Object.defineProperty(e, t, {
          value: n,
          writable: !0,
          configurable: !0
        })
      } catch (n) {
        F_ && J_.log('Failed to add non-enumerable property "'.concat(t, '" to object'), e)
      }
    }
    function _C (e, t) {
      try {
        const n = t.prototype || {}
        e.prototype = t.prototype = n,
        wC(e, '__sentry_original__', t)
      } catch (e) {}
    }
    function CC (e) {
      return e.__sentry_original__
    }
    function SC (e) {
      if (eC(e)) {
        return EC({
          message: e.message,
          name: e.name,
          stack: e.stack
        }, jC(e))
      }
      if (cC(e)) {
        const t = EC({
          type: e.type,
          target: kC(e.target),
          currentTarget: kC(e.currentTarget)
        }, jC(e))
        return typeof CustomEvent !== 'undefined' && pC(e, CustomEvent) && (t.detail = e.detail),
        t
      }
      return e
    }
    function kC (e) {
      try {
        return typeof Element !== 'undefined' && pC(e, Element) ? hC(e) : Object.prototype.toString.call(e)
      } catch (e) {
        return '<unknown>'
      }
    }
    function jC (e) {
      if (bC(e) === 'object' && e !== null) {
        const t = {}
        for (const n in e) { Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]) }
        return t
      }
      return {}
    }
    function BC (e) {
      return DC(e, new Map())
    }
    function DC (e, t) {
      if (function (e) {
        if (!sC(e)) { return !1 }
        try {
          const t = Object.getPrototypeOf(e).constructor.name
          return !t || t === 'Object'
        } catch (e) {
          return !0
        }
      }(e)) {
        const n = t.get(e)
        if (void 0 !== n) { return n }
        const r = {}
        t.set(e, r)
        for (let o = 0, i = Object.keys(e); o < i.length; o++) {
          const a = i[o]
          void 0 !== e[a] && (r[a] = DC(e[a], t))
        }
        return r
      }
      if (Array.isArray(e)) {
        const s = t.get(e)
        if (void 0 !== s) { return s }
        const c = []
        return t.set(e, c),
        e.forEach(function (e) {
          c.push(DC(e, t))
        }
        ),
        c
      }
      return e
    }
    function PC (e) {
      return PC = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      PC(e)
    }
    function OC (e, t) {
      const n = Object.keys(e)
      if (Object.getOwnPropertySymbols) {
        let r = Object.getOwnPropertySymbols(e)
        t && (r = r.filter(function (t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable
        }
        )),
        n.push.apply(n, r)
      }
      return n
    }
    function TC (e) {
      for (let t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {}
        t % 2
          ? OC(Object(n), !0).forEach(function (t) {
            let r, o, i
            r = e,
            o = t,
            i = n[t],
            o = (function (e) {
              const t = (function (e, t) {
                if (PC(e) != 'object' || !e) { return e }
                const n = e[Symbol.toPrimitive]
                if (void 0 !== n) {
                  const r = n.call(e, 'string')
                  if (PC(r) != 'object') { return r }
                  throw new TypeError('@@toPrimitive must return a primitive value.')
                }
                return String(e)
              }(e))
              return PC(t) == 'symbol' ? t : t + ''
            }(o)),
            o in r
              ? Object.defineProperty(r, o, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
              })
              : r[o] = i
          }
          )
          : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
            : OC(Object(n)).forEach(function (t) {
              Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
            }
            )
      }
      return e
    }
    function RC () {
      const e = q_
      const t = e.crypto || e.msCrypto
      let n = function () {
        return 16 * Math.random()
      }
      try {
        if (t && t.randomUUID) { return t.randomUUID().replace(/-/g, '') }
        t && t.getRandomValues && (n = function () {
          const e = new Uint8Array(1)
          return t.getRandomValues(e),
          e[0]
        }
        )
      } catch (e) {}
      return ([1e7] + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, function (e) {
        return (e ^ (15 & n()) >> e / 4).toString(16)
      }
      )
    }
    function NC (e) {
      return e.exception && e.exception.values ? e.exception.values[0] : void 0
    }
    function MC (e) {
      const t = e.message
      const n = e.event_id
      if (t) { return t }
      const r = NC(e)
      return r ? r.type && r.value ? ''.concat(r.type, ': ').concat(r.value) : r.type || r.value || n || '<unknown>' : n || '<unknown>'
    }
    function IC (e, t, n) {
      const r = e.exception = e.exception || {}
      const o = r.values = r.values || []
      const i = o[0] = o[0] || {}
      i.value || (i.value = t || ''),
      i.type || (i.type = n || 'Error')
    }
    function LC (e, t) {
      const n = NC(e)
      if (n) {
        const r = n.mechanism
        if (n.mechanism = TC(TC(TC({}, {
          type: 'generic',
          handled: !0
        }), r), t),
        t && 'data' in t) {
          const o = TC(TC({}, r && r.data), t.data)
          n.mechanism.data = o
        }
      }
    }
    function zC (e) {
      if (e && e.__sentry_captured__) { return !0 }
      try {
        wC(e, '__sentry_captured__', !0)
      } catch (e) {}
      return !1
    }
    function FC (e) {
      return Array.isArray(e) ? e : [e]
    }
    let $C; const HC = typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__
    function qC (e) {
      return qC = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      qC(e)
    }
    function WC (e, t) {
      for (let n = 0; n < t.length; n++) {
        const r = t[n]
        r.enumerable = r.enumerable || !1,
        r.configurable = !0,
        'value' in r && (r.writable = !0),
        Object.defineProperty(e, GC(r.key), r)
      }
    }
    function GC (e) {
      const t = (function (e, t) {
        if (qC(e) != 'object' || !e) { return e }
        const n = e[Symbol.toPrimitive]
        if (void 0 !== n) {
          const r = n.call(e, 'string')
          if (qC(r) != 'object') { return r }
          throw new TypeError('@@toPrimitive must return a primitive value.')
        }
        return String(e)
      }(e))
      return qC(t) == 'symbol' ? t : t + ''
    }
    function UC (e) {
      return new QC(function (t) {
        t(e)
      }
      )
    }
    function VC (e) {
      return new QC(function (t, n) {
        n(e)
      }
      )
    }
    !(function (e) {
      e[e.PENDING = 0] = 'PENDING',
      e[e.RESOLVED = 1] = 'RESOLVED',
      e[e.REJECTED = 2] = 'REJECTED'
    }($C || ($C = {})))
    var QC = (function () {
      function e (t) {
        !(function (e, t) {
          if (!(e instanceof t)) { throw new TypeError('Cannot call a class as a function') }
        }(this, e)),
        e.prototype.__init.call(this),
        e.prototype.__init2.call(this),
        e.prototype.__init3.call(this),
        e.prototype.__init4.call(this),
        this._state = $C.PENDING,
        this._handlers = []
        try {
          t(this._resolve, this._reject)
        } catch (e) {
          this._reject(e)
        }
      }
      return t = e,
      n = [{
        key: 'then',
        value: function (t, n) {
          const r = this
          return new e(function (e, o) {
            r._handlers.push([!1, function (n) {
              if (t) {
                try {
                  e(t(n))
                } catch (e) {
                  o(e)
                }
              } else { e(n) }
            },
            function (t) {
              if (n) {
                try {
                  e(n(t))
                } catch (e) {
                  o(e)
                }
              } else { o(t) }
            }
            ]),
            r._executeHandlers()
          }
          )
        }
      }, {
        key: 'catch',
        value: function (e) {
          return this.then(function (e) {
            return e
          }
          , e)
        }
      }, {
        key: 'finally',
        value: function (t) {
          const n = this
          return new e(function (e, r) {
            let o, i
            return n.then(function (e) {
              i = !1,
              o = e,
              t && t()
            }
            , function (e) {
              i = !0,
              o = e,
              t && t()
            }
            ).then(function () {
              i ? r(o) : e(o)
            }
            )
          }
          )
        }
      }, {
        key: '__init',
        value: function () {
          const e = this
          this._resolve = function (t) {
            e._setResult($C.RESOLVED, t)
          }
        }
      }, {
        key: '__init2',
        value: function () {
          const e = this
          this._reject = function (t) {
            e._setResult($C.REJECTED, t)
          }
        }
      }, {
        key: '__init3',
        value: function () {
          const e = this
          this._setResult = function (t, n) {
            e._state === $C.PENDING && (lC(n)
              ? n.then(e._resolve, e._reject)
              : (e._state = t,
                e._value = n,
                e._executeHandlers()))
          }
        }
      }, {
        key: '__init4',
        value: function () {
          const e = this
          this._executeHandlers = function () {
            if (e._state !== $C.PENDING) {
              const t = e._handlers.slice()
              e._handlers = [],
              t.forEach(function (t) {
                t[0] || (e._state === $C.RESOLVED && t[1](e._value),
                e._state === $C.REJECTED && t[2](e._value),
                t[0] = !0)
              }
              )
            }
          }
        }
      }],
      n && WC(t.prototype, n),
      Object.defineProperty(t, 'prototype', {
        writable: !1
      }),
      t
      let t, n
    }())
    function YC (e) {
      return YC = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      YC(e)
    }
    function KC (e, t) {
      const n = Object.keys(e)
      if (Object.getOwnPropertySymbols) {
        let r = Object.getOwnPropertySymbols(e)
        t && (r = r.filter(function (t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable
        }
        )),
        n.push.apply(n, r)
      }
      return n
    }
    function JC () {
      return G_('globalEventProcessors', function () {
        return []
      }
      )
    }
    function XC (e) {
      JC().push(e)
    }
    function ZC (e, t, n) {
      const r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0
      return new QC(function (o, i) {
        const a = e[r]
        if (t === null || typeof a !== 'function') { o(t) } else {
          const s = a((function (e) {
            for (let t = 1; t < arguments.length; t++) {
              var n = arguments[t] != null ? arguments[t] : {}
              t % 2
                ? KC(Object(n), !0).forEach(function (t) {
                  let r, o, i
                  r = e,
                  o = t,
                  i = n[t],
                  o = (function (e) {
                    const t = (function (e, t) {
                      if (YC(e) != 'object' || !e) { return e }
                      const n = e[Symbol.toPrimitive]
                      if (void 0 !== n) {
                        const r = n.call(e, 'string')
                        if (YC(r) != 'object') { return r }
                        throw new TypeError('@@toPrimitive must return a primitive value.')
                      }
                      return String(e)
                    }(e))
                    return YC(t) == 'symbol' ? t : t + ''
                  }(o)),
                  o in r
                    ? Object.defineProperty(r, o, {
                      value: i,
                      enumerable: !0,
                      configurable: !0,
                      writable: !0
                    })
                    : r[o] = i
                }
                )
                : Object.getOwnPropertyDescriptors
                  ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
                  : KC(Object(n)).forEach(function (t) {
                    Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
                  }
                  )
            }
            return e
          }({}, t)), n)
          HC && a.id && s === null && J_.log('Event processor "'.concat(a.id, '" dropped event')),
          lC(s)
            ? s.then(function (t) {
              return ZC(e, t, n, r + 1).then(o)
            }
            ).then(null, i)
            : ZC(e, s, n, r + 1).then(o).then(null, i)
        }
      }
      )
    }
    const eS = 1e3
    function tS () {
      return Date.now() / eS
    }
    const nS = (function () {
      const e = q_.performance
      if (!e || !e.now) { return tS }
      const t = Date.now() - e.now()
      const n = e.timeOrigin == null ? t : e.timeOrigin
      return function () {
        return (n + e.now()) / eS
      }
    }())
    const rS = ((function () {
      const e = q_.performance
      if (e && e.now) {
        const t = 36e5
        const n = e.now()
        const r = Date.now()
        const o = e.timeOrigin ? Math.abs(e.timeOrigin + n - r) : t
        const i = o < t
        const a = e.timing && e.timing.navigationStart
        const s = typeof a === 'number' ? Math.abs(a + n - r) : t;
        (i || s < t) && (o <= s && e.timeOrigin)
      }
    }()),
    'production')
    function oS (e) {
      const t = nS()
      var n = {
        sid: RC(),
        init: !0,
        timestamp: t,
        started: t,
        duration: 0,
        status: 'ok',
        errors: 0,
        ignoreDuration: !1,
        toJSON: function () {
          return (function (e) {
            return BC({
              sid: ''.concat(e.sid),
              init: e.init,
              started: new Date(1e3 * e.started).toISOString(),
              timestamp: new Date(1e3 * e.timestamp).toISOString(),
              status: e.status,
              errors: e.errors,
              did: typeof e.did === 'number' || typeof e.did === 'string' ? ''.concat(e.did) : void 0,
              duration: e.duration,
              abnormal_mechanism: e.abnormal_mechanism,
              attrs: {
                release: e.release,
                environment: e.environment,
                ip_address: e.ipAddress,
                user_agent: e.userAgent
              }
            })
          }(n))
        }
      }
      return e && iS(n, e),
      n
    }
    function iS (e) {
      const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
      if (t.user && (!e.ipAddress && t.user.ip_address && (e.ipAddress = t.user.ip_address),
      e.did || t.did || (e.did = t.user.id || t.user.email || t.user.username)),
      e.timestamp = t.timestamp || nS(),
      t.abnormal_mechanism && (e.abnormal_mechanism = t.abnormal_mechanism),
      t.ignoreDuration && (e.ignoreDuration = t.ignoreDuration),
      t.sid && (e.sid = t.sid.length === 32 ? t.sid : RC()),
      void 0 !== t.init && (e.init = t.init),
      !e.did && t.did && (e.did = ''.concat(t.did)),
      typeof t.started === 'number' && (e.started = t.started),
      e.ignoreDuration) { e.duration = void 0 } else if (typeof t.duration === 'number') { e.duration = t.duration } else {
        const n = e.timestamp - e.started
        e.duration = n >= 0 ? n : 0
      }
      t.release && (e.release = t.release),
      t.environment && (e.environment = t.environment),
      !e.ipAddress && t.ipAddress && (e.ipAddress = t.ipAddress),
      !e.userAgent && t.userAgent && (e.userAgent = t.userAgent),
      typeof t.errors === 'number' && (e.errors = t.errors),
      t.status && (e.status = t.status)
    }
    function aS (e, t) {
      let n = {}
      t
        ? n = {
          status: t
        }
        : e.status === 'ok' && (n = {
          status: 'exited'
        }),
      iS(e, n)
    }
    function sS (e) {
      return sS = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      sS(e)
    }
    function cS (e, t) {
      const n = Object.keys(e)
      if (Object.getOwnPropertySymbols) {
        let r = Object.getOwnPropertySymbols(e)
        t && (r = r.filter(function (t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable
        }
        )),
        n.push.apply(n, r)
      }
      return n
    }
    function lS (e) {
      for (let t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {}
        t % 2
          ? cS(Object(n), !0).forEach(function (t) {
            let r, o, i
            r = e,
            o = t,
            i = n[t],
            o = (function (e) {
              const t = (function (e, t) {
                if (sS(e) != 'object' || !e) { return e }
                const n = e[Symbol.toPrimitive]
                if (void 0 !== n) {
                  const r = n.call(e, 'string')
                  if (sS(r) != 'object') { return r }
                  throw new TypeError('@@toPrimitive must return a primitive value.')
                }
                return String(e)
              }(e))
              return sS(t) == 'symbol' ? t : t + ''
            }(o)),
            o in r
              ? Object.defineProperty(r, o, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
              })
              : r[o] = i
          }
          )
          : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
            : cS(Object(n)).forEach(function (t) {
              Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
            }
            )
      }
      return e
    }
    function pS (e, t) {
      let n = typeof Symbol !== 'undefined' && e[Symbol.iterator] || e['@@iterator']
      if (!n) {
        if (Array.isArray(e) || (n = uS(e)) || t && e && typeof e.length === 'number') {
          n && (e = n)
          let r = 0
          const o = function () {}
          return {
            s: o,
            n: function () {
              return r >= e.length
                ? {
                    done: !0
                  }
                : {
                    done: !1,
                    value: e[r++]
                  }
            },
            e: function (e) {
              throw e
            },
            f: o
          }
        }
        throw new TypeError('Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
      }
      let i; let a = !0; let s = !1
      return {
        s: function () {
          n = n.call(e)
        },
        n: function () {
          const e = n.next()
          return a = e.done,
          e
        },
        e: function (e) {
          s = !0,
          i = e
        },
        f: function () {
          try {
            a || n.return == null || n.return()
          } finally {
            if (s) { throw i }
          }
        }
      }
    }
    function uS (e, t) {
      if (e) {
        if (typeof e === 'string') { return dS(e, t) }
        let n = Object.prototype.toString.call(e).slice(8, -1)
        return n === 'Object' && e.constructor && (n = e.constructor.name),
        n === 'Map' || n === 'Set' ? Array.from(e) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? dS(e, t) : void 0
      }
    }
    function dS (e, t) {
      (t == null || t > e.length) && (t = e.length)
      for (var n = 0, r = new Array(t); n < t; n++) { r[n] = e[n] }
      return r
    }
    const fS = 50
    const hS = /\(error: (.*)\)/
    const mS = /captureMessage|captureException/
    function vS () {
      for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) { t[n] = arguments[n] }
      const r = t.sort(function (e, t) {
        return e[0] - t[0]
      }
      ).map(function (e) {
        return e[1]
      }
      )
      return function (e) {
        for (var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n = [], o = e.split('\n'), i = t; i < o.length; i++) {
          const a = o[i]
          if (!(a.length > 1024)) {
            const s = hS.test(a) ? a.replace(hS, '$1') : a
            if (!s.match(/\S*Error: /)) {
              var c; const l = pS(r)
              try {
                for (l.s(); !(c = l.n()).done;) {
                  const p = (0,
                  c.value)(s)
                  if (p) {
                    n.push(p)
                    break
                  }
                }
              } catch (e) {
                l.e(e)
              } finally {
                l.f()
              }
              if (n.length >= fS) { break }
            }
          }
        }
        return (function (e) {
          if (!e.length) { return [] }
          const t = Array.from(e)
          return /sentryWrapped/.test(t[t.length - 1].function || '') && t.pop(),
          t.reverse(),
          mS.test(t[t.length - 1].function || '') && (t.pop(),
          mS.test(t[t.length - 1].function || '') && t.pop()),
          t.slice(0, fS).map(function (e) {
            return lS(lS({}, e), {}, {
              filename: e.filename || t[t.length - 1].filename,
              function: e.function || '?'
            })
          }
          )
        }(n))
      }
    }
    const gS = '<anonymous>'
    function yS (e) {
      try {
        return e && typeof e === 'function' && e.name || gS
      } catch (e) {
        return gS
      }
    }
    function bS (e) {
      return bS = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      bS(e)
    }
    function AS (e, t) {
      (t == null || t > e.length) && (t = e.length)
      for (var n = 0, r = new Array(t); n < t; n++) { r[n] = e[n] }
      return r
    }
    function ES (e) {
      const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 100
      const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1 / 0
      try {
        return wS('', e, t, n)
      } catch (e) {
        return {
          ERROR: '**non-serializable** ('.concat(e, ')')
        }
      }
    }
    function xS (e) {
      let t; const n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 3; const r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 102400; const o = ES(e, n)
      return t = o,
      (function (e) {
        return ~-encodeURI(e).split(/%..|./).length
      }(JSON.stringify(t))) > r
        ? xS(e, n - 1, r)
        : o
    }
    function wS (e, t) {
      let r; let o; let i; let a; let s; const c = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1 / 0; const l = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1 / 0; const p = arguments.length > 4 && void 0 !== arguments[4]
        ? arguments[4]
        : (r = typeof WeakSet === 'function',
          o = r ? new WeakSet() : [],
          [function (e) {
            if (r) {
              return !!o.has(e) || (o.add(e),
              !1)
            }
            for (let t = 0; t < o.length; t++) {
              if (o[t] === e) { return !0 }
            }
            return o.push(e),
            !1
          },
          function (e) {
            if (r) { o.delete(e) } else {
              for (let t = 0; t < o.length; t++) {
                if (o[t] === e) {
                  o.splice(t, 1)
                  break
                }
              }
            }
          }
          ]); const u = (s = 2,
      (function (e) {
        if (Array.isArray(e)) { return e }
      }(a = p)) || (function (e, t) {
        let n = e == null ? null : typeof Symbol !== 'undefined' && e[Symbol.iterator] || e['@@iterator']
        if (n != null) {
          let r; let o; let i; let a; const s = []; let c = !0; let l = !1
          try {
            if (i = (n = n.call(e)).next,
            t === 0) {
              if (Object(n) !== n) { return }
              c = !1
            } else {
              for (; !(c = (r = i.call(n)).done) && (s.push(r.value),
              s.length !== t); c = !0)
                ;
            }
          } catch (e) {
            l = !0,
            o = e
          } finally {
            try {
              if (!c && n.return != null && (a = n.return(),
              Object(a) !== a)) { return }
            } finally {
              if (l) { throw o }
            }
          }
          return s
        }
      }(a, s)) || (function (e, t) {
        if (e) {
          if (typeof e === 'string') { return AS(e, t) }
          let n = Object.prototype.toString.call(e).slice(8, -1)
          return n === 'Object' && e.constructor && (n = e.constructor.name),
          n === 'Map' || n === 'Set' ? Array.from(e) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? AS(e, t) : void 0
        }
      }(a, s)) || (function () {
        throw new TypeError('Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
      }())); const d = u[0]; const f = u[1]
      if (t == null || ['number', 'boolean', 'string'].includes(bS(t)) && (typeof (i = t) !== 'number' || i == i)) { return t }
      const h = (function (e, t) {
        try {
          if (e === 'domain' && t && bS(t) === 'object' && t._events) { return '[Domain]' }
          if (e === 'domainEmitter') { return '[DomainEmitter]' }
          if (void 0 !== n.g && t === n.g) { return '[Global]' }
          if (typeof window !== 'undefined' && t === window) { return '[Window]' }
          if (typeof document !== 'undefined' && t === document) { return '[Document]' }
          if (uC(t)) { return '[VueViewModel]' }
          if (function (e) {
            return sC(e) && 'nativeEvent' in e && 'preventDefault' in e && 'stopPropagation' in e
          }(t)) { return '[SyntheticEvent]' }
          if (typeof t === 'number' && t != t) { return '[NaN]' }
          if (typeof t === 'function') { return '[Function: '.concat(yS(t), ']') }
          if (bS(t) === 'symbol') { return '['.concat(String(t), ']') }
          if (typeof t === 'bigint') { return '[BigInt: '.concat(String(t), ']') }
          const r = (function (e) {
            const t = Object.getPrototypeOf(e)
            return t ? t.constructor.name : 'null prototype'
          }(t))
          return /^HTML(\w*)Element$/.test(r) ? '[HTMLElement: '.concat(r, ']') : '[object '.concat(r, ']')
        } catch (e) {
          return '**non-serializable** ('.concat(e, ')')
        }
      }(e, t))
      if (!h.startsWith('[object ')) { return h }
      if (t.__sentry_skip_normalization__) { return t }
      const m = typeof t.__sentry_override_normalization_depth__ === 'number' ? t.__sentry_override_normalization_depth__ : c
      if (m === 0) { return h.replace('object ', '') }
      if (d(t)) { return '[Circular ~]' }
      const v = t
      if (v && typeof v.toJSON === 'function') {
        try {
          return wS('', v.toJSON(), m - 1, l, p)
        } catch (e) {}
      }
      const g = Array.isArray(t) ? [] : {}
      let y = 0
      const b = SC(t)
      for (const A in b) {
        if (Object.prototype.hasOwnProperty.call(b, A)) {
          if (y >= l) {
            g[A] = '[MaxProperties ~]'
            break
          }
          const E = b[A]
          g[A] = wS(A, E, m - 1, l, p),
          y++
        }
      }
      return f(t),
      g
    }
    const _S = 1
    function CS (e) {
      const t = e.spanContext()
      const n = t.spanId
      const r = t.traceId
      const o = SS(e)
      return BC({
        data: o.data,
        op: o.op,
        parent_span_id: o.parent_span_id,
        span_id: n,
        status: o.status,
        tags: o.tags,
        trace_id: r,
        origin: o.origin
      })
    }
    function SS (e) {
      return (function (e) {
        return typeof e.getSpanJSON === 'function'
      }(e))
        ? e.getSpanJSON()
        : typeof e.toJSON === 'function' ? e.toJSON() : {}
    }
    function kS (e) {
      return kS = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      kS(e)
    }
    function jS (e) {
      return (function (e) {
        if (Array.isArray(e)) { return BS(e) }
      }(e)) || (function (e) {
        if (typeof Symbol !== 'undefined' && e[Symbol.iterator] != null || e['@@iterator'] != null) { return Array.from(e) }
      }(e)) || (function (e, t) {
        if (e) {
          if (typeof e === 'string') { return BS(e, t) }
          let n = Object.prototype.toString.call(e).slice(8, -1)
          return n === 'Object' && e.constructor && (n = e.constructor.name),
          n === 'Map' || n === 'Set' ? Array.from(e) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? BS(e, t) : void 0
        }
      }(e)) || (function () {
        throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
      }())
    }
    function BS (e, t) {
      (t == null || t > e.length) && (t = e.length)
      for (var n = 0, r = new Array(t); n < t; n++) { r[n] = e[n] }
      return r
    }
    function DS (e, t) {
      const n = Object.keys(e)
      if (Object.getOwnPropertySymbols) {
        let r = Object.getOwnPropertySymbols(e)
        t && (r = r.filter(function (t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable
        }
        )),
        n.push.apply(n, r)
      }
      return n
    }
    function PS (e) {
      for (let t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {}
        t % 2
          ? DS(Object(n), !0).forEach(function (t) {
            let r, o, i
            r = e,
            o = t,
            i = n[t],
            o = (function (e) {
              const t = (function (e, t) {
                if (kS(e) != 'object' || !e) { return e }
                const n = e[Symbol.toPrimitive]
                if (void 0 !== n) {
                  const r = n.call(e, 'string')
                  if (kS(r) != 'object') { return r }
                  throw new TypeError('@@toPrimitive must return a primitive value.')
                }
                return String(e)
              }(e))
              return kS(t) == 'symbol' ? t : t + ''
            }(o)),
            o in r
              ? Object.defineProperty(r, o, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
              })
              : r[o] = i
          }
          )
          : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
            : DS(Object(n)).forEach(function (t) {
              Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
            }
            )
      }
      return e
    }
    const OS = new WeakMap()
    const TS = ['user', 'level', 'extra', 'contexts', 'tags', 'fingerprint', 'requestSession', 'propagationContext']
    function RS (e) {
      return function () {
        for (var t = [], n = 0; n < arguments.length; n++) { t[n] = arguments[n] }
        try {
          return Promise.resolve(e.apply(this, t))
        } catch (e) {
          return Promise.reject(e)
        }
      }
    }
    function NS (e) {
      return NS = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      NS(e)
    }
    function MS (e, t) {
      const n = Object.keys(e)
      if (Object.getOwnPropertySymbols) {
        let r = Object.getOwnPropertySymbols(e)
        t && (r = r.filter(function (t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable
        }
        )),
        n.push.apply(n, r)
      }
      return n
    }
    function IS (e) {
      for (let t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {}
        t % 2
          ? MS(Object(n), !0).forEach(function (t) {
            let r, o, i
            r = e,
            o = t,
            i = n[t],
            o = (function (e) {
              const t = (function (e, t) {
                if (NS(e) != 'object' || !e) { return e }
                const n = e[Symbol.toPrimitive]
                if (void 0 !== n) {
                  const r = n.call(e, 'string')
                  if (NS(r) != 'object') { return r }
                  throw new TypeError('@@toPrimitive must return a primitive value.')
                }
                return String(e)
              }(e))
              return NS(t) == 'symbol' ? t : t + ''
            }(o)),
            o in r
              ? Object.defineProperty(r, o, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
              })
              : r[o] = i
          }
          )
          : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
            : MS(Object(n)).forEach(function (t) {
              Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
            }
            )
      }
      return e
    }
    function LS (e, t) {
      return _k().captureEvent(e, t)
    }
    function zS (e, t) {
      _k().addBreadcrumb(e, t)
    }
    function FS () {
      return _k().getClient()
    }
    function $S () {
      return _k().getScope()
    }
    function HS (e) {
      const t = FS()
      const n = Ck()
      const r = $S()
      const o = t && t.getOptions() || {}
      const i = o.release
      const a = o.environment
      const s = void 0 === a ? rS : a
      const c = (q_.navigator || {}).userAgent
      const l = oS(IS(IS({
        release: i,
        environment: s,
        user: r.getUser() || n.getUser()
      }, c && {
        userAgent: c
      }), e))
      const p = n.getSession()
      return p && p.status === 'ok' && iS(p, {
        status: 'exited'
      }),
      qS(),
      n.setSession(l),
      r.setSession(l),
      l
    }
    function qS () {
      const e = Ck()
      const t = $S()
      const n = t.getSession() || e.getSession()
      n && aS(n),
      WS(),
      e.setSession(),
      t.setSession()
    }
    function WS () {
      const e = Ck()
      const t = $S()
      const n = FS()
      const r = t.getSession() || e.getSession()
      r && n && n.captureSession && n.captureSession(r)
    }
    function GS () {
      arguments.length > 0 && void 0 !== arguments[0] && arguments[0] ? qS() : WS()
    }
    function US (e) {
      return e.transaction
    }
    function VS (e, t, n) {
      const r = t.getOptions()
      const o = (t.getDsn() || {}).publicKey
      const i = (n && n.getUser() || {}).segment
      const a = BC({
        environment: r.environment || rS,
        release: r.release,
        user_segment: i,
        public_key: o,
        trace_id: e
      })
      return t.emit && t.emit('createDsc', a),
      a
    }
    function QS (e) {
      const t = FS()
      if (!t) { return {} }
      const n = VS(SS(e).trace_id || '', t, $S())
      const r = US(e)
      if (!r) { return n }
      const o = r && r._frozenDynamicSamplingContext
      if (o) { return o }
      const i = r.metadata
      const a = i.sampleRate
      const s = i.source
      a != null && (n.sample_rate = ''.concat(a))
      const c = SS(r)
      return s && s !== 'url' && (n.transaction = c.description),
      n.sampled = String(function (e) {
        const t = e.spanContext().traceFlags
        return Boolean(t & _S)
      }(r)),
      t.emit && t.emit('createDsc', n),
      n
    }
    function YS (e) {
      return YS = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      YS(e)
    }
    function KS (e, t) {
      const n = Object.keys(e)
      if (Object.getOwnPropertySymbols) {
        let r = Object.getOwnPropertySymbols(e)
        t && (r = r.filter(function (t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable
        }
        )),
        n.push.apply(n, r)
      }
      return n
    }
    function JS (e) {
      for (let t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {}
        t % 2
          ? KS(Object(n), !0).forEach(function (t) {
            let r, o, i
            r = e,
            o = t,
            i = n[t],
            o = (function (e) {
              const t = (function (e, t) {
                if (YS(e) != 'object' || !e) { return e }
                const n = e[Symbol.toPrimitive]
                if (void 0 !== n) {
                  const r = n.call(e, 'string')
                  if (YS(r) != 'object') { return r }
                  throw new TypeError('@@toPrimitive must return a primitive value.')
                }
                return String(e)
              }(e))
              return YS(t) == 'symbol' ? t : t + ''
            }(o)),
            o in r
              ? Object.defineProperty(r, o, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
              })
              : r[o] = i
          }
          )
          : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
            : KS(Object(n)).forEach(function (t) {
              Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
            }
            )
      }
      return e
    }
    function XS (e) {
      return (function (e) {
        if (Array.isArray(e)) { return ZS(e) }
      }(e)) || (function (e) {
        if (typeof Symbol !== 'undefined' && e[Symbol.iterator] != null || e['@@iterator'] != null) { return Array.from(e) }
      }(e)) || (function (e, t) {
        if (e) {
          if (typeof e === 'string') { return ZS(e, t) }
          let n = Object.prototype.toString.call(e).slice(8, -1)
          return n === 'Object' && e.constructor && (n = e.constructor.name),
          n === 'Map' || n === 'Set' ? Array.from(e) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? ZS(e, t) : void 0
        }
      }(e)) || (function () {
        throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
      }())
    }
    function ZS (e, t) {
      (t == null || t > e.length) && (t = e.length)
      for (var n = 0, r = new Array(t); n < t; n++) { r[n] = e[n] }
      return r
    }
    function ek (e, t) {
      const n = t.fingerprint
      const r = t.span
      const o = t.breadcrumbs
      const i = t.sdkProcessingMetadata
      !(function (e, t) {
        const n = t.extra
        const r = t.tags
        const o = t.user
        const i = t.contexts
        const a = t.level
        const s = t.transactionName
        const c = BC(n)
        c && Object.keys(c).length && (e.extra = JS(JS({}, c), e.extra))
        const l = BC(r)
        l && Object.keys(l).length && (e.tags = JS(JS({}, l), e.tags))
        const p = BC(o)
        p && Object.keys(p).length && (e.user = JS(JS({}, p), e.user))
        const u = BC(i)
        u && Object.keys(u).length && (e.contexts = JS(JS({}, u), e.contexts)),
        a && (e.level = a),
        s && (e.transaction = s)
      }(e, t)),
      r && (function (e, t) {
        e.contexts = JS({
          trace: CS(t)
        }, e.contexts)
        const n = US(t)
        if (n) {
          e.sdkProcessingMetadata = JS({
            dynamicSamplingContext: QS(t)
          }, e.sdkProcessingMetadata)
          const r = SS(n).description
          r && (e.tags = JS({
            transaction: r
          }, e.tags))
        }
      }(e, r)),
      (function (e, t) {
        e.fingerprint = e.fingerprint ? FC(e.fingerprint) : [],
        t && (e.fingerprint = e.fingerprint.concat(t)),
        e.fingerprint && !e.fingerprint.length && delete e.fingerprint
      }(e, n)),
      (function (e, t) {
        const n = [].concat(XS(e.breadcrumbs || []), XS(t))
        e.breadcrumbs = n.length ? n : void 0
      }(e, o)),
      (function (e, t) {
        e.sdkProcessingMetadata = JS(JS({}, e.sdkProcessingMetadata), t)
      }(e, i))
    }
    function tk (e, t) {
      const n = t.extra
      const r = t.tags
      const o = t.user
      const i = t.contexts
      const a = t.level
      const s = t.sdkProcessingMetadata
      const c = t.breadcrumbs
      const l = t.fingerprint
      const p = t.eventProcessors
      const u = t.attachments
      const d = t.propagationContext
      const f = t.transactionName
      const h = t.span
      nk(e, 'extra', n),
      nk(e, 'tags', r),
      nk(e, 'user', o),
      nk(e, 'contexts', i),
      nk(e, 'sdkProcessingMetadata', s),
      a && (e.level = a),
      f && (e.transactionName = f),
      h && (e.span = h),
      c.length && (e.breadcrumbs = [].concat(XS(e.breadcrumbs), XS(c))),
      l.length && (e.fingerprint = [].concat(XS(e.fingerprint), XS(l))),
      p.length && (e.eventProcessors = [].concat(XS(e.eventProcessors), XS(p))),
      u.length && (e.attachments = [].concat(XS(e.attachments), XS(u))),
      e.propagationContext = JS(JS({}, e.propagationContext), d)
    }
    function nk (e, t, n) {
      if (n && Object.keys(n).length) {
        for (const r in e[t] = JS({}, e[t]),
        n) { Object.prototype.hasOwnProperty.call(n, r) && (e[t][r] = n[r]) }
      }
    }
    function rk (e) {
      return rk = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      rk(e)
    }
    function ok (e, t) {
      const n = Object.keys(e)
      if (Object.getOwnPropertySymbols) {
        let r = Object.getOwnPropertySymbols(e)
        t && (r = r.filter(function (t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable
        }
        )),
        n.push.apply(n, r)
      }
      return n
    }
    function ik (e) {
      for (let t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {}
        t % 2
          ? ok(Object(n), !0).forEach(function (t) {
            ak(e, t, n[t])
          }
          )
          : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
            : ok(Object(n)).forEach(function (t) {
              Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
            }
            )
      }
      return e
    }
    function ak (e, t, n) {
      return (t = pk(t)) in e
        ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
        : e[t] = n,
      e
    }
    function sk (e) {
      return (function (e) {
        if (Array.isArray(e)) { return ck(e) }
      }(e)) || (function (e) {
        if (typeof Symbol !== 'undefined' && e[Symbol.iterator] != null || e['@@iterator'] != null) { return Array.from(e) }
      }(e)) || (function (e, t) {
        if (e) {
          if (typeof e === 'string') { return ck(e, t) }
          let n = Object.prototype.toString.call(e).slice(8, -1)
          return n === 'Object' && e.constructor && (n = e.constructor.name),
          n === 'Map' || n === 'Set' ? Array.from(e) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? ck(e, t) : void 0
        }
      }(e)) || (function () {
        throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
      }())
    }
    function ck (e, t) {
      (t == null || t > e.length) && (t = e.length)
      for (var n = 0, r = new Array(t); n < t; n++) { r[n] = e[n] }
      return r
    }
    function lk (e, t) {
      for (let n = 0; n < t.length; n++) {
        const r = t[n]
        r.enumerable = r.enumerable || !1,
        r.configurable = !0,
        'value' in r && (r.writable = !0),
        Object.defineProperty(e, pk(r.key), r)
      }
    }
    function pk (e) {
      const t = (function (e, t) {
        if (rk(e) != 'object' || !e) { return e }
        const n = e[Symbol.toPrimitive]
        if (void 0 !== n) {
          const r = n.call(e, 'string')
          if (rk(r) != 'object') { return r }
          throw new TypeError('@@toPrimitive must return a primitive value.')
        }
        return String(e)
      }(e))
      return rk(t) == 'symbol' ? t : t + ''
    }
    RS(function (e) {
      const t = FS()
      return t
        ? t.close(e)
        : (HC && J_.warn('Cannot flush events and disable SDK. No client defined.'),
          Promise.resolve(!1))
    }
    ),
    RS(function (e) {
      const t = FS()
      return t
        ? t.flush(e)
        : (HC && J_.warn('Cannot flush events. No client defined.'),
          Promise.resolve(!1))
    }
    )
    let uk; const dk = (function () {
      function e () {
        !(function (e, t) {
          if (!(e instanceof t)) { throw new TypeError('Cannot call a class as a function') }
        }(this, e)),
        this._notifyingListeners = !1,
        this._scopeListeners = [],
        this._eventProcessors = [],
        this._breadcrumbs = [],
        this._attachments = [],
        this._user = {},
        this._tags = {},
        this._extra = {},
        this._contexts = {},
        this._sdkProcessingMetadata = {},
        this._propagationContext = fk()
      }
      return t = e,
      n = [{
        key: 'clone',
        value: function () {
          const t = new e()
          return t._breadcrumbs = sk(this._breadcrumbs),
          t._tags = ik({}, this._tags),
          t._extra = ik({}, this._extra),
          t._contexts = ik({}, this._contexts),
          t._user = this._user,
          t._level = this._level,
          t._span = this._span,
          t._session = this._session,
          t._transactionName = this._transactionName,
          t._fingerprint = this._fingerprint,
          t._eventProcessors = sk(this._eventProcessors),
          t._requestSession = this._requestSession,
          t._attachments = sk(this._attachments),
          t._sdkProcessingMetadata = ik({}, this._sdkProcessingMetadata),
          t._propagationContext = ik({}, this._propagationContext),
          t._client = this._client,
          t
        }
      }, {
        key: 'setClient',
        value: function (e) {
          this._client = e
        }
      }, {
        key: 'getClient',
        value: function () {
          return this._client
        }
      }, {
        key: 'addScopeListener',
        value: function (e) {
          this._scopeListeners.push(e)
        }
      }, {
        key: 'addEventProcessor',
        value: function (e) {
          return this._eventProcessors.push(e),
          this
        }
      }, {
        key: 'setUser',
        value: function (e) {
          return this._user = e || {
            email: void 0,
            id: void 0,
            ip_address: void 0,
            segment: void 0,
            username: void 0
          },
          this._session && iS(this._session, {
            user: e
          }),
          this._notifyScopeListeners(),
          this
        }
      }, {
        key: 'getUser',
        value: function () {
          return this._user
        }
      }, {
        key: 'getRequestSession',
        value: function () {
          return this._requestSession
        }
      }, {
        key: 'setRequestSession',
        value: function (e) {
          return this._requestSession = e,
          this
        }
      }, {
        key: 'setTags',
        value: function (e) {
          return this._tags = ik(ik({}, this._tags), e),
          this._notifyScopeListeners(),
          this
        }
      }, {
        key: 'setTag',
        value: function (e, t) {
          return this._tags = ik(ik({}, this._tags), {}, ak({}, e, t)),
          this._notifyScopeListeners(),
          this
        }
      }, {
        key: 'setExtras',
        value: function (e) {
          return this._extra = ik(ik({}, this._extra), e),
          this._notifyScopeListeners(),
          this
        }
      }, {
        key: 'setExtra',
        value: function (e, t) {
          return this._extra = ik(ik({}, this._extra), {}, ak({}, e, t)),
          this._notifyScopeListeners(),
          this
        }
      }, {
        key: 'setFingerprint',
        value: function (e) {
          return this._fingerprint = e,
          this._notifyScopeListeners(),
          this
        }
      }, {
        key: 'setLevel',
        value: function (e) {
          return this._level = e,
          this._notifyScopeListeners(),
          this
        }
      }, {
        key: 'setTransactionName',
        value: function (e) {
          return this._transactionName = e,
          this._notifyScopeListeners(),
          this
        }
      }, {
        key: 'setContext',
        value: function (e, t) {
          return t === null ? delete this._contexts[e] : this._contexts[e] = t,
          this._notifyScopeListeners(),
          this
        }
      }, {
        key: 'setSpan',
        value: function (e) {
          return this._span = e,
          this._notifyScopeListeners(),
          this
        }
      }, {
        key: 'getSpan',
        value: function () {
          return this._span
        }
      }, {
        key: 'getTransaction',
        value: function () {
          const e = this._span
          return e && e.transaction
        }
      }, {
        key: 'setSession',
        value: function (e) {
          return e ? this._session = e : delete this._session,
          this._notifyScopeListeners(),
          this
        }
      }, {
        key: 'getSession',
        value: function () {
          return this._session
        }
      }, {
        key: 'update',
        value: function (t) {
          if (!t) { return this }
          const n = typeof t === 'function' ? t(this) : t
          if (n instanceof e) {
            const r = n.getScopeData()
            this._tags = ik(ik({}, this._tags), r.tags),
            this._extra = ik(ik({}, this._extra), r.extra),
            this._contexts = ik(ik({}, this._contexts), r.contexts),
            r.user && Object.keys(r.user).length && (this._user = r.user),
            r.level && (this._level = r.level),
            r.fingerprint.length && (this._fingerprint = r.fingerprint),
            n.getRequestSession() && (this._requestSession = n.getRequestSession()),
            r.propagationContext && (this._propagationContext = r.propagationContext)
          } else if (sC(n)) {
            const o = t
            this._tags = ik(ik({}, this._tags), o.tags),
            this._extra = ik(ik({}, this._extra), o.extra),
            this._contexts = ik(ik({}, this._contexts), o.contexts),
            o.user && (this._user = o.user),
            o.level && (this._level = o.level),
            o.fingerprint && (this._fingerprint = o.fingerprint),
            o.requestSession && (this._requestSession = o.requestSession),
            o.propagationContext && (this._propagationContext = o.propagationContext)
          }
          return this
        }
      }, {
        key: 'clear',
        value: function () {
          return this._breadcrumbs = [],
          this._tags = {},
          this._extra = {},
          this._user = {},
          this._contexts = {},
          this._level = void 0,
          this._transactionName = void 0,
          this._fingerprint = void 0,
          this._requestSession = void 0,
          this._span = void 0,
          this._session = void 0,
          this._notifyScopeListeners(),
          this._attachments = [],
          this._propagationContext = fk(),
          this
        }
      }, {
        key: 'addBreadcrumb',
        value: function (e, t) {
          const n = typeof t === 'number' ? t : 100
          if (n <= 0) { return this }
          const r = ik({
            timestamp: tS()
          }, e)
          const o = this._breadcrumbs
          return o.push(r),
          this._breadcrumbs = o.length > n ? o.slice(-n) : o,
          this._notifyScopeListeners(),
          this
        }
      }, {
        key: 'getLastBreadcrumb',
        value: function () {
          return this._breadcrumbs[this._breadcrumbs.length - 1]
        }
      }, {
        key: 'clearBreadcrumbs',
        value: function () {
          return this._breadcrumbs = [],
          this._notifyScopeListeners(),
          this
        }
      }, {
        key: 'addAttachment',
        value: function (e) {
          return this._attachments.push(e),
          this
        }
      }, {
        key: 'getAttachments',
        value: function () {
          return this.getScopeData().attachments
        }
      }, {
        key: 'clearAttachments',
        value: function () {
          return this._attachments = [],
          this
        }
      }, {
        key: 'getScopeData',
        value: function () {
          return {
            breadcrumbs: this._breadcrumbs,
            attachments: this._attachments,
            contexts: this._contexts,
            tags: this._tags,
            extra: this._extra,
            user: this._user,
            level: this._level,
            fingerprint: this._fingerprint || [],
            eventProcessors: this._eventProcessors,
            propagationContext: this._propagationContext,
            sdkProcessingMetadata: this._sdkProcessingMetadata,
            transactionName: this._transactionName,
            span: this._span
          }
        }
      }, {
        key: 'applyToEvent',
        value: function (e) {
          const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
          const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : []
          return ek(e, this.getScopeData()),
          ZC([].concat(sk(n), sk(JC()), sk(this._eventProcessors)), e, t)
        }
      }, {
        key: 'setSDKProcessingMetadata',
        value: function (e) {
          return this._sdkProcessingMetadata = ik(ik({}, this._sdkProcessingMetadata), e),
          this
        }
      }, {
        key: 'setPropagationContext',
        value: function (e) {
          return this._propagationContext = e,
          this
        }
      }, {
        key: 'getPropagationContext',
        value: function () {
          return this._propagationContext
        }
      }, {
        key: 'captureException',
        value: function (e, t) {
          const n = t && t.event_id ? t.event_id : RC()
          if (!this._client) {
            return J_.warn('No client configured on scope - will not capture exception!'),
            n
          }
          const r = new Error('Sentry syntheticException')
          return this._client.captureException(e, ik(ik({
            originalException: e,
            syntheticException: r
          }, t), {}, {
            event_id: n
          }), this),
          n
        }
      }, {
        key: 'captureMessage',
        value: function (e, t, n) {
          const r = n && n.event_id ? n.event_id : RC()
          if (!this._client) {
            return J_.warn('No client configured on scope - will not capture message!'),
            r
          }
          const o = new Error(e)
          return this._client.captureMessage(e, t, ik(ik({
            originalException: e,
            syntheticException: o
          }, n), {}, {
            event_id: r
          }), this),
          r
        }
      }, {
        key: 'captureEvent',
        value: function (e, t) {
          const n = t && t.event_id ? t.event_id : RC()
          return this._client
            ? (this._client.captureEvent(e, ik(ik({}, t), {}, {
                event_id: n
              }), this),
              n)
            : (J_.warn('No client configured on scope - will not capture event!'),
              n)
        }
      }, {
        key: '_notifyScopeListeners',
        value: function () {
          const e = this
          this._notifyingListeners || (this._notifyingListeners = !0,
          this._scopeListeners.forEach(function (t) {
            t(e)
          }
          ),
          this._notifyingListeners = !1)
        }
      }],
      r = [{
        key: 'clone',
        value: function (t) {
          return t ? t.clone() : new e()
        }
      }],
      n && lk(t.prototype, n),
      r && lk(t, r),
      Object.defineProperty(t, 'prototype', {
        writable: !1
      }),
      t
      let t, n, r
    }())
    function fk () {
      return {
        traceId: RC(),
        spanId: RC().substring(16)
      }
    }
    const hk = '7.109.0'
    function mk (e) {
      return mk = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      mk(e)
    }
    function vk (e, t) {
      const n = Object.keys(e)
      if (Object.getOwnPropertySymbols) {
        let r = Object.getOwnPropertySymbols(e)
        t && (r = r.filter(function (t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable
        }
        )),
        n.push.apply(n, r)
      }
      return n
    }
    function gk (e) {
      for (let t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {}
        t % 2
          ? vk(Object(n), !0).forEach(function (t) {
            let r, o, i
            r = e,
            o = t,
            i = n[t],
            (o = bk(o)) in r
              ? Object.defineProperty(r, o, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
              })
              : r[o] = i
          }
          )
          : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
            : vk(Object(n)).forEach(function (t) {
              Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
            }
            )
      }
      return e
    }
    function yk (e, t) {
      for (let n = 0; n < t.length; n++) {
        const r = t[n]
        r.enumerable = r.enumerable || !1,
        r.configurable = !0,
        'value' in r && (r.writable = !0),
        Object.defineProperty(e, bk(r.key), r)
      }
    }
    function bk (e) {
      const t = (function (e, t) {
        if (mk(e) != 'object' || !e) { return e }
        const n = e[Symbol.toPrimitive]
        if (void 0 !== n) {
          const r = n.call(e, 'string')
          if (mk(r) != 'object') { return r }
          throw new TypeError('@@toPrimitive must return a primitive value.')
        }
        return String(e)
      }(e))
      return mk(t) == 'symbol' ? t : t + ''
    }
    const Ak = parseFloat(hk)
    const Ek = (function () {
      return e = function e (t, n, r) {
        let o; let i; const a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Ak
        !(function (e, t) {
          if (!(e instanceof t)) { throw new TypeError('Cannot call a class as a function') }
        }(this, e)),
        this._version = a,
        n ? o = n : (o = new dk()).setClient(t),
        r ? i = r : (i = new dk()).setClient(t),
        this._stack = [{
          scope: o
        }],
        t && this.bindClient(t),
        this._isolationScope = i
      }
      ,
      t = [{
        key: 'isOlderThan',
        value: function (e) {
          return this._version < e
        }
      }, {
        key: 'bindClient',
        value: function (e) {
          const t = this.getStackTop()
          t.client = e,
          t.scope.setClient(e),
          e && e.setupIntegrations && e.setupIntegrations()
        }
      }, {
        key: 'pushScope',
        value: function () {
          const e = this.getScope().clone()
          return this.getStack().push({
            client: this.getClient(),
            scope: e
          }),
          e
        }
      }, {
        key: 'popScope',
        value: function () {
          return !(this.getStack().length <= 1 || !this.getStack().pop())
        }
      }, {
        key: 'withScope',
        value: function (e) {
          let t; const n = this; const r = this.pushScope()
          try {
            t = e(r)
          } catch (e) {
            throw this.popScope(),
            e
          }
          return lC(t)
            ? t.then(function (e) {
              return n.popScope(),
              e
            }
            , function (e) {
              throw n.popScope(),
              e
            }
            )
            : (this.popScope(),
              t)
        }
      }, {
        key: 'getClient',
        value: function () {
          return this.getStackTop().client
        }
      }, {
        key: 'getScope',
        value: function () {
          return this.getStackTop().scope
        }
      }, {
        key: 'getIsolationScope',
        value: function () {
          return this._isolationScope
        }
      }, {
        key: 'getStack',
        value: function () {
          return this._stack
        }
      }, {
        key: 'getStackTop',
        value: function () {
          return this._stack[this._stack.length - 1]
        }
      }, {
        key: 'captureException',
        value: function (e, t) {
          const n = this._lastEventId = t && t.event_id ? t.event_id : RC()
          const r = new Error('Sentry syntheticException')
          return this.getScope().captureException(e, gk(gk({
            originalException: e,
            syntheticException: r
          }, t), {}, {
            event_id: n
          })),
          n
        }
      }, {
        key: 'captureMessage',
        value: function (e, t, n) {
          const r = this._lastEventId = n && n.event_id ? n.event_id : RC()
          const o = new Error(e)
          return this.getScope().captureMessage(e, t, gk(gk({
            originalException: e,
            syntheticException: o
          }, n), {}, {
            event_id: r
          })),
          r
        }
      }, {
        key: 'captureEvent',
        value: function (e, t) {
          const n = t && t.event_id ? t.event_id : RC()
          return e.type || (this._lastEventId = n),
          this.getScope().captureEvent(e, gk(gk({}, t), {}, {
            event_id: n
          })),
          n
        }
      }, {
        key: 'lastEventId',
        value: function () {
          return this._lastEventId
        }
      }, {
        key: 'addBreadcrumb',
        value: function (e, t) {
          const n = this.getStackTop()
          const r = n.scope
          const o = n.client
          if (o) {
            const i = o.getOptions && o.getOptions() || {}
            const a = i.beforeBreadcrumb
            const s = void 0 === a ? null : a
            const c = i.maxBreadcrumbs
            const l = void 0 === c ? 100 : c
            if (!(l <= 0)) {
              const p = gk({
                timestamp: tS()
              }, e)
              const u = s
                ? Q_(function () {
                  return s(p, t)
                }
                )
                : p
              u !== null && (o.emit && o.emit('beforeAddBreadcrumb', u, t),
              r.addBreadcrumb(u, l))
            }
          }
        }
      }, {
        key: 'setUser',
        value: function (e) {
          this.getScope().setUser(e),
          this.getIsolationScope().setUser(e)
        }
      }, {
        key: 'setTags',
        value: function (e) {
          this.getScope().setTags(e),
          this.getIsolationScope().setTags(e)
        }
      }, {
        key: 'setExtras',
        value: function (e) {
          this.getScope().setExtras(e),
          this.getIsolationScope().setExtras(e)
        }
      }, {
        key: 'setTag',
        value: function (e, t) {
          this.getScope().setTag(e, t),
          this.getIsolationScope().setTag(e, t)
        }
      }, {
        key: 'setExtra',
        value: function (e, t) {
          this.getScope().setExtra(e, t),
          this.getIsolationScope().setExtra(e, t)
        }
      }, {
        key: 'setContext',
        value: function (e, t) {
          this.getScope().setContext(e, t),
          this.getIsolationScope().setContext(e, t)
        }
      }, {
        key: 'configureScope',
        value: function (e) {
          const t = this.getStackTop()
          const n = t.scope
          t.client && e(n)
        }
      }, {
        key: 'run',
        value: function (e) {
          const t = wk(this)
          try {
            e(this)
          } finally {
            wk(t)
          }
        }
      }, {
        key: 'getIntegration',
        value: function (e) {
          const t = this.getClient()
          if (!t) { return null }
          try {
            return t.getIntegration(e)
          } catch (t) {
            return HC && J_.warn('Cannot retrieve integration '.concat(e.id, ' from the current Hub')),
            null
          }
        }
      }, {
        key: 'startTransaction',
        value: function (e, t) {
          const n = this._callExtensionMethod('startTransaction', e, t)
          return HC && !n && (this.getClient() ? J_.warn("Tracing extension 'startTransaction' has not been added. Call 'addTracingExtensions' before calling 'init':\nSentry.addTracingExtensions();\nSentry.init({...});\n") : J_.warn("Tracing extension 'startTransaction' is missing. You should 'init' the SDK before calling 'startTransaction'")),
          n
        }
      }, {
        key: 'traceHeaders',
        value: function () {
          return this._callExtensionMethod('traceHeaders')
        }
      }, {
        key: 'captureSession',
        value: function () {
          if (arguments.length > 0 && void 0 !== arguments[0] && arguments[0]) { return this.endSession() }
          this._sendSessionUpdate()
        }
      }, {
        key: 'endSession',
        value: function () {
          const e = this.getStackTop().scope
          const t = e.getSession()
          t && aS(t),
          this._sendSessionUpdate(),
          e.setSession()
        }
      }, {
        key: 'startSession',
        value: function (e) {
          const t = this.getStackTop()
          const n = t.scope
          const r = t.client
          const o = r && r.getOptions() || {}
          const i = o.release
          const a = o.environment
          const s = void 0 === a ? rS : a
          const c = (q_.navigator || {}).userAgent
          const l = oS(gk(gk({
            release: i,
            environment: s,
            user: n.getUser()
          }, c && {
            userAgent: c
          }), e))
          const p = n.getSession && n.getSession()
          return p && p.status === 'ok' && iS(p, {
            status: 'exited'
          }),
          this.endSession(),
          n.setSession(l),
          l
        }
      }, {
        key: 'shouldSendDefaultPii',
        value: function () {
          const e = this.getClient()
          const t = e && e.getOptions()
          return Boolean(t && t.sendDefaultPii)
        }
      }, {
        key: '_sendSessionUpdate',
        value: function () {
          const e = this.getStackTop()
          const t = e.scope
          const n = e.client
          const r = t.getSession()
          r && n && n.captureSession && n.captureSession(r)
        }
      }, {
        key: '_callExtensionMethod',
        value: function (e) {
          const t = xk().__SENTRY__
          if (t && t.extensions && typeof t.extensions[e] === 'function') {
            for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++) { r[o - 1] = arguments[o] }
            return t.extensions[e].apply(this, r)
          }
          HC && J_.warn('Extension method '.concat(e, " couldn't be found, doing nothing."))
        }
      }],
      t && yk(e.prototype, t),
      Object.defineProperty(e, 'prototype', {
        writable: !1
      }),
      e
      let e, t
    }())
    function xk () {
      return q_.__SENTRY__ = q_.__SENTRY__ || {
        extensions: {},
        hub: void 0
      },
      q_
    }
    function wk (e) {
      const t = xk()
      const n = Sk(t)
      return kk(t, e),
      n
    }
    function _k () {
      const e = xk()
      if (e.__SENTRY__ && e.__SENTRY__.acs) {
        const t = e.__SENTRY__.acs.getCurrentHub()
        if (t) { return t }
      }
      return (function () {
        const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : xk()
        return t = e,
        !!(t && t.__SENTRY__ && t.__SENTRY__.hub) && !Sk(e).isOlderThan(Ak) || kk(e, new Ek()),
        Sk(e)
        let t
      }(e))
    }
    function Ck () {
      return _k().getIsolationScope()
    }
    function Sk (e) {
      return G_('hub', function () {
        return new Ek()
      }
      , e)
    }
    function kk (e, t) {
      return !!e && ((e.__SENTRY__ = e.__SENTRY__ || {}).hub = t,
      !0)
    }
    function jk (e) {
      return (function (e) {
        if (Array.isArray(e)) { return Dk(e) }
      }(e)) || (function (e) {
        if (typeof Symbol !== 'undefined' && e[Symbol.iterator] != null || e['@@iterator'] != null) { return Array.from(e) }
      }(e)) || Bk(e) || (function () {
        throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
      }())
    }
    function Bk (e, t) {
      if (e) {
        if (typeof e === 'string') { return Dk(e, t) }
        let n = Object.prototype.toString.call(e).slice(8, -1)
        return n === 'Object' && e.constructor && (n = e.constructor.name),
        n === 'Map' || n === 'Set' ? Array.from(e) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Dk(e, t) : void 0
      }
    }
    function Dk (e, t) {
      (t == null || t > e.length) && (t = e.length)
      for (var n = 0, r = new Array(t); n < t; n++) { r[n] = e[n] }
      return r
    }
    const Pk = []
    function Ok (e) {
      const t = e.defaultIntegrations || []
      const n = e.integrations
      t.forEach(function (e) {
        e.isDefaultInstance = !0
      }
      )
      let r; let o; let i; let a; const s = (r = Array.isArray(n) ? [].concat(jk(t), jk(n)) : typeof n === 'function' ? FC(n(t)) : t,
      o = {},
      r.forEach(function (e) {
        const t = e.name
        const n = o[t]
        n && !n.isDefaultInstance && e.isDefaultInstance || (o[t] = e)
      }
      ),
      Object.keys(o).map(function (e) {
        return o[e]
      }
      )); const c = (function (e, t) {
        for (let n = 0; n < e.length; n++) {
          if (!0 == (e[n].name === 'Debug')) { return n }
        }
        return -1
      }(s))
      if (c !== -1) {
        const l = (i = s.splice(c, 1),
        a = 1,
        (function (e) {
          if (Array.isArray(e)) { return e }
        }(i)) || (function (e, t) {
          let n = e == null ? null : typeof Symbol !== 'undefined' && e[Symbol.iterator] || e['@@iterator']
          if (n != null) {
            let r; let o; let i; let a; const s = []; let c = !0; let l = !1
            try {
              if (i = (n = n.call(e)).next,
              t === 0) {
                if (Object(n) !== n) { return }
                c = !1
              } else {
                for (; !(c = (r = i.call(n)).done) && (s.push(r.value),
                s.length !== t); c = !0)
                  ;
              }
            } catch (e) {
              l = !0,
              o = e
            } finally {
              try {
                if (!c && n.return != null && (a = n.return(),
                Object(a) !== a)) { return }
              } finally {
                if (l) { throw o }
              }
            }
            return s
          }
        }(i, a)) || Bk(i, a) || (function () {
          throw new TypeError('Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
        }()))[0]
        s.push(l)
      }
      return s
    }
    function Tk (e, t) {
      let n; const r = (function (e, t) {
        let n = typeof Symbol !== 'undefined' && e[Symbol.iterator] || e['@@iterator']
        if (!n) {
          if (Array.isArray(e) || (n = Bk(e))) {
            n && (e = n)
            let r = 0
            const o = function () {}
            return {
              s: o,
              n: function () {
                return r >= e.length
                  ? {
                      done: !0
                    }
                  : {
                      done: !1,
                      value: e[r++]
                    }
              },
              e: function (e) {
                throw e
              },
              f: o
            }
          }
          throw new TypeError('Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
        }
        let i; let a = !0; let s = !1
        return {
          s: function () {
            n = n.call(e)
          },
          n: function () {
            const e = n.next()
            return a = e.done,
            e
          },
          e: function (e) {
            s = !0,
            i = e
          },
          f: function () {
            try {
              a || n.return == null || n.return()
            } finally {
              if (s) { throw i }
            }
          }
        }
      }(t))
      try {
        for (r.s(); !(n = r.n()).done;) {
          const o = n.value
          o && o.afterAllSetup && o.afterAllSetup(e)
        }
      } catch (e) {
        r.e(e)
      } finally {
        r.f()
      }
    }
    function Rk (e, t, n) {
      if (n[t.name]) { HC && J_.log('Integration skipped because it was already installed: '.concat(t.name)) } else {
        if (n[t.name] = t,
        Pk.indexOf(t.name) === -1 && (t.setupOnce(XC, _k),
        Pk.push(t.name)),
        t.setup && typeof t.setup === 'function' && t.setup(e),
        e.on && typeof t.preprocessEvent === 'function') {
          const r = t.preprocessEvent.bind(t)
          e.on('preprocessEvent', function (t, n) {
            return r(t, n, e)
          }
          )
        }
        if (e.addEventProcessor && typeof t.processEvent === 'function') {
          const o = t.processEvent.bind(t)
          const i = Object.assign(function (t, n) {
            return o(t, n, e)
          }
          , {
            id: t.name
          })
          e.addEventProcessor(i)
        }
        HC && J_.log('Integration installed: '.concat(t.name))
      }
    }
    function Nk (e, t) {
      return Object.assign(function () {
        return t.apply(void 0, arguments)
      }
      , {
        id: e
      })
    }
    function Mk (e) {
      return (function (e) {
        if (Array.isArray(e)) { return Ik(e) }
      }(e)) || (function (e) {
        if (typeof Symbol !== 'undefined' && e[Symbol.iterator] != null || e['@@iterator'] != null) { return Array.from(e) }
      }(e)) || (function (e, t) {
        if (e) {
          if (typeof e === 'string') { return Ik(e, t) }
          let n = Object.prototype.toString.call(e).slice(8, -1)
          return n === 'Object' && e.constructor && (n = e.constructor.name),
          n === 'Map' || n === 'Set' ? Array.from(e) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Ik(e, t) : void 0
        }
      }(e)) || (function () {
        throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
      }())
    }
    function Ik (e, t) {
      (t == null || t > e.length) && (t = e.length)
      for (var n = 0, r = new Array(t); n < t; n++) { r[n] = e[n] }
      return r
    }
    let Lk; const zk = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/, /^ResizeObserver loop completed with undelivered notifications.$/, /^Cannot redefine property: googletag$/]; const Fk = [/^.*\/healthcheck$/, /^.*\/healthy$/, /^.*\/live$/, /^.*\/ready$/, /^.*\/heartbeat$/, /^.*\/health$/, /^.*\/healthz$/]; const $k = 'InboundFilters'; const Hk = function () {
      const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
      return {
        name: $k,
        setupOnce: function () {},
        processEvent: function (t, n, r) {
          const o = r.getOptions()
          const i = (function () {
            const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
            const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
            return {
              allowUrls: [].concat(Mk(e.allowUrls || []), Mk(t.allowUrls || [])),
              denyUrls: [].concat(Mk(e.denyUrls || []), Mk(t.denyUrls || [])),
              ignoreErrors: [].concat(Mk(e.ignoreErrors || []), Mk(t.ignoreErrors || []), Mk(e.disableErrorDefaults ? [] : zk)),
              ignoreTransactions: [].concat(Mk(e.ignoreTransactions || []), Mk(t.ignoreTransactions || []), Mk(e.disableTransactionDefaults ? [] : Fk)),
              ignoreInternal: void 0 === e.ignoreInternal || e.ignoreInternal
            }
          }(e, o))
          return (function (e, t) {
            return t.ignoreInternal && (function (e) {
              try {
                return e.exception.values[0].type === 'SentryError'
              } catch (e) {}
              return !1
            }(e))
              ? (HC && J_.warn('Event dropped due to being internal Sentry Error.\nEvent: '.concat(MC(e))),
                !0)
              : (function (e, t) {
                  return !(e.type || !t || !t.length) && (function (e) {
                    let t; const n = []
                    e.message && n.push(e.message)
                    try {
                      t = e.exception.values[e.exception.values.length - 1]
                    } catch (e) {}
                    return t && t.value && (n.push(t.value),
                    t.type && n.push(''.concat(t.type, ': ').concat(t.value))),
                    HC && n.length === 0 && J_.error('Could not extract message for event '.concat(MC(e))),
                    n
                  }(e)).some(function (e) {
                    return yC(e, t)
                  }
                  )
                }(e, t.ignoreErrors))
                  ? (HC && J_.warn('Event dropped due to being matched by `ignoreErrors` option.\nEvent: '.concat(MC(e))),
                    !0)
                  : (function (e, t) {
                      if (e.type !== 'transaction' || !t || !t.length) { return !1 }
                      const n = e.transaction
                      return !!n && yC(n, t)
                    }(e, t.ignoreTransactions))
                      ? (HC && J_.warn('Event dropped due to being matched by `ignoreTransactions` option.\nEvent: '.concat(MC(e))),
                        !0)
                      : (function (e, t) {
                          if (!t || !t.length) { return !1 }
                          const n = qk(e)
                          return !!n && yC(n, t)
                        }(e, t.denyUrls))
                          ? (HC && J_.warn('Event dropped due to being matched by `denyUrls` option.\nEvent: '.concat(MC(e), '.\nUrl: ').concat(qk(e))),
                            !0)
                          : !(function (e, t) {
                              if (!t || !t.length) { return !0 }
                              const n = qk(e)
                              return !n || yC(n, t)
                            }(e, t.allowUrls)) && (HC && J_.warn('Event dropped due to not being matched by `allowUrls` option.\nEvent: '.concat(MC(e), '.\nUrl: ').concat(qk(e))),
                            !0)
          }(t, i))
            ? null
            : t
        }
      }
    }
    function qk (e) {
      try {
        let t
        try {
          t = e.exception.values[0].stacktrace.frames
        } catch (e) {}
        return t
          ? (function () {
              for (let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], t = e.length - 1; t >= 0; t--) {
                const n = e[t]
                if (n && n.filename !== '<anonymous>' && n.filename !== '[native code]') { return n.filename || null }
              }
              return null
            }(t))
          : null
      } catch (t) {
        return HC && J_.error('Cannot extract url for event '.concat(MC(e))),
        null
      }
    }
    Nk($k, Hk)
    const Wk = 'FunctionToString'
    const Gk = new WeakMap()
    const Uk = function () {
      return {
        name: Wk,
        setupOnce: function () {
          Lk = Function.prototype.toString
          try {
            Function.prototype.toString = function () {
              for (var e = CC(this), t = Gk.has(FS()) && void 0 !== e ? e : this, n = arguments.length, r = new Array(n), o = 0; o < n; o++) { r[o] = arguments[o] }
              return Lk.apply(t, r)
            }
          } catch (e) {}
        },
        setup: function (e) {
          Gk.set(e, !0)
        }
      }
    }
    Nk(Wk, Uk)
    const Vk = W_()
    function Qk () {
      if (!('fetch' in Vk)) { return !1 }
      try {
        return new Headers(),
        new Request('http://www.example.com'),
        new Response(),
        !0
      } catch (e) {
        return !1
      }
    }
    function Yk (e) {
      return e && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(e.toString())
    }
    const Kk = W_()
    function Jk (e, t) {
      (t == null || t > e.length) && (t = e.length)
      for (var n = 0, r = new Array(t); n < t; n++) { r[n] = e[n] }
      return r
    }
    const Xk = {}
    const Zk = {}
    function ej (e, t) {
      Xk[e] = Xk[e] || [],
      Xk[e].push(t)
    }
    function tj (e, t) {
      Zk[e] || (t(),
      Zk[e] = !0)
    }
    function nj (e, t) {
      const n = e && Xk[e]
      if (n) {
        let r; const o = (function (e, t) {
          let n = typeof Symbol !== 'undefined' && e[Symbol.iterator] || e['@@iterator']
          if (!n) {
            if (Array.isArray(e) || (n = (function (e, t) {
              if (e) {
                if (typeof e === 'string') { return Jk(e, t) }
                let n = Object.prototype.toString.call(e).slice(8, -1)
                return n === 'Object' && e.constructor && (n = e.constructor.name),
                n === 'Map' || n === 'Set' ? Array.from(e) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Jk(e, t) : void 0
              }
            }(e))) || t && e && typeof e.length === 'number') {
              n && (e = n)
              let r = 0
              const o = function () {}
              return {
                s: o,
                n: function () {
                  return r >= e.length
                    ? {
                        done: !0
                      }
                    : {
                        done: !1,
                        value: e[r++]
                      }
                },
                e: function (e) {
                  throw e
                },
                f: o
              }
            }
            throw new TypeError('Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
          }
          let i; let a = !0; let s = !1
          return {
            s: function () {
              n = n.call(e)
            },
            n: function () {
              const e = n.next()
              return a = e.done,
              e
            },
            e: function (e) {
              s = !0,
              i = e
            },
            f: function () {
              try {
                a || n.return == null || n.return()
              } finally {
                if (s) { throw i }
              }
            }
          }
        }(n))
        try {
          for (o.s(); !(r = o.n()).done;) {
            const i = r.value
            try {
              i(t)
            } catch (t) {
              F_ && J_.error('Error while triggering instrumentation handler.\nType: '.concat(e, '\nName: ').concat(yS(i), '\nError:'), t)
            }
          }
        } catch (e) {
          o.e(e)
        } finally {
          o.f()
        }
      }
    }
    let rj; const oj = q_
    function ij (e) {
      const t = 'history'
      ej(t, e),
      tj(t, aj)
    }
    function aj () {
      if (t = (e = Kk.chrome) && e.app && e.app.runtime,
      n = 'history' in Kk && !!Kk.history.pushState && !!Kk.history.replaceState,
      !t && n) {
        var e; var t; var n; const r = oj.onpopstate
        oj.onpopstate = function () {
          const e = oj.location.href
          const t = rj
          if (rj = e,
          nj('history', {
            from: t,
            to: e
          }),
          r) {
            try {
              for (var n = arguments.length, o = new Array(n), i = 0; i < n; i++) { o[i] = arguments[i] }
              return r.apply(this, o)
            } catch (e) {}
          }
        }
        ,
        xC(oj.history, 'pushState', o),
        xC(oj.history, 'replaceState', o)
      }
      function o (e) {
        return function () {
          for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++) { n[r] = arguments[r] }
          const o = n.length > 2 ? n[2] : void 0
          if (o) {
            const i = rj
            const a = String(o)
            rj = a,
            nj('history', {
              from: i,
              to: a
            })
          }
          return e.apply(this, n)
        }
      }
    }
    function sj (e, t) {
      (t == null || t > e.length) && (t = e.length)
      for (var n = 0, r = new Array(t); n < t; n++) { r[n] = e[n] }
      return r
    }
    const cj = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/
    function lj (e) {
      const t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
      const n = e.host
      const r = e.path
      const o = e.pass
      const i = e.port
      const a = e.projectId
      const s = e.protocol
      const c = e.publicKey
      return ''.concat(s, '://').concat(c).concat(t && o ? ':'.concat(o) : '') + '@'.concat(n).concat(i ? ':'.concat(i) : '', '/').concat(r ? ''.concat(r, '/') : r).concat(a)
    }
    function pj (e) {
      return {
        protocol: e.protocol,
        publicKey: e.publicKey || '',
        pass: e.pass || '',
        host: e.host,
        port: e.port || '',
        path: e.path || '',
        projectId: e.projectId
      }
    }
    function uj (e) {
      const t = typeof e === 'string'
        ? (function (e) {
            let t; let n; const r = cj.exec(e)
            if (r) {
              const o = (t = r.slice(1),
              n = 6,
              (function (e) {
                if (Array.isArray(e)) { return e }
              }(t)) || (function (e, t) {
                let n = e == null ? null : typeof Symbol !== 'undefined' && e[Symbol.iterator] || e['@@iterator']
                if (n != null) {
                  let r; let o; let i; let a; const s = []; let c = !0; let l = !1
                  try {
                    if (i = (n = n.call(e)).next,
                    t === 0) {
                      if (Object(n) !== n) { return }
                      c = !1
                    } else {
                      for (; !(c = (r = i.call(n)).done) && (s.push(r.value),
                      s.length !== t); c = !0)
                        ;
                    }
                  } catch (e) {
                    l = !0,
                    o = e
                  } finally {
                    try {
                      if (!c && n.return != null && (a = n.return(),
                      Object(a) !== a)) { return }
                    } finally {
                      if (l) { throw o }
                    }
                  }
                  return s
                }
              }(t, n)) || (function (e, t) {
                if (e) {
                  if (typeof e === 'string') { return sj(e, t) }
                  let n = Object.prototype.toString.call(e).slice(8, -1)
                  return n === 'Object' && e.constructor && (n = e.constructor.name),
                  n === 'Map' || n === 'Set' ? Array.from(e) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? sj(e, t) : void 0
                }
              }(t, n)) || (function () {
                throw new TypeError('Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
              }()))
              const i = o[0]
              const a = o[1]
              const s = o[2]
              const c = void 0 === s ? '' : s
              const l = o[3]
              const p = o[4]
              const u = void 0 === p ? '' : p
              let d = ''
              let f = o[5]
              const h = f.split('/')
              if (h.length > 1 && (d = h.slice(0, -1).join('/'),
              f = h.pop()),
              f) {
                const m = f.match(/^\d+/)
                m && (f = m[0])
              }
              return pj({
                host: l,
                pass: c,
                path: d,
                projectId: f,
                port: u,
                protocol: i,
                publicKey: a
              })
            }
            Q_(function () {
              console.error('Invalid Sentry Dsn: '.concat(e))
            }
            )
          }(e))
        : pj(e)
      if (t && (function (e) {
        if (!F_) { return !0 }
        const t = e.port
        const n = e.projectId
        const r = e.protocol
        return !(['protocol', 'publicKey', 'host', 'projectId'].find(function (t) {
          return !e[t] && (J_.error('Invalid Sentry Dsn: '.concat(t, ' missing')),
          !0)
        }
        ) || (n.match(/^\d+$/)
          ? (function (e) {
              return e === 'http' || e === 'https'
            }(r))
              ? t && isNaN(parseInt(t, 10)) && (J_.error('Invalid Sentry Dsn: Invalid port '.concat(t)),
              1)
              : (J_.error('Invalid Sentry Dsn: Invalid protocol '.concat(r)),
                1)
          : (J_.error('Invalid Sentry Dsn: Invalid projectId '.concat(n)),
            1)))
      }(t))) { return t }
    }
    function dj (e) {
      return dj = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      dj(e)
    }
    function fj (e, t) {
      const n = Object.keys(e)
      if (Object.getOwnPropertySymbols) {
        let r = Object.getOwnPropertySymbols(e)
        t && (r = r.filter(function (t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable
        }
        )),
        n.push.apply(n, r)
      }
      return n
    }
    function hj (e) {
      for (let t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {}
        t % 2
          ? fj(Object(n), !0).forEach(function (t) {
            let r, o, i
            r = e,
            o = t,
            i = n[t],
            o = (function (e) {
              const t = (function (e, t) {
                if (dj(e) != 'object' || !e) { return e }
                const n = e[Symbol.toPrimitive]
                if (void 0 !== n) {
                  const r = n.call(e, 'string')
                  if (dj(r) != 'object') { return r }
                  throw new TypeError('@@toPrimitive must return a primitive value.')
                }
                return String(e)
              }(e))
              return dj(t) == 'symbol' ? t : t + ''
            }(o)),
            o in r
              ? Object.defineProperty(r, o, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
              })
              : r[o] = i
          }
          )
          : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
            : fj(Object(n)).forEach(function (t) {
              Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
            }
            )
      }
      return e
    }
    function mj (e, t) {
      let n = typeof Symbol !== 'undefined' && e[Symbol.iterator] || e['@@iterator']
      if (!n) {
        if (Array.isArray(e) || (n = gj(e)) || t && e && typeof e.length === 'number') {
          n && (e = n)
          let r = 0
          const o = function () {}
          return {
            s: o,
            n: function () {
              return r >= e.length
                ? {
                    done: !0
                  }
                : {
                    done: !1,
                    value: e[r++]
                  }
            },
            e: function (e) {
              throw e
            },
            f: o
          }
        }
        throw new TypeError('Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
      }
      let i; let a = !0; let s = !1
      return {
        s: function () {
          n = n.call(e)
        },
        n: function () {
          const e = n.next()
          return a = e.done,
          e
        },
        e: function (e) {
          s = !0,
          i = e
        },
        f: function () {
          try {
            a || n.return == null || n.return()
          } finally {
            if (s) { throw i }
          }
        }
      }
    }
    function vj (e, t) {
      return (function (e) {
        if (Array.isArray(e)) { return e }
      }(e)) || (function (e, t) {
        let n = e == null ? null : typeof Symbol !== 'undefined' && e[Symbol.iterator] || e['@@iterator']
        if (n != null) {
          let r; let o; let i; let a; const s = []; let c = !0; let l = !1
          try {
            if (i = (n = n.call(e)).next,
            t === 0) {
              if (Object(n) !== n) { return }
              c = !1
            } else {
              for (; !(c = (r = i.call(n)).done) && (s.push(r.value),
              s.length !== t); c = !0)
                ;
            }
          } catch (e) {
            l = !0,
            o = e
          } finally {
            try {
              if (!c && n.return != null && (a = n.return(),
              Object(a) !== a)) { return }
            } finally {
              if (l) { throw o }
            }
          }
          return s
        }
      }(e, t)) || gj(e, t) || (function () {
        throw new TypeError('Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
      }())
    }
    function gj (e, t) {
      if (e) {
        if (typeof e === 'string') { return yj(e, t) }
        let n = Object.prototype.toString.call(e).slice(8, -1)
        return n === 'Object' && e.constructor && (n = e.constructor.name),
        n === 'Map' || n === 'Set' ? Array.from(e) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? yj(e, t) : void 0
      }
    }
    function yj (e, t) {
      (t == null || t > e.length) && (t = e.length)
      for (var n = 0, r = new Array(t); n < t; n++) { r[n] = e[n] }
      return r
    }
    function bj (e) {
      return [e, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : []]
    }
    function Aj (e, t) {
      let n; const r = mj(e[1])
      try {
        for (r.s(); !(n = r.n()).done;) {
          const o = n.value
          if (t(o, o[0].type)) { return !0 }
        }
      } catch (e) {
        r.e(e)
      } finally {
        r.f()
      }
      return !1
    }
    function Ej (e, t) {
      return (t || new TextEncoder()).encode(e)
    }
    function xj (e, t) {
      const n = vj(e, 2)
      const r = n[0]
      const o = n[1]
      let i = JSON.stringify(r)
      function a (e) {
        typeof i === 'string' ? i = typeof e === 'string' ? i + e : [Ej(i, t), e] : i.push(typeof e === 'string' ? Ej(e, t) : e)
      }
      let s; const c = mj(o)
      try {
        for (c.s(); !(s = c.n()).done;) {
          const l = vj(s.value, 2)
          const p = l[0]
          const u = l[1]
          if (a('\n'.concat(JSON.stringify(p), '\n')),
          typeof u === 'string' || u instanceof Uint8Array) { a(u) } else {
            let d = void 0
            try {
              d = JSON.stringify(u)
            } catch (e) {
              d = JSON.stringify(ES(u))
            }
            a(d)
          }
        }
      } catch (e) {
        c.e(e)
      } finally {
        c.f()
      }
      return typeof i === 'string'
        ? i
        : (function (e) {
            let t; const n = e.reduce(function (e, t) {
              return e + t.length
            }
            , 0); const r = new Uint8Array(n); let o = 0; const i = mj(e)
            try {
              for (i.s(); !(t = i.n()).done;) {
                const a = t.value
                r.set(a, o),
                o += a.length
              }
            } catch (e) {
              i.e(e)
            } finally {
              i.f()
            }
            return r
          }(i))
    }
    function wj (e, t) {
      const n = typeof e.data === 'string' ? Ej(e.data, t) : e.data
      return [BC({
        type: 'attachment',
        length: n.length,
        filename: e.filename,
        content_type: e.contentType,
        attachment_type: e.attachmentType
      }), n]
    }
    const _j = {
      session: 'session',
      sessions: 'session',
      attachment: 'attachment',
      transaction: 'transaction',
      event: 'error',
      client_report: 'internal',
      user_report: 'default',
      profile: 'profile',
      replay_event: 'replay',
      replay_recording: 'replay',
      check_in: 'monitor',
      feedback: 'feedback',
      span: 'span',
      statsd: 'statsd'
    }
    function Cj (e) {
      return _j[e]
    }
    function Sj (e) {
      if (e && e.sdk) {
        const t = e.sdk
        return {
          name: t.name,
          version: t.version
        }
      }
    }
    function kj (e) {
      return kj = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      kj(e)
    }
    function jj (e) {
      const t = typeof Map === 'function' ? new Map() : void 0
      return jj = function (e) {
        if (e === null || !(function (e) {
          try {
            return Function.toString.call(e).indexOf('[native code]') !== -1
          } catch (t) {
            return typeof e === 'function'
          }
        }(e))) { return e }
        if (typeof e !== 'function') { throw new TypeError('Super expression must either be null or a function') }
        if (void 0 !== t) {
          if (t.has(e)) { return t.get(e) }
          t.set(e, n)
        }
        function n () {
          return (function (e, t, n) {
            if (Bj()) { return Reflect.construct.apply(null, arguments) }
            const r = [null]
            r.push.apply(r, t)
            const o = new (e.bind.apply(e, r))()
            return n && Dj(o, n.prototype),
            o
          }(e, arguments, Pj(this).constructor))
        }
        return n.prototype = Object.create(e.prototype, {
          constructor: {
            value: n,
            enumerable: !1,
            writable: !0,
            configurable: !0
          }
        }),
        Dj(n, e)
      }
      ,
      jj(e)
    }
    function Bj () {
      try {
        var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}
        ))
      } catch (e) {}
      return (Bj = function () {
        return !!e
      }
      )()
    }
    function Dj (e, t) {
      return Dj = Object.setPrototypeOf
        ? Object.setPrototypeOf.bind()
        : function (e, t) {
          return e.__proto__ = t,
          e
        }
      ,
      Dj(e, t)
    }
    function Pj (e) {
      return Pj = Object.setPrototypeOf
        ? Object.getPrototypeOf.bind()
        : function (e) {
          return e.__proto__ || Object.getPrototypeOf(e)
        }
      ,
      Pj(e)
    }
    const Oj = (function (e) {
      function t (e) {
        let n; const r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'warn'
        return (function (e, t) {
          if (!(e instanceof t)) { throw new TypeError('Cannot call a class as a function') }
        }(this, t)),
        (n = (function (e, t, n) {
          return t = Pj(t),
          (function (e, t) {
            if (t && (kj(t) === 'object' || typeof t === 'function')) { return t }
            if (void 0 !== t) { throw new TypeError('Derived constructors may only return object or undefined') }
            return (function (e) {
              if (void 0 === e) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called") }
              return e
            }(e))
          }(e, Bj() ? Reflect.construct(t, n || [], Pj(e).constructor) : t.apply(e, n)))
        }(this, t, [e]))).message = e,
        n.name = (this instanceof t ? this.constructor : void 0).prototype.constructor.name,
        Object.setPrototypeOf(n, (this instanceof t ? this.constructor : void 0).prototype),
        n.logLevel = r,
        n
      }
      return (function (e, t) {
        if (typeof t !== 'function' && t !== null) { throw new TypeError('Super expression must either be null or a function') }
        e.prototype = Object.create(t && t.prototype, {
          constructor: {
            value: e,
            writable: !0,
            configurable: !0
          }
        }),
        Object.defineProperty(e, 'prototype', {
          writable: !1
        }),
        t && Dj(e, t)
      }(t, e)),
      n = t,
      Object.defineProperty(n, 'prototype', {
        writable: !1
      }),
      n
      let n
    }(jj(Error)))
    function Tj (e) {
      return Tj = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      Tj(e)
    }
    function Rj (e, t) {
      const n = Object.keys(e)
      if (Object.getOwnPropertySymbols) {
        let r = Object.getOwnPropertySymbols(e)
        t && (r = r.filter(function (t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable
        }
        )),
        n.push.apply(n, r)
      }
      return n
    }
    const Nj = '7'
    function Mj (e) {
      const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
      const n = typeof t === 'string' ? t : t.tunnel
      const r = typeof t !== 'string' && t._metadata ? t._metadata.sdk : void 0
      return n || ''.concat((function (e) {
        return ''.concat(function (e) {
          const t = e.protocol ? ''.concat(e.protocol, ':') : ''
          const n = e.port ? ':'.concat(e.port) : ''
          return ''.concat(t, '//').concat(e.host).concat(n).concat(e.path ? '/'.concat(e.path) : '', '/api/')
        }(e)).concat(e.projectId, '/envelope/')
      }(e)), '?').concat(function (e, t) {
        return n = (function (e) {
          for (let t = 1; t < arguments.length; t++) {
            var n = arguments[t] != null ? arguments[t] : {}
            t % 2
              ? Rj(Object(n), !0).forEach(function (t) {
                let r, o, i
                r = e,
                o = t,
                i = n[t],
                o = (function (e) {
                  const t = (function (e, t) {
                    if (Tj(e) != 'object' || !e) { return e }
                    const n = e[Symbol.toPrimitive]
                    if (void 0 !== n) {
                      const r = n.call(e, 'string')
                      if (Tj(r) != 'object') { return r }
                      throw new TypeError('@@toPrimitive must return a primitive value.')
                    }
                    return String(e)
                  }(e))
                  return Tj(t) == 'symbol' ? t : t + ''
                }(o)),
                o in r
                  ? Object.defineProperty(r, o, {
                    value: i,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                  })
                  : r[o] = i
              }
              )
              : Object.getOwnPropertyDescriptors
                ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
                : Rj(Object(n)).forEach(function (t) {
                  Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
                }
                )
          }
          return e
        }({
          sentry_key: e.publicKey,
          sentry_version: Nj
        }, t && {
          sentry_client: ''.concat(t.name, '/').concat(t.version)
        })),
        Object.keys(n).map(function (e) {
          return ''.concat(encodeURIComponent(e), '=').concat(encodeURIComponent(n[e]))
        }
        ).join('&')
        let n
      }(e, r))
    }
    function Ij (e) {
      return Ij = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      Ij(e)
    }
    function Lj (e, t) {
      const n = Object.keys(e)
      if (Object.getOwnPropertySymbols) {
        let r = Object.getOwnPropertySymbols(e)
        t && (r = r.filter(function (t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable
        }
        )),
        n.push.apply(n, r)
      }
      return n
    }
    function zj (e) {
      for (let t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {}
        t % 2
          ? Lj(Object(n), !0).forEach(function (t) {
            let r, o, i
            r = e,
            o = t,
            i = n[t],
            o = (function (e) {
              const t = (function (e, t) {
                if (Ij(e) != 'object' || !e) { return e }
                const n = e[Symbol.toPrimitive]
                if (void 0 !== n) {
                  const r = n.call(e, 'string')
                  if (Ij(r) != 'object') { return r }
                  throw new TypeError('@@toPrimitive must return a primitive value.')
                }
                return String(e)
              }(e))
              return Ij(t) == 'symbol' ? t : t + ''
            }(o)),
            o in r
              ? Object.defineProperty(r, o, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
              })
              : r[o] = i
          }
          )
          : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
            : Lj(Object(n)).forEach(function (t) {
              Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
            }
            )
      }
      return e
    }
    function Fj (e) {
      return (function (e) {
        if (Array.isArray(e)) { return $j(e) }
      }(e)) || (function (e) {
        if (typeof Symbol !== 'undefined' && e[Symbol.iterator] != null || e['@@iterator'] != null) { return Array.from(e) }
      }(e)) || (function (e, t) {
        if (e) {
          if (typeof e === 'string') { return $j(e, t) }
          let n = Object.prototype.toString.call(e).slice(8, -1)
          return n === 'Object' && e.constructor && (n = e.constructor.name),
          n === 'Map' || n === 'Set' ? Array.from(e) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? $j(e, t) : void 0
        }
      }(e)) || (function () {
        throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
      }())
    }
    function $j (e, t) {
      (t == null || t > e.length) && (t = e.length)
      for (var n = 0, r = new Array(t); n < t; n++) { r[n] = e[n] }
      return r
    }
    function Hj (e, t) {
      if (e) {
        if (typeof e === 'string') { return qj(e, t) }
        let n = Object.prototype.toString.call(e).slice(8, -1)
        return n === 'Object' && e.constructor && (n = e.constructor.name),
        n === 'Map' || n === 'Set' ? Array.from(e) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? qj(e, t) : void 0
      }
    }
    function qj (e, t) {
      (t == null || t > e.length) && (t = e.length)
      for (var n = 0, r = new Array(t); n < t; n++) { r[n] = e[n] }
      return r
    }
    function Wj (e, t, n, r) {
      const o = {
        sent_at: (new Date()).toISOString()
      }
      n && n.sdk && (o.sdk = {
        name: n.sdk.name,
        version: n.sdk.version
      }),
      r && t && (o.dsn = lj(t))
      const i = (function (e) {
        const t = (function (e) {
          let t; let n = ''; const r = (function (e, t) {
            let n = typeof Symbol !== 'undefined' && e[Symbol.iterator] || e['@@iterator']
            if (!n) {
              if (Array.isArray(e) || (n = Hj(e))) {
                n && (e = n)
                let r = 0
                const o = function () {}
                return {
                  s: o,
                  n: function () {
                    return r >= e.length
                      ? {
                          done: !0
                        }
                      : {
                          done: !1,
                          value: e[r++]
                        }
                  },
                  e: function (e) {
                    throw e
                  },
                  f: o
                }
              }
              throw new TypeError('Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
            }
            let i; let a = !0; let s = !1
            return {
              s: function () {
                n = n.call(e)
              },
              n: function () {
                const e = n.next()
                return a = e.done,
                e
              },
              e: function (e) {
                s = !0,
                i = e
              },
              f: function () {
                try {
                  a || n.return == null || n.return()
                } finally {
                  if (s) { throw i }
                }
              }
            }
          }(e))
          try {
            for (r.s(); !(t = r.n()).done;) {
              const o = t.value
              const i = Object.entries(o.tags)
              const a = i.length > 0
                ? '|#'.concat(i.map(function (e) {
                  let t; let n; const r = (n = 2,
                  (function (e) {
                    if (Array.isArray(e)) { return e }
                  }(t = e)) || (function (e, t) {
                    let n = e == null ? null : typeof Symbol !== 'undefined' && e[Symbol.iterator] || e['@@iterator']
                    if (n != null) {
                      let r; let o; let i; let a; const s = []; let c = !0; let l = !1
                      try {
                        if (i = (n = n.call(e)).next,
                        t === 0) {
                          if (Object(n) !== n) { return }
                          c = !1
                        } else {
                          for (; !(c = (r = i.call(n)).done) && (s.push(r.value),
                          s.length !== t); c = !0)
                            ;
                        }
                      } catch (e) {
                        l = !0,
                        o = e
                      } finally {
                        try {
                          if (!c && n.return != null && (a = n.return(),
                          Object(a) !== a)) { return }
                        } finally {
                          if (l) { throw o }
                        }
                      }
                      return s
                    }
                  }(t, n)) || Hj(t, n) || (function () {
                    throw new TypeError('Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
                  }())); const o = r[0]; const i = r[1]
                  return ''.concat(o, ':').concat(i)
                }
                ).join(','))
                : ''
              n += ''.concat(o.name, '@').concat(o.unit, ':').concat(o.metric, '|').concat(o.metricType).concat(a, '|T').concat(o.timestamp, '\n')
            }
          } catch (e) {
            r.e(e)
          } finally {
            r.f()
          }
          return n
        }(e))
        return [{
          type: 'statsd',
          length: t.length
        }, t]
      }(e))
      return bj(o, [i])
    }
    function Gj (e) {
      return Gj = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      Gj(e)
    }
    function Uj (e, t) {
      let n = typeof Symbol !== 'undefined' && e[Symbol.iterator] || e['@@iterator']
      if (!n) {
        if (Array.isArray(e) || (n = Vj(e)) || t && e && typeof e.length === 'number') {
          n && (e = n)
          let r = 0
          const o = function () {}
          return {
            s: o,
            n: function () {
              return r >= e.length
                ? {
                    done: !0
                  }
                : {
                    done: !1,
                    value: e[r++]
                  }
            },
            e: function (e) {
              throw e
            },
            f: o
          }
        }
        throw new TypeError('Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
      }
      let i; let a = !0; let s = !1
      return {
        s: function () {
          n = n.call(e)
        },
        n: function () {
          const e = n.next()
          return a = e.done,
          e
        },
        e: function (e) {
          s = !0,
          i = e
        },
        f: function () {
          try {
            a || n.return == null || n.return()
          } finally {
            if (s) { throw i }
          }
        }
      }
    }
    function Vj (e, t) {
      if (e) {
        if (typeof e === 'string') { return Qj(e, t) }
        let n = Object.prototype.toString.call(e).slice(8, -1)
        return n === 'Object' && e.constructor && (n = e.constructor.name),
        n === 'Map' || n === 'Set' ? Array.from(e) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Qj(e, t) : void 0
      }
    }
    function Qj (e, t) {
      (t == null || t > e.length) && (t = e.length)
      for (var n = 0, r = new Array(t); n < t; n++) { r[n] = e[n] }
      return r
    }
    function Yj (e, t) {
      const n = Object.keys(e)
      if (Object.getOwnPropertySymbols) {
        let r = Object.getOwnPropertySymbols(e)
        t && (r = r.filter(function (t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable
        }
        )),
        n.push.apply(n, r)
      }
      return n
    }
    function Kj (e) {
      for (let t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {}
        t % 2
          ? Yj(Object(n), !0).forEach(function (t) {
            let r, o, i
            r = e,
            o = t,
            i = n[t],
            (o = Xj(o)) in r
              ? Object.defineProperty(r, o, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
              })
              : r[o] = i
          }
          )
          : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
            : Yj(Object(n)).forEach(function (t) {
              Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
            }
            )
      }
      return e
    }
    function Jj (e, t) {
      for (let n = 0; n < t.length; n++) {
        const r = t[n]
        r.enumerable = r.enumerable || !1,
        r.configurable = !0,
        'value' in r && (r.writable = !0),
        Object.defineProperty(e, Xj(r.key), r)
      }
    }
    function Xj (e) {
      const t = (function (e, t) {
        if (Gj(e) != 'object' || !e) { return e }
        const n = e[Symbol.toPrimitive]
        if (void 0 !== n) {
          const r = n.call(e, 'string')
          if (Gj(r) != 'object') { return r }
          throw new TypeError('@@toPrimitive must return a primitive value.')
        }
        return String(e)
      }(e))
      return Gj(t) == 'symbol' ? t : t + ''
    }
    const Zj = "Not capturing exception because it's already been captured."
    const eB = (function () {
      return e = function e (t) {
        if ((function (e, t) {
          if (!(e instanceof t)) { throw new TypeError('Cannot call a class as a function') }
        }(this, e)),
        this._options = t,
        this._integrations = {},
        this._integrationsInitialized = !1,
        this._numProcessing = 0,
        this._outcomes = {},
        this._hooks = {},
        this._eventProcessors = [],
        t.dsn ? this._dsn = uj(t.dsn) : HC && J_.warn('No DSN provided, client will not send events.'),
        this._dsn) {
          const n = Mj(this._dsn, t)
          this._transport = t.transport(Kj(Kj({
            recordDroppedEvent: this.recordDroppedEvent.bind(this)
          }, t.transportOptions), {}, {
            url: n
          }))
        }
      }
      ,
      t = [{
        key: 'captureException',
        value: function (e, t, n) {
          const r = this
          if (!zC(e)) {
            let o = t && t.event_id
            return this._process(this.eventFromException(e, t).then(function (e) {
              return r._captureEvent(e, t, n)
            }
            ).then(function (e) {
              o = e
            }
            )),
            o
          }
          HC && J_.log(Zj)
        }
      }, {
        key: 'captureMessage',
        value: function (e, t, n, r) {
          const o = this
          let i = n && n.event_id
          const a = iC(e) ? e : String(e)
          const s = aC(e) ? this.eventFromMessage(a, t, n) : this.eventFromException(e, n)
          return this._process(s.then(function (e) {
            return o._captureEvent(e, n, r)
          }
          ).then(function (e) {
            i = e
          }
          )),
          i
        }
      }, {
        key: 'captureEvent',
        value: function (e, t, n) {
          if (!(t && t.originalException && zC(t.originalException))) {
            let r = t && t.event_id
            const o = (e.sdkProcessingMetadata || {}).capturedSpanScope
            return this._process(this._captureEvent(e, t, o || n).then(function (e) {
              r = e
            }
            )),
            r
          }
          HC && J_.log(Zj)
        }
      }, {
        key: 'captureSession',
        value: function (e) {
          typeof e.release !== 'string'
            ? HC && J_.warn('Discarded session because of missing or non-string release')
            : (this.sendSession(e),
              iS(e, {
                init: !1
              }))
        }
      }, {
        key: 'getDsn',
        value: function () {
          return this._dsn
        }
      }, {
        key: 'getOptions',
        value: function () {
          return this._options
        }
      }, {
        key: 'getSdkMetadata',
        value: function () {
          return this._options._metadata
        }
      }, {
        key: 'getTransport',
        value: function () {
          return this._transport
        }
      }, {
        key: 'flush',
        value: function (e) {
          const t = this._transport
          return t
            ? (this.metricsAggregator && this.metricsAggregator.flush(),
              this._isClientDoneProcessing(e).then(function (n) {
                return t.flush(e).then(function (e) {
                  return n && e
                }
                )
              }
              ))
            : UC(!0)
        }
      }, {
        key: 'close',
        value: function (e) {
          const t = this
          return this.flush(e).then(function (e) {
            return t.getOptions().enabled = !1,
            t.metricsAggregator && t.metricsAggregator.close(),
            e
          }
          )
        }
      }, {
        key: 'getEventProcessors',
        value: function () {
          return this._eventProcessors
        }
      }, {
        key: 'addEventProcessor',
        value: function (e) {
          this._eventProcessors.push(e)
        }
      }, {
        key: 'setupIntegrations',
        value: function (e) {
          (e && !this._integrationsInitialized || this._isEnabled() && !this._integrationsInitialized) && this._setupIntegrations()
        }
      }, {
        key: 'init',
        value: function () {
          this._isEnabled() && this._setupIntegrations()
        }
      }, {
        key: 'getIntegrationById',
        value: function (e) {
          return this.getIntegrationByName(e)
        }
      }, {
        key: 'getIntegrationByName',
        value: function (e) {
          return this._integrations[e]
        }
      }, {
        key: 'getIntegration',
        value: function (e) {
          try {
            return this._integrations[e.id] || null
          } catch (t) {
            return HC && J_.warn('Cannot retrieve integration '.concat(e.id, ' from the current Client')),
            null
          }
        }
      }, {
        key: 'addIntegration',
        value: function (e) {
          const t = this._integrations[e.name]
          Rk(this, e, this._integrations),
          t || Tk(this, [e])
        }
      }, {
        key: 'sendEvent',
        value: function (e) {
          const t = this
          const n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
          this.emit('beforeSendEvent', e, n)
          let r; let o; let i; let a; let s; let c; let l; let p = (function (e, t, n, r) {
            const o = Sj(n)
            const i = e.type && e.type !== 'replay_event' ? e.type : 'event'
            !(function (e, t) {
              t && (e.sdk = e.sdk || {},
              e.sdk.name = e.sdk.name || t.name,
              e.sdk.version = e.sdk.version || t.version,
              e.sdk.integrations = [].concat(Fj(e.sdk.integrations || []), Fj(t.integrations || [])),
              e.sdk.packages = [].concat(Fj(e.sdk.packages || []), Fj(t.packages || [])))
            }(e, n && n.sdk))
            const a = (function (e, t, n, r) {
              const o = e.sdkProcessingMetadata && e.sdkProcessingMetadata.dynamicSamplingContext
              return hj(hj(hj({
                event_id: e.event_id,
                sent_at: (new Date()).toISOString()
              }, t && {
                sdk: t
              }), !!n && r && {
                dsn: lj(r)
              }), o && {
                trace: BC(hj({}, o))
              })
            }(e, o, r, t))
            return delete e.sdkProcessingMetadata,
            bj(a, [[{
              type: i
            }, e]])
          }(e, this._dsn, this._options._metadata, this._options.tunnel)); const u = Uj(n.attachments || [])
          try {
            for (u.s(); !(r = u.n()).done;) {
              const d = r.value
              o = p,
              i = wj(d, this._options.transportOptions && this._options.transportOptions.textEncoder),
              void 0,
              void 0,
              void 0,
              s = (a = vj(o, 2))[0],
              c = a[1],
              p = [s, [].concat((l = c,
              (function (e) {
                if (Array.isArray(e)) { return yj(e) }
              }(l)) || (function (e) {
                if (typeof Symbol !== 'undefined' && e[Symbol.iterator] != null || e['@@iterator'] != null) { return Array.from(e) }
              }(l)) || gj(l) || (function () {
                throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
              }())), [i])]
            }
          } catch (e) {
            u.e(e)
          } finally {
            u.f()
          }
          const f = this._sendEnvelope(p)
          f && f.then(function (n) {
            return t.emit('afterSendEvent', e, n)
          }
          , null)
        }
      }, {
        key: 'sendSession',
        value: function (e) {
          const t = (function (e, t, n, r) {
            const o = Sj(n)
            return bj(zj(zj({
              sent_at: (new Date()).toISOString()
            }, o && {
              sdk: o
            }), !!r && t && {
              dsn: lj(t)
            }), ['aggregates' in e
              ? [{
                  type: 'sessions'
                }, e]
              : [{
                  type: 'session'
                }, e.toJSON()]])
          }(e, this._dsn, this._options._metadata, this._options.tunnel))
          this._sendEnvelope(t)
        }
      }, {
        key: 'recordDroppedEvent',
        value: function (e, t, n) {
          if (this._options.sendClientReports) {
            const r = ''.concat(e, ':').concat(t)
            HC && J_.log('Adding outcome: "'.concat(r, '"')),
            this._outcomes[r] = this._outcomes[r] + 1 || 1
          }
        }
      }, {
        key: 'captureAggregateMetrics',
        value: function (e) {
          HC && J_.log('Flushing aggregated metrics, number of metrics: '.concat(e.length))
          const t = Wj(e, this._dsn, this._options._metadata, this._options.tunnel)
          this._sendEnvelope(t)
        }
      }, {
        key: 'on',
        value: function (e, t) {
          this._hooks[e] || (this._hooks[e] = []),
          this._hooks[e].push(t)
        }
      }, {
        key: 'emit',
        value: function (e) {
          for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) { n[r - 1] = arguments[r] }
          this._hooks[e] && this._hooks[e].forEach(function (e) {
            return e.apply(void 0, n)
          }
          )
        }
      }, {
        key: '_setupIntegrations',
        value: function () {
          const e = this._options.integrations
          this._integrations = (function (e, t) {
            const n = {}
            return t.forEach(function (t) {
              t && Rk(e, t, n)
            }
            ),
            n
          }(this, e)),
          Tk(this, e),
          this._integrationsInitialized = !0
        }
      }, {
        key: '_updateSessionFromEvent',
        value: function (e, t) {
          let n = !1
          let r = !1
          const o = t.exception && t.exception.values
          if (o) {
            r = !0
            let i; const a = Uj(o)
            try {
              for (a.s(); !(i = a.n()).done;) {
                const s = i.value.mechanism
                if (s && !1 === s.handled) {
                  n = !0
                  break
                }
              }
            } catch (e) {
              a.e(e)
            } finally {
              a.f()
            }
          }
          const c = e.status === 'ok';
          (c && e.errors === 0 || c && n) && (iS(e, Kj(Kj({}, n && {
            status: 'crashed'
          }), {}, {
            errors: e.errors || Number(r || n)
          })),
          this.captureSession(e))
        }
      }, {
        key: '_isClientDoneProcessing',
        value: function (e) {
          const t = this
          return new QC(function (n) {
            let r = 0
            var o = setInterval(function () {
              t._numProcessing == 0
                ? (clearInterval(o),
                  n(!0))
                : (r += 1,
                  e && r >= e && (clearInterval(o),
                  n(!1)))
            }
            , 1)
          }
          )
        }
      }, {
        key: '_isEnabled',
        value: function () {
          return !1 !== this.getOptions().enabled && void 0 !== this._transport
        }
      }, {
        key: '_prepareEvent',
        value: function (e, t, n) {
          const r = this
          const o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Ck()
          const i = this.getOptions()
          const a = Object.keys(this._integrations)
          return !t.integrations && a.length > 0 && (t.integrations = a),
          this.emit('preprocessEvent', e, t),
          (function (e, t, n, r, o, i) {
            const a = e.normalizeDepth
            const s = void 0 === a ? 3 : a
            const c = e.normalizeMaxBreadth
            const l = void 0 === c ? 1e3 : c
            const p = PS(PS({}, t), {}, {
              event_id: t.event_id || n.event_id || RC(),
              timestamp: t.timestamp || tS()
            })
            const u = n.integrations || e.integrations.map(function (e) {
              return e.name
            }
            )
            !(function (e, t) {
              const n = t.environment
              const r = t.release
              const o = t.dist
              const i = t.maxValueLength
              const a = void 0 === i ? 250 : i
              'environment' in e || (e.environment = 'environment' in t ? n : rS),
              void 0 === e.release && void 0 !== r && (e.release = r),
              void 0 === e.dist && void 0 !== o && (e.dist = o),
              e.message && (e.message = vC(e.message, a))
              const s = e.exception && e.exception.values && e.exception.values[0]
              s && s.value && (s.value = vC(s.value, a))
              const c = e.request
              c && c.url && (c.url = vC(c.url, a))
            }(p, e)),
            (function (e, t) {
              t.length > 0 && (e.sdk = e.sdk || {},
              e.sdk.integrations = [].concat(jS(e.sdk.integrations || []), jS(t)))
            }(p, u)),
            void 0 === t.type && (function (e, t) {
              let n; const r = q_._sentryDebugIds
              if (r) {
                const o = OS.get(t)
                o
                  ? n = o
                  : (n = new Map(),
                    OS.set(t, n))
                const i = Object.keys(r).reduce(function (e, o) {
                  let i; const a = n.get(o)
                  a
                    ? i = a
                    : (i = t(o),
                      n.set(o, i))
                  for (let s = i.length - 1; s >= 0; s--) {
                    const c = i[s]
                    if (c.filename) {
                      e[c.filename] = r[o]
                      break
                    }
                  }
                  return e
                }
                , {})
                try {
                  e.exception.values.forEach(function (e) {
                    e.stacktrace.frames.forEach(function (e) {
                      e.filename && (e.debug_id = i[e.filename])
                    }
                    )
                  }
                  )
                } catch (e) {}
              }
            }(p, e.stackParser))
            const d = (function (e, t) {
              if (!t) { return e }
              const n = e ? e.clone() : new dk()
              return n.update(t),
              n
            }(r, n.captureContext))
            n.mechanism && LC(p, n.mechanism)
            const f = o && o.getEventProcessors ? o.getEventProcessors() : []
            const h = (uk || (uk = new dk()),
            uk).getScopeData()
            i && tk(h, i.getScopeData()),
            d && tk(h, d.getScopeData())
            const m = [].concat(jS(n.attachments || []), jS(h.attachments))
            return m.length && (n.attachments = m),
            ek(p, h),
            ZC([].concat(jS(f), jS(JC()), jS(h.eventProcessors)), p, n).then(function (e) {
              return e && (function (e) {
                const t = {}
                try {
                  e.exception.values.forEach(function (e) {
                    e.stacktrace.frames.forEach(function (e) {
                      e.debug_id && (e.abs_path ? t[e.abs_path] = e.debug_id : e.filename && (t[e.filename] = e.debug_id),
                      delete e.debug_id)
                    }
                    )
                  }
                  )
                } catch (e) {}
                if (Object.keys(t).length !== 0) {
                  e.debug_meta = e.debug_meta || {},
                  e.debug_meta.images = e.debug_meta.images || []
                  const n = e.debug_meta.images
                  Object.keys(t).forEach(function (e) {
                    n.push({
                      type: 'sourcemap',
                      code_file: e,
                      debug_id: t[e]
                    })
                  }
                  )
                }
              }(e)),
              typeof s === 'number' && s > 0
                ? (function (e, t, n) {
                    if (!e) { return null }
                    const r = PS(PS(PS(PS(PS({}, e), e.breadcrumbs && {
                      breadcrumbs: e.breadcrumbs.map(function (e) {
                        return PS(PS({}, e), e.data && {
                          data: ES(e.data, t, n)
                        })
                      }
                      )
                    }), e.user && {
                      user: ES(e.user, t, n)
                    }), e.contexts && {
                      contexts: ES(e.contexts, t, n)
                    }), e.extra && {
                      extra: ES(e.extra, t, n)
                    })
                    return e.contexts && e.contexts.trace && r.contexts && (r.contexts.trace = e.contexts.trace,
                    e.contexts.trace.data && (r.contexts.trace.data = ES(e.contexts.trace.data, t, n))),
                    e.spans && (r.spans = e.spans.map(function (e) {
                      const r = SS(e).data
                      return r && (e.data = ES(r, t, n)),
                      e
                    }
                    )),
                    r
                  }(e, s, l))
                : e
            }
            )
          }(i, e, t, n, this, o)).then(function (e) {
            if (e === null) { return e }
            const t = Kj(Kj({}, o.getPropagationContext()), n ? n.getPropagationContext() : void 0)
            if ((!e.contexts || !e.contexts.trace) && t) {
              const i = t.traceId
              const a = t.spanId
              const s = t.parentSpanId
              const c = t.dsc
              e.contexts = Kj({
                trace: {
                  trace_id: i,
                  span_id: a,
                  parent_span_id: s
                }
              }, e.contexts)
              const l = c || VS(i, r, n)
              e.sdkProcessingMetadata = Kj({
                dynamicSamplingContext: l
              }, e.sdkProcessingMetadata)
            }
            return e
          }
          )
        }
      }, {
        key: '_captureEvent',
        value: function (e) {
          const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
          const n = arguments.length > 2 ? arguments[2] : void 0
          return this._processEvent(e, t, n).then(function (e) {
            return e.event_id
          }
          , function (e) {
            if (HC) {
              const t = e
              t.logLevel === 'log' ? J_.log(t.message) : J_.warn(t)
            }
          }
          )
        }
      }, {
        key: '_processEvent',
        value: function (e, t, n) {
          const r = this
          const o = this.getOptions()
          const i = o.sampleRate
          const a = nB(e)
          const s = tB(e)
          const c = e.type || 'error'
          const l = 'before send for type `'.concat(c, '`')
          if (s && typeof i === 'number' && Math.random() > i) {
            return this.recordDroppedEvent('sample_rate', 'error', e),
            VC(new Oj("Discarding event because it's not included in the random sample (sampling rate = ".concat(i, ')'), 'log'))
          }
          const p = c === 'replay_event' ? 'replay' : c
          const u = (e.sdkProcessingMetadata || {}).capturedSpanIsolationScope
          return this._prepareEvent(e, t, n, u).then(function (n) {
            if (n === null) {
              throw r.recordDroppedEvent('event_processor', p, e),
              new Oj('An event processor returned `null`, will not send event.', 'log')
            }
            if (t.data && !0 === t.data.__sentry__) { return n }
            const i = (function (e, t, n) {
              const r = e.beforeSend
              const o = e.beforeSendTransaction
              return tB(t) && r ? r(t, n) : nB(t) && o ? o(t, n) : t
            }(o, n, t))
            return (function (e, t) {
              const n = ''.concat(t, ' must return `null` or a valid event.')
              if (lC(e)) {
                return e.then(function (e) {
                  if (!sC(e) && e !== null) { throw new Oj(n) }
                  return e
                }
                , function (e) {
                  throw new Oj(''.concat(t, ' rejected with ').concat(e))
                }
                )
              }
              if (!sC(e) && e !== null) { throw new Oj(n) }
              return e
            }(i, l))
          }
          ).then(function (o) {
            if (o === null) {
              throw r.recordDroppedEvent('before_send', p, e),
              new Oj(''.concat(l, ' returned `null`, will not send event.'), 'log')
            }
            const i = n && n.getSession()
            !a && i && r._updateSessionFromEvent(i, o)
            const s = o.transaction_info
            return a && s && o.transaction !== e.transaction && (o.transaction_info = Kj(Kj({}, s), {}, {
              source: 'custom'
            })),
            r.sendEvent(o, t),
            o
          }
          ).then(null, function (e) {
            if (e instanceof Oj) { throw e }
            throw r.captureException(e, {
              data: {
                __sentry__: !0
              },
              originalException: e
            }),
            new Oj('Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\nReason: '.concat(e))
          }
          )
        }
      }, {
        key: '_process',
        value: function (e) {
          const t = this
          this._numProcessing++,
          e.then(function (e) {
            return t._numProcessing--,
            e
          }
          , function (e) {
            return t._numProcessing--,
            e
          }
          )
        }
      }, {
        key: '_sendEnvelope',
        value: function (e) {
          if (this.emit('beforeEnvelope', e),
          this._isEnabled() && this._transport) {
            return this._transport.send(e).then(null, function (e) {
              HC && J_.error('Error while sending event:', e)
            }
            )
          }
          HC && J_.error('Transport disabled')
        }
      }, {
        key: '_clearOutcomes',
        value: function () {
          const e = this._outcomes
          return this._outcomes = {},
          Object.keys(e).map(function (t) {
            let n; let r; const o = (n = t.split(':'),
            r = 2,
            (function (e) {
              if (Array.isArray(e)) { return e }
            }(n)) || (function (e, t) {
              let n = e == null ? null : typeof Symbol !== 'undefined' && e[Symbol.iterator] || e['@@iterator']
              if (n != null) {
                let r; let o; let i; let a; const s = []; let c = !0; let l = !1
                try {
                  if (i = (n = n.call(e)).next,
                  t === 0) {
                    if (Object(n) !== n) { return }
                    c = !1
                  } else {
                    for (; !(c = (r = i.call(n)).done) && (s.push(r.value),
                    s.length !== t); c = !0)
                      ;
                  }
                } catch (e) {
                  l = !0,
                  o = e
                } finally {
                  try {
                    if (!c && n.return != null && (a = n.return(),
                    Object(a) !== a)) { return }
                  } finally {
                    if (l) { throw o }
                  }
                }
                return s
              }
            }(n, r)) || Vj(n, r) || (function () {
              throw new TypeError('Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
            }()))
            return {
              reason: o[0],
              category: o[1],
              quantity: e[t]
            }
          }
          )
        }
      }],
      t && Jj(e.prototype, t),
      Object.defineProperty(e, 'prototype', {
        writable: !1
      }),
      e
      let e, t
    }())
    function tB (e) {
      return void 0 === e.type
    }
    function nB (e) {
      return e.type === 'transaction'
    }
    const rB = typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__
    function oB (e) {
      return oB = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      oB(e)
    }
    function iB (e, t) {
      const n = Object.keys(e)
      if (Object.getOwnPropertySymbols) {
        let r = Object.getOwnPropertySymbols(e)
        t && (r = r.filter(function (t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable
        }
        )),
        n.push.apply(n, r)
      }
      return n
    }
    function aB (e) {
      for (let t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {}
        t % 2
          ? iB(Object(n), !0).forEach(function (t) {
            let r, o, i
            r = e,
            o = t,
            i = n[t],
            o = (function (e) {
              const t = (function (e, t) {
                if (oB(e) != 'object' || !e) { return e }
                const n = e[Symbol.toPrimitive]
                if (void 0 !== n) {
                  const r = n.call(e, 'string')
                  if (oB(r) != 'object') { return r }
                  throw new TypeError('@@toPrimitive must return a primitive value.')
                }
                return String(e)
              }(e))
              return oB(t) == 'symbol' ? t : t + ''
            }(o)),
            o in r
              ? Object.defineProperty(r, o, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
              })
              : r[o] = i
          }
          )
          : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
            : iB(Object(n)).forEach(function (t) {
              Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
            }
            )
      }
      return e
    }
    function sB (e, t) {
      const n = lB(e, t)
      const r = {
        type: t && t.name,
        value: uB(t)
      }
      return n.length && (r.stacktrace = {
        frames: n
      }),
      void 0 === r.type && r.value === '' && (r.value = 'Unrecoverable error caught'),
      r
    }
    function cB (e, t) {
      return {
        exception: {
          values: [sB(e, t)]
        }
      }
    }
    function lB (e, t) {
      const n = t.stacktrace || t.stack || ''
      const r = (function (e) {
        if (e) {
          if (typeof e.framesToPop === 'number') { return e.framesToPop }
          if (pB.test(e.message)) { return 1 }
        }
        return 0
      }(t))
      try {
        return e(n, r)
      } catch (e) {}
      return []
    }
    var pB = /Minified React error #\d+;/i
    function uB (e) {
      const t = e && e.message
      return t ? t.error && typeof t.error.message === 'string' ? t.error.message : t : 'No error message'
    }
    function dB (e, t, n, r, o) {
      let i
      if (nC(t) && t.error) { return cB(e, t.error) }
      if (rC(t) || tC(t, 'DOMException')) {
        const a = t
        if ('stack' in t) { i = cB(e, t) } else {
          const s = a.name || (rC(a) ? 'DOMError' : 'DOMException')
          const c = a.message ? ''.concat(s, ': ').concat(a.message) : s
          IC(i = fB(e, c, n, r), c)
        }
        return 'code' in a && (i.tags = aB(aB({}, i.tags), {}, {
          'DOMException.code': ''.concat(a.code)
        })),
        i
      }
      return eC(t)
        ? cB(e, t)
        : sC(t) || cC(t)
          ? (i = (function (e, t, n, r) {
              const o = FS()
              const i = o && o.getOptions().normalizeDepth
              const a = {
                exception: {
                  values: [{
                    type: cC(t) ? t.constructor.name : r ? 'UnhandledRejection' : 'Error',
                    value: hB(t, {
                      isUnhandledRejection: r
                    })
                  }]
                },
                extra: {
                  __serialized__: xS(t, i)
                }
              }
              if (n) {
                const s = lB(e, n)
                s.length && (a.exception.values[0].stacktrace = {
                  frames: s
                })
              }
              return a
            }(e, t, n, o)),
            LC(i, {
              synthetic: !0
            }),
            i)
          : (IC(i = fB(e, t, n, r), ''.concat(t), void 0),
            LC(i, {
              synthetic: !0
            }),
            i)
    }
    function fB (e, t, n, r) {
      const o = {}
      if (r && n) {
        const i = lB(e, n)
        i.length && (o.exception = {
          values: [{
            value: t,
            stacktrace: {
              frames: i
            }
          }]
        })
      }
      if (iC(t)) {
        const a = t.__sentry_template_string__
        const s = t.__sentry_template_values__
        return o.logentry = {
          message: a,
          params: s
        },
        o
      }
      return o.message = t,
      o
    }
    function hB (e, t) {
      const n = t.isUnhandledRejection
      const r = (function (e) {
        const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 40
        const n = Object.keys(SC(e))
        if (n.sort(),
        !n.length) { return '[object has no keys]' }
        if (n[0].length >= t) { return vC(n[0], t) }
        for (let r = n.length; r > 0; r--) {
          const o = n.slice(0, r).join(', ')
          if (!(o.length > t)) { return r === n.length ? o : vC(o, t) }
        }
        return ''
      }(e))
      const o = n ? 'promise rejection' : 'exception'
      if (nC(e)) { return 'Event `ErrorEvent` captured as '.concat(o, ' with message `').concat(e.message, '`') }
      if (cC(e)) {
        const i = (function (e) {
          try {
            const t = Object.getPrototypeOf(e)
            return t ? t.constructor.name : void 0
          } catch (e) {}
        }(e))
        return 'Event `'.concat(i, '` (type=').concat(e.type, ') captured as ').concat(o)
      }
      return 'Object captured as '.concat(o, ' with keys: ').concat(r)
    }
    function mB (e) {
      return mB = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      mB(e)
    }
    function vB (e, t) {
      const n = Object.keys(e)
      if (Object.getOwnPropertySymbols) {
        let r = Object.getOwnPropertySymbols(e)
        t && (r = r.filter(function (t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable
        }
        )),
        n.push.apply(n, r)
      }
      return n
    }
    function gB (e) {
      for (let t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {}
        t % 2
          ? vB(Object(n), !0).forEach(function (t) {
            let r, o, i
            r = e,
            o = t,
            i = n[t],
            o = (function (e) {
              const t = (function (e, t) {
                if (mB(e) != 'object' || !e) { return e }
                const n = e[Symbol.toPrimitive]
                if (void 0 !== n) {
                  const r = n.call(e, 'string')
                  if (mB(r) != 'object') { return r }
                  throw new TypeError('@@toPrimitive must return a primitive value.')
                }
                return String(e)
              }(e))
              return mB(t) == 'symbol' ? t : t + ''
            }(o)),
            o in r
              ? Object.defineProperty(r, o, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
              })
              : r[o] = i
          }
          )
          : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
            : vB(Object(n)).forEach(function (t) {
              Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
            }
            )
      }
      return e
    }
    const yB = q_
    let bB = 0
    function AB () {
      return bB > 0
    }
    function EB (e) {
      const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
      const n = arguments.length > 2 ? arguments[2] : void 0
      if (typeof e !== 'function') { return e }
      try {
        const r = e.__sentry_wrapped__
        if (r) { return r }
        if (CC(e)) { return e }
      } catch (t) {
        return e
      }
      const o = function () {
        const r = Array.prototype.slice.call(arguments)
        try {
          n && typeof n === 'function' && n.apply(this, arguments)
          const o = r.map(function (e) {
            return EB(e, t)
          }
          )
          return e.apply(this, o)
        } catch (e) {
          throw bB++,
          setTimeout(function () {
            bB--
          }
          ),
          (function () {
            for (var e = _k(), t = arguments.length, n = new Array(t), r = 0; r < t; r++) { n[r] = arguments[r] }
            if (n.length === 2) {
              const o = n[0]
              const i = n[1]
              return o
                ? e.withScope(function () {
                  return e.getStackTop().scope = o,
                  i(o)
                }
                )
                : e.withScope(i)
            }
            e.withScope(n[0])
          }(function (n) {
            let o
            n.addEventProcessor(function (e) {
              return t.mechanism && (IC(e, void 0, void 0),
              LC(e, t.mechanism)),
              e.extra = gB(gB({}, e.extra), {}, {
                arguments: r
              }),
              e
            }
            ),
            o = e,
            _k().captureException(o, (function (e) {
              if (e) {
                return (function (e) {
                  return e instanceof dk || typeof e === 'function'
                }(e)) || (function (e) {
                  return Object.keys(e).some(function (e) {
                    return TS.includes(e)
                  }
                  )
                }(e))
                  ? {
                      captureContext: e
                    }
                  : e
              }
            }(undefined)))
          }
          )),
          e
        }
      }
      try {
        for (const i in e) { Object.prototype.hasOwnProperty.call(e, i) && (o[i] = e[i]) }
      } catch (e) {}
      _C(o, e),
      wC(e, '__sentry_wrapped__', o)
      try {
        Object.getOwnPropertyDescriptor(o, 'name').configurable && Object.defineProperty(o, 'name', {
          get: function () {
            return e.name
          }
        })
      } catch (e) {}
      return o
    }
    function xB (e) {
      return xB = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      xB(e)
    }
    function wB (e, t) {
      const n = Object.keys(e)
      if (Object.getOwnPropertySymbols) {
        let r = Object.getOwnPropertySymbols(e)
        t && (r = r.filter(function (t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable
        }
        )),
        n.push.apply(n, r)
      }
      return n
    }
    function _B (e) {
      for (let t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {}
        t % 2
          ? wB(Object(n), !0).forEach(function (t) {
            let r, o, i
            r = e,
            o = t,
            i = n[t],
            o = (function (e) {
              const t = (function (e, t) {
                if (xB(e) != 'object' || !e) { return e }
                const n = e[Symbol.toPrimitive]
                if (void 0 !== n) {
                  const r = n.call(e, 'string')
                  if (xB(r) != 'object') { return r }
                  throw new TypeError('@@toPrimitive must return a primitive value.')
                }
                return String(e)
              }(e))
              return xB(t) == 'symbol' ? t : t + ''
            }(o)),
            o in r
              ? Object.defineProperty(r, o, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
              })
              : r[o] = i
          }
          )
          : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
            : wB(Object(n)).forEach(function (t) {
              Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
            }
            )
      }
      return e
    }
    function CB (e) {
      return CB = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      CB(e)
    }
    function SB (e, t) {
      for (let n = 0; n < t.length; n++) {
        const r = t[n]
        r.enumerable = r.enumerable || !1,
        r.configurable = !0,
        'value' in r && (r.writable = !0),
        Object.defineProperty(e, kB(r.key), r)
      }
    }
    function kB (e) {
      const t = (function (e, t) {
        if (CB(e) != 'object' || !e) { return e }
        const n = e[Symbol.toPrimitive]
        if (void 0 !== n) {
          const r = n.call(e, 'string')
          if (CB(r) != 'object') { return r }
          throw new TypeError('@@toPrimitive must return a primitive value.')
        }
        return String(e)
      }(e))
      return CB(t) == 'symbol' ? t : t + ''
    }
    function jB (e, t, n) {
      return t = PB(t),
      (function (e, t) {
        if (t && (CB(t) === 'object' || typeof t === 'function')) { return t }
        if (void 0 !== t) { throw new TypeError('Derived constructors may only return object or undefined') }
        return (function (e) {
          if (void 0 === e) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called") }
          return e
        }(e))
      }(e, BB() ? Reflect.construct(t, n || [], PB(e).constructor) : t.apply(e, n)))
    }
    function BB () {
      try {
        var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}
        ))
      } catch (e) {}
      return (BB = function () {
        return !!e
      }
      )()
    }
    function DB () {
      return DB = typeof Reflect !== 'undefined' && Reflect.get
        ? Reflect.get.bind()
        : function (e, t, n) {
          const r = (function (e, t) {
            for (; !Object.prototype.hasOwnProperty.call(e, t) && (e = PB(e)) !== null;)
              ;
            return e
          }(e, t))
          if (r) {
            const o = Object.getOwnPropertyDescriptor(r, t)
            return o.get ? o.get.call(arguments.length < 3 ? e : n) : o.value
          }
        }
      ,
      DB.apply(this, arguments)
    }
    function PB (e) {
      return PB = Object.setPrototypeOf
        ? Object.getPrototypeOf.bind()
        : function (e) {
          return e.__proto__ || Object.getPrototypeOf(e)
        }
      ,
      PB(e)
    }
    function OB (e, t) {
      return OB = Object.setPrototypeOf
        ? Object.setPrototypeOf.bind()
        : function (e, t) {
          return e.__proto__ = t,
          e
        }
      ,
      OB(e, t)
    }
    const TB = (function (e) {
      function t (e) {
        let n
        return (function (e, t) {
          if (!(e instanceof t)) { throw new TypeError('Cannot call a class as a function') }
        }(this, t)),
        (function (e, t) {
          const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [t]
          const r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 'npm'
          const o = e._metadata || {}
          o.sdk || (o.sdk = {
            name: 'sentry.javascript.'.concat(t),
            packages: n.map(function (e) {
              return {
                name: ''.concat(r, ':@sentry/').concat(e),
                version: hk
              }
            }
            ),
            version: hk
          }),
          e._metadata = o
        }(e, 'browser', ['browser'], yB.SENTRY_SDK_SOURCE || 'npm')),
        n = jB(this, t, [e]),
        e.sendClientReports && yB.document && yB.document.addEventListener('visibilitychange', function () {
          yB.document.visibilityState === 'hidden' && n._flushOutcomes()
        }
        ),
        n
      }
      return (function (e, t) {
        if (typeof t !== 'function' && t !== null) { throw new TypeError('Super expression must either be null or a function') }
        e.prototype = Object.create(t && t.prototype, {
          constructor: {
            value: e,
            writable: !0,
            configurable: !0
          }
        }),
        Object.defineProperty(e, 'prototype', {
          writable: !1
        }),
        t && OB(e, t)
      }(t, e)),
      n = t,
      r = [{
        key: 'eventFromException',
        value: function (e, t) {
          return (function (e, t, n, r) {
            const o = dB(e, t, n && n.syntheticException || void 0, r)
            return LC(o),
            o.level = 'error',
            n && n.event_id && (o.event_id = n.event_id),
            UC(o)
          }(this._options.stackParser, e, t, this._options.attachStacktrace))
        }
      }, {
        key: 'eventFromMessage',
        value: function (e) {
          const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'info'
          const n = arguments.length > 2 ? arguments[2] : void 0
          return (function (e, t) {
            const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 'info'
            const r = arguments.length > 3 ? arguments[3] : void 0
            const o = arguments.length > 4 ? arguments[4] : void 0
            const i = fB(e, t, r && r.syntheticException || void 0, o)
            return i.level = n,
            r && r.event_id && (i.event_id = r.event_id),
            UC(i)
          }(this._options.stackParser, e, t, n, this._options.attachStacktrace))
        }
      }, {
        key: 'captureUserFeedback',
        value: function (e) {
          if (this._isEnabled()) {
            const t = (function (e, t) {
              const n = t.metadata
              const r = t.tunnel
              const o = t.dsn
              const i = _B(_B({
                event_id: e.event_id,
                sent_at: (new Date()).toISOString()
              }, n && n.sdk && {
                sdk: {
                  name: n.sdk.name,
                  version: n.sdk.version
                }
              }), !!r && !!o && {
                dsn: lj(o)
              })
              const a = (function (e) {
                return [{
                  type: 'user_report'
                }, e]
              }(e))
              return bj(i, [a])
            }(e, {
              metadata: this.getSdkMetadata(),
              dsn: this.getDsn(),
              tunnel: this.getOptions().tunnel
            }))
            this._sendEnvelope(t)
          } else { rB && J_.warn('SDK not enabled, will not capture user feedback.') }
        }
      }, {
        key: '_prepareEvent',
        value: function (e, n, r) {
          return e.platform = e.platform || 'javascript',
          DB(PB(t.prototype), '_prepareEvent', this).call(this, e, n, r)
        }
      }, {
        key: '_flushOutcomes',
        value: function () {
          const e = this._clearOutcomes()
          if (e.length !== 0) {
            if (this._dsn) {
              rB && J_.log('Sending outcomes:', e)
              let t; let n; const r = (t = e,
              bj((n = this._options.tunnel && lj(this._dsn))
                ? {
                    dsn: n
                  }
                : {}, [[{
                type: 'client_report'
              }, {
                timestamp: tS(),
                discarded_events: t
              }]]))
              this._sendEnvelope(r)
            } else { rB && J_.log('No dsn provided, will not send outcomes') }
          } else { rB && J_.log('No outcomes to send') }
        }
      }],
      r && SB(n.prototype, r),
      Object.defineProperty(n, 'prototype', {
        writable: !1
      }),
      n
      let n, r
    }(eB))
    function RB () {
      'console' in q_ && U_.forEach(function (e) {
        e in q_.console && xC(q_.console, e, function (t) {
          return V_[e] = t,
          function () {
            for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++) { n[r] = arguments[r] }
            nj('console', {
              args: n,
              level: e
            })
            const o = V_[e]
            o && o.apply(q_.console, n)
          }
        }
        )
      }
      )
    }
    let NB; let MB; let IB; const LB = q_; const zB = 1e3
    function FB () {
      if (LB.document) {
        const e = nj.bind(null, 'dom')
        const t = $B(e, !0)
        LB.document.addEventListener('click', t, !1),
        LB.document.addEventListener('keypress', t, !1),
        ['EventTarget', 'Node'].forEach(function (t) {
          const n = LB[t] && LB[t].prototype
          n && n.hasOwnProperty && n.hasOwnProperty('addEventListener') && (xC(n, 'addEventListener', function (t) {
            return function (n, r, o) {
              if (n === 'click' || n == 'keypress') {
                try {
                  const i = this.__sentry_instrumentation_handlers__ = this.__sentry_instrumentation_handlers__ || {}
                  const a = i[n] = i[n] || {
                    refCount: 0
                  }
                  if (!a.handler) {
                    const s = $B(e)
                    a.handler = s,
                    t.call(this, n, s, o)
                  }
                  a.refCount++
                } catch (e) {}
              }
              return t.call(this, n, r, o)
            }
          }
          ),
          xC(n, 'removeEventListener', function (e) {
            return function (t, n, r) {
              if (t === 'click' || t == 'keypress') {
                try {
                  const o = this.__sentry_instrumentation_handlers__ || {}
                  const i = o[t]
                  i && (i.refCount--,
                  i.refCount <= 0 && (e.call(this, t, i.handler, r),
                  i.handler = void 0,
                  delete o[t]),
                  Object.keys(o).length === 0 && delete this.__sentry_instrumentation_handlers__)
                } catch (e) {}
              }
              return e.call(this, t, n, r)
            }
          }
          ))
        }
        )
      }
    }
    function $B (e) {
      const t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
      return function (n) {
        if (n && !n._sentryCaptured) {
          const r = (function (e) {
            try {
              return e.target
            } catch (e) {
              return null
            }
          }(n))
          if (!(function (e, t) {
            return e === 'keypress' && (!t || !t.tagName || t.tagName !== 'INPUT' && t.tagName !== 'TEXTAREA' && !t.isContentEditable)
          }(n.type, r))) {
            wC(n, '_sentryCaptured', !0),
            r && !r._sentryId && wC(r, '_sentryId', RC())
            const o = n.type === 'keypress' ? 'input' : n.type;
            (function (e) {
              if (e.type !== MB) { return !1 }
              try {
                if (!e.target || e.target._sentryId !== IB) { return !1 }
              } catch (e) {}
              return !0
            }
            )(n) || (e({
              event: n,
              name: o,
              global: t
            }),
            MB = n.type,
            IB = r ? r._sentryId : void 0),
            clearTimeout(NB),
            NB = LB.setTimeout(function () {
              IB = void 0,
              MB = void 0
            }
            , zB)
          }
        }
      }
    }
    const HB = q_
    const qB = '__sentry_xhr_v3__'
    function WB () {
      if (HB.XMLHttpRequest) {
        const e = XMLHttpRequest.prototype
        xC(e, 'open', function (e) {
          return function () {
            for (var t = this, n = Date.now(), r = arguments.length, o = new Array(r), i = 0; i < r; i++) { o[i] = arguments[i] }
            const a = oC(o[0]) ? o[0].toUpperCase() : void 0
            const s = (function (e) {
              if (oC(e)) { return e }
              try {
                return e.toString()
              } catch (e) {}
            }(o[1]))
            if (!a || !s) { return e.apply(this, o) }
            this[qB] = {
              method: a,
              url: s,
              request_headers: {}
            },
            a === 'POST' && s.match(/sentry_key/) && (this.__sentry_own_request__ = !0)
            const c = function () {
              const e = t[qB]
              if (e && t.readyState === 4) {
                try {
                  e.status_code = t.status
                } catch (e) {}
                nj('xhr', {
                  args: [a, s],
                  endTimestamp: Date.now(),
                  startTimestamp: n,
                  xhr: t
                })
              }
            }
            return 'onreadystatechange' in this && typeof this.onreadystatechange === 'function'
              ? xC(this, 'onreadystatechange', function (e) {
                return function () {
                  c()
                  for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++) { n[r] = arguments[r] }
                  return e.apply(this, n)
                }
              }
              )
              : this.addEventListener('readystatechange', c),
            xC(this, 'setRequestHeader', function (e) {
              return function () {
                for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++) { n[r] = arguments[r] }
                const o = n[0]
                const i = n[1]
                const a = this[qB]
                return a && oC(o) && oC(i) && (a.request_headers[o.toLowerCase()] = i),
                e.apply(this, n)
              }
            }
            ),
            e.apply(this, o)
          }
        }
        ),
        xC(e, 'send', function (e) {
          return function () {
            for (var t = this[qB], n = arguments.length, r = new Array(n), o = 0; o < n; o++) { r[o] = arguments[o] }
            return t
              ? (void 0 !== r[0] && (t.body = r[0]),
                nj('xhr', {
                  args: [t.method, t.url],
                  startTimestamp: Date.now(),
                  xhr: this
                }),
                e.apply(this, r))
              : e.apply(this, r)
          }
        }
        )
      }
    }
    function GB (e, t) {
      (t == null || t > e.length) && (t = e.length)
      for (var n = 0, r = new Array(t); n < t; n++) { r[n] = e[n] }
      return r
    }
    function UB (e) {
      return UB = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      UB(e)
    }
    function VB (e, t) {
      const n = Object.keys(e)
      if (Object.getOwnPropertySymbols) {
        let r = Object.getOwnPropertySymbols(e)
        t && (r = r.filter(function (t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable
        }
        )),
        n.push.apply(n, r)
      }
      return n
    }
    function QB (e) {
      for (let t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {}
        t % 2
          ? VB(Object(n), !0).forEach(function (t) {
            let r, o, i
            r = e,
            o = t,
            i = n[t],
            o = (function (e) {
              const t = (function (e, t) {
                if (UB(e) != 'object' || !e) { return e }
                const n = e[Symbol.toPrimitive]
                if (void 0 !== n) {
                  const r = n.call(e, 'string')
                  if (UB(r) != 'object') { return r }
                  throw new TypeError('@@toPrimitive must return a primitive value.')
                }
                return String(e)
              }(e))
              return UB(t) == 'symbol' ? t : t + ''
            }(o)),
            o in r
              ? Object.defineProperty(r, o, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
              })
              : r[o] = i
          }
          )
          : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
            : VB(Object(n)).forEach(function (t) {
              Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
            }
            )
      }
      return e
    }
    function YB () {
      (function () {
        if (typeof EdgeRuntime === 'string') { return !0 }
        if (!Qk()) { return !1 }
        if (Yk(Vk.fetch)) { return !0 }
        let e = !1
        const t = Vk.document
        if (t && typeof t.createElement === 'function') {
          try {
            const n = t.createElement('iframe')
            n.hidden = !0,
            t.head.appendChild(n),
            n.contentWindow && n.contentWindow.fetch && (e = Yk(n.contentWindow.fetch)),
            t.head.removeChild(n)
          } catch (e) {
            F_ && J_.warn('Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ', e)
          }
        }
        return e
      }
      )() && xC(q_, 'fetch', function (e) {
        return function () {
          for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++) { n[r] = arguments[r] }
          const o = (function (e) {
            if (e.length === 0) {
              return {
                method: 'GET',
                url: ''
              }
            }
            if (e.length === 2) {
              const t = (i = 2,
              (function (e) {
                if (Array.isArray(e)) { return e }
              }(o = e)) || (function (e, t) {
                let n = e == null ? null : typeof Symbol !== 'undefined' && e[Symbol.iterator] || e['@@iterator']
                if (n != null) {
                  let r; let o; let i; let a; const s = []; let c = !0; let l = !1
                  try {
                    if (i = (n = n.call(e)).next,
                    t === 0) {
                      if (Object(n) !== n) { return }
                      c = !1
                    } else {
                      for (; !(c = (r = i.call(n)).done) && (s.push(r.value),
                      s.length !== t); c = !0)
                        ;
                    }
                  } catch (e) {
                    l = !0,
                    o = e
                  } finally {
                    try {
                      if (!c && n.return != null && (a = n.return(),
                      Object(a) !== a)) { return }
                    } finally {
                      if (l) { throw o }
                    }
                  }
                  return s
                }
              }(o, i)) || (function (e, t) {
                if (e) {
                  if (typeof e === 'string') { return GB(e, t) }
                  let n = Object.prototype.toString.call(e).slice(8, -1)
                  return n === 'Object' && e.constructor && (n = e.constructor.name),
                  n === 'Map' || n === 'Set' ? Array.from(e) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? GB(e, t) : void 0
                }
              }(o, i)) || (function () {
                throw new TypeError('Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
              }()))
              const n = t[0]
              const r = t[1]
              return {
                url: JB(n),
                method: KB(r, 'method') ? String(r.method).toUpperCase() : 'GET'
              }
            }
            let o; let i; const a = e[0]
            return {
              url: JB(a),
              method: KB(a, 'method') ? String(a.method).toUpperCase() : 'GET'
            }
          }(n))
          const i = {
            args: n,
            fetchData: {
              method: o.method,
              url: o.url
            },
            startTimestamp: Date.now()
          }
          return nj('fetch', QB({}, i)),
          e.apply(q_, n).then(function (e) {
            return nj('fetch', QB(QB({}, i), {}, {
              endTimestamp: Date.now(),
              response: e
            })),
            e
          }
          , function (e) {
            throw nj('fetch', QB(QB({}, i), {}, {
              endTimestamp: Date.now(),
              error: e
            })),
            e
          }
          )
        }
      }
      )
    }
    function KB (e, t) {
      return !!e && UB(e) === 'object' && !!e[t]
    }
    function JB (e) {
      return typeof e === 'string' ? e : e ? KB(e, 'url') ? e.url : e.toString ? e.toString() : '' : ''
    }
    const XB = ['fatal', 'error', 'warning', 'log', 'info', 'debug']
    function ZB (e) {
      if (!e) { return {} }
      const t = e.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/)
      if (!t) { return {} }
      const n = t[6] || ''
      const r = t[8] || ''
      return {
        host: t[4],
        path: t[5],
        protocol: t[2],
        search: n,
        hash: r,
        relative: t[5] + n + r
      }
    }
    function eD (e) {
      return eD = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      eD(e)
    }
    function tD (e, t) {
      const n = Object.keys(e)
      if (Object.getOwnPropertySymbols) {
        let r = Object.getOwnPropertySymbols(e)
        t && (r = r.filter(function (t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable
        }
        )),
        n.push.apply(n, r)
      }
      return n
    }
    function nD (e) {
      for (let t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {}
        t % 2
          ? tD(Object(n), !0).forEach(function (t) {
            let r, o, i
            r = e,
            o = t,
            i = n[t],
            o = (function (e) {
              const t = (function (e, t) {
                if (eD(e) != 'object' || !e) { return e }
                const n = e[Symbol.toPrimitive]
                if (void 0 !== n) {
                  const r = n.call(e, 'string')
                  if (eD(r) != 'object') { return r }
                  throw new TypeError('@@toPrimitive must return a primitive value.')
                }
                return String(e)
              }(e))
              return eD(t) == 'symbol' ? t : t + ''
            }(o)),
            o in r
              ? Object.defineProperty(r, o, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
              })
              : r[o] = i
          }
          )
          : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
            : tD(Object(n)).forEach(function (t) {
              Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
            }
            )
      }
      return e
    }
    const rD = 1024
    const oD = 'Breadcrumbs'
    const iD = function () {
      const e = nD({
        console: !0,
        dom: !0,
        fetch: !0,
        history: !0,
        sentry: !0,
        xhr: !0
      }, arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {})
      return {
        name: oD,
        setupOnce: function () {},
        setup: function (t) {
          let n
          e.console && (n = (function (e) {
            return function (t) {
              if (FS() === e) {
                const n = {
                  category: 'console',
                  data: {
                    arguments: t.args,
                    logger: 'console'
                  },
                  level: (r = t.level,
                  r === 'warn' ? 'warning' : XB.includes(r) ? r : 'log'),
                  message: gC(t.args, ' ')
                }
                if (t.level === 'assert') {
                  if (!1 !== t.args[0]) { return }
                  n.message = 'Assertion failed: '.concat(gC(t.args.slice(1), ' ') || 'console.assert'),
                  n.data.arguments = t.args.slice(1)
                }
                zS(n, {
                  input: t.args,
                  level: t.level
                })
              }
              let r
            }
          }(t)),
          ej('console', n),
          tj('console', RB)),
          e.dom && (function (e) {
            ej('dom', e),
            tj('dom', FB)
          }(function (e, t) {
            return function (n) {
              if (FS() === e) {
                let r; let o; let i = eD(t) === 'object' ? t.serializeAttribute : void 0; let a = eD(t) === 'object' && typeof t.maxStringLength === 'number' ? t.maxStringLength : void 0
                a && a > rD && (rB && J_.warn('`dom.maxStringLength` cannot exceed '.concat(rD, ', but a value of ').concat(a, ' was configured. Sentry will use ').concat(rD, ' instead.')),
                a = rD),
                typeof i === 'string' && (i = [i])
                try {
                  const s = n.event
                  const c = (function (e) {
                    return !!e && !!e.target
                  }(s))
                    ? s.target
                    : s
                  r = hC(c, {
                    keyAttrs: i,
                    maxStringLength: a
                  }),
                  o = (function (e) {
                    if (!dC.HTMLElement) { return null }
                    for (let t = e, n = 0; n < 5; n++) {
                      if (!t) { return null }
                      if (t instanceof HTMLElement && t.dataset.sentryComponent) { return t.dataset.sentryComponent }
                      t = t.parentNode
                    }
                    return null
                  }(c))
                } catch (e) {
                  r = '<unknown>'
                }
                if (r.length !== 0) {
                  const l = {
                    category: 'ui.'.concat(n.name),
                    message: r
                  }
                  o && (l.data = {
                    'ui.component_name': o
                  }),
                  zS(l, {
                    event: n.event,
                    name: n.name,
                    global: n.global
                  })
                }
              }
            }
          }(t, e.dom))),
          e.xhr && (function (e) {
            ej('xhr', e),
            tj('xhr', WB)
          }(function (e) {
            return function (t) {
              if (FS() === e) {
                const n = t.startTimestamp
                const r = t.endTimestamp
                const o = t.xhr[qB]
                if (n && r && o) {
                  const i = o.method
                  const a = o.url
                  const s = o.status_code
                  const c = o.body
                  zS({
                    category: 'xhr',
                    data: {
                      method: i,
                      url: a,
                      status_code: s
                    },
                    type: 'http'
                  }, {
                    xhr: t.xhr,
                    input: c,
                    startTimestamp: n,
                    endTimestamp: r
                  })
                }
              }
            }
          }(t))),
          e.fetch && (function (e) {
            const t = 'fetch'
            ej(t, e),
            tj(t, YB)
          }(function (e) {
            return function (t) {
              if (FS() === e) {
                const n = t.startTimestamp
                const r = t.endTimestamp
                if (r && (!t.fetchData.url.match(/sentry_key/) || t.fetchData.method !== 'POST')) {
                  if (t.error) {
                    zS({
                      category: 'fetch',
                      data: t.fetchData,
                      level: 'error',
                      type: 'http'
                    }, {
                      data: t.error,
                      input: t.args,
                      startTimestamp: n,
                      endTimestamp: r
                    })
                  } else {
                    const o = t.response
                    zS({
                      category: 'fetch',
                      data: nD(nD({}, t.fetchData), {}, {
                        status_code: o && o.status
                      }),
                      type: 'http'
                    }, {
                      input: t.args,
                      response: o,
                      startTimestamp: n,
                      endTimestamp: r
                    })
                  }
                }
              }
            }
          }(t))),
          e.history && ij(function (e) {
            return function (t) {
              if (FS() === e) {
                let n = t.from
                let r = t.to
                const o = ZB(yB.location.href)
                let i = n ? ZB(n) : void 0
                const a = ZB(r)
                i && i.path || (i = o),
                o.protocol === a.protocol && o.host === a.host && (r = a.relative),
                o.protocol === i.protocol && o.host === i.host && (n = i.relative),
                zS({
                  category: 'navigation',
                  data: {
                    from: n,
                    to: r
                  }
                })
              }
            }
          }(t)),
          e.sentry && t.on && t.on('beforeSendEvent', (function (e) {
            return function (t) {
              FS() === e && zS({
                category: 'sentry.'.concat(t.type === 'transaction' ? 'transaction' : 'event'),
                event_id: t.event_id,
                level: t.level,
                message: MC(t)
              }, {
                event: t
              })
            }
          }(t)))
        }
      }
    }
    Nk(oD, iD)
    const aD = 'Dedupe'
    const sD = function () {
      let e
      return {
        name: aD,
        setupOnce: function () {},
        processEvent: function (t) {
          if (t.type) { return t }
          try {
            if (function (e, t) {
              return !!t && (!!(function (e, t) {
                const n = e.message
                const r = t.message
                return !(!n && !r) && (!(n && !r || !n && r) && (n === r && (!!lD(e, t) && !!cD(e, t))))
              }(e, t)) || !!(function (e, t) {
                const n = pD(t)
                const r = pD(e)
                return !(!n || !r) && (n.type === r.type && n.value === r.value && (!!lD(e, t) && !!cD(e, t)))
              }(e, t)))
            }(t, e)) {
              return rB && J_.warn('Event dropped due to being a duplicate of previously captured event.'),
              null
            }
          } catch (e) {}
          return e = t
        }
      }
    }
    function cD (e, t) {
      const n = uD(e)
      const r = uD(t)
      if (!n && !r) { return !0 }
      if (n && !r || !n && r) { return !1 }
      if (r.length !== n.length) { return !1 }
      for (let o = 0; o < r.length; o++) {
        const i = r[o]
        const a = n[o]
        if (i.filename !== a.filename || i.lineno !== a.lineno || i.colno !== a.colno || i.function !== a.function) { return !1 }
      }
      return !0
    }
    function lD (e, t) {
      const n = e.fingerprint
      const r = t.fingerprint
      if (!n && !r) { return !0 }
      if (n && !r || !n && r) { return !1 }
      try {
        return !(n.join('') !== r.join(''))
      } catch (e) {
        return !1
      }
    }
    function pD (e) {
      return e.exception && e.exception.values && e.exception.values[0]
    }
    function uD (e) {
      const t = e.exception
      if (t) {
        try {
          return t.values[0].stacktrace.frames
        } catch (e) {

        }
      }
    }
    Nk(aD, sD)
    let dD = null
    function fD () {
      dD = q_.onerror,
      q_.onerror = function (e, t, n, r, o) {
        return nj('error', {
          column: r,
          error: o,
          line: n,
          msg: e,
          url: t
        }),
        !(!dD || dD.__SENTRY_LOADER__) && dD.apply(this, arguments)
      }
      ,
      q_.onerror.__SENTRY_INSTRUMENTED__ = !0
    }
    let hD = null
    function mD () {
      hD = q_.onunhandledrejection,
      q_.onunhandledrejection = function (e) {
        return nj('unhandledrejection', e),
        !(hD && !hD.__SENTRY_LOADER__) || hD.apply(this, arguments)
      }
      ,
      q_.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0
    }
    function vD (e) {
      return vD = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      vD(e)
    }
    function gD (e, t) {
      const n = Object.keys(e)
      if (Object.getOwnPropertySymbols) {
        let r = Object.getOwnPropertySymbols(e)
        t && (r = r.filter(function (t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable
        }
        )),
        n.push.apply(n, r)
      }
      return n
    }
    const yD = 'GlobalHandlers'
    const bD = function () {
      const e = (function (e) {
        for (let t = 1; t < arguments.length; t++) {
          var n = arguments[t] != null ? arguments[t] : {}
          t % 2
            ? gD(Object(n), !0).forEach(function (t) {
              let r, o, i
              r = e,
              o = t,
              i = n[t],
              o = (function (e) {
                const t = (function (e, t) {
                  if (vD(e) != 'object' || !e) { return e }
                  const n = e[Symbol.toPrimitive]
                  if (void 0 !== n) {
                    const r = n.call(e, 'string')
                    if (vD(r) != 'object') { return r }
                    throw new TypeError('@@toPrimitive must return a primitive value.')
                  }
                  return String(e)
                }(e))
                return vD(t) == 'symbol' ? t : t + ''
              }(o)),
              o in r
                ? Object.defineProperty(r, o, {
                  value: i,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0
                })
                : r[o] = i
            }
            )
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
              : gD(Object(n)).forEach(function (t) {
                Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
              }
              )
        }
        return e
      }({
        onerror: !0,
        onunhandledrejection: !0
      }, arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}))
      return {
        name: yD,
        setupOnce: function () {
          Error.stackTraceLimit = 50
        },
        setup: function (t) {
          e.onerror && ((function (e) {
            let t, n
            t = function (t) {
              const n = xD()
              const r = n.stackParser
              const o = n.attachStacktrace
              if (FS() === e && !AB()) {
                const i = t.msg
                const a = t.url
                const s = t.line
                const c = t.column
                const l = t.error
                const p = void 0 === l && oC(i)
                  ? (function (e, t, n, r) {
                      let o = nC(e) ? e.message : e
                      let i = 'Error'
                      const a = o.match(/^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i)
                      return a && (i = a[1],
                      o = a[2]),
                      AD({
                        exception: {
                          values: [{
                            type: i,
                            value: o
                          }]
                        }
                      }, t, n, r)
                    }(i, a, s, c))
                  : AD(dB(r, l || i, void 0, o, !1), a, s, c)
                p.level = 'error',
                LS(p, {
                  originalException: l,
                  mechanism: {
                    handled: !1,
                    type: 'onerror'
                  }
                })
              }
            }
            ,
            ej(n = 'error', t),
            tj(n, fD)
          }(t)),
          ED('onerror')),
          e.onunhandledrejection && ((function (e) {
            let t, n
            t = function (t) {
              const n = xD()
              const r = n.stackParser
              const o = n.attachStacktrace
              if (FS() === e && !AB()) {
                const i = (function (e) {
                  if (aC(e)) { return e }
                  const t = e
                  try {
                    if ('reason' in t) { return t.reason }
                    if ('detail' in t && 'reason' in t.detail) { return t.detail.reason }
                  } catch (e) {}
                  return e
                }(t))
                const a = aC(i)
                  ? {
                      exception: {
                        values: [{
                          type: 'UnhandledRejection',
                          value: 'Non-Error promise rejection captured with value: '.concat(String(i))
                        }]
                      }
                    }
                  : dB(r, i, void 0, o, !0)
                a.level = 'error',
                LS(a, {
                  originalException: i,
                  mechanism: {
                    handled: !1,
                    type: 'onunhandledrejection'
                  }
                })
              }
            }
            ,
            ej(n = 'unhandledrejection', t),
            tj(n, mD)
          }(t)),
          ED('onunhandledrejection'))
        }
      }
    }
    function AD (e, t, n, r) {
      const o = e.exception = e.exception || {}
      const i = o.values = o.values || []
      const a = i[0] = i[0] || {}
      const s = a.stacktrace = a.stacktrace || {}
      const c = s.frames = s.frames || []
      const l = isNaN(parseInt(r, 10)) ? void 0 : r
      const p = isNaN(parseInt(n, 10)) ? void 0 : n
      const u = oC(t) && t.length > 0
        ? t
        : (function () {
            try {
              return dC.document.location.href
            } catch (e) {
              return ''
            }
          }())
      return c.length === 0 && c.push({
        colno: l,
        filename: u,
        function: '?',
        in_app: !0,
        lineno: p
      }),
      e
    }
    function ED (e) {
      rB && J_.log('Global Handler attached: '.concat(e))
    }
    function xD () {
      const e = FS()
      return e && e.getOptions() || {
        stackParser: function () {
          return []
        },
        attachStacktrace: !1
      }
    }
    function wD (e) {
      return wD = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      wD(e)
    }
    function _D (e, t) {
      const n = Object.keys(e)
      if (Object.getOwnPropertySymbols) {
        let r = Object.getOwnPropertySymbols(e)
        t && (r = r.filter(function (t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable
        }
        )),
        n.push.apply(n, r)
      }
      return n
    }
    function CD (e) {
      for (let t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {}
        t % 2
          ? _D(Object(n), !0).forEach(function (t) {
            let r, o, i
            r = e,
            o = t,
            i = n[t],
            o = (function (e) {
              const t = (function (e, t) {
                if (wD(e) != 'object' || !e) { return e }
                const n = e[Symbol.toPrimitive]
                if (void 0 !== n) {
                  const r = n.call(e, 'string')
                  if (wD(r) != 'object') { return r }
                  throw new TypeError('@@toPrimitive must return a primitive value.')
                }
                return String(e)
              }(e))
              return wD(t) == 'symbol' ? t : t + ''
            }(o)),
            o in r
              ? Object.defineProperty(r, o, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
              })
              : r[o] = i
          }
          )
          : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
            : _D(Object(n)).forEach(function (t) {
              Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
            }
            )
      }
      return e
    }
    Nk(yD, bD)
    const SD = 'HttpContext'
    const kD = function () {
      return {
        name: SD,
        setupOnce: function () {},
        preprocessEvent: function (e) {
          if (yB.navigator || yB.location || yB.document) {
            const t = e.request && e.request.url || yB.location && yB.location.href
            const n = (yB.document || {}).referrer
            const r = (yB.navigator || {}).userAgent
            const o = CD(CD(CD({}, e.request && e.request.headers), n && {
              Referer: n
            }), r && {
              'User-Agent': r
            })
            const i = CD(CD(CD({}, e.request), t && {
              url: t
            }), {}, {
              headers: o
            })
            e.request = i
          }
        }
      }
    }
    function jD (e) {
      return jD = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      jD(e)
    }
    function BD (e, t) {
      const n = Object.keys(e)
      if (Object.getOwnPropertySymbols) {
        let r = Object.getOwnPropertySymbols(e)
        t && (r = r.filter(function (t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable
        }
        )),
        n.push.apply(n, r)
      }
      return n
    }
    function DD (e) {
      for (let t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {}
        t % 2
          ? BD(Object(n), !0).forEach(function (t) {
            let r, o, i
            r = e,
            o = t,
            i = n[t],
            o = (function (e) {
              const t = (function (e, t) {
                if (jD(e) != 'object' || !e) { return e }
                const n = e[Symbol.toPrimitive]
                if (void 0 !== n) {
                  const r = n.call(e, 'string')
                  if (jD(r) != 'object') { return r }
                  throw new TypeError('@@toPrimitive must return a primitive value.')
                }
                return String(e)
              }(e))
              return jD(t) == 'symbol' ? t : t + ''
            }(o)),
            o in r
              ? Object.defineProperty(r, o, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
              })
              : r[o] = i
          }
          )
          : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
            : BD(Object(n)).forEach(function (t) {
              Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
            }
            )
      }
      return e
    }
    function PD (e) {
      return (function (e) {
        if (Array.isArray(e)) { return OD(e) }
      }(e)) || (function (e) {
        if (typeof Symbol !== 'undefined' && e[Symbol.iterator] != null || e['@@iterator'] != null) { return Array.from(e) }
      }(e)) || (function (e, t) {
        if (e) {
          if (typeof e === 'string') { return OD(e, t) }
          let n = Object.prototype.toString.call(e).slice(8, -1)
          return n === 'Object' && e.constructor && (n = e.constructor.name),
          n === 'Map' || n === 'Set' ? Array.from(e) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? OD(e, t) : void 0
        }
      }(e)) || (function () {
        throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
      }())
    }
    function OD (e, t) {
      (t == null || t > e.length) && (t = e.length)
      for (var n = 0, r = new Array(t); n < t; n++) { r[n] = e[n] }
      return r
    }
    function TD (e, t) {
      const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 250
      const r = arguments.length > 3 ? arguments[3] : void 0
      const o = arguments.length > 4 ? arguments[4] : void 0
      const i = arguments.length > 5 ? arguments[5] : void 0
      const a = arguments.length > 6 ? arguments[6] : void 0
      if (i.exception && i.exception.values && a && pC(a.originalException, Error)) {
        let s; let c; const l = i.exception.values.length > 0 ? i.exception.values[i.exception.values.length - 1] : void 0
        l && (i.exception.values = (s = RD(e, t, o, a.originalException, r, i.exception.values, l, 0),
        c = n,
        s.map(function (e) {
          return e.value && (e.value = vC(e.value, c)),
          e
        }
        )))
      }
    }
    function RD (e, t, n, r, o, i, a, s) {
      if (i.length >= n + 1) { return i }
      let c = PD(i)
      if (pC(r[o], Error)) {
        ND(a, s)
        const l = e(t, r[o])
        const p = c.length
        MD(l, o, p, s),
        c = RD(e, t, n, r[o], o, [l].concat(PD(c)), l, p)
      }
      return Array.isArray(r.errors) && r.errors.forEach(function (r, i) {
        if (pC(r, Error)) {
          ND(a, s)
          const l = e(t, r)
          const p = c.length
          MD(l, 'errors['.concat(i, ']'), p, s),
          c = RD(e, t, n, r, o, [l].concat(PD(c)), l, p)
        }
      }
      ),
      c
    }
    function ND (e, t) {
      e.mechanism = e.mechanism || {
        type: 'generic',
        handled: !0
      },
      e.mechanism = DD(DD(DD({}, e.mechanism), e.type === 'AggregateError' && {
        is_exception_group: !0
      }), {}, {
        exception_id: t
      })
    }
    function MD (e, t, n, r) {
      e.mechanism = e.mechanism || {
        type: 'generic',
        handled: !0
      },
      e.mechanism = DD(DD({}, e.mechanism), {}, {
        type: 'chained',
        source: t,
        exception_id: n,
        parent_id: r
      })
    }
    Nk(SD, kD)
    const ID = 'LinkedErrors'
    const LD = function () {
      const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
      const t = e.limit || 5
      const n = e.key || 'cause'
      return {
        name: ID,
        setupOnce: function () {},
        preprocessEvent: function (e, r, o) {
          const i = o.getOptions()
          TD(sB, i.stackParser, i.maxValueLength, n, t, e, r)
        }
      }
    }
    function zD (e) {
      return zD = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      zD(e)
    }
    function FD (e, t) {
      const n = Object.keys(e)
      if (Object.getOwnPropertySymbols) {
        let r = Object.getOwnPropertySymbols(e)
        t && (r = r.filter(function (t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable
        }
        )),
        n.push.apply(n, r)
      }
      return n
    }
    Nk(ID, LD)
    const $D = ['EventTarget', 'Window', 'Node', 'ApplicationCache', 'AudioTrackList', 'BroadcastChannel', 'ChannelMergerNode', 'CryptoOperation', 'EventSource', 'FileReader', 'HTMLUnknownElement', 'IDBDatabase', 'IDBRequest', 'IDBTransaction', 'KeyOperation', 'MediaController', 'MessagePort', 'ModalWindow', 'Notification', 'SVGElementInstance', 'Screen', 'SharedWorker', 'TextTrack', 'TextTrackCue', 'TextTrackList', 'WebSocket', 'WebSocketWorker', 'Worker', 'XMLHttpRequest', 'XMLHttpRequestEventTarget', 'XMLHttpRequestUpload']
    const HD = 'TryCatch'
    const qD = function () {
      const e = (function (e) {
        for (let t = 1; t < arguments.length; t++) {
          var n = arguments[t] != null ? arguments[t] : {}
          t % 2
            ? FD(Object(n), !0).forEach(function (t) {
              let r, o, i
              r = e,
              o = t,
              i = n[t],
              o = (function (e) {
                const t = (function (e, t) {
                  if (zD(e) != 'object' || !e) { return e }
                  const n = e[Symbol.toPrimitive]
                  if (void 0 !== n) {
                    const r = n.call(e, 'string')
                    if (zD(r) != 'object') { return r }
                    throw new TypeError('@@toPrimitive must return a primitive value.')
                  }
                  return String(e)
                }(e))
                return zD(t) == 'symbol' ? t : t + ''
              }(o)),
              o in r
                ? Object.defineProperty(r, o, {
                  value: i,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0
                })
                : r[o] = i
            }
            )
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
              : FD(Object(n)).forEach(function (t) {
                Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
              }
              )
        }
        return e
      }({
        XMLHttpRequest: !0,
        eventTarget: !0,
        requestAnimationFrame: !0,
        setInterval: !0,
        setTimeout: !0
      }, arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}))
      return {
        name: HD,
        setupOnce: function () {
          e.setTimeout && xC(yB, 'setTimeout', WD),
          e.setInterval && xC(yB, 'setInterval', WD),
          e.requestAnimationFrame && xC(yB, 'requestAnimationFrame', GD),
          e.XMLHttpRequest && 'XMLHttpRequest' in yB && xC(XMLHttpRequest.prototype, 'send', UD)
          const t = e.eventTarget
          t && (Array.isArray(t) ? t : $D).forEach(VD)
        }
      }
    }
    function WD (e) {
      return function () {
        for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++) { n[r] = arguments[r] }
        const o = n[0]
        return n[0] = EB(o, {
          mechanism: {
            data: {
              function: yS(e)
            },
            handled: !1,
            type: 'instrument'
          }
        }),
        e.apply(this, n)
      }
    }
    function GD (e) {
      return function (t) {
        return e.apply(this, [EB(t, {
          mechanism: {
            data: {
              function: 'requestAnimationFrame',
              handler: yS(e)
            },
            handled: !1,
            type: 'instrument'
          }
        })])
      }
    }
    function UD (e) {
      return function () {
        const t = this;
        ['onload', 'onerror', 'onprogress', 'onreadystatechange'].forEach(function (e) {
          e in t && typeof t[e] === 'function' && xC(t, e, function (t) {
            const n = {
              mechanism: {
                data: {
                  function: e,
                  handler: yS(t)
                },
                handled: !1,
                type: 'instrument'
              }
            }
            const r = CC(t)
            return r && (n.mechanism.data.handler = yS(r)),
            EB(t, n)
          }
          )
        }
        )
        for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++) { r[o] = arguments[o] }
        return e.apply(this, r)
      }
    }
    function VD (e) {
      const t = yB
      const n = t[e] && t[e].prototype
      n && n.hasOwnProperty && n.hasOwnProperty('addEventListener') && (xC(n, 'addEventListener', function (t) {
        return function (n, r, o) {
          try {
            typeof r.handleEvent === 'function' && (r.handleEvent = EB(r.handleEvent, {
              mechanism: {
                data: {
                  function: 'handleEvent',
                  handler: yS(r),
                  target: e
                },
                handled: !1,
                type: 'instrument'
              }
            }))
          } catch (e) {}
          return t.apply(this, [n, EB(r, {
            mechanism: {
              data: {
                function: 'addEventListener',
                handler: yS(r),
                target: e
              },
              handled: !1,
              type: 'instrument'
            }
          }), o])
        }
      }
      ),
      xC(n, 'removeEventListener', function (e) {
        return function (t, n, r) {
          const o = n
          try {
            const i = o && o.__sentry_wrapped__
            i && e.call(this, t, i, r)
          } catch (e) {}
          return e.call(this, t, o, r)
        }
      }
      ))
    }
    function QD (e, t) {
      return (function (e) {
        if (Array.isArray(e)) { return e }
      }(e)) || (function (e, t) {
        let n = e == null ? null : typeof Symbol !== 'undefined' && e[Symbol.iterator] || e['@@iterator']
        if (n != null) {
          let r; let o; let i; let a; const s = []; let c = !0; let l = !1
          try {
            if (i = (n = n.call(e)).next,
            t === 0) {
              if (Object(n) !== n) { return }
              c = !1
            } else {
              for (; !(c = (r = i.call(n)).done) && (s.push(r.value),
              s.length !== t); c = !0)
                ;
            }
          } catch (e) {
            l = !0,
            o = e
          } finally {
            try {
              if (!c && n.return != null && (a = n.return(),
              Object(a) !== a)) { return }
            } finally {
              if (l) { throw o }
            }
          }
          return s
        }
      }(e, t)) || (function (e, t) {
        if (e) {
          if (typeof e === 'string') { return YD(e, t) }
          let n = Object.prototype.toString.call(e).slice(8, -1)
          return n === 'Object' && e.constructor && (n = e.constructor.name),
          n === 'Map' || n === 'Set' ? Array.from(e) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? YD(e, t) : void 0
        }
      }(e, t)) || (function () {
        throw new TypeError('Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
      }())
    }
    function YD (e, t) {
      (t == null || t > e.length) && (t = e.length)
      for (var n = 0, r = new Array(t); n < t; n++) { r[n] = e[n] }
      return r
    }
    Nk(HD, qD)
    const KD = '?'
    function JD (e, t, n, r) {
      const o = {
        filename: e,
        function: t,
        in_app: !0
      }
      return void 0 !== n && (o.lineno = n),
      void 0 !== r && (o.colno = r),
      o
    }
    const XD = /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i
    const ZD = /\((\S*)(?::(\d+))(?::(\d+))\)/
    const eP = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i
    const tP = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i
    const nP = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:[-a-z]+):.*?):(\d+)(?::(\d+))?\)?\s*$/i
    const rP = [[30, function (e) {
      const t = XD.exec(e)
      if (t) {
        if (t[2] && t[2].indexOf('eval') === 0) {
          const n = ZD.exec(t[2])
          n && (t[2] = n[1],
          t[3] = n[2],
          t[4] = n[3])
        }
        const r = QD(iP(t[1] || KD, t[2]), 2)
        const o = r[0]
        return JD(r[1], o, t[3] ? +t[3] : void 0, t[4] ? +t[4] : void 0)
      }
    }
    ], [50, function (e) {
      const t = eP.exec(e)
      if (t) {
        if (t[3] && t[3].indexOf(' > eval') > -1) {
          const n = tP.exec(t[3])
          n && (t[1] = t[1] || 'eval',
          t[3] = n[1],
          t[4] = n[2],
          t[5] = '')
        }
        let r = t[3]
        let o = t[1] || KD
        const i = QD(iP(o, r), 2)
        return o = i[0],
        JD(r = i[1], o, t[4] ? +t[4] : void 0, t[5] ? +t[5] : void 0)
      }
    }
    ], [40, function (e) {
      const t = nP.exec(e)
      return t ? JD(t[2], t[1] || KD, +t[3], t[4] ? +t[4] : void 0) : void 0
    }
    ]]
    const oP = vS.apply(void 0, rP)
    var iP = function (e, t) {
      const n = e.indexOf('safari-extension') !== -1
      const r = e.indexOf('safari-web-extension') !== -1
      return n || r ? [e.indexOf('@') !== -1 ? e.split('@')[0] : KD, n ? 'safari-extension:'.concat(t) : 'safari-web-extension:'.concat(t)] : [e, t]
    }
    function aP (e) {
      return aP = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      aP(e)
    }
    function sP (e, t) {
      let n = typeof Symbol !== 'undefined' && e[Symbol.iterator] || e['@@iterator']
      if (!n) {
        if (Array.isArray(e) || (n = cP(e)) || t && e && typeof e.length === 'number') {
          n && (e = n)
          let r = 0
          const o = function () {}
          return {
            s: o,
            n: function () {
              return r >= e.length
                ? {
                    done: !0
                  }
                : {
                    done: !1,
                    value: e[r++]
                  }
            },
            e: function (e) {
              throw e
            },
            f: o
          }
        }
        throw new TypeError('Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
      }
      let i; let a = !0; let s = !1
      return {
        s: function () {
          n = n.call(e)
        },
        n: function () {
          const e = n.next()
          return a = e.done,
          e
        },
        e: function (e) {
          s = !0,
          i = e
        },
        f: function () {
          try {
            a || n.return == null || n.return()
          } finally {
            if (s) { throw i }
          }
        }
      }
    }
    function cP (e, t) {
      if (e) {
        if (typeof e === 'string') { return lP(e, t) }
        let n = Object.prototype.toString.call(e).slice(8, -1)
        return n === 'Object' && e.constructor && (n = e.constructor.name),
        n === 'Map' || n === 'Set' ? Array.from(e) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? lP(e, t) : void 0
      }
    }
    function lP (e, t) {
      (t == null || t > e.length) && (t = e.length)
      for (var n = 0, r = new Array(t); n < t; n++) { r[n] = e[n] }
      return r
    }
    function pP (e, t) {
      const n = Object.keys(e)
      if (Object.getOwnPropertySymbols) {
        let r = Object.getOwnPropertySymbols(e)
        t && (r = r.filter(function (t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable
        }
        )),
        n.push.apply(n, r)
      }
      return n
    }
    const uP = 6e4
    const dP = 30
    function fP (e, t) {
      const n = arguments.length > 2 && void 0 !== arguments[2]
        ? arguments[2]
        : (function (e) {
            const t = []
            function n (e) {
              return t.splice(t.indexOf(e), 1)[0]
            }
            return {
              $: t,
              add: function (r) {
                if (!(void 0 === e || t.length < e)) { return VC(new Oj('Not adding Promise because buffer limit was reached.')) }
                const o = r()
                return t.indexOf(o) === -1 && t.push(o),
                o.then(function () {
                  return n(o)
                }
                ).then(null, function () {
                  return n(o).then(null, function () {}
                  )
                }
                ),
                o
              },
              drain: function (e) {
                return new QC(function (n, r) {
                  let o = t.length
                  if (!o) { return n(!0) }
                  const i = setTimeout(function () {
                    e && e > 0 && n(!1)
                  }
                  , e)
                  t.forEach(function (e) {
                    UC(e).then(function () {
                      --o || (clearTimeout(i),
                      n(!0))
                    }
                    , r)
                  }
                  )
                }
                )
              }
            }
          }(e.bufferSize || dP))
      let r = {}
      function o (o) {
        const i = []
        if (Aj(o, function (t, n) {
          const o = Cj(n)
          if (function (e, t) {
            const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Date.now()
            return (function (e, t) {
              return e[t] || e.all || 0
            }(e, t)) > n
          }(r, o)) {
            const a = hP(t, n)
            e.recordDroppedEvent('ratelimit_backoff', o, a)
          } else { i.push(t) }
        }
        ),
        i.length === 0) { return UC() }
        const a = bj(o[0], i)
        const s = function (t) {
          Aj(a, function (n, r) {
            const o = hP(n, r)
            e.recordDroppedEvent(t, Cj(r), o)
          }
          )
        }
        return n.add(function () {
          return t({
            body: xj(a, e.textEncoder)
          }).then(function (e) {
            return void 0 !== e.statusCode && (e.statusCode < 200 || e.statusCode >= 300) && HC && J_.warn('Sentry responded with status code '.concat(e.statusCode, ' to sent event.')),
            r = (function (e, t) {
              let n; let r; const o = t.statusCode; const i = t.headers; const a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Date.now(); const s = (function (e) {
                for (let t = 1; t < arguments.length; t++) {
                  var n = arguments[t] != null ? arguments[t] : {}
                  t % 2
                    ? pP(Object(n), !0).forEach(function (t) {
                      let r, o, i
                      r = e,
                      o = t,
                      i = n[t],
                      o = (function (e) {
                        const t = (function (e, t) {
                          if (aP(e) != 'object' || !e) { return e }
                          const n = e[Symbol.toPrimitive]
                          if (void 0 !== n) {
                            const r = n.call(e, 'string')
                            if (aP(r) != 'object') { return r }
                            throw new TypeError('@@toPrimitive must return a primitive value.')
                          }
                          return String(e)
                        }(e))
                        return aP(t) == 'symbol' ? t : t + ''
                      }(o)),
                      o in r
                        ? Object.defineProperty(r, o, {
                          value: i,
                          enumerable: !0,
                          configurable: !0,
                          writable: !0
                        })
                        : r[o] = i
                    }
                    )
                    : Object.getOwnPropertyDescriptors
                      ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
                      : pP(Object(n)).forEach(function (t) {
                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
                      }
                      )
                }
                return e
              }({}, e)); const c = i && i['x-sentry-rate-limits']; const l = i && i['retry-after']
              if (c) {
                let p; const u = sP(c.trim().split(','))
                try {
                  for (u.s(); !(p = u.n()).done;) {
                    const d = (n = p.value.split(':', 2),
                    r = 2,
                    (function (e) {
                      if (Array.isArray(e)) { return e }
                    }(n)) || (function (e, t) {
                      let n = e == null ? null : typeof Symbol !== 'undefined' && e[Symbol.iterator] || e['@@iterator']
                      if (n != null) {
                        let r; let o; let i; let a; const s = []; let c = !0; let l = !1
                        try {
                          if (i = (n = n.call(e)).next,
                          t === 0) {
                            if (Object(n) !== n) { return }
                            c = !1
                          } else {
                            for (; !(c = (r = i.call(n)).done) && (s.push(r.value),
                            s.length !== t); c = !0)
                              ;
                          }
                        } catch (e) {
                          l = !0,
                          o = e
                        } finally {
                          try {
                            if (!c && n.return != null && (a = n.return(),
                            Object(a) !== a)) { return }
                          } finally {
                            if (l) { throw o }
                          }
                        }
                        return s
                      }
                    }(n, r)) || cP(n, r) || (function () {
                      throw new TypeError('Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
                    }()))
                    const f = d[0]
                    const h = d[1]
                    const m = parseInt(f, 10)
                    const v = 1e3 * (isNaN(m) ? 60 : m)
                    if (h) {
                      var g; const y = sP(h.split(';'))
                      try {
                        for (y.s(); !(g = y.n()).done;) { s[g.value] = a + v }
                      } catch (e) {
                        y.e(e)
                      } finally {
                        y.f()
                      }
                    } else { s.all = a + v }
                  }
                } catch (e) {
                  u.e(e)
                } finally {
                  u.f()
                }
              } else {
                l
                  ? s.all = a + (function (e) {
                    const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Date.now()
                    const n = parseInt(''.concat(e), 10)
                    if (!isNaN(n)) { return 1e3 * n }
                    const r = Date.parse(''.concat(e))
                    return isNaN(r) ? uP : r - t
                  }(l, a))
                  : o === 429 && (s.all = a + 6e4)
              }
              return s
            }(r, e)),
            e
          }
          , function (e) {
            throw s('network_error'),
            e
          }
          )
        }
        ).then(function (e) {
          return e
        }
        , function (e) {
          if (e instanceof Oj) {
            return HC && J_.error('Skipped sending event because buffer is full.'),
            s('queue_overflow'),
            UC()
          }
          throw e
        }
        )
      }
      return o.__sentry__baseTransport__ = !0,
      {
        send: o,
        flush: function (e) {
          return n.drain(e)
        }
      }
    }
    function hP (e, t) {
      if (t === 'event' || t === 'transaction') { return Array.isArray(e) ? e[1] : void 0 }
    }
    let mP = void 0
    function vP (e) {
      return vP = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      vP(e)
    }
    function gP (e, t) {
      const n = Object.keys(e)
      if (Object.getOwnPropertySymbols) {
        let r = Object.getOwnPropertySymbols(e)
        t && (r = r.filter(function (t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable
        }
        )),
        n.push.apply(n, r)
      }
      return n
    }
    function yP (e) {
      const t = arguments.length > 1 && void 0 !== arguments[1]
        ? arguments[1]
        : (function () {
            if (mP) { return mP }
            if (Yk(yB.fetch)) { return mP = yB.fetch.bind(yB) }
            const e = yB.document
            let t = yB.fetch
            if (e && typeof e.createElement === 'function') {
              try {
                const n = e.createElement('iframe')
                n.hidden = !0,
                e.head.appendChild(n)
                const r = n.contentWindow
                r && r.fetch && (t = r.fetch),
                e.head.removeChild(n)
              } catch (e) {
                rB && J_.warn('Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ', e)
              }
            }
            return mP = t.bind(yB)
          }())
      let n = 0
      let r = 0
      return fP(e, function (o) {
        const i = o.body.length
        n += i,
        r++
        const a = (function (e) {
          for (let t = 1; t < arguments.length; t++) {
            var n = arguments[t] != null ? arguments[t] : {}
            t % 2
              ? gP(Object(n), !0).forEach(function (t) {
                let r, o, i
                r = e,
                o = t,
                i = n[t],
                o = (function (e) {
                  const t = (function (e, t) {
                    if (vP(e) != 'object' || !e) { return e }
                    const n = e[Symbol.toPrimitive]
                    if (void 0 !== n) {
                      const r = n.call(e, 'string')
                      if (vP(r) != 'object') { return r }
                      throw new TypeError('@@toPrimitive must return a primitive value.')
                    }
                    return String(e)
                  }(e))
                  return vP(t) == 'symbol' ? t : t + ''
                }(o)),
                o in r
                  ? Object.defineProperty(r, o, {
                    value: i,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                  })
                  : r[o] = i
              }
              )
              : Object.getOwnPropertyDescriptors
                ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
                : gP(Object(n)).forEach(function (t) {
                  Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
                }
                )
          }
          return e
        }({
          body: o.body,
          method: 'POST',
          referrerPolicy: 'origin',
          headers: e.headers,
          keepalive: n <= 6e4 && r < 15
        }, e.fetchOptions))
        try {
          return t(e.url, a).then(function (e) {
            return n -= i,
            r--,
            {
              statusCode: e.status,
              headers: {
                'x-sentry-rate-limits': e.headers.get('X-Sentry-Rate-Limits'),
                'retry-after': e.headers.get('Retry-After')
              }
            }
          }
          )
        } catch (e) {
          return mP = void 0,
          n -= i,
          r--,
          VC(e)
        }
      }
      )
    }
    const bP = 4
    function AP (e) {
      return fP(e, function (t) {
        return new QC(function (n, r) {
          const o = new XMLHttpRequest()
          for (const i in o.onerror = r,
          o.onreadystatechange = function () {
            o.readyState === bP && n({
              statusCode: o.status,
              headers: {
                'x-sentry-rate-limits': o.getResponseHeader('X-Sentry-Rate-Limits'),
                'retry-after': o.getResponseHeader('Retry-After')
              }
            })
          }
          ,
          o.open('POST', e.url),
          e.headers) { Object.prototype.hasOwnProperty.call(e.headers, i) && o.setRequestHeader(i, e.headers[i]) }
          o.send(t.body)
        }
        )
      }
      )
    }
    function EP (e) {
      return EP = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
        ? function (e) {
          return typeof e
        }
        : function (e) {
          return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e
        }
      ,
      EP(e)
    }
    function xP (e, t) {
      const n = Object.keys(e)
      if (Object.getOwnPropertySymbols) {
        let r = Object.getOwnPropertySymbols(e)
        t && (r = r.filter(function (t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable
        }
        )),
        n.push.apply(n, r)
      }
      return n
    }
    function wP (e) {
      for (let t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {}
        t % 2
          ? xP(Object(n), !0).forEach(function (t) {
            let r, o, i
            r = e,
            o = t,
            i = n[t],
            o = (function (e) {
              const t = (function (e, t) {
                if (EP(e) != 'object' || !e) { return e }
                const n = e[Symbol.toPrimitive]
                if (void 0 !== n) {
                  const r = n.call(e, 'string')
                  if (EP(r) != 'object') { return r }
                  throw new TypeError('@@toPrimitive must return a primitive value.')
                }
                return String(e)
              }(e))
              return EP(t) == 'symbol' ? t : t + ''
            }(o)),
            o in r
              ? Object.defineProperty(r, o, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
              })
              : r[o] = i
          }
          )
          : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
            : xP(Object(n)).forEach(function (t) {
              Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
            }
            )
      }
      return e
    }
    const _P = [Hk(), Uk(), qD(), iD(), bD(), LD(), sD(), kD()]
    function CP () {
      const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
      void 0 === e.defaultIntegrations && (e.defaultIntegrations = [].concat(_P)),
      void 0 === e.release && (typeof __SENTRY_RELEASE__ === 'string' && (e.release = __SENTRY_RELEASE__),
      yB.SENTRY_RELEASE && yB.SENTRY_RELEASE.id && (e.release = yB.SENTRY_RELEASE.id)),
      void 0 === e.autoSessionTracking && (e.autoSessionTracking = !0),
      void 0 === e.sendClientReports && (e.sendClientReports = !0)
      let t; let n; const r = wP(wP({}, e), {}, {
        stackParser: (t = e.stackParser || oP,
        Array.isArray(t)
          ? vS.apply(void 0, (n = t,
          (function (e) {
            if (Array.isArray(e)) { return dS(e) }
          }(n)) || (function (e) {
            if (typeof Symbol !== 'undefined' && e[Symbol.iterator] != null || e['@@iterator'] != null) { return Array.from(e) }
          }(n)) || uS(n) || (function () {
            throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
          }())))
          : t),
        integrations: Ok(e),
        transport: e.transport || (Qk() ? yP : AP)
      });
      (function (e, t) {
        !0 === t.debug && (HC
          ? J_.enable()
          : Q_(function () {
            console.warn('[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.')
          }
          )),
        $S().update(t.initialScope)
        const n = new e(t)
        !(function (e) {
          const t = _k().getStackTop()
          t.client = e,
          t.scope.setClient(e)
        }(n)),
        (function (e) {
          e.init ? e.init() : e.setupIntegrations && e.setupIntegrations()
        }(n))
      }
      )(TB, r),
      e.autoSessionTracking && (void 0 !== yB.document
        ? (HS({
            ignoreDuration: !0
          }),
          GS(),
          ij(function (e) {
            const t = e.from
            const n = e.to
            void 0 !== t && t !== n && (HS({
              ignoreDuration: !0
            }),
            GS())
          }
          ))
        : rB && J_.warn('Session tracking in non-browser environment with @sentry/browser is not supported.'))
    }
    Object.prototype.toString,
    Object.prototype.hasOwnProperty
    const SP = Object.prototype.toString
    function kP (e) {
      if (!e || !e.nodeType) { throw new Error('A DOM element reference is required') }
      this.el = e,
      this.list = e.classList
    }
    kP.prototype.add = function (e) {
      return this.list.add(e),
      this
    }
    ,
    kP.prototype.remove = function (e) {
      return SP.call(e) == '[object RegExp]'
        ? this.removeMatching(e)
        : (this.list.remove(e),
          this)
    }
    ,
    kP.prototype.removeMatching = function (e) {
      for (let t = this.array(), n = 0; n < t.length; n++) { e.test(t[n]) && this.remove(t[n]) }
      return this
    }
    ,
    kP.prototype.toggle = function (e, t) {
      return void 0 !== t ? t !== this.list.toggle(e, t) && this.list.toggle(e) : this.list.toggle(e),
      this
    }
    ,
    kP.prototype.array = function () {
      return Array.from(this.list)
    }
    ,
    kP.prototype.has = kP.prototype.contains = function (e) {
      return this.list.contains(e)
    }

    let jP; let BP; let DP; const PP = {}
    function OP () {
      jP = window.addEventListener ? 'addEventListener' : 'attachEvent',
      BP = window.removeEventListener ? 'removeEventListener' : 'detachEvent',
      DP = jP !== 'addEventListener' ? 'on' : ''
    }
    PP.bind = function (e, t, n, r) {
      return jP || OP(),
      e[jP](DP + t, n, r || !1),
      n
    }
    ,
    PP.unbind = function (e, t, n, r) {
      return BP || OP(),
      e[BP](DP + t, n, r || !1),
      n
    }

    let TP; let RP = !1
    typeof document !== 'undefined' && ((TP = document.createElement('div')).innerHTML = '  <link/><table></table><a href="/a">a</a><input type="checkbox"/>',
    RP = !TP.getElementsByTagName('link').length,
    TP = void 0)
    const NP = {
      legend: [1, '<fieldset>', '</fieldset>'],
      tr: [2, '<table><tbody>', '</tbody></table>'],
      col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
      _default: RP ? [1, 'X<div>', '</div>'] : [0, '', '']
    }
    NP.td = NP.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'],
    NP.option = NP.optgroup = [1, '<select multiple="multiple">', '</select>'],
    NP.thead = NP.tbody = NP.colgroup = NP.caption = NP.tfoot = [1, '<table>', '</table>'],
    NP.polyline = NP.ellipse = NP.polygon = NP.circle = NP.text = NP.line = NP.path = NP.rect = NP.g = [1, '<svg xmlns="http://www.w3.org/2000/svg" version="1.1">', '</svg>']
    const MP = function (e, t) {
      if (typeof e !== 'string') { throw new TypeError('String expected') }
      t || (t = document)
      const n = /<([\w:]+)/.exec(e)
      if (!n) { return t.createTextNode(e) }
      e = e.replace(/^\s+|\s+$/g, '')
      const r = n[1]
      if (r == 'body') {
        return (o = t.createElement('html')).innerHTML = e,
        o.removeChild(o.lastChild)
      }
      let o; const i = Object.prototype.hasOwnProperty.call(NP, r) ? NP[r] : NP._default; let a = i[0]; const s = i[1]; const c = i[2]
      for ((o = t.createElement('div')).innerHTML = s + e + c; a--;) { o = o.lastChild }
      if (o.firstChild == o.lastChild) { return o.removeChild(o.firstChild) }
      for (var l = t.createDocumentFragment(); o.firstChild;) { l.appendChild(o.removeChild(o.firstChild)) }
      return l
    }
    function IP (e, t) {
      if (!window.FileReader) { return t() }
      const n = new FileReader()
      n.onload = function (n) {
        t(null, {
          name: e.name,
          path: e.path,
          contents: n.target.result
        })
      }
      ,
      n.onerror = function (e) {
        t(e.target.error)
      }
      ,
      n.readAsText(e)
    }
    function LP (e) {
      e.preventDefault()
    }
    !(function (e) {
      CP({
        dsn: 'https://396f66329e384c1d8617484db0ce06dd@o313460.ingest.sentry.io/5218065',
        release: '55c2c947f6065dbcd119b006cdc66b859f7ad32d',
        environment: 'production'
      }),
      _k().setTag('component', 'bpmn')
      try {
        t = {
          id: window.localStorage.__bio_demo_id = window.localStorage.__bio_demo_id || '_' + Math.random()
        },
        _k().setUser(t)
      } catch (e) {}
      let t
    }())
    let zP; let FP; const $P = new URL(window.location.href).searchParams.has('pm'); const HP = T_()('#js-drop-zone'); const qP = T_()('#js-canvas'); let WP = 'diagram.bpmn'; let GP = !1
    function UP (e) {
      GP = e
    }
    function VP () {
      if (GP) { return 'This will discard changes you made to the current diagram.' }
    }
    window.onbeforeunload = VP,
    window.onresize = se(function (e) {
      zP && zP.get('canvas').resized()
    }
    , 300)
    const QP = ['error', 'loading', 'loaded', 'shown', 'intro', 'animate', 'preload']
    function YP (e) {
      T_()(document.body).removeClass(QP.join(' ')).addClass(e),
      setTimeout(function () {
        T_()(document.body).addClass('animate')
      }
      , 0)
    }
    function KP (e) {
      YP('error'),
      HP.find('.error .error-log').val(e.message),
      console.error(e)
    }
    function JP (e) {
      const t = e && e.length
      if (XP(aO['import-warnings-alert'], t),
      t) {
        console.warn('imported with warnings')
        let n = ''
        e.forEach(function (e) {
          console.log(e),
          n += e.message + '\n\n'
        }
        ),
        aO['import-warnings-dialog'].find('.error-log').val(n)
      }
    }
    function XP (e, t) {
      e && e[t ? 'addClass' : 'removeClass']('open')
    }
    function ZP (e) {
      const t = e.find('.content')
      function n (e) {
        e.stopPropagation()
      }
      XP(e, !0),
      t.on('click', n),
      e.on('click', function r (o) {
        XP(e, !1),
        e.off('click', r),
        t.off('click', n)
      }
      )
    }
    function eO (e, t) {
      return e.matches(t) ? e : e.closest(t)
    }
    function tO (e) {
      return function (t) {
        const n = t.target
        try {
          const r = eO(n, '[data-entry-id] .cmd-change-menu__entry-help')
          const o = eO(n, '.bio-properties-panel-header-actions [title="Open documentation"]')
          const i = eO(n, '[data-action], [data-entry-id]')
          if (o) { return z_('diagram:bpmn:propertiesPanelHelp') }
          if (r) { return z_('diagram:bpmn:entryIdHelp', i.dataset.entryId, e) }
          i && (i.dataset.action && z_('diagram:bpmn:action', i.dataset.action, e),
          i.dataset.entryId && z_('diagram:bpmn:entryId', i.dataset.entryId, e))
        } catch (e) {
          console.error(e)
        }
      }
    }
    function nO () {
      zP.get('dragging').cancel()
    }
    function rO (e) {
      const t = VP()
      t && !window.confirm(t) || (YP('loading'),
      zP.importXML(e).then(function () {
        return z_('diagram', 'open', 'success')
      }
      , function (e) {
        return z_('diagram', 'open', 'error')
      }
      ))
    }
    function oO () {
      let e; let t; const n = VP()
      if (!n || window.confirm(n)) {
        const r = (e = '<?xml version="1.0" encoding="UTF-8"?>\n<bpmn:definitions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:bpmn="http://www.omg.org/spec/BPMN/20100524/MODEL" xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI" xmlns:dc="http://www.omg.org/spec/DD/20100524/DC" id="Definitions_{{ ID }}" targetNamespace="http://bpmn.io/schema/bpmn">\n  <bpmn:process id="Process_{{ ID:process }}" isExecutable="false">\n    <bpmn:startEvent id="StartEvent_{{ ID:event }}" />\n  </bpmn:process>\n  <bpmndi:BPMNDiagram id="BPMNDiagram_1">\n    <bpmndi:BPMNPlane id="BPMNPlane_1" bpmnElement="Process_{{ ID:process }}">\n      <bpmndi:BPMNShape id="_BPMNShape_StartEvent_2" bpmnElement="StartEvent_{{ ID:event }}">\n        <dc:Bounds x="156" y="82" width="36" height="36" />\n      </bpmndi:BPMNShape>\n    </bpmndi:BPMNPlane>\n  </bpmndi:BPMNDiagram>\n</bpmn:definitions>\n',
        t = (function (e) {
          const t = {}
          return function (n) {
            return n ? n in t ? t[n] : t[n] = e() : e()
          }
        }(function (e) {
          if (typeof e === 'function') { return e }
          if (typeof e.next === 'function') {
            return function () {
              return e.next()
            }
          }
          throw new Error('unsupported generator')
        }(L_))),
        e.replace(I_, function (e, n) {
          return t(n)
        }
        ))
        zP.importXML(r).then(function () {
          z_('diagram', 'create', 'success'),
          zP.get('selection').select(zP.get('elementRegistry').get('StartEvent_1'))
        }
        , function (e) {
          return z_('diagram', 'create', 'error')
        }
        )
      }
    }
    FP = new function () {
      const e = window.localStorage || {}
      this.get = function (t) {
        return e[t]
      }
      ,
      this.set = function (t, n) {
        e[t] = n
      }
    }()
    ,
    zP = new hx({
      container: qP,
      keyboard: {
        bindTo: document
      },
      additionalModules: [gx, ew, bx, $P ? {} : kx, $P ? {} : uw, $P ? {} : x_],
      exporter: {
        name: 'bpmn-js (https://demo.bpmn.io)',
        version: '17.2.1'
      }
    }),
    document.body.addEventListener('click', tO('click'), !0),
    document.body.addEventListener('dragstart', tO('dragstart'), !0),
    zP.on('dragging.init', function () {
      zP.on('error', 5e3, nO),
      zP.once('dragging.cleanup', 50, function () {
        zP.off(nO)
      }
      )
    }
    ),
    zP.on('import.done', function (e) {
      const t = e.error
      const n = e.warnings
      t
        ? KP(t)
        : (setTimeout(function () {
            zP.get('canvas').zoom('fit-viewport'),
            YP('shown')
          }
          , 0),
          YP('loaded')),
      JP(n)
    }
    ),
    document.body.addEventListener('dragover', (function (e, t) {
      let n, r, o
      function i (e) {
        let o, i, a, s, c
        e.preventDefault(),
        o = e.dataTransfer.files,
        i = IP,
        a = function (o, i) {
          if (o) { console.warn('file drop failed', o) } else {
            const a = r.concat([i, e])
            t.apply(n, a)
          }
        }
        ,
        s = 0,
        c = [],
        (function e () {
          s === o.length
            ? a(null, c)
            : i(o[s], function (t, n) {
              if (t) { return a(t) }
              c[s] = n,
              s++,
              e()
            }
            )
        }())
      }
      function a () {
        let t; const a = (t = arguments,
        Array.prototype.slice.call(t)); const s = a.pop(); const c = s.dataTransfer; const l = s.currentTarget || s.target
        function p (e) {
          const t = e.relatedTarget
          l.contains(t) || u()
        }
        function u (e) {
          document.removeEventListener('drop', i),
          document.removeEventListener('drop', u),
          document.removeEventListener('dragleave', p),
          document.removeEventListener('dragend', u),
          document.removeEventListener('dragover', LP),
          o && (l.removeChild(o),
          o = null)
        }
        (function (e) {
          if (!e || !e.items.length) { return !1 }
          for (var t = !1, n = 0; n < e.items.length; n++) { e.items[n].type !== 'file' && e.items[n].kind !== 'file' || (t = !0) }
          return t
        }
        )(c) && (s.preventDefault(),
        c.dropEffect = 'copy',
        o || (o = (function (e) {
          const t = '<div class="drop-overlay"><div class="box"><div class="label">{label}</div></div></div>'.replace('{label}', e)
          return MP(t)
        }(e)),
        l.appendChild(o),
        n = this,
        r = a,
        l && (document.addEventListener('drop', i),
        document.addEventListener('drop', u),
        document.addEventListener('dragleave', p),
        document.addEventListener('dragend', u),
        document.addEventListener('dragover', LP))))
      }
      return typeof e === 'function' && (t = e,
      e = 'Drop files here'),
      a.onDrop = i,
      a
    }('Open BPMN diagram', function (e) {
      const t = e[0]
      t && (z_('diagram', 'open-drop'),
      rO(t.contents))
    }
    )), !1)
    const iO = T_()('<input type="file" />').appendTo(document.body).css({
      width: 1,
      height: 1,
      display: 'none',
      overflow: 'hidden'
    }).on('change', function (e) {
      z_('diagram', 'open-dialog'),
      (function (e, t) {
        if (!window.FileReader) { return window.alert('Looks like you use an older browser that does not support drag and drop. Try using a modern browser such as Chrome, Firefox or Internet Explorer > 10.') }
        if (e) {
          WP = e.name
          const n = new FileReader()
          n.onload = function (e) {
            const n = e.target.result
            t(n)
          }
          ,
          n.readAsText(e)
        }
      }(e.target.files[0], rO))
    }
    )
    var aO = {}
    function sO () {
      if (!FP.get('hide-alert')) {
        const e = zP.get('commandStack')._stackIdx
        XP(aO['undo-redo-alert'], e >= 0)
      }
    }
    function cO (e) {
      e.preventDefault(),
      zP.saveXML({
        format: !0
      }).then(function (e) {
        M_(e.xml, WP, 'application/xml'),
        UP(!1)
      }
      ).catch(function (e) {
        return console.error(e)
      }
      )
    }
    function lO () {
      const e = T_()(iO)
      e.val(''),
      e.trigger('click')
    }
    const pO = {
      'bio.toggleFullscreen': function () {
        let e
        e = document.querySelector('html'),
        (document.fullscreenElement ? document.exitFullscreen() : e.requestFullscreen()).catch(function (e) {
          console.warn('fullscreen toggle failed', e)
        }
        )
      },
      'bio.createNew': oO,
      'bio.openLocal': lO,
      'bio.zoomReset': function () {
        zP.get('zoomScroll').reset()
      },
      'bio.zoomIn': function (e) {
        zP.get('zoomScroll').stepZoom(1)
      },
      'bio.zoomOut': function (e) {
        zP.get('zoomScroll').stepZoom(-1)
      },
      'bio.showKeyboard': function (e) {
        const t = aO['keybindings-dialog']
        const n = navigator.platform;
        /Mac/.test(n) ? t.find('.bindings-default').remove() : t.find('.bindings-mac').remove(),
        ZP(t)
      },
      'bio.showAbout': function (e) {
        ZP(aO['about-dialog'])
      },
      'bio.undo': function (e) {
        zP.get('commandStack').undo()
      },
      'bio.hideUndoAlert': function (e) {
        XP(aO['undo-redo-alert'], !1),
        FP.set('hide-alert', 'yes')
      },
      'bio.clearImportDetails': function (e) {
        JP(null)
      },
      'bio.showImportDetails': function (e) {
        ZP(aO['import-warnings-dialog'])
      }
    }
    T_()(function () {
      function e (e) {
        const t = T_()(e).attr('jsaction').split(/:(.+$)/, 2)
        return {
          event: t[0],
          name: t[1]
        }
      }
      function t (t) {
        const n = e(T_()(this)).name
        const r = pO[n]
        if (!r) { throw new Error('no action <' + n + '> defined') }
        t.preventDefault(),
        r(t)
      }
      T_()('[jswidget]').each(function () {
        const e = T_()(this)
        const t = e.attr('jswidget')
        aO[t] = e
      }
      )
      const n = {}
      T_()('[jsaction]').each(function () {
        const r = e(T_()(this))
        const o = r.event
        n[o] || (T_()(document.body).on(o, '[jsaction]', t),
        n[o] = !0)
        const i = r.name
        if (!pO[i]) { throw new Error('no action <' + i + '> defined') }
      }
      ),
      T_()(aO.downloadDiagram).click(cO),
      T_()(aO.downloadSVG).click(function (e) {
        e.preventDefault(),
        zP.saveSVG().then(function (e) {
          return M_(e.svg, 'diagram.svg', 'image/svg+xml')
        }
        ).catch(function (e) {
          return console.error(e)
        }
        )
      }
      ),
      zP.on('commandStack.changed', function () {
        UP(!0),
        sO()
      }
      ),
      zP.on('import.done', function (e) {
        e.error || (UP(!1),
        sO(),
        aO['editing-tools'].show(),
        document.requestFullscreen || (document.querySelector('li:has(button[title="Toggle Fullscreen"])').style.display = 'none'))
      }
      ),
      document.body.addEventListener('keydown', function (e) {
        e.code === 'KeyS' && (e.metaKey || e.ctrlKey) && cO(e),
        e.code === 'KeyO' && (e.metaKey || e.ctrlKey) && (e.preventDefault(),
        lO())
      }
      )
    }
    ),
    n.g.bpmnio = {
      modeler: zP,
      openDiagram: rO
    },
    (function () {
      const e = window.location.href
      let t = null
      const n = /\/s\/([^?]*)/.exec(e)
      if (n) {
        t = function () {
          const e = '/bpmn/diagrams/' + n[1] + '.bpmn'
          T_().get(e, {
            dataType: 'text'
          }).then(rO, function (e) {
            KP(e.status === 404 ? new Error('The diagram does not exist (code=404)') : new Error('Failed to load diagram (code=' + e.code + ')'))
          }
          )
        }
      } else if (/\/new(\?.*)?/.test(e)) { t = oO } else if (FP.get('save')) {
        const r = FP.get('save.diagramXML')
        r && (t = function () {
          rO(r)
        }
        )
      }
      t
        ? (YP('loading'),
          setTimeout(t, 100))
        : YP('intro')
    }())
  }
  )()
}
)()
// # sourceMappingURL=app.js.map
